

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Program Listing for File test.md &mdash; TNT NIST 2021  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> TNT NIST 2021
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">Library API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">TNT NIST 2021</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Program Listing for File test.md</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/api/program_listing_file_src_test.md.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-test-md">
<span id="program-listing-file-src-test-md"></span><h1>Program Listing for File test.md<a class="headerlink" href="#program-listing-for-file-test-md" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_src_test.md.html#file-src-test-md"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/test.md</span></code>)</p>
<div class="highlight-markdown notranslate"><div class="highlight"><pre><span></span>typedef __char16_t char16_t;
typedef __char32_t char32_t;
namespace std { inline namespace __1 { } }






typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;







typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];


struct __darwin_pthread_handler_rec {
 void (<span class="ge">*__routine)(void *</span>);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};

struct <span class="ge">_opaque_</span>pthread_attr_t {
 long __sig;
 char __opaque[56];
};

struct <span class="ge">_opaque_</span>pthread_cond_t {
 long __sig;
 char __opaque[40];
};

struct <span class="ge">_opaque_</span>pthread_condattr_t {
 long __sig;
 char __opaque[8];
};

struct <span class="ge">_opaque_</span>pthread_mutex_t {
 long __sig;
 char __opaque[56];
};

struct <span class="ge">_opaque_</span>pthread_mutexattr_t {
 long __sig;
 char __opaque[8];
};

struct <span class="ge">_opaque_</span>pthread_once_t {
 long __sig;
 char __opaque[8];
};

struct <span class="ge">_opaque_</span>pthread_rwlock_t {
 long __sig;
 char __opaque[192];
};

struct <span class="ge">_opaque_</span>pthread_rwlockattr_t {
 long __sig;
 char __opaque[16];
};

struct <span class="ge">_opaque_</span>pthread_t {
 long __sig;
 struct __darwin_pthread_handler_rec *__cleanup_stack;
 char __opaque[8176];
};

typedef struct <span class="ge">_opaque_</span>pthread_attr_t __darwin_pthread_attr_t;
typedef struct <span class="ge">_opaque_</span>pthread_cond_t __darwin_pthread_cond_t;
typedef struct <span class="ge">_opaque_</span>pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct <span class="ge">_opaque_</span>pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct <span class="ge">_opaque_</span>pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct <span class="ge">_opaque_</span>pthread_once_t __darwin_pthread_once_t;
typedef struct <span class="ge">_opaque_</span>pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct <span class="ge">_opaque_</span>pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct <span class="ge">_opaque_</span>pthread_t *__darwin_pthread_t;
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;


typedef __darwin_size_t size_t;
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;

typedef unsigned char u<span class="ge">_int8_</span>t;
typedef unsigned short u<span class="ge">_int16_</span>t;
typedef unsigned int u<span class="ge">_int32_</span>t;
typedef unsigned long long u<span class="ge">_int64_</span>t;


typedef int64_t register_t;






typedef __darwin_intptr_t intptr_t;
typedef unsigned long uintptr_t;



typedef u<span class="ge">_int64_</span>t user_addr_t;
typedef u<span class="ge">_int64_</span>t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u<span class="ge">_int64_</span>t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;







typedef u<span class="ge">_int64_</span>t syscall_arg_t;
typedef __darwin_mbstate_t mbstate_t;
typedef __darwin_ct_rune_t ct_rune_t;
typedef __darwin_rune_t rune_t;
typedef __builtin_va_list va_list;
typedef __builtin_va_list __gnuc_va_list;


typedef __darwin_va_list va_list;



extern &quot;C&quot; {

int renameat(int, const char <span class="ge">*, int, const char *</span>) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.10)));






int renamex_np(const char <span class="ge">*, const char *</span>, unsigned int) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,introduced=10.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=3.0)));
int renameatx_np(int, const char <span class="ge">*, int, const char *</span>, unsigned int) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,introduced=10.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=3.0)));



}

typedef __darwin_off_t fpos_t;
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (* <span class="ge">_Nullable _</span>close)(void *);
 int (* <span class="ge">_Nullable _</span>read) (void <span class="ge">*, char *</span>, int);
 fpos_t (* <span class="ge">_Nullable _</span>seek) (void *, fpos_t, int);
 int (* <span class="ge">_Nullable _</span>write)(void <span class="ge">*, const char *</span>, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;

extern &quot;C&quot; {
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}
extern &quot;C&quot; {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char <span class="ge">*fgets(char *</span> , int, FILE *);



FILE <span class="ge">*fopen(const char *</span> <span class="gs">__filename, const char * __</span>mode) __asm(&quot;_&quot; &quot;fopen&quot; );

int fprintf(FILE * , const char * , ...) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm(&quot;_&quot; &quot;fputs&quot; );
size_t fread(void * __ptr, size_t __size, size_t <span class="gs">__nitems, FILE * __</span>stream);
FILE <span class="ge">*freopen(const char *</span> , const char * ,
                 FILE * ) __asm(&quot;_&quot; &quot;freopen&quot; );
int fscanf(FILE * , const char * , ...) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__scanf__</span>, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE <span class="ge">*, const fpos_t *</span>);
long ftell(FILE *);
size_t fwrite(const void * __ptr, size_t __size, size_t <span class="gs">__nitems, FILE * __</span>stream) __asm(&quot;_&quot; &quot;fwrite&quot; );
int getc(FILE *);
int getchar(void);
char <span class="ge">*gets(char *</span>);
void perror(const char *) <span class="gs">__attribute__</span>((__cold__));
int printf(const char * , ...) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char <span class="ge">*__old, const char *</span>__new);
void rewind(FILE *);
int scanf(const char * , ...) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__scanf__</span>, 1, 2)));
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
int sprintf(char * , const char * , ...) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 2, 3))) <span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use snprintf instead.&quot;)));
int sscanf(const char * , const char * , ...) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__scanf__</span>, 2, 3)));
FILE *tmpfile(void);

<span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use mkstemp(3) instead.&quot;)))

<span class="gs">__attribute__</span>((__deprecated__(&quot;This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.&quot;)))

char <span class="ge">*tmpnam(char *</span>);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 2, 0)));
int vprintf(const char * , va_list) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 1, 0)));
int vsprintf(char * , const char * , va_list) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 2, 0))) <span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use vsnprintf instead.&quot;)));
}
extern &quot;C&quot; {

extern &quot;C&quot; {

char <span class="ge">*ctermid(char *</span>);

}




FILE <span class="ge">*fdopen(int, const char *</span>) __asm(&quot;_&quot; &quot;fdopen&quot; );

int fileno(FILE *);
}
extern &quot;C&quot; {
int pclose(FILE *) <span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use posix_spawn APIs or NSTask instead.&quot;)));



FILE <span class="ge">*popen(const char *</span>, const char *) __asm(&quot;_&quot; &quot;popen&quot; ) <span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use posix_spawn APIs or NSTask instead.&quot;)));

}
extern &quot;C&quot; {
int __srget(FILE *);
int __svfscanf(FILE <span class="ge">*, const char *</span>, va_list) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__scanf__</span>, 2, 0)));
int __swbuf(int, FILE *);
}







inline <span class="gs">__attribute__</span> ((__always_inline__)) int __sputc(int <span class="ge">_c, FILE *_</span>p) {
 if (--_p-&gt;_w &gt;= 0 || (<span class="ge">_p-&gt;_</span>w &gt;= <span class="ge">_p-&gt;_</span>lbfsize &amp;&amp; (char)_c != &#39;\n&#39;))
  return (*_p-&gt;_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
extern &quot;C&quot; {
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);



int getw(FILE *);
int putw(int, FILE *);


<span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use mkstemp(3) instead.&quot;)))

<span class="gs">__attribute__</span>((__deprecated__(&quot;This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead.&quot;)))

char <span class="ge">*tempnam(const char *</span><span class="gs">__dir, const char *__</span>prefix) __asm(&quot;_&quot; &quot;tempnam&quot; );
}
typedef __darwin_off_t off_t;

extern &quot;C&quot; {
int fseeko(FILE * __stream, off_t <span class="gs">__offset, int __</span>whence);
off_t ftello(FILE * __stream);
}



extern &quot;C&quot; {
int snprintf(char * __str, size_t <span class="gs">__size, const char * __</span>format, ...) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 3, 4)));
int vfscanf(FILE * <span class="gs">__stream, const char * __</span>format, va_list) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__scanf__</span>, 2, 0)));
int vscanf(const char * __format, va_list) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__scanf__</span>, 1, 0)));
int vsnprintf(char * __str, size_t <span class="gs">__size, const char * __</span>format, va_list) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 3, 0)));
int vsscanf(const char * <span class="gs">__str, const char * __</span>format, va_list) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__scanf__</span>, 2, 0)));
}
typedef __darwin_ssize_t ssize_t;

extern &quot;C&quot; {
int dprintf(int, const char * , ...) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 2, 3))) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
int vdprintf(int, const char * , va_list) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 2, 0))) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
ssize_t getdelim(char ** __linep, size_t * <span class="gs">__linecapp, int __</span>delimiter, FILE * <span class="gs">__stream) __</span>attribute__((availability(macosx,introduced=10.7)));
ssize_t getline(char ** __linep, size_t * <span class="gs">__linecapp, FILE * __</span>stream) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
FILE <span class="ge">*fmemopen(void *</span> __buf, size_t <span class="gs">__size, const char * __</span>mode) <span class="gs">__attribute__</span>((availability(macos,introduced=10.13))) <span class="gs">__attribute__</span>((availability(ios,introduced=11.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=11.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=4.0)));
FILE <span class="ge">*open_memstream(char **__bufp, size_t *</span><span class="gs">__sizep) __</span>attribute__((availability(macos,introduced=10.13))) <span class="gs">__attribute__</span>((availability(ios,introduced=11.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=11.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=4.0)));
}







extern &quot;C&quot; {
extern const int sys_nerr;
extern const char *const sys_errlist[];

int asprintf(char ** , const char * , ...) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 2, 3)));
char <span class="ge">*ctermid_r(char *</span>);
char <span class="ge">*fgetln(FILE *</span>, size_t *);
const char <span class="ge">*fmtcheck(const char *</span>, const char *);
int fpurge(FILE *);
void setbuffer(FILE <span class="ge">*, char *</span>, int);
int setlinebuf(FILE *);
int vasprintf(char ** , const char * , va_list) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 2, 0)));
FILE <span class="ge">*zopen(const char *</span>, const char *, int);





FILE <span class="ge">*funopen(const void *</span>,
                 int (* _Nullable)(void <span class="ge">*, char *</span>, int),
                 int (* _Nullable)(void <span class="ge">*, const char *</span>, int),
                 fpos_t (* <span class="ge">_Nullable)(void *, fpos_</span>t, int),
                 int (* _Nullable)(void *));
}
typedef __darwin_clock_t clock_t;


typedef __darwin_time_t time_t;
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};

struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm(&quot;_&quot; &quot;timezone&quot; );

extern int daylight;

extern &quot;C&quot; {
char <span class="ge">*asctime(const struct tm *</span>);
clock_t clock(void) __asm(&quot;_&quot; &quot;clock&quot; );
char <span class="ge">*ctime(const time_t *</span>);
double difftime(time_t, time_t);
struct tm <span class="ge">*getdate(const char *</span>);
struct tm <span class="ge">*gmtime(const time_t *</span>);
struct tm <span class="ge">*localtime(const time_t *</span>);
time_t mktime(struct tm *) __asm(&quot;_&quot; &quot;mktime&quot; );
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm(&quot;_&quot; &quot;strftime&quot; );
char <span class="ge">*strptime(const char *</span> , const char * , struct tm * ) __asm(&quot;_&quot; &quot;strptime&quot; );
time_t time(time_t *);


void tzset(void);



char <span class="ge">*asctime_r(const struct tm *</span> , char * );
char <span class="ge">*ctime_r(const time_t *</span>, char *);
struct tm <span class="ge">*gmtime_r(const time_t *</span> , struct tm * );
struct tm <span class="ge">*localtime_r(const time_t *</span> , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec <span class="ge">*__rqtp, struct timespec *</span><span class="gs">__rmtp) __</span>asm(&quot;_&quot; &quot;nanosleep&quot; );
typedef enum {
<span class="ge">_CLOCK_</span>REALTIME <span class="gs">__attribute__</span>((availability(macosx,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,introduced=10.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=3.0))) = 0,

<span class="ge">_CLOCK_</span>MONOTONIC <span class="gs">__attribute__</span>((availability(macosx,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,introduced=10.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=3.0))) = 6,


<span class="ge">_CLOCK_</span>MONOTONIC_RAW <span class="gs">__attribute__</span>((availability(macosx,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,introduced=10.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=3.0))) = 4,

<span class="ge">_CLOCK_</span>MONOTONIC_RAW_APPROX <span class="gs">__attribute__</span>((availability(macosx,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,introduced=10.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=3.0))) = 5,

<span class="ge">_CLOCK_</span>UPTIME_RAW <span class="gs">__attribute__</span>((availability(macosx,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,introduced=10.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=3.0))) = 8,

<span class="ge">_CLOCK_</span>UPTIME_RAW_APPROX <span class="gs">__attribute__</span>((availability(macosx,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,introduced=10.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=3.0))) = 9,


<span class="ge">_CLOCK_</span>PROCESS_CPUTIME_ID <span class="gs">__attribute__</span>((availability(macosx,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,introduced=10.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=3.0))) = 12,

<span class="ge">_CLOCK_</span>THREAD_CPUTIME_ID <span class="gs">__attribute__</span>((availability(macosx,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,introduced=10.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=3.0))) = 16

} clockid_t;

<span class="gs">__attribute__</span>((availability(macosx,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,introduced=10.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=3.0)))
int clock_getres(clockid_t __clock_id, struct timespec *__res);

<span class="gs">__attribute__</span>((availability(macosx,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,introduced=10.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=3.0)))
int clock_gettime(clockid_t __clock_id, struct timespec *__tp);


<span class="gs">__attribute__</span>((availability(macosx,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,introduced=10.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=3.0)))
__uint64_t clock_gettime_nsec_np(clockid_t __clock_id);


<span class="gs">__attribute__</span>((availability(macosx,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,unavailable)))
<span class="gs">__attribute__</span>((availability(tvos,unavailable))) <span class="gs">__attribute__</span>((availability(watchos,unavailable)))
int clock_settime(clockid_t __clock_id, const struct timespec *__tp);
}
typedef __darwin_wint_t wint_t;

typedef __darwin_wctype_t wctype_t;


typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;

typedef struct {
 int __nranges;
 <span class="ge">_RuneEntry *_</span>_ranges;
} _RuneRange;

typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;

typedef struct {
 char __magic[8];
 char __encoding[32];

 __darwin_rune_t (<span class="ge">*__sgetrune)(const char *</span>, __darwin_size_t, char const **);
 int (<span class="ge">*__sputrune)(__darwin_rune_t, char *</span>, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;

 __uint32_t __runetype[(1 &lt;&lt;8 )];
 __darwin_rune_t __maplower[(1 &lt;&lt;8 )];
 __darwin_rune_t __mapupper[(1 &lt;&lt;8 )];






 <span class="ge">_RuneRange __runetype_</span>ext;
 <span class="ge">_RuneRange __maplower_</span>ext;
 <span class="ge">_RuneRange __mapupper_</span>ext;

 void *__variable;
 int __variable_len;




 int __ncharclasses;
 <span class="ge">_RuneCharClass *_</span>_charclasses;
} _RuneLocale;



extern &quot;C&quot; {
extern <span class="ge">_RuneLocale _</span>DefaultRuneLocale;
extern <span class="ge">_RuneLocale *_</span>CurrentRuneLocale;
}
extern &quot;C&quot; {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}

inline int
isascii(int _c)
{
 return ((_c &amp; ~0x7F) == 0);
}
extern &quot;C&quot; {
int <span class="gs">__maskrune(__</span>darwin_ct_rune_t, unsigned long);
}


inline int
<span class="gs">__istype(__</span>darwin_ct_rune_t <span class="ge">_c, unsigned long _</span>f)
{



 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] &amp; _f)
  : !!__maskrune(_c, _f));

}

inline __darwin_ct_rune_t
<span class="gs">__isctype(__</span>darwin_ct_rune_t <span class="ge">_c, unsigned long _</span>f)
{



 return (<span class="ge">_c &lt; 0 || _</span>c &gt;= (1 &lt;&lt;8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] &amp; _f);

}
extern &quot;C&quot; {
__darwin_ct_rune_t <span class="gs">__toupper(__</span>darwin_ct_rune_t);
__darwin_ct_rune_t <span class="gs">__tolower(__</span>darwin_ct_rune_t);
}


inline int
<span class="gs">__wcwidth(__</span>darwin_ct_rune_t _c)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 <span class="ge">_x = (unsigned int)__maskrune(_</span>c, 0xe0000000L|0x00040000L);
 if ((_x &amp; 0xe0000000L) != 0)
  return ((_x &amp; 0xe0000000L) &gt;&gt; 30);
 return ((_x &amp; 0x00040000L) != 0 ? 1 : -1);
}






inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}

inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}

inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}

inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}


inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}

inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}

inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}

inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}

inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}

inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}

inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}


inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}

inline int
toascii(int _c)
{
 return (_c &amp; 0x7F);
}

inline int
tolower(int _c)
{
        return (__tolower(_c));
}

inline int
toupper(int _c)
{
        return (__toupper(_c));
}


inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}

inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}

inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}

inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}

inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}

inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}

inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}







inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}

inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}

inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}

inline int
iswctype(wint_t <span class="ge">_wc, wctype_</span>t _charclass)
{
 return (__istype(_wc, _charclass));
}

inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}

inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}

inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}

inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}

inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}

inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}

inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}

inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}

inline wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}

inline wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
extern &quot;C&quot; {
wctype_t
 wctype(const char *);
}



extern &quot;C&quot; {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t <span class="ge">*fgetws(wchar_t *</span> , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...);
int fwscanf(FILE * , const wchar_t * , ...);
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * , ...);
int swscanf(const wchar_t * , const wchar_t * , ...);
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list);
int vwprintf(const wchar_t * , __darwin_va_list);
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t <span class="ge">*wcscat(wchar_t *</span> , const wchar_t * );
wchar_t <span class="ge">*wcschr(const wchar_t *</span>, wchar_t);
int wcscmp(const wchar_t <span class="ge">*, const wchar_t *</span>);
int wcscoll(const wchar_t <span class="ge">*, const wchar_t *</span>);
wchar_t <span class="ge">*wcscpy(wchar_t *</span> , const wchar_t * );
size_t wcscspn(const wchar_t <span class="ge">*, const wchar_t *</span>);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm(&quot;_&quot; &quot;wcsftime&quot; );
size_t wcslen(const wchar_t *);
wchar_t <span class="ge">*wcsncat(wchar_t *</span> , const wchar_t * , size_t);
int wcsncmp(const wchar_t <span class="ge">*, const wchar_t *</span>, size_t);
wchar_t <span class="ge">*wcsncpy(wchar_t *</span> , const wchar_t * , size_t);
wchar_t <span class="ge">*wcspbrk(const wchar_t *</span>, const wchar_t *);
wchar_t <span class="ge">*wcsrchr(const wchar_t *</span>, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t <span class="ge">*, const wchar_t *</span>);
wchar_t <span class="ge">*wcsstr(const wchar_t *</span> , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t <span class="ge">*wcstok(wchar_t *</span> , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t <span class="ge">*wmemchr(const wchar_t *</span>, wchar_t, size_t);
int wmemcmp(const wchar_t <span class="ge">*, const wchar_t *</span>, size_t);
wchar_t <span class="ge">*wmemcpy(wchar_t *</span> , const wchar_t * , size_t);
wchar_t <span class="ge">*wmemmove(wchar_t *</span>, const wchar_t *, size_t);
wchar_t <span class="ge">*wmemset(wchar_t *</span>, wchar_t, size_t);
int wprintf(const wchar_t * , ...);
int wscanf(const wchar_t * , ...);
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);
}
extern &quot;C&quot; {
int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list);
int vwscanf(const wchar_t * , __darwin_va_list);
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** );

long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);

}
extern &quot;C&quot; {
size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
            size_t, mbstate_t * );
wchar_t <span class="ge">*wcpcpy(wchar_t *</span> , const wchar_t * ) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
wchar_t <span class="ge">*wcpncpy(wchar_t *</span> , const wchar_t * , size_t) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
wchar_t <span class="ge">*wcsdup(const wchar_t *</span>) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
int wcscasecmp(const wchar_t <span class="ge">*, const wchar_t *</span>) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
int wcsncasecmp(const wchar_t <span class="ge">*, const wchar_t *</span>, size_t n) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
size_t wcsnlen(const wchar_t *, size_t) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
            size_t, mbstate_t * );
FILE <span class="ge">*open_wmemstream(wchar_t *</span>* __bufp, size_t * <span class="gs">__sizep) __</span>attribute__((availability(macos,introduced=10.13))) <span class="gs">__attribute__</span>((availability(ios,introduced=11.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=11.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=4.0)));
}







extern &quot;C&quot; {
wchar_t <span class="ge">*fgetwln(FILE *</span> , size_t *) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
size_t wcslcat(wchar_t <span class="ge">*, const wchar_t *</span>, size_t);
size_t wcslcpy(wchar_t <span class="ge">*, const wchar_t *</span>, size_t);
}
extern &quot;C++&quot; {
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
wchar_t* __libcpp_wcschr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcschr(__s, __c);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
const wchar_t* wcschr(const wchar_t* __s, wchar_t <span class="gs">__c) {return __</span>libcpp_wcschr(__s, __c);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
      wchar_t* wcschr( wchar_t* __s, wchar_t <span class="gs">__c) {return __</span>libcpp_wcschr(__s, __c);}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
wchar_t* __libcpp_wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcspbrk(__s1, __s2);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
const wchar_t* wcspbrk(const wchar_t* __s1, const wchar_t* <span class="gs">__s2) {return __</span>libcpp_wcspbrk(__s1, __s2);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
      wchar_t* wcspbrk( wchar_t* __s1, const wchar_t* <span class="gs">__s2) {return __</span>libcpp_wcspbrk(__s1, __s2);}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
wchar_t* __libcpp_wcsrchr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcsrchr(__s, __c);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
const wchar_t* wcsrchr(const wchar_t* __s, wchar_t <span class="gs">__c) {return __</span>libcpp_wcsrchr(__s, __c);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
      wchar_t* wcsrchr( wchar_t* __s, wchar_t <span class="gs">__c) {return __</span>libcpp_wcsrchr(__s, __c);}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
wchar_t* __libcpp_wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcsstr(__s1, __s2);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
const wchar_t* wcsstr(const wchar_t* __s1, const wchar_t* <span class="gs">__s2) {return __</span>libcpp_wcsstr(__s1, __s2);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
      wchar_t* wcsstr( wchar_t* __s1, const wchar_t* <span class="gs">__s2) {return __</span>libcpp_wcsstr(__s1, __s2);}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
wchar_t* __libcpp_wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return (wchar_t*)wmemchr(__s, <span class="gs">__c, __</span>n);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
const wchar_t* wmemchr(const wchar_t* __s, wchar_t __c, size_t <span class="gs">__n) {return __</span>libcpp_wmemchr(__s, <span class="gs">__c, __</span>n);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
      wchar_t* wmemchr( wchar_t* __s, wchar_t __c, size_t <span class="gs">__n) {return __</span>libcpp_wmemchr(__s, <span class="gs">__c, __</span>n);}
}


namespace std { inline namespace __1 {

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) ios_base;

template&lt;class <span class="ge">_CharT&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) char_traits;
template&lt;&gt; struct char_traits&lt;char&gt;;



template&lt;&gt; struct char_traits&lt;char16_t&gt;;
template&lt;&gt; struct char_traits&lt;char32_t&gt;;
template&lt;&gt; struct char_traits&lt;wchar_t&gt;;

template&lt;class <span class="ge">_Tp&gt; class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) allocator;

template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_ios;

template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_streambuf;
template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_istream;
template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_ostream;
template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_iostream;

template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt;,
          class <span class="ge">_Allocator = allocator&lt;_</span>CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_stringbuf;
template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt;,
          class <span class="ge">_Allocator = allocator&lt;_</span>CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_istringstream;
template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt;,
          class <span class="ge">_Allocator = allocator&lt;_</span>CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_ostringstream;
template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt;,
          class <span class="ge">_Allocator = allocator&lt;_</span>CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_stringstream;

template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_filebuf;
template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_ifstream;
template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_ofstream;
template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_fstream;

template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) istreambuf_iterator;
template &lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) ostreambuf_iterator;

typedef basic_ios&lt;char&gt; ios;
typedef basic_ios&lt;wchar_t&gt; wios;

typedef basic_streambuf&lt;char&gt; streambuf;
typedef basic_istream&lt;char&gt; istream;
typedef basic_ostream&lt;char&gt; ostream;
typedef basic_iostream&lt;char&gt; iostream;

typedef basic_stringbuf&lt;char&gt; stringbuf;
typedef basic_istringstream&lt;char&gt; istringstream;
typedef basic_ostringstream&lt;char&gt; ostringstream;
typedef basic_stringstream&lt;char&gt; stringstream;

typedef basic_filebuf&lt;char&gt; filebuf;
typedef basic_ifstream&lt;char&gt; ifstream;
typedef basic_ofstream&lt;char&gt; ofstream;
typedef basic_fstream&lt;char&gt; fstream;

typedef basic_streambuf&lt;wchar_t&gt; wstreambuf;
typedef basic_istream&lt;wchar_t&gt; wistream;
typedef basic_ostream&lt;wchar_t&gt; wostream;
typedef basic_iostream&lt;wchar_t&gt; wiostream;

typedef basic_stringbuf&lt;wchar_t&gt; wstringbuf;
typedef basic_istringstream&lt;wchar_t&gt; wistringstream;
typedef basic_ostringstream&lt;wchar_t&gt; wostringstream;
typedef basic_stringstream&lt;wchar_t&gt; wstringstream;

typedef basic_filebuf&lt;wchar_t&gt; wfilebuf;
typedef basic_ifstream&lt;wchar_t&gt; wifstream;
typedef basic_ofstream&lt;wchar_t&gt; wofstream;
typedef basic_fstream&lt;wchar_t&gt; wfstream;

template &lt;class <span class="ge">_State&gt; class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) fpos;
typedef fpos&lt;mbstate_t&gt; streampos;
typedef fpos&lt;mbstate_t&gt; wstreampos;




typedef fpos&lt;mbstate_t&gt; u16streampos;
typedef fpos&lt;mbstate_t&gt; u32streampos;






typedef long long streamoff;


template &lt;class _CharT,
          class <span class="ge">_Traits = char_</span>traits&lt;_CharT&gt;,
          class <span class="ge">_Allocator = allocator&lt;_</span>CharT&gt; &gt;
    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_string;
typedef basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt; string;
typedef basic_string&lt;wchar_t, char_traits&lt;wchar_t&gt;, allocator&lt;wchar_t&gt; &gt; wstring;



template &lt;class <span class="ge">_Tp, class _</span>Alloc = allocator&lt;_Tp&gt; &gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) vector;

} }



typedef long int ptrdiff_t;
typedef long unsigned int rsize_t;




namespace std { inline namespace __1 {

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) nullptr_t
{
    void* __lx;

    struct <span class="gs">__nat {int __</span>for_bool_;};

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) nullptr_t() : __lx(0) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) nullptr_t(int <span class="gs">__nat::*) : __</span>lx(0) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) operator int __nat::*() const {return 0;}

    template &lt;class _Tp&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        operator _Tp* () const {return 0;}

    template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        operator <span class="ge">_Tp _</span>Up::* () const {return 0;}

    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool operator==(nullptr_t, nullptr_t) {return true;}
    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool operator!=(nullptr_t, nullptr_t) {return false;}
};

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) nullptr_t __get_nullptr_t() {return nullptr_t(0);}



} }

namespace std { inline namespace __1 {

using ::ptrdiff_t;
using ::size_t;






typedef long double max_align_t;


} }


namespace std
{
}


namespace std { inline namespace __1 {

template &lt;class <span class="ge">_T1, class _</span>T2&gt; struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) pair;
template &lt;class <span class="ge">_Tp&gt; class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) reference_wrapper;
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) hash;

template &lt;class <span class="ge">_Tp, _</span>Tp __v&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) integral_constant
{
  static const <span class="ge">_Tp value = _</span>_v;
  typedef <span class="ge">_Tp value_</span>type;
  typedef integral_constant type;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                    operator value_type() const throw() {return value;}




};

template &lt;class <span class="ge">_Tp, _</span>Tp __v&gt;
                  const <span class="ge">_Tp integral_</span>constant&lt;_Tp, __v&gt;::value;
typedef integral_constant&lt;bool,(true)&gt; true_type;
typedef integral_constant&lt;bool,(false)&gt; false_type;

template &lt;bool _Val&gt;
using <span class="ge">_BoolConstant = integral_</span>constant&lt;bool, _Val&gt;;

template &lt;bool&gt; struct _MetaBase;
template &lt;&gt;
struct _MetaBase&lt;true&gt; {
  template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
  using <span class="ge">_SelectImpl = _</span>Tp;
  template &lt;template &lt;class...&gt; class <span class="ge">_FirstFn, template &lt;class...&gt; class, class ..._</span>Args&gt;
  using <span class="ge">_SelectApplyImpl = _</span>FirstFn&lt;_Args...&gt;;
  template &lt;class _First, class...&gt;
  using <span class="ge">_FirstImpl = _</span>First;
  template &lt;class, class _Second, class...&gt;
  using <span class="ge">_SecondImpl = _</span>Second;
  template &lt;class _Tp = void&gt;
  using <span class="ge">_EnableIfImpl = _</span>Tp;
  template &lt;class <span class="ge">_Result, class _</span>First, class ..._Rest&gt;
  using <span class="ge">_OrImpl = typename _</span>MetaBase&lt;_First::value != true &amp;&amp; sizeof...(_Rest) != 0&gt;::template <span class="ge">_OrImpl&lt;_</span>First, _Rest...&gt;;
  template &lt;class <span class="ge">_Result, class _</span>First, class ..._Rest&gt;
  using <span class="ge">_AndImpl = typename _</span>MetaBase&lt;_First::value == true &amp;&amp; sizeof...(_Rest) != 0&gt;::template <span class="ge">_AndImpl&lt;_</span>First, _Rest...&gt;;
};

template &lt;&gt;
struct _MetaBase&lt;false&gt; {
  template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
  using <span class="ge">_SelectImpl = _</span>Up;
  template &lt;template &lt;class...&gt; class, template &lt;class...&gt; class <span class="ge">_SecondFn, class ..._</span>Args&gt;
  using <span class="ge">_SelectApplyImpl = _</span>SecondFn&lt;_Args...&gt;;
  template &lt;class _Result, class ...&gt;
  using <span class="ge">_OrImpl = _</span>Result;
  template &lt;class _Result, class ...&gt;
  using <span class="ge">_AndImpl = _</span>Result;
};
template &lt;bool <span class="ge">_Cond, class _</span>Ret = void&gt;
using <span class="ge">_EnableIf = typename _</span>MetaBase&lt;_Cond&gt;::template <span class="ge">_EnableIfImpl&lt;_</span>Ret&gt;;
template &lt;bool <span class="ge">_Cond, class _</span>IfRes, class _ElseRes&gt;
using <span class="ge">_If = typename _</span>MetaBase&lt;_Cond&gt;::template <span class="ge">_SelectImpl&lt;_</span>IfRes, _ElseRes&gt;;
template &lt;class ..._Rest&gt;
using <span class="ge">_Or = typename _</span>MetaBase&lt; sizeof...(_Rest) != 0 &gt;::template <span class="ge">_OrImpl&lt;false_</span>type, _Rest...&gt;;
template &lt;class ..._Rest&gt;
using <span class="ge">_And = typename _</span>MetaBase&lt; sizeof...(_Rest) != 0 &gt;::template <span class="ge">_AndImpl&lt;true_</span>type, _Rest...&gt;;
template &lt;class _Pred&gt;
struct <span class="ge">_Not : _</span>BoolConstant&lt;!_Pred::value&gt; {};
template &lt;class ..._Args&gt;
using <span class="ge">_FirstType = typename _</span>MetaBase&lt;(sizeof...(_Args) &gt;= 1)&gt;::template <span class="ge">_FirstImpl&lt;_</span>Args...&gt;;
template &lt;class ..._Args&gt;
using <span class="ge">_SecondType = typename _</span>MetaBase&lt;(sizeof...(_Args) &gt;= 2)&gt;::template <span class="ge">_SecondImpl&lt;_</span>Args...&gt;;

template &lt;template &lt;class...&gt; class <span class="ge">_Func, class ..._</span>Args&gt;
struct <span class="ge">_Lazy : _</span>Func&lt;_Args...&gt; {};



template &lt;template &lt;class...&gt; class <span class="ge">_Templ, class ..._</span>Args, class = <span class="ge">_Templ&lt;_</span>Args...&gt; &gt;
true_type __sfinae_test_impl(int);
template &lt;template &lt;class...&gt; class, class ...&gt;
false_type __sfinae_test_impl(...);

template &lt;template &lt;class ...&gt; class <span class="ge">_Templ, class ..._</span>Args&gt;
using <span class="ge">_IsValidExpansion = __decltype(std::__sfinae_</span>test_impl&lt;_Templ, _Args...&gt;(0));

template &lt;class&gt;
struct __void_t { typedef void type; };

template &lt;class _Tp&gt;
struct __identity { typedef _Tp type; };

template &lt;class _Tp, bool&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) __dependent_type : public _Tp {};


template &lt;bool <span class="ge">_Bp, class _</span>If, class _Then&gt;
    struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) conditional {typedef _If type;};
template &lt;class <span class="ge">_If, class _</span>Then&gt;
    struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) conditional&lt;false, <span class="ge">_If, _</span>Then&gt; {typedef _Then type;};





template &lt;bool, class <span class="ge">_Tp = void&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) enable_if {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) enable_if&lt;true, <span class="ge">_Tp&gt; {typedef _</span>Tp type;};







template &lt;class <span class="ge">_Tp, class _</span>Up&gt; struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_same : public false_type {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_same&lt;_Tp, <span class="ge">_Tp&gt; : public true_</span>type {};







template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
using <span class="ge">_IsSame = _</span>BoolConstant&lt;

    __is_same(_Tp, _Up)



&gt;;

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
using <span class="ge">_IsNotSame = _</span>BoolConstant&lt;

    !__is_same(_Tp, _Up)



&gt;;


template &lt;class _Tp&gt;
using __test_for_primary_template = _EnableIf&lt;
    <span class="ge">_IsSame&lt;_</span>Tp, typename <span class="ge">_Tp::__primary_</span>template&gt;::value
  &gt;;
template &lt;class _Tp&gt;
using __is_primary_template = _IsValidExpansion&lt;
    __test_for_primary_template, _Tp
  &gt;;




template &lt;class _Tp&gt;
inline
<span class="gs">__attribute__</span>((__no_sanitize__(&quot;cfi&quot;))) <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp*
addressof(_Tp&amp; __x) throw()
{
    return __builtin_addressof(__x);
}
struct <span class="gs">__two {char __</span>lx[2];};





template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_const : public false_type {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_const&lt;_Tp const&gt; : public true_type {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_volatile : public false_type {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_volatile&lt;_Tp volatile&gt; : public true_type {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_const {typedef _Tp type;};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_const&lt;const <span class="ge">_Tp&gt; {typedef _</span>Tp type;};






template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_volatile {typedef _Tp type;};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_volatile&lt;volatile <span class="ge">_Tp&gt; {typedef _</span>Tp type;};






template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_cv
{typedef typename remove_volatile&lt;typename remove_const&lt;_Tp&gt;::type&gt;::type type;};






template &lt;class <span class="ge">_Tp&gt; struct __libcpp_</span>is_void : public false_type {};
template &lt;&gt; struct __libcpp_is_void&lt;void&gt; : public true_type {};

template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_void
    : public __libcpp_is_void&lt;typename remove_cv&lt;_Tp&gt;::type&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __is_</span>nullptr_t_impl : public false_type {};
template &lt;&gt; struct __is_nullptr_t_impl&lt;nullptr_t&gt; : public true_type {};

template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) __is_nullptr_t
    : public __is_nullptr_t_impl&lt;typename remove_cv&lt;_Tp&gt;::type&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __libcpp_</span>is_integral : public false_type {};
template &lt;&gt; struct __libcpp_is_integral&lt;bool&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_integral&lt;char&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_integral&lt;signed char&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_integral&lt;unsigned char&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_integral&lt;wchar_t&gt; : public true_type {};




template &lt;&gt; struct __libcpp_is_integral&lt;char16_t&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_integral&lt;char32_t&gt; : public true_type {};

template &lt;&gt; struct __libcpp_is_integral&lt;short&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_integral&lt;unsigned short&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_integral&lt;int&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_integral&lt;unsigned int&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_integral&lt;long&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_integral&lt;unsigned long&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_integral&lt;long long&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_integral&lt;unsigned long long&gt; : public true_type {};

template &lt;&gt; struct __libcpp_is_integral&lt;__int128_t&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_integral&lt;__uint128_t&gt; : public true_type {};


template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_integral
    : public __libcpp_is_integral&lt;typename remove_cv&lt;_Tp&gt;::type&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __libcpp_</span>is_floating_point : public false_type {};
template &lt;&gt; struct __libcpp_is_floating_point&lt;float&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_floating_point&lt;double&gt; : public true_type {};
template &lt;&gt; struct __libcpp_is_floating_point&lt;long double&gt; : public true_type {};

template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_floating_point
    : public __libcpp_is_floating_point&lt;typename remove_cv&lt;_Tp&gt;::type&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_array
    : public false_type {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_array&lt;_Tp[]&gt;
    : public true_type {};
template &lt;class <span class="ge">_Tp, size_</span>t <span class="ge">_Np&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_array&lt;_Tp[_Np]&gt;
    : public true_type {};
template &lt;class <span class="ge">_Tp&gt; struct __libcpp_</span>is_pointer : public false_type {};
template &lt;class <span class="ge">_Tp&gt; struct __libcpp_</span>is_pointer&lt;_Tp*&gt; : public true_type {};

template &lt;class <span class="ge">_Tp&gt; struct __libcpp_</span>remove_objc_qualifiers { typedef _Tp type; };







template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_pointer
    : public __libcpp_is_pointer&lt;typename __libcpp_remove_objc_qualifiers&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::type&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_lvalue_reference : public false_type {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_lvalue_reference&lt;_Tp&amp;&gt; : public true_type {};

template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_rvalue_reference : public false_type {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_rvalue_reference&lt;_Tp&amp;&amp;&gt; : public true_type {};

template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_reference : public false_type {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_reference&lt;_Tp&amp;&gt; : public true_type {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_reference&lt;_Tp&amp;&amp;&gt; : public true_type {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_union
    : public integral_constant&lt;bool, __is_union(_Tp)&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_class
    : public integral_constant&lt;bool, __is_class(_Tp)&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_function
    : public _BoolConstant&lt;

    __is_function(_Tp)



<span class="k">    &gt; </span><span class="ge">{};</span>
template &lt;class <span class="ge">_Tp&gt; struct __libcpp_</span>is_member_pointer {
  enum {
    __is_member = false,
    __is_func = false,
    __is_obj = false
  };
};
template &lt;class <span class="ge">_Tp, class _</span>Up&gt; struct __libcpp_is_member_pointer&lt;_Tp _Up::*&gt; {
  enum {
    __is_member = true,
    __is_func = is_function&lt;_Tp&gt;::value,
    __is_obj = !__is_func,
  };
};


template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_member_function_pointer
    : public <span class="ge">_BoolConstant&lt; __libcpp_</span>is_member_pointer&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::__is_func &gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_member_pointer
 : public <span class="ge">_BoolConstant&lt; __libcpp_</span>is_member_pointer&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::__is_member &gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_member_object_pointer
    : public <span class="ge">_BoolConstant&lt; __libcpp_</span>is_member_pointer&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::__is_obj &gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_enum
    : public integral_constant&lt;bool, __is_enum(_Tp)&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_arithmetic
    : public integral_constant&lt;bool, is_integral&lt;_Tp&gt;::value ||
                                     is_floating_point&lt;_Tp&gt;::value&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_fundamental
    : public integral_constant&lt;bool, is_void&lt;_Tp&gt;::value ||
                                     __is_nullptr_t&lt;_Tp&gt;::value ||
                                     is_arithmetic&lt;_Tp&gt;::value&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __is_</span>block : false_type {};

template &lt;class <span class="ge">_Rp, class ..._</span>Args&gt; struct __is_block&lt;_Rp (^)(_Args...)&gt; : true_type {};


template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_scalar
    : public integral_constant&lt;bool, is_arithmetic&lt;_Tp&gt;::value ||
                                     is_member_pointer&lt;_Tp&gt;::value ||
                                     is_pointer&lt;_Tp&gt;::value ||
                                     __is_nullptr_t&lt;_Tp&gt;::value ||
                                     __is_block&lt;_Tp&gt;::value ||
                                     is_enum&lt;_Tp&gt;::value &gt; {};

template &lt;&gt; struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_scalar&lt;nullptr_t&gt; : public true_type {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_object
    : public integral_constant&lt;bool, is_scalar&lt;_Tp&gt;::value ||
                                     is_array&lt;_Tp&gt;::value ||
                                     is_union&lt;_Tp&gt;::value ||
                                     is_class&lt;_Tp&gt;::value &gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_compound
    : public integral_constant&lt;bool, !is_fundamental&lt;_Tp&gt;::value&gt; {};
struct __is_referenceable_impl {
    template &lt;class <span class="ge">_Tp&gt; static _</span>Tp&amp; __test(int);
    template &lt;class <span class="ge">_Tp&gt; static __two _</span>_test(...);
};

template &lt;class _Tp&gt;
struct __is_referenceable : integral_constant&lt;bool,
    <span class="ge">_IsNotSame&lt;__decltype(__is_</span>referenceable_impl::__test&lt;_Tp&gt;(0)), __two&gt;::value&gt; {};




template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) add_const {
  typedef const _Tp type;
};







template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) add_volatile {
  typedef volatile _Tp type;
};






template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) add_cv {
  typedef const volatile _Tp type;
};







template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_reference {typedef _Tp type;};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_reference&lt;_Tp&amp;&gt; {typedef _Tp type;};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_reference&lt;_Tp&amp;&amp;&gt; {typedef _Tp type;};







template &lt;class <span class="ge">_Tp, bool = __is_</span>referenceable&lt;_Tp&gt;::value&gt; struct __add_lvalue_reference_impl { typedef _Tp type; };
template &lt;class <span class="ge">_Tp &gt; struct __add_</span>lvalue_reference_impl&lt;_Tp, true&gt; { typedef _Tp&amp; type; };

template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) add_lvalue_reference
{typedef typename __add_lvalue_reference_impl&lt;_Tp&gt;::type type;};





template &lt;class <span class="ge">_Tp, bool = __is_</span>referenceable&lt;_Tp&gt;::value&gt; struct __add_rvalue_reference_impl { typedef _Tp type; };
template &lt;class <span class="ge">_Tp &gt; struct __add_</span>rvalue_reference_impl&lt;_Tp, true&gt; { typedef _Tp&amp;&amp; type; };

template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) add_rvalue_reference
{typedef typename __add_rvalue_reference_impl&lt;_Tp&gt;::type type;};







<span class="gh">#pragma GCC diagnostic push</span>
<span class="gh">#pragma GCC diagnostic ignored &quot;-Wdeprecated&quot;</span>
template &lt;class <span class="ge">_Tp&gt; _</span>Tp&amp;&amp; __declval(int);
template &lt;class <span class="ge">_Tp&gt; _</span>Tp __declval(long);
<span class="gh">#pragma GCC diagnostic pop</span>

template &lt;class _Tp&gt;
<span class="gs">__decltype(std::__</span>1::__declval&lt;_Tp&gt;(0))
declval() throw();



template &lt;class _Tp&gt;
struct __uncvref {
    typedef typename remove_cv&lt;typename remove_reference&lt;_Tp&gt;::type&gt;::type type;
};

template &lt;class _Tp&gt;
struct __unconstref {
    typedef typename remove_const&lt;typename remove_reference&lt;_Tp&gt;::type&gt;::type type;
};
template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __is_same_uncvref : <span class="ge">_IsSame&lt;typename __uncvref&lt;_</span>Tp&gt;::type,
                                   typename __uncvref&lt;_Up&gt;::type&gt; {};
struct __any
{
    __any(...);
};



template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_pointer {typedef _Tp type;};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_pointer&lt;_Tp*&gt; {typedef _Tp type;};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_pointer&lt;_Tp* const&gt; {typedef _Tp type;};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_pointer&lt;_Tp* volatile&gt; {typedef _Tp type;};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_pointer&lt;_Tp* const volatile&gt; {typedef _Tp type;};







template &lt;class _Tp,
        bool = __is_referenceable&lt;_Tp&gt;::value ||
                <span class="ge">_IsSame&lt;typename remove_</span>cv&lt;_Tp&gt;::type, void&gt;::value&gt;
struct __add_pointer_impl
    {typedef typename remove_reference&lt;_Tp&gt;::type* type;};
template &lt;class <span class="ge">_Tp&gt; struct __add_</span>pointer_impl&lt;_Tp, false&gt;
    {typedef _Tp type;};

template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) add_pointer
    {typedef typename __add_pointer_impl&lt;_Tp&gt;::type type;};
template &lt;class <span class="ge">_Tp, bool = is_</span>integral&lt;_Tp&gt;::value&gt;
struct __libcpp_is_signed_impl : public integral_constant&lt;bool,(_Tp(-1) &lt; _Tp(0))&gt; {};

template &lt;class _Tp&gt;
struct __libcpp_is_signed_impl&lt;_Tp, false&gt; : public true_type {};

template &lt;class <span class="ge">_Tp, bool = is_</span>arithmetic&lt;_Tp&gt;::value&gt;
struct __libcpp_is_signed : public __libcpp_is_signed_impl&lt;_Tp&gt; {};

template &lt;class <span class="ge">_Tp&gt; struct __libcpp_</span>is_signed&lt;_Tp, false&gt; : public false_type {};

template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_signed : public __libcpp_is_signed&lt;_Tp&gt; {};
template &lt;class <span class="ge">_Tp, bool = is_</span>integral&lt;_Tp&gt;::value&gt;
struct __libcpp_is_unsigned_impl : public integral_constant&lt;bool,(_Tp(0) &lt; _Tp(-1))&gt; {};

template &lt;class _Tp&gt;
struct __libcpp_is_unsigned_impl&lt;_Tp, false&gt; : public false_type {};

template &lt;class <span class="ge">_Tp, bool = is_</span>arithmetic&lt;_Tp&gt;::value&gt;
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl&lt;_Tp&gt; {};

template &lt;class <span class="ge">_Tp&gt; struct __libcpp_</span>is_unsigned&lt;_Tp, false&gt; : public false_type {};

template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_unsigned : public __libcpp_is_unsigned&lt;_Tp&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) rank
    : public integral_constant&lt;size_t, 0&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) rank&lt;_Tp[]&gt;
    : public integral_constant&lt;size_t, rank&lt;_Tp&gt;::value + 1&gt; {};
template &lt;class <span class="ge">_Tp, size_</span>t <span class="ge">_Np&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) rank&lt;_Tp[_Np]&gt;
    : public integral_constant&lt;size_t, rank&lt;_Tp&gt;::value + 1&gt; {};
template &lt;class <span class="ge">_Tp, unsigned _</span>Ip = 0&gt; struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) extent
    : public integral_constant&lt;size_t, 0&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) extent&lt;_Tp[], 0&gt;
    : public integral_constant&lt;size_t, 0&gt; {};
template &lt;class <span class="ge">_Tp, unsigned _</span>Ip&gt; struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) extent&lt;_Tp[], _Ip&gt;
    : public integral_constant&lt;size_t, extent&lt;_Tp, _Ip-1&gt;::value&gt; {};
template &lt;class <span class="ge">_Tp, size_</span>t <span class="ge">_Np&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) extent&lt;_Tp[_Np], 0&gt;
    : public integral_constant&lt;size_t, _Np&gt; {};
template &lt;class <span class="ge">_Tp, size_</span>t <span class="ge">_Np, unsigned _</span>Ip&gt; struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) extent&lt;_Tp[_Np], _Ip&gt;
    : public integral_constant&lt;size_t, extent&lt;_Tp, _Ip-1&gt;::value&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_extent
    {typedef _Tp type;};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_extent&lt;_Tp[]&gt;
    {typedef _Tp type;};
template &lt;class <span class="ge">_Tp, size_</span>t <span class="ge">_Np&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_extent&lt;_Tp[_Np]&gt;
    {typedef _Tp type;};







template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_all_extents
    {typedef _Tp type;};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_all_extents&lt;_Tp[]&gt;
    {typedef typename remove_all_extents&lt;_Tp&gt;::type type;};
template &lt;class <span class="ge">_Tp, size_</span>t <span class="ge">_Np&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) remove_all_extents&lt;_Tp[_Np]&gt;
    {typedef typename remove_all_extents&lt;_Tp&gt;::type type;};
template &lt;class _Up, bool&gt;
struct __decay {
    typedef typename remove_cv&lt;_Up&gt;::type type;
};

template &lt;class _Up&gt;
struct __decay&lt;_Up, true&gt; {
public:
    typedef typename conditional
                     &lt;
                         is_array&lt;_Up&gt;::value,
                         typename remove_extent&lt;_Up&gt;::type*,
                         typename conditional
                         &lt;
                              is_function&lt;_Up&gt;::value,
                              typename add_pointer&lt;_Up&gt;::type,
                              typename remove_cv&lt;_Up&gt;::type
                         &gt;::type
                     &gt;::type type;
};

template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) decay
{
private:
    typedef typename remove_reference&lt;_Tp&gt;::type _Up;
public:
    typedef typename __decay&lt;_Up, __is_referenceable&lt;_Up&gt;::value&gt;::type type;
};







template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_abstract
    : public integral_constant&lt;bool, __is_abstract(_Tp)&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;)))
__libcpp_is_final : public integral_constant&lt;bool, __is_final(_Tp)&gt; {};
template &lt;class <span class="ge">_Bp, class _</span>Dp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_base_of
    : public integral_constant&lt;bool, __is_base_of(_Bp, _Dp)&gt; {};
template &lt;class <span class="ge">_T1, class _</span>T2&gt; struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_convertible
    : public integral_constant&lt;bool, __is_convertible_to(_T1, _T2)&gt; {};
template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_empty
    : public integral_constant&lt;bool, __is_empty(_Tp)&gt; {};
template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_polymorphic
    : public integral_constant&lt;bool, __is_polymorphic(_Tp)&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) has_virtual_destructor
    : public integral_constant&lt;bool, __has_virtual_destructor(_Tp)&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) alignment_of
    : public integral_constant&lt;size_t, <span class="ge">_Alignof(_</span>Tp)&gt; {};
template &lt;class <span class="ge">_Hp, class _</span>Tp&gt;
struct __type_list
{
    typedef <span class="ge">_Hp _</span>Head;
    typedef <span class="ge">_Tp _</span>Tail;
};

struct __nat
{






};

template &lt;class _Tp&gt;
struct __align_type
{
    static const size_t value = __alignof(_Tp);
    typedef _Tp type;
};

struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};

typedef
    __type_list&lt;__align_type&lt;unsigned char&gt;,
    __type_list&lt;__align_type&lt;unsigned short&gt;,
    __type_list&lt;__align_type&lt;unsigned int&gt;,
    __type_list&lt;__align_type&lt;unsigned long&gt;,
    __type_list&lt;__align_type&lt;unsigned long long&gt;,
    __type_list&lt;__align_type&lt;double&gt;,
    __type_list&lt;__align_type&lt;long double&gt;,
    __type_list&lt;__align_type&lt;__struct_double&gt;,
    __type_list&lt;__align_type&lt;__struct_double4&gt;,
    __type_list&lt;__align_type&lt;int*&gt;,
    __nat
<span class="k">    &gt; </span><span class="ge">&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; __all_types;</span>

template &lt;size_t _Align&gt;
struct <span class="gs">__attribute__</span>((__aligned__(_Align))) __fallback_overaligned {};

template &lt;class <span class="ge">_TL, size_</span>t <span class="ge">_Align&gt; struct __find_</span>pod;

template &lt;class <span class="ge">_Hp, size_</span>t _Align&gt;
struct __find_pod&lt;__type_list&lt;_Hp, __nat&gt;, _Align&gt;
{
    typedef typename conditional&lt;
                             <span class="ge">_Align == _</span>Hp::value,
                             typename _Hp::type,
                             __fallback_overaligned&lt;_Align&gt;
                         &gt;::type type;
};

template &lt;class <span class="ge">_Hp, class _</span>Tp, size_t _Align&gt;
struct __find_pod&lt;__type_list&lt;_Hp, <span class="ge">_Tp&gt;, _</span>Align&gt;
{
    typedef typename conditional&lt;
                             <span class="ge">_Align == _</span>Hp::value,
                             typename _Hp::type,
                             typename __find_pod&lt;_Tp, _Align&gt;::type
                         &gt;::type type;
};

template &lt;class <span class="ge">_TL, size_</span>t <span class="ge">_Len&gt; struct __find_</span>max_align;

template &lt;class <span class="ge">_Hp, size_</span>t _Len&gt;
struct __find_max_align&lt;__type_list&lt;_Hp, __nat&gt;, <span class="ge">_Len&gt; : public integral_</span>constant&lt;size_t, _Hp::value&gt; {};

template &lt;size_t <span class="ge">_Len, size_</span>t <span class="ge">_A1, size_</span>t _A2&gt;
struct __select_align
{
private:
    static const size_t __min = <span class="ge">_A2 &lt; _</span>A1 ? <span class="ge">_A2 : _</span>A1;
    static const size_t __max = <span class="ge">_A1 &lt; _</span>A2 ? <span class="ge">_A2 : _</span>A1;
public:
    static const size_t value = <span class="ge">_Len &lt; __max ? __min : _</span>_max;
};

template &lt;class <span class="ge">_Hp, class _</span>Tp, size_t _Len&gt;
struct __find_max_align&lt;__type_list&lt;_Hp, <span class="ge">_Tp&gt;, _</span>Len&gt;
    : public integral_constant&lt;size_t, __select_align&lt;_Len, <span class="ge">_Hp::value, __find_</span>max_align&lt;_Tp, _Len&gt;::value&gt;::value&gt; {};

template &lt;size_t <span class="ge">_Len, size_</span>t <span class="ge">_Align = __find_</span>max_align&lt;__all_types, _Len&gt;::value&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) aligned_storage
{
    typedef typename __find_pod&lt;__all_types, <span class="ge">_Align&gt;::type _</span>Aligner;
    union type
    {
        <span class="ge">_Aligner _</span>_align;
        unsigned char __data[(_Len + <span class="ge">_Align - 1)/_</span>Align * _Align];
    };
};
template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x1&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x1))) type { unsigned char __lx[(_Len + 0x1 - 1)/0x1 * 0x1]; };};
template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x2&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x2))) type { unsigned char __lx[(_Len + 0x2 - 1)/0x2 * 0x2]; };};
template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x4&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x4))) type { unsigned char __lx[(_Len + 0x4 - 1)/0x4 * 0x4]; };};
template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x8&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x8))) type { unsigned char __lx[(_Len + 0x8 - 1)/0x8 * 0x8]; };};
template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x10&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x10))) type { unsigned char __lx[(_Len + 0x10 - 1)/0x10 * 0x10]; };};
template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x20&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x20))) type { unsigned char __lx[(_Len + 0x20 - 1)/0x20 * 0x20]; };};
template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x40&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x40))) type { unsigned char __lx[(_Len + 0x40 - 1)/0x40 * 0x40]; };};
template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x80&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x80))) type { unsigned char __lx[(_Len + 0x80 - 1)/0x80 * 0x80]; };};
template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x100&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x100))) type { unsigned char __lx[(_Len + 0x100 - 1)/0x100 * 0x100]; };};
template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x200&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x200))) type { unsigned char __lx[(_Len + 0x200 - 1)/0x200 * 0x200]; };};
template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x400&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x400))) type { unsigned char __lx[(_Len + 0x400 - 1)/0x400 * 0x400]; };};
template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x800&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x800))) type { unsigned char __lx[(_Len + 0x800 - 1)/0x800 * 0x800]; };};
template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x1000&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x1000))) type { unsigned char __lx[(_Len + 0x1000 - 1)/0x1000 * 0x1000]; };};
template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x2000&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x2000))) type { unsigned char __lx[(_Len + 0x2000 - 1)/0x2000 * 0x2000]; };};


template &lt;size_t <span class="ge">_Len&gt;struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) aligned_storage&lt;_Len, 0x4000&gt;{ struct <span class="gs">__attribute__</span>((__aligned__(0x4000))) type { unsigned char __lx[(_Len + 0x4000 - 1)/0x4000 * 0x4000]; };};







template &lt;size_t <span class="ge">_I0, size_</span>t ..._In&gt;
struct __static_max;

template &lt;size_t _I0&gt;
struct __static_max&lt;_I0&gt;
{
    static const size_t value = _I0;
};

template &lt;size_t <span class="ge">_I0, size_</span>t <span class="ge">_I1, size_</span>t ..._In&gt;
struct __static_max&lt;_I0, <span class="ge">_I1, _</span>In...&gt;
{
    static const size_t value = <span class="ge">_I0 &gt;= _</span>I1 ? __static_max&lt;_I0, _In...&gt;::value :
                                             __static_max&lt;_I1, _In...&gt;::value;
};

template &lt;size_t <span class="ge">_Len, class _</span>Type0, class ..._Types&gt;
struct aligned_union
{
    static const size_t alignment_value = __static_max&lt;__alignof(_Type0),
                                                       __alignof(_Types)...&gt;::value;
    static const size_t <span class="gs">__len = __</span>static_max&lt;_Len, sizeof(_Type0),
                                             sizeof(_Types)...&gt;::value;
    typedef typename aligned_storage&lt;__len, alignment_value&gt;::type type;
};





template &lt;class _Tp&gt;
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);

   typedef <span class="gs">__decltype(__</span>test(declval&lt;_Tp&gt;())) type;
   static const bool value = _IsNotSame&lt;type, void&gt;::value;
};

template &lt;&gt;
struct __numeric_type&lt;void&gt;
{
   static const bool value = true;
};



template &lt;class <span class="ge">_A1, class _</span>A2 = void, class _A3 = void,
          bool = __numeric_type&lt;_A1&gt;::value &amp;&amp;
                 __numeric_type&lt;_A2&gt;::value &amp;&amp;
                 __numeric_type&lt;_A3&gt;::value&gt;
class __promote_imp
{
public:
    static const bool value = false;
};

template &lt;class <span class="ge">_A1, class _</span>A2, class _A3&gt;
class __promote_imp&lt;_A1, <span class="ge">_A2, _</span>A3, true&gt;
{
private:
    typedef typename __promote_imp&lt;_A1&gt;::type __type1;
    typedef typename __promote_imp&lt;_A2&gt;::type __type2;
    typedef typename __promote_imp&lt;_A3&gt;::type __type3;
public:
    typedef <span class="gs">__decltype(__</span>type1() + <span class="gs">__type2() + __</span>type3()) type;
    static const bool value = true;
};

template &lt;class <span class="ge">_A1, class _</span>A2&gt;
class __promote_imp&lt;_A1, _A2, void, true&gt;
{
private:
    typedef typename __promote_imp&lt;_A1&gt;::type __type1;
    typedef typename __promote_imp&lt;_A2&gt;::type __type2;
public:
    typedef <span class="gs">__decltype(__</span>type1() + __type2()) type;
    static const bool value = true;
};

template &lt;class _A1&gt;
class __promote_imp&lt;_A1, void, void, true&gt;
{
public:
    typedef typename __numeric_type&lt;_A1&gt;::type type;
    static const bool value = true;
};

template &lt;class <span class="ge">_A1, class _</span>A2 = void, class _A3 = void&gt;
class <span class="gs">__promote : public __</span>promote_imp&lt;_A1, <span class="ge">_A2, _</span>A3&gt; {};



typedef
    __type_list&lt;signed char,
    __type_list&lt;signed short,
    __type_list&lt;signed int,
    __type_list&lt;signed long,
    __type_list&lt;signed long long,

    __type_list&lt;__int128_t,

    __nat

    &gt;

<span class="k">    &gt; </span><span class="ge">&gt; &gt; &gt; &gt; __signed_types;</span>

typedef
    __type_list&lt;unsigned char,
    __type_list&lt;unsigned short,
    __type_list&lt;unsigned int,
    __type_list&lt;unsigned long,
    __type_list&lt;unsigned long long,

    __type_list&lt;__uint128_t,

    __nat

    &gt;

<span class="k">    &gt; </span><span class="ge">&gt; &gt; &gt; &gt; __unsigned_types;</span>

template &lt;class <span class="ge">_TypeList, size_</span>t <span class="ge">_Size, bool = _</span>Size &lt;= sizeof(typename <span class="ge">_TypeList::_</span>Head)&gt; struct __find_first;

template &lt;class <span class="ge">_Hp, class _</span>Tp, size_t _Size&gt;
struct __find_first&lt;__type_list&lt;_Hp, <span class="ge">_Tp&gt;, _</span>Size, true&gt;
{
    typedef _Hp type;
};

template &lt;class <span class="ge">_Hp, class _</span>Tp, size_t _Size&gt;
struct __find_first&lt;__type_list&lt;_Hp, <span class="ge">_Tp&gt;, _</span>Size, false&gt;
{
    typedef typename __find_first&lt;_Tp, _Size&gt;::type type;
};

template &lt;class <span class="ge">_Tp, class _</span>Up, bool = is_const&lt;typename remove_reference&lt;_Tp&gt;::type&gt;::value,
                             bool = is_volatile&lt;typename remove_reference&lt;_Tp&gt;::type&gt;::value&gt;
struct __apply_cv
{
    typedef _Up type;
};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __apply_cv&lt;_Tp, _Up, true, false&gt;
{
    typedef const _Up type;
};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __apply_cv&lt;_Tp, _Up, false, true&gt;
{
    typedef volatile _Up type;
};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __apply_cv&lt;_Tp, _Up, true, true&gt;
{
    typedef const volatile _Up type;
};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __apply_cv&lt;_Tp&amp;, _Up, false, false&gt;
{
    typedef _Up&amp; type;
};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __apply_cv&lt;_Tp&amp;, _Up, true, false&gt;
{
    typedef const _Up&amp; type;
};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __apply_cv&lt;_Tp&amp;, _Up, false, true&gt;
{
    typedef volatile _Up&amp; type;
};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __apply_cv&lt;_Tp&amp;, _Up, true, true&gt;
{
    typedef const volatile _Up&amp; type;
};

template &lt;class <span class="ge">_Tp, bool = is_</span>integral&lt;_Tp&gt;::value || is_enum&lt;_Tp&gt;::value&gt;
struct __make_signed {};

template &lt;class _Tp&gt;
struct __make_signed&lt;_Tp, true&gt;
{
    typedef typename __find_first&lt;__signed_types, sizeof(_Tp)&gt;::type type;
};

template &lt;&gt; struct __make_signed&lt;bool, true&gt; {};
template &lt;&gt; struct __make_signed&lt; signed short, true&gt; {typedef short type;};
template &lt;&gt; struct __make_signed&lt;unsigned short, true&gt; {typedef short type;};
template &lt;&gt; struct __make_signed&lt; signed int, true&gt; {typedef int type;};
template &lt;&gt; struct __make_signed&lt;unsigned int, true&gt; {typedef int type;};
template &lt;&gt; struct __make_signed&lt; signed long, true&gt; {typedef long type;};
template &lt;&gt; struct __make_signed&lt;unsigned long, true&gt; {typedef long type;};
template &lt;&gt; struct __make_signed&lt; signed long long, true&gt; {typedef long long type;};
template &lt;&gt; struct __make_signed&lt;unsigned long long, true&gt; {typedef long long type;};

template &lt;&gt; struct __make_signed&lt;__int128_t, true&gt; {typedef __int128_t type;};
template &lt;&gt; struct __make_signed&lt;__uint128_t, true&gt; {typedef __int128_t type;};


template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) make_signed
{
    typedef typename __apply_cv&lt;_Tp, typename __make_signed&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::type&gt;::type type;
};





template &lt;class <span class="ge">_Tp, bool = is_</span>integral&lt;_Tp&gt;::value || is_enum&lt;_Tp&gt;::value&gt;
struct __make_unsigned {};

template &lt;class _Tp&gt;
struct __make_unsigned&lt;_Tp, true&gt;
{
    typedef typename __find_first&lt;__unsigned_types, sizeof(_Tp)&gt;::type type;
};

template &lt;&gt; struct __make_unsigned&lt;bool, true&gt; {};
template &lt;&gt; struct __make_unsigned&lt; signed short, true&gt; {typedef unsigned short type;};
template &lt;&gt; struct __make_unsigned&lt;unsigned short, true&gt; {typedef unsigned short type;};
template &lt;&gt; struct __make_unsigned&lt; signed int, true&gt; {typedef unsigned int type;};
template &lt;&gt; struct __make_unsigned&lt;unsigned int, true&gt; {typedef unsigned int type;};
template &lt;&gt; struct __make_unsigned&lt; signed long, true&gt; {typedef unsigned long type;};
template &lt;&gt; struct __make_unsigned&lt;unsigned long, true&gt; {typedef unsigned long type;};
template &lt;&gt; struct __make_unsigned&lt; signed long long, true&gt; {typedef unsigned long long type;};
template &lt;&gt; struct __make_unsigned&lt;unsigned long long, true&gt; {typedef unsigned long long type;};

template &lt;&gt; struct __make_unsigned&lt;__int128_t, true&gt; {typedef __uint128_t type;};
template &lt;&gt; struct __make_unsigned&lt;__uint128_t, true&gt; {typedef __uint128_t type;};


template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) make_unsigned
{
    typedef typename __apply_cv&lt;_Tp, typename __make_unsigned&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::type&gt;::type type;
};





template &lt;class <span class="ge">_Tp, class _</span>Up, class = void&gt;
struct __common_type2_imp {};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __common_type2_imp&lt;_Tp, _Up,
                          typename __void_t&lt;__decltype(true ? std::__1::declval&lt;_Tp&gt;() : std::__1::declval&lt;_Up&gt;())&gt;::type&gt;


{
  typedef typename decay&lt;__decltype(true ? std::__1::declval&lt;_Tp&gt;() : std::__1::declval&lt;_Up&gt;())&gt;::type type;


};

template &lt;class, class = void&gt;
struct __common_type_impl {};




template &lt;class... Tp&gt;
struct __common_types;
template &lt;class... _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) common_type;
template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __common_type_impl&lt;
    __common_types&lt;_Tp, _Up&gt;,
    typename __void_t&lt;typename common_type&lt;_Tp, _Up&gt;::type&gt;::type&gt;
{
  typedef typename common_type&lt;_Tp, _Up&gt;::type type;
};

template &lt;class <span class="ge">_Tp, class _</span>Up, class <span class="ge">_Vp , class... _</span>Rest&gt;
struct __common_type_impl&lt;
    __common_types&lt;_Tp, <span class="ge">_Up, _</span>Vp , _Rest...&gt;,
    typename __void_t&lt;typename common_type&lt;_Tp, _Up&gt;::type&gt;::type&gt;
    : __common_type_impl&lt;__common_types&lt;typename common_type&lt;_Tp, _Up&gt;::type,
                                        <span class="ge">_Vp , _</span>Rest...&gt; &gt; {
};



template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) common_type&lt;&gt; {};



template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) common_type&lt;_Tp&gt;
    : public common_type&lt;_Tp, _Tp&gt; {};



template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) common_type&lt;_Tp, _Up&gt;
    : conditional&lt;
        <span class="ge">_IsSame&lt;_</span>Tp, typename decay&lt;_Tp&gt;::type&gt;::value &amp;&amp; <span class="ge">_IsSame&lt;_</span>Up, typename decay&lt;_Up&gt;::type&gt;::value,
        __common_type2_imp&lt;_Tp, _Up&gt;,
        common_type&lt;typename decay&lt;_Tp&gt;::type, typename decay&lt;_Up&gt;::type&gt;
    &gt;::type
{};



template &lt;class <span class="ge">_Tp, class _</span>Up, class <span class="ge">_Vp , class... _</span>Rest&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;)))
    common_type&lt;_Tp, <span class="ge">_Up, _</span>Vp , _Rest...&gt;
    : __common_type_impl&lt;
          __common_types&lt;_Tp, <span class="ge">_Up, _</span>Vp , _Rest...&gt; &gt; {};
template&lt;typename, typename <span class="ge">_Tp&gt; struct __select_</span>2nd { typedef _Tp type; };

template &lt;class <span class="ge">_Tp, class _</span>Arg&gt;
typename __select_2nd&lt;__decltype((std::__1::declval&lt;_Tp&gt;() = std::__1::declval&lt;_Arg&gt;())), true_type&gt;::type
__is_assignable_test(int);

template &lt;class, class&gt;
false_type __is_assignable_test(...);


template &lt;class <span class="ge">_Tp, class _</span>Arg, bool = is_void&lt;_Tp&gt;::value || is_void&lt;_Arg&gt;::value&gt;
struct __is_assignable_imp
    : public <span class="gs">__decltype((std::__</span>1::__is_assignable_test&lt;_Tp, _Arg&gt;(0))) {};

template &lt;class <span class="ge">_Tp, class _</span>Arg&gt;
struct __is_assignable_imp&lt;_Tp, _Arg, true&gt;
    : public false_type
{
};

template &lt;class <span class="ge">_Tp, class _</span>Arg&gt;
struct is_assignable
    : public __is_assignable_imp&lt;_Tp, _Arg&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_copy_assignable
    : public is_assignable&lt;typename add_lvalue_reference&lt;_Tp&gt;::type,
                  typename add_lvalue_reference&lt;typename add_const&lt;_Tp&gt;::type&gt;::type&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_move_assignable
    : public is_assignable&lt;typename add_lvalue_reference&lt;_Tp&gt;::type,
                           typename add_rvalue_reference&lt;_Tp&gt;::type&gt; {};
template &lt;class&gt;
struct __is_destructible_apply { typedef int type; };

template &lt;typename _Tp&gt;
struct __is_destructor_wellformed {
    template &lt;typename _Tp1&gt;
    static char __test (
        typename __is_destructible_apply&lt;__decltype(std::__1::declval&lt;_Tp1&amp;&gt;().~_Tp1())&gt;::type
    );

    template &lt;typename _Tp1&gt;
    static <span class="gs">__two __</span>test (...);

    static const bool value = sizeof(__test&lt;_Tp&gt;(12)) == sizeof(char);
};

template &lt;class _Tp, bool&gt;
struct __destructible_imp;

template &lt;class _Tp&gt;
struct __destructible_imp&lt;_Tp, false&gt;
   : public std::__1::integral_constant&lt;bool,
        __is_destructor_wellformed&lt;typename std::__1::remove_all_extents&lt;_Tp&gt;::type&gt;::value&gt; {};

template &lt;class _Tp&gt;
struct __destructible_imp&lt;_Tp, true&gt;
    : public std::__1::true_type {};

template &lt;class _Tp, bool&gt;
struct __destructible_false;

template &lt;class _Tp&gt;
struct __destructible_false&lt;_Tp, false&gt; : public __destructible_imp&lt;_Tp, std::__1::is_reference&lt;_Tp&gt;::value&gt; {};

template &lt;class _Tp&gt;
struct __destructible_false&lt;_Tp, true&gt; : public std::__1::false_type {};

template &lt;class _Tp&gt;
struct is_destructible
    : public __destructible_false&lt;_Tp, std::__1::is_function&lt;_Tp&gt;::value&gt; {};

template &lt;class _Tp&gt;
struct is_destructible&lt;_Tp[]&gt;
    : public std::__1::false_type {};

template &lt;&gt;
struct is_destructible&lt;void&gt;
    : public std::__1::false_type {};
template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename remove_reference&lt;_Tp&gt;::type&amp;&amp;
move(_Tp&amp;&amp; __t) throw()
{
    typedef typename remove_reference&lt;_Tp&gt;::type _Up;
    return static_cast&lt;_Up&amp;&amp;&gt;(__t);
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp&amp;&amp;
forward(typename remove_reference&lt;_Tp&gt;::type&amp; __t) throw()
{
    return static_cast&lt;_Tp&amp;&amp;&gt;(__t);
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp&amp;&amp;
forward(typename remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) throw()
{
    <span class="ge">_Static_</span>assert(!is_lvalue_reference&lt;_Tp&gt;::value, &quot;can not forward an rvalue as an lvalue&quot;);

    return static_cast&lt;_Tp&amp;&amp;&gt;(__t);
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename decay&lt;_Tp&gt;::type
__decay_copy(_Tp&amp;&amp; __t)
{
    return std::__1::forward&lt;_Tp&gt;(__t);
}

template &lt;class <span class="ge">_MP, bool _</span>IsMemberFunctionPtr, bool _IsMemberObjectPtr&gt;
struct __member_pointer_traits_imp
{
};

template &lt;class <span class="ge">_Rp, class _</span>Class, class ..._Param&gt;
struct __member_pointer_traits_imp&lt;_Rp (<span class="ge">_Class::*)(_</span>Param...), true, false&gt;
{
    typedef <span class="ge">_Class _</span>ClassType;
    typedef <span class="ge">_Rp _</span>ReturnType;
    typedef <span class="ge">_Rp (_</span>FnType) (_Param...);
};

template &lt;class <span class="ge">_Rp, class _</span>Class, class ..._Param&gt;
struct __member_pointer_traits_imp&lt;_Rp (<span class="ge">_Class::*)(_</span>Param..., ...), true, false&gt;
{
    typedef <span class="ge">_Class _</span>ClassType;
    typedef <span class="ge">_Rp _</span>ReturnType;
    typedef <span class="ge">_Rp (_</span>FnType) (_Param..., ...);
};

template &lt;class <span class="ge">_Rp, class _</span>Class, class ..._Param&gt;
struct __member_pointer_traits_imp&lt;_Rp (<span class="ge">_Class::*)(_</span>Param...) const, true, false&gt;
{
    typedef <span class="ge">_Class const _</span>ClassType;
    typedef <span class="ge">_Rp _</span>ReturnType;
    typedef <span class="ge">_Rp (_</span>FnType) (_Param...);
};

template &lt;class <span class="ge">_Rp, class _</span>Class, class ..._Param&gt;
struct __member_pointer_traits_imp&lt;_Rp (<span class="ge">_Class::*)(_</span>Param..., ...) const, true, false&gt;
{
    typedef <span class="ge">_Class const _</span>ClassType;
    typedef <span class="ge">_Rp _</span>ReturnType;
    typedef <span class="ge">_Rp (_</span>FnType) (_Param..., ...);
};

template &lt;class <span class="ge">_Rp, class _</span>Class, class ..._Param&gt;
struct __member_pointer_traits_imp&lt;_Rp (<span class="ge">_Class::*)(_</span>Param...) volatile, true, false&gt;
{
    typedef <span class="ge">_Class volatile _</span>ClassType;
    typedef <span class="ge">_Rp _</span>ReturnType;
    typedef <span class="ge">_Rp (_</span>FnType) (_Param...);
};

template &lt;class <span class="ge">_Rp, class _</span>Class, class ..._Param&gt;
struct __member_pointer_traits_imp&lt;_Rp (<span class="ge">_Class::*)(_</span>Param..., ...) volatile, true, false&gt;
{
    typedef <span class="ge">_Class volatile _</span>ClassType;
    typedef <span class="ge">_Rp _</span>ReturnType;
    typedef <span class="ge">_Rp (_</span>FnType) (_Param..., ...);
};

template &lt;class <span class="ge">_Rp, class _</span>Class, class ..._Param&gt;
struct __member_pointer_traits_imp&lt;_Rp (<span class="ge">_Class::*)(_</span>Param...) const volatile, true, false&gt;
{
    typedef <span class="ge">_Class const volatile _</span>ClassType;
    typedef <span class="ge">_Rp _</span>ReturnType;
    typedef <span class="ge">_Rp (_</span>FnType) (_Param...);
};

template &lt;class <span class="ge">_Rp, class _</span>Class, class ..._Param&gt;
struct __member_pointer_traits_imp&lt;_Rp (<span class="ge">_Class::*)(_</span>Param..., ...) const volatile, true, false&gt;
{
    typedef <span class="ge">_Class const volatile _</span>ClassType;
    typedef <span class="ge">_Rp _</span>ReturnType;
    typedef <span class="ge">_Rp (_</span>FnType) (_Param..., ...);
};
template &lt;class <span class="ge">_Rp, class _</span>Class&gt;
struct __member_pointer_traits_imp&lt;_Rp _Class::*, false, true&gt;
{
    typedef <span class="ge">_Class _</span>ClassType;
    typedef <span class="ge">_Rp _</span>ReturnType;
};

template &lt;class _MP&gt;
struct __member_pointer_traits
    : public __member_pointer_traits_imp&lt;typename remove_cv&lt;_MP&gt;::type,
                    is_member_function_pointer&lt;_MP&gt;::value,
                    is_member_object_pointer&lt;_MP&gt;::value&gt;
{



};


template &lt;class _DecayedFp&gt;
struct __member_pointer_class_type {};

template &lt;class <span class="ge">_Ret, class _</span>ClassType&gt;
struct __member_pointer_class_type&lt;_Ret _ClassType::*&gt; {
  typedef _ClassType type;
};



template &lt;class <span class="ge">_Callable&gt; class result_</span>of;



template &lt;class _Fn, bool, bool&gt;
class __result_of
{
};

template &lt;class _Fn&gt;
class __result_of&lt;_Fn(), true, false&gt;
{
public:
    typedef __decltype(declval&lt;_Fn&gt;()()) type;
};

template &lt;class <span class="ge">_Fn, class _</span>A0&gt;
class __result_of&lt;_Fn(_A0), true, false&gt;
{
public:
    typedef __decltype(declval&lt;_Fn&gt;()(declval&lt;_A0&gt;())) type;
};

template &lt;class <span class="ge">_Fn, class _</span>A0, class _A1&gt;
class __result_of&lt;_Fn(_A0, _A1), true, false&gt;
{
public:
    typedef __decltype(declval&lt;_Fn&gt;()(declval&lt;_A0&gt;(), declval&lt;_A1&gt;())) type;
};

template &lt;class <span class="ge">_Fn, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
class __result_of&lt;_Fn(_A0, <span class="ge">_A1, _</span>A2), true, false&gt;
{
public:
    typedef __decltype(declval&lt;_Fn&gt;()(declval&lt;_A0&gt;(), declval&lt;_A1&gt;(), declval&lt;_A2&gt;())) type;
};

template &lt;class <span class="ge">_MP, class _</span>Tp, bool _IsMemberFunctionPtr&gt;
struct __result_of_mp;



template &lt;class <span class="ge">_MP, class _</span>Tp&gt;
struct __result_of_mp&lt;_MP, _Tp, true&gt;
    : public <span class="gs">__identity&lt;typename __</span>member_pointer_traits&lt;_MP&gt;::_ReturnType&gt;
{
};



template &lt;class <span class="ge">_MP, class _</span>Tp, bool&gt;
struct __result_of_mdp;

template &lt;class <span class="ge">_Rp, class _</span>Class, class _Tp&gt;
struct __result_of_mdp&lt;_Rp <span class="ge">_Class::*, _</span>Tp, false&gt;
{
    typedef typename __apply_cv&lt;__decltype(*std::__1::declval&lt;_Tp&gt;()), _Rp&gt;::type&amp; type;
};

template &lt;class <span class="ge">_Rp, class _</span>Class, class _Tp&gt;
struct __result_of_mdp&lt;_Rp <span class="ge">_Class::*, _</span>Tp, true&gt;
{
    typedef typename __apply_cv&lt;_Tp, _Rp&gt;::type&amp; type;
};

template &lt;class <span class="ge">_Rp, class _</span>Class, class _Tp&gt;
struct __result_of_mp&lt;_Rp <span class="ge">_Class::*, _</span>Tp, false&gt;
    : public __result_of_mdp&lt;_Rp <span class="ge">_Class::*, _</span>Tp,
            is_base_of&lt;_Class, typename remove_reference&lt;_Tp&gt;::type&gt;::value&gt;
{
};



template &lt;class <span class="ge">_Fn, class _</span>Tp&gt;
class __result_of&lt;_Fn(_Tp), false, true&gt;
    : public __result_of_mp&lt;typename remove_reference&lt;_Fn&gt;::type,
                            _Tp,
                            is_member_function_pointer&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::value&gt;
{
};

template &lt;class <span class="ge">_Fn, class _</span>Tp, class _A0&gt;
class __result_of&lt;_Fn(_Tp, _A0), false, true&gt;
    : public __result_of_mp&lt;typename remove_reference&lt;_Fn&gt;::type,
                            _Tp,
                            is_member_function_pointer&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::value&gt;
{
};

template &lt;class <span class="ge">_Fn, class _</span>Tp, class <span class="ge">_A0, class _</span>A1&gt;
class __result_of&lt;_Fn(_Tp, <span class="ge">_A0, _</span>A1), false, true&gt;
    : public __result_of_mp&lt;typename remove_reference&lt;_Fn&gt;::type,
                            _Tp,
                            is_member_function_pointer&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::value&gt;
{
};

template &lt;class <span class="ge">_Fn, class _</span>Tp, class <span class="ge">_A0, class _</span>A1, class _A2&gt;
class __result_of&lt;_Fn(_Tp, <span class="ge">_A0, _</span>A1, _A2), false, true&gt;
    : public __result_of_mp&lt;typename remove_reference&lt;_Fn&gt;::type,
                            _Tp,
                            is_member_function_pointer&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::value&gt;
{
};



template &lt;class _Fn&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) result_of&lt;_Fn()&gt;
    : public __result_of&lt;_Fn(),
                         is_class&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::value ||
                         is_function&lt;typename remove_pointer&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::type&gt;::value,
                         is_member_pointer&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::value
<span class="k">                        &gt;</span>
<span class="ge">{</span>
};

template &lt;class <span class="ge">_Fn, class _</span>A0&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) result_of&lt;_Fn(_A0)&gt;
    : public __result_of&lt;_Fn(_A0),
                         is_class&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::value ||
                         is_function&lt;typename remove_pointer&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::type&gt;::value,
                         is_member_pointer&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::value
<span class="k">                        &gt;</span>
<span class="ge">{</span>
};

template &lt;class <span class="ge">_Fn, class _</span>A0, class _A1&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) result_of&lt;_Fn(_A0, _A1)&gt;
    : public __result_of&lt;_Fn(_A0, _A1),
                         is_class&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::value ||
                         is_function&lt;typename remove_pointer&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::type&gt;::value,
                         is_member_pointer&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::value
<span class="k">                        &gt;</span>
<span class="ge">{</span>
};

template &lt;class <span class="ge">_Fn, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) result_of&lt;_Fn(_A0, <span class="ge">_A1, _</span>A2)&gt;
    : public __result_of&lt;_Fn(_A0, <span class="ge">_A1, _</span>A2),
                         is_class&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::value ||
                         is_function&lt;typename remove_pointer&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::type&gt;::value,
                         is_member_pointer&lt;typename remove_reference&lt;_Fn&gt;::type&gt;::value
<span class="k">                        &gt;</span>
<span class="ge">{</span>
};





namespace __is_construct
{
struct __nat {};
}
template &lt;class <span class="ge">_Tp, class ..._</span>Args&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_constructible
    : public integral_constant&lt;bool, __is_constructible(_Tp, _Args...)&gt;
    {};
template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_default_constructible
    : public is_constructible&lt;_Tp&gt;
    {};
template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_copy_constructible
    : public is_constructible&lt;_Tp,
                  typename add_lvalue_reference&lt;typename add_const&lt;_Tp&gt;::type&gt;::type&gt; {};
template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_move_constructible
    : public is_constructible&lt;_Tp, typename add_rvalue_reference&lt;_Tp&gt;::type&gt;
    {};
template &lt;class <span class="ge">_Tp, class... _</span>Args&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_trivially_constructible
    : integral_constant&lt;bool, __is_trivially_constructible(_Tp, _Args...)&gt;
{
};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_trivially_default_constructible
    : public is_trivially_constructible&lt;_Tp&gt;
    {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_trivially_copy_constructible
    : public is_trivially_constructible&lt;_Tp, typename add_lvalue_reference&lt;const _Tp&gt;::type&gt;
    {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_trivially_move_constructible
    : public is_trivially_constructible&lt;_Tp, typename add_rvalue_reference&lt;_Tp&gt;::type&gt;
    {};
template &lt;class <span class="ge">_Tp, class _</span>Arg&gt;
struct is_trivially_assignable
    : integral_constant&lt;bool, __is_trivially_assignable(_Tp, _Arg)&gt;
{
};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_trivially_copy_assignable
    : public is_trivially_assignable&lt;typename add_lvalue_reference&lt;_Tp&gt;::type,
                  typename add_lvalue_reference&lt;typename add_const&lt;_Tp&gt;::type&gt;::type&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_trivially_move_assignable
    : public is_trivially_assignable&lt;typename add_lvalue_reference&lt;_Tp&gt;::type,
                                     typename add_rvalue_reference&lt;_Tp&gt;::type&gt;
    {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_trivially_destructible
    : public integral_constant&lt;bool, __is_trivially_destructible(_Tp)&gt; {};
template &lt;class <span class="ge">_Tp, class... _</span>Args&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_nothrow_constructible
    : public integral_constant&lt;bool, __is_nothrow_constructible(_Tp, _Args...)&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_nothrow_default_constructible
    : public is_nothrow_constructible&lt;_Tp&gt;
    {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_nothrow_copy_constructible
    : public is_nothrow_constructible&lt;_Tp,
                  typename add_lvalue_reference&lt;typename add_const&lt;_Tp&gt;::type&gt;::type&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_nothrow_move_constructible
    : public is_nothrow_constructible&lt;_Tp, typename add_rvalue_reference&lt;_Tp&gt;::type&gt;
    {};
template &lt;class <span class="ge">_Tp, class _</span>Arg&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_nothrow_assignable
    : public integral_constant&lt;bool, __is_nothrow_assignable(_Tp, _Arg)&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_nothrow_copy_assignable
    : public is_nothrow_assignable&lt;typename add_lvalue_reference&lt;_Tp&gt;::type,
                  typename add_lvalue_reference&lt;typename add_const&lt;_Tp&gt;::type&gt;::type&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_nothrow_move_assignable
    : public is_nothrow_assignable&lt;typename add_lvalue_reference&lt;_Tp&gt;::type,
                                     typename add_rvalue_reference&lt;_Tp&gt;::type&gt;
    {};
template &lt;class <span class="ge">_Tp&gt; struct __libcpp_</span>nothrow_destructor
    : public integral_constant&lt;bool, is_scalar&lt;_Tp&gt;::value ||
                                     is_reference&lt;_Tp&gt;::value&gt; {};

template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_nothrow_destructible
    : public __libcpp_nothrow_destructor&lt;typename remove_all_extents&lt;_Tp&gt;::type&gt; {};

template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_nothrow_destructible&lt;_Tp[]&gt;
    : public false_type {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_pod
    : public integral_constant&lt;bool, __is_pod(_Tp)&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_literal_type
    : public integral_constant&lt;bool, __is_literal_type(_Tp)&gt;
    {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_standard_layout

    : public integral_constant&lt;bool, __is_standard_layout(_Tp)&gt;



    {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_trivially_copyable

    : public integral_constant&lt;bool, __is_trivially_copyable(_Tp)&gt;





    {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_trivial

    : public integral_constant&lt;bool, __is_trivial(_Tp)&gt;




    {};







template &lt;class <span class="ge">_Tp&gt; struct __is_</span>reference_wrapper_impl : public false_type {};
template &lt;class <span class="ge">_Tp&gt; struct __is_</span>reference_wrapper_impl&lt;reference_wrapper&lt;_Tp&gt; &gt; : public true_type {};
template &lt;class <span class="ge">_Tp&gt; struct __is_</span>reference_wrapper
    : public __is_reference_wrapper_impl&lt;typename remove_cv&lt;_Tp&gt;::type&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __is_</span>swappable;
template &lt;class <span class="ge">_Tp&gt; struct __is_</span>nothrow_swappable;



template &lt;class <span class="ge">_ForwardIterator1, class _</span>ForwardIterator2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, <span class="ge">_ForwardIterator1 __last1, _</span>ForwardIterator2 __first2);

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))







void


swap(_Tp&amp; __x, <span class="ge">_Tp&amp; _</span>_y)

{
    <span class="ge">_Tp __t(std::__1::move(_</span>_x));
    <span class="gs">__x = std::__</span>1::move(__y);
    <span class="gs">__y = std::__</span>1::move(__t);
}

template&lt;class <span class="ge">_Tp, size_</span>t _Np&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if&lt;
    __is_swappable&lt;_Tp&gt;::value
&gt;::type
swap(_Tp (&amp;__a)[_Np], <span class="ge">_Tp (&amp;__b)[_</span>Np])
{
    std::__1::swap_ranges(__a, __a + <span class="ge">_Np, _</span>_b);
}

template &lt;class <span class="ge">_ForwardIterator1, class _</span>ForwardIterator2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, <span class="ge">_ForwardIterator1 __last1, _</span>ForwardIterator2 __first2)
{
    for(; <span class="gs">__first1 != __</span>last1; ++__first1, (void) ++__first2)
        swap(*__first1, *__first2);
    return __first2;
}



template &lt;class <span class="ge">_ForwardIterator1, class _</span>ForwardIterator2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
iter_swap(_ForwardIterator1 __a, <span class="ge">_ForwardIterator2 _</span>_b)



{
    swap(*__a, *__b);
}



namespace __detail
{


template &lt;class <span class="ge">_Tp, class _</span>Up = _Tp,
          bool <span class="ge">_NotVoid = !is_</span>void&lt;_Tp&gt;::value &amp;&amp; !is_void&lt;_Up&gt;::value&gt;
struct __swappable_with
{
    template &lt;class <span class="ge">_LHS, class _</span>RHS&gt;
    static <span class="gs">__decltype(swap(std::__</span>1::declval&lt;_LHS&gt;(), std::__1::declval&lt;_RHS&gt;()))
    __test_swap(int);
    template &lt;class, class&gt;
    static <span class="gs">__nat __</span>test_swap(long);


    typedef <span class="gs">__decltype((__</span>test_swap&lt;_Tp, <span class="ge">_Up&gt;(0))) _</span>_swap1;
    typedef <span class="gs">__decltype((__</span>test_swap&lt;_Up, <span class="ge">_Tp&gt;(0))) _</span>_swap2;

    static const bool value = <span class="ge">_IsNotSame&lt;__swap1, _</span>_nat&gt;::value
                           &amp;&amp; <span class="ge">_IsNotSame&lt;__swap2, _</span>_nat&gt;::value;
};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __swappable_with&lt;_Tp, <span class="ge">_Up, false&gt; : false_</span>type {};

template &lt;class <span class="ge">_Tp, class _</span>Up = <span class="ge">_Tp, bool _</span>Swappable = __swappable_with&lt;_Tp, _Up&gt;::value&gt;
struct __nothrow_swappable_with {
  static const bool value =




      false;

};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __nothrow_swappable_with&lt;_Tp, <span class="ge">_Up, false&gt; : false_</span>type {};

}

template &lt;class _Tp&gt;
struct __is_swappable
    : public integral_constant&lt;bool, <span class="gs">__detail::__</span>swappable_with&lt;_Tp&amp;&gt;::value&gt;
{
};

template &lt;class _Tp&gt;
struct __is_nothrow_swappable
    : public integral_constant&lt;bool, <span class="gs">__detail::__</span>nothrow_swappable_with&lt;_Tp&amp;&gt;::value&gt;
{
};
template &lt;class <span class="ge">_Tp, bool = is_</span>enum&lt;_Tp&gt;::value&gt; struct __underlying_type_impl;

template &lt;class _Tp&gt;
struct __underlying_type_impl&lt;_Tp, false&gt; {};

template &lt;class _Tp&gt;
struct __underlying_type_impl&lt;_Tp, true&gt;
{
    typedef __underlying_type(_Tp) type;
};

template &lt;class _Tp&gt;
struct underlying_type : __underlying_type_impl&lt;_Tp, is_enum&lt;_Tp&gt;::value&gt; {};






template &lt;class <span class="ge">_Tp, bool = is_</span>enum&lt;_Tp&gt;::value&gt;
struct __sfinae_underlying_type
{
    typedef typename underlying_type&lt;_Tp&gt;::type type;
    typedef <span class="gs">__decltype(((type)1) + 0) __</span>promoted_type;
};

template &lt;class _Tp&gt;
struct __sfinae_underlying_type&lt;_Tp, false&gt; {};

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __convert_to_integral(int <span class="gs">__val) { return __</span>val; }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
unsigned __convert_to_integral(unsigned <span class="gs">__val) { return __</span>val; }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
long __convert_to_integral(long <span class="gs">__val) { return __</span>val; }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
unsigned long __convert_to_integral(unsigned long <span class="gs">__val) { return __</span>val; }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
long long __convert_to_integral(long long <span class="gs">__val) { return __</span>val; }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
unsigned long long __convert_to_integral(unsigned long long <span class="gs">__val) {return __</span>val; }

template&lt;typename _Fp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if&lt;is_floating_point&lt;_Fp&gt;::value, long long&gt;::type
 __convert_to_integral(_Fp <span class="gs">__val) { return __</span>val; }


inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__int128_t __convert_to_integral(__int128_t <span class="gs">__val) { return __</span>val; }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__uint128_t __convert_to_integral(__uint128_t <span class="gs">__val) { return __</span>val; }


template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __sfinae_underlying_type&lt;_Tp&gt;::__promoted_type
__convert_to_integral(_Tp <span class="gs">__val) { return __</span>val; }
inline
bool __libcpp_is_constant_evaluated() throw() { return __builtin_is_constant_evaluated(); }





template &lt;class _CharT&gt;
using <span class="ge">_IsCharLikeType = _</span>And&lt;is_standard_layout&lt;_CharT&gt;, is_trivial&lt;_CharT&gt; &gt;;

} }


extern &quot;C&quot; {
void <span class="ge">*memchr(const void *</span><span class="gs">__s, int __</span>c, size_t __n);
int memcmp(const void <span class="ge">*__s1, const void *</span>__s2, size_t __n);
void <span class="ge">*memcpy(void *</span><span class="gs">__dst, const void *__</span>src, size_t __n);
void <span class="ge">*memmove(void *</span><span class="gs">__dst, const void *__</span>src, size_t __len);
void <span class="ge">*memset(void *</span><span class="gs">__b, int __</span>c, size_t __len);
char <span class="ge">*strcat(char *</span><span class="gs">__s1, const char *__</span>s2);
char <span class="ge">*strchr(const char *</span><span class="gs">__s, int __</span>c);
int strcmp(const char <span class="ge">*__s1, const char *</span>__s2);
int strcoll(const char <span class="ge">*__s1, const char *</span>__s2);
char <span class="ge">*strcpy(char *</span><span class="gs">__dst, const char *__</span>src);
size_t strcspn(const char <span class="ge">*__s, const char *</span>__charset);
char *strerror(int <span class="gs">__errnum) __</span>asm(&quot;_&quot; &quot;strerror&quot; );
size_t strlen(const char *__s);
char <span class="ge">*strncat(char *</span><span class="gs">__s1, const char *__</span>s2, size_t __n);
int strncmp(const char <span class="ge">*__s1, const char *</span>__s2, size_t __n);
char <span class="ge">*strncpy(char *</span><span class="gs">__dst, const char *__</span>src, size_t __n);
char <span class="ge">*strpbrk(const char *</span><span class="gs">__s, const char *__</span>charset);
char <span class="ge">*strrchr(const char *</span><span class="gs">__s, int __</span>c);
size_t strspn(const char <span class="ge">*__s, const char *</span>__charset);
char <span class="ge">*strstr(const char *</span><span class="gs">__big, const char *__</span>little);
char <span class="ge">*strtok(char *</span><span class="gs">__str, const char *__</span>sep);
size_t strxfrm(char <span class="ge">*__s1, const char *</span>__s2, size_t __n);
}
extern &quot;C&quot; {
char <span class="ge">*strtok_r(char *</span><span class="gs">__str, const char *__</span>sep, char **__lasts);
}
extern &quot;C&quot; {
int strerror_r(int <span class="gs">__errnum, char *__</span>strerrbuf, size_t __buflen);
char <span class="ge">*strdup(const char *</span>__s1);
void <span class="ge">*memccpy(void *</span><span class="gs">__dst, const void *__</span>src, int __c, size_t __n);
}
extern &quot;C&quot; {
char <span class="ge">*stpcpy(char *</span><span class="gs">__dst, const char *__</span>src);
char <span class="ge">*stpncpy(char *</span><span class="gs">__dst, const char *__</span>src, size_t <span class="gs">__n) __</span>attribute__((availability(macosx,introduced=10.7)));
char <span class="ge">*strndup(const char *</span>__s1, size_t <span class="gs">__n) __</span>attribute__((availability(macosx,introduced=10.7)));
size_t strnlen(const char *__s1, size_t <span class="gs">__n) __</span>attribute__((availability(macosx,introduced=10.7)));
char *strsignal(int __sig);
}






typedef int errno_t;

extern &quot;C&quot; {
errno_t memset_s(void *__s, rsize_t <span class="gs">__smax, int __</span>c, rsize_t <span class="gs">__n) __</span>attribute__((availability(macosx,introduced=10.9)));
}







extern &quot;C&quot; {
void <span class="ge">*memmem(const void *</span>__big, size_t __big_len, const void *__little, size_t __little_len) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
void memset_pattern4(void <span class="ge">*__b, const void *</span>__pattern4, size_t <span class="gs">__len) __</span>attribute__((availability(macosx,introduced=10.5)));
void memset_pattern8(void <span class="ge">*__b, const void *</span>__pattern8, size_t <span class="gs">__len) __</span>attribute__((availability(macosx,introduced=10.5)));
void memset_pattern16(void <span class="ge">*__b, const void *</span>__pattern16, size_t <span class="gs">__len) __</span>attribute__((availability(macosx,introduced=10.5)));

char <span class="ge">*strcasestr(const char *</span><span class="gs">__big, const char *__</span>little);
char <span class="ge">*strnstr(const char *</span><span class="gs">__big, const char *__</span>little, size_t __len);
size_t strlcat(char <span class="ge">*__dst, const char *</span>__source, size_t __size);
size_t strlcpy(char <span class="ge">*__dst, const char *</span>__source, size_t __size);
void strmode(int <span class="gs">__mode, char *__</span>bp);
char <span class="ge">*strsep(char *</span>*<span class="gs">__stringp, const char *__</span>delim);


void swab(const void * , void * , ssize_t);

<span class="gs">__attribute__</span>((availability(macosx,introduced=10.12.1))) <span class="gs">__attribute__</span>((availability(ios,introduced=10.1)))
<span class="gs">__attribute__</span>((availability(tvos,introduced=10.0.1))) <span class="gs">__attribute__</span>((availability(watchos,introduced=3.1)))
int timingsafe_bcmp(const void <span class="ge">*__b1, const void *</span>__b2, size_t __len);

<span class="gs">__attribute__</span>((availability(macosx,introduced=11.0))) <span class="gs">__attribute__</span>((availability(ios,introduced=14.0)))
<span class="gs">__attribute__</span>((availability(tvos,introduced=14.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=7.0)))
int strsignal_r(int <span class="gs">__sig, char *__</span>strsignalbuf, size_t __buflen);
}







extern &quot;C&quot; {


int bcmp(const void <span class="ge">*, const void *</span>, size_t) ;
void bcopy(const void <span class="ge">*, void *</span>, size_t) ;
void bzero(void *, size_t) ;
char <span class="ge">*index(const char *</span>, int) ;
char <span class="ge">*rindex(const char *</span>, int) ;


int ffs(int);
int strcasecmp(const char <span class="ge">*, const char *</span>);
int strncasecmp(const char <span class="ge">*, const char *</span>, size_t);
}



extern &quot;C&quot; {
int ffsl(long) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.5)));
int ffsll(long long) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.9)));
int fls(int) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.5)));
int flsl(long) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.5)));
int flsll(long long) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.9)));
}


extern &quot;C++&quot; {
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
char* __libcpp_strchr(const char* <span class="gs">__s, int __</span>c) {return (char*)strchr(__s, __c);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
const char* strchr(const char* <span class="gs">__s, int __</span>c) {return __libcpp_strchr(__s, __c);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
      char* strchr( char* <span class="gs">__s, int __</span>c) {return __libcpp_strchr(__s, __c);}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
char* __libcpp_strpbrk(const char* <span class="gs">__s1, const char* __</span>s2) {return (char*)strpbrk(__s1, __s2);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
const char* strpbrk(const char* <span class="gs">__s1, const char* __</span>s2) {return __libcpp_strpbrk(__s1, __s2);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
      char* strpbrk( char* <span class="gs">__s1, const char* __</span>s2) {return __libcpp_strpbrk(__s1, __s2);}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
char* __libcpp_strrchr(const char* <span class="gs">__s, int __</span>c) {return (char*)strrchr(__s, __c);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
const char* strrchr(const char* <span class="gs">__s, int __</span>c) {return __libcpp_strrchr(__s, __c);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
      char* strrchr( char* <span class="gs">__s, int __</span>c) {return __libcpp_strrchr(__s, __c);}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void* __libcpp_memchr(const void* <span class="gs">__s, int __</span>c, size_t <span class="gs">__n) {return (void*)memchr(__</span>s, <span class="gs">__c, __</span>n);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
const void* memchr(const void* <span class="gs">__s, int __</span>c, size_t <span class="gs">__n) {return __</span>libcpp_memchr(__s, <span class="gs">__c, __</span>n);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
      void* memchr( void* <span class="gs">__s, int __</span>c, size_t <span class="gs">__n) {return __</span>libcpp_memchr(__s, <span class="gs">__c, __</span>n);}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
char* __libcpp_strstr(const char* <span class="gs">__s1, const char* __</span>s2) {return (char*)strstr(__s1, __s2);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
const char* strstr(const char* <span class="gs">__s1, const char* __</span>s2) {return __libcpp_strstr(__s1, __s2);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
      char* strstr( char* <span class="gs">__s1, const char* __</span>s2) {return __libcpp_strstr(__s1, __s2);}
}


namespace std { inline namespace __1 {

using ::size_t;
using ::memcpy;
using ::memmove;
using ::strcpy;
using ::strncpy;
using ::strcat;
using ::strncat;
using ::memcmp;
using ::strcmp;
using ::strncmp;
using ::strcoll;
using ::strxfrm;
using ::memchr;
using ::strchr;
using ::strcspn;
using ::strpbrk;
using ::strrchr;
using ::strspn;
using ::strstr;

using ::strtok;

using ::memset;
using ::strerror;
using ::strlen;

} }



namespace std { inline namespace __1 {

template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) tuple_size;
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) tuple_size&lt;const <span class="ge">_Tp&gt; : public tuple_</span>size&lt;_Tp&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) tuple_size&lt;volatile <span class="ge">_Tp&gt; : public tuple_</span>size&lt;_Tp&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) tuple_size&lt;const volatile <span class="ge">_Tp&gt; : public tuple_</span>size&lt;_Tp&gt; {};


template &lt;size_t <span class="ge">_Ip, class _</span>Tp&gt; struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) tuple_element;

template &lt;size_t <span class="ge">_Ip, class _</span>Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) tuple_element&lt;_Ip, const _Tp&gt;
{
    typedef typename add_const&lt;typename tuple_element&lt;_Ip, _Tp&gt;::type&gt;::type type;
};

template &lt;size_t <span class="ge">_Ip, class _</span>Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) tuple_element&lt;_Ip, volatile _Tp&gt;
{
    typedef typename add_volatile&lt;typename tuple_element&lt;_Ip, _Tp&gt;::type&gt;::type type;
};

template &lt;size_t <span class="ge">_Ip, class _</span>Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) tuple_element&lt;_Ip, const volatile _Tp&gt;
{
    typedef typename add_cv&lt;typename tuple_element&lt;_Ip, _Tp&gt;::type&gt;::type type;
};

template &lt;class <span class="ge">_Tp&gt; struct __tuple_</span>like : false_type {};

template &lt;class <span class="ge">_Tp&gt; struct __tuple_</span>like&lt;const <span class="ge">_Tp&gt; : public __tuple_</span>like&lt;_Tp&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __tuple_</span>like&lt;volatile <span class="ge">_Tp&gt; : public __tuple_</span>like&lt;_Tp&gt; {};
template &lt;class <span class="ge">_Tp&gt; struct __tuple_</span>like&lt;const volatile <span class="ge">_Tp&gt; : public __tuple_</span>like&lt;_Tp&gt; {};
template &lt;class <span class="ge">_T1, class _</span>T2&gt; struct __tuple_like&lt;pair&lt;_T1, <span class="ge">_T2&gt; &gt; : true_</span>type {};

template &lt;size_t <span class="ge">_Ip, class _</span>T1, class _T2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename tuple_element&lt;_Ip, pair&lt;_T1, _T2&gt; &gt;::type&amp;
get(pair&lt;_T1, _T2&gt;&amp;) throw();

template &lt;size_t <span class="ge">_Ip, class _</span>T1, class _T2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
const typename tuple_element&lt;_Ip, pair&lt;_T1, _T2&gt; &gt;::type&amp;
get(const pair&lt;_T1, _T2&gt;&amp;) throw();
template &lt;class <span class="ge">_Tp, size_</span>t <span class="ge">_Size&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) array;

template &lt;class <span class="ge">_Tp, size_</span>t <span class="ge">_Size&gt; struct __tuple_</span>like&lt;array&lt;_Tp, <span class="ge">_Size&gt; &gt; : true_</span>type {};

template &lt;size_t <span class="ge">_Ip, class _</span>Tp, size_t _Size&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp&amp;
get(array&lt;_Tp, _Size&gt;&amp;) throw();

template &lt;size_t <span class="ge">_Ip, class _</span>Tp, size_t _Size&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
const _Tp&amp;
get(const array&lt;_Tp, _Size&gt;&amp;) throw();
} }




typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;


typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
typedef long int intmax_t;
typedef long unsigned int uintmax_t;


namespace std { inline namespace __1 {

using::int8_t;
using::int16_t;
using::int32_t;
using::int64_t;

using::uint8_t;
using::uint16_t;
using::uint32_t;
using::uint64_t;

using::int_least8_t;
using::int_least16_t;
using::int_least32_t;
using::int_least64_t;

using::uint_least8_t;
using::uint_least16_t;
using::uint_least32_t;
using::uint_least64_t;

using::int_fast8_t;
using::int_fast16_t;
using::int_fast32_t;
using::int_fast64_t;

using::uint_fast8_t;
using::uint_fast16_t;
using::uint_fast32_t;
using::uint_fast64_t;

using::intptr_t;
using::uintptr_t;

using::intmax_t;
using::uintmax_t;

} }

namespace std { inline namespace __1 {

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) __libcpp_debug_info {
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  __libcpp_debug_info()
      : __file_(std::__1::__get_nullptr_t()), __line_(-1), __pred_(std::__1::__get_nullptr_t()), __msg_(std::__1::__get_nullptr_t()) {}
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  __libcpp_debug_info(const char* <span class="gs">__f, int __</span>l, const char* <span class="gs">__p, const char* __</span>m)
    : __file_(__f), __line_(__l), __pred_(__p), __msg_(__m) {}

  <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) std::string what() const;

  const char* __file_;
  int __line_;
  const char* __pred_;
  const char* __msg_;
};


typedef void(*__libcpp_debug_function_type)(__libcpp_debug_info const&amp;);



extern <span class="gs">__attribute__</span>((__visibility__(&quot;default&quot;))) __libcpp_debug_function_type __libcpp_debug_function;


<span class="gs">__attribute__</span> ((noreturn)) <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;)))
void __libcpp_abort_debug_function(__libcpp_debug_info const&amp;);



<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;)))
bool __libcpp_set_debug_function(__libcpp_debug_function_type __func);
} }


namespace std { inline namespace __1 {

namespace rel_ops
{

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const <span class="ge">_Tp&amp; __x, const _</span>Tp&amp; __y)
{
    return !(__x == __y);
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt; (const <span class="ge">_Tp&amp; __x, const _</span>Tp&amp; __y)
{
    return <span class="gs">__y &lt; __</span>x;
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const <span class="ge">_Tp&amp; __x, const _</span>Tp&amp; __y)
{
    return !(__y &lt; __x);
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const <span class="ge">_Tp&amp; __x, const _</span>Tp&amp; __y)
{
    return !(__x &lt; __y);
}

}







template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
const _Tp&amp;

move_if_noexcept(_Tp&amp; __x) throw()
{
    return std::__1::move(__x);
}






struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) piecewise_construct_t { explicit piecewise_construct_t() = default; };

extern <span class="gs">__attribute__</span>((__visibility__(&quot;default&quot;))) const piecewise_construct_t piecewise_construct;
template &lt;class <span class="ge">_T1, class _</span>T2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) pair



{
    typedef <span class="ge">_T1 first_</span>type;
    typedef <span class="ge">_T2 second_</span>type;

    _T1 first;
    _T2 second;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pair() : first(), second() {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pair(_T1 const&amp; __t1, <span class="ge">_T2 const&amp; __t2) : first(__t1), second(_</span>_t2) {}

    template &lt;class <span class="ge">_U1, class _</span>U2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pair(const pair&lt;_U1, <span class="ge">_U2&gt;&amp; __p) : first(__p.first), second(_</span>_p.second) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pair&amp; operator=(pair const&amp; __p) {
        first = __p.first;
        second = __p.second;
        return *this;
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void
    swap(pair&amp; __p)

    {
        using std::__1::swap;
        swap(first, __p.first);
        swap(second, __p.second);
    }
private:
};






template &lt;class <span class="ge">_T1, class _</span>T2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const pair&lt;_T1,_T2&gt;&amp; __x, const pair&lt;_T1,_T2&gt;&amp; __y)
{
    return <span class="gs">__x.first == __</span>y.first &amp;&amp; <span class="gs">__x.second == __</span>y.second;
}

template &lt;class <span class="ge">_T1, class _</span>T2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const pair&lt;_T1,_T2&gt;&amp; __x, const pair&lt;_T1,_T2&gt;&amp; __y)
{
    return !(__x == __y);
}

template &lt;class <span class="ge">_T1, class _</span>T2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt; (const pair&lt;_T1,_T2&gt;&amp; __x, const pair&lt;_T1,_T2&gt;&amp; __y)
{
    return <span class="gs">__x.first &lt; __</span>y.first || (!(__y.first &lt; <span class="gs">__x.first) &amp;&amp; __</span>x.second &lt; __y.second);
}

template &lt;class <span class="ge">_T1, class _</span>T2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt; (const pair&lt;_T1,_T2&gt;&amp; __x, const pair&lt;_T1,_T2&gt;&amp; __y)
{
    return <span class="gs">__y &lt; __</span>x;
}

template &lt;class <span class="ge">_T1, class _</span>T2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const pair&lt;_T1,_T2&gt;&amp; __x, const pair&lt;_T1,_T2&gt;&amp; __y)
{
    return !(__x &lt; __y);
}

template &lt;class <span class="ge">_T1, class _</span>T2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const pair&lt;_T1,_T2&gt;&amp; __x, const pair&lt;_T1,_T2&gt;&amp; __y)
{
    return !(__y &lt; __x);
}

template &lt;class <span class="ge">_T1, class _</span>T2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    __is_swappable&lt;_T1&gt;::value &amp;&amp;
    __is_swappable&lt;_T2&gt;::value,
    void
&gt;::type
swap(pair&lt;_T1, <span class="ge">_T2&gt;&amp; __x, pair&lt;_</span>T1, <span class="ge">_T2&gt;&amp; _</span>_y)


{
    <span class="gs">__x.swap(__</span>y);
}

template &lt;class _Tp&gt;
struct __unwrap_reference { typedef _Tp type; };

template &lt;class _Tp&gt;
struct __unwrap_reference&lt;reference_wrapper&lt;_Tp&gt; &gt; { typedef _Tp&amp; type; };
template &lt;class _Tp&gt;
struct __unwrap_ref_decay



    : __unwrap_reference&lt;typename decay&lt;_Tp&gt;::type&gt;

{ };
template &lt;class <span class="ge">_T1, class _</span>T2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
pair&lt;_T1,_T2&gt;
make_pair(_T1 __x, <span class="ge">_T2 _</span>_y)
{
    return pair&lt;_T1, <span class="ge">_T2&gt;(__x, _</span>_y);
}



template &lt;class <span class="ge">_T1, class _</span>T2&gt;
  struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) tuple_size&lt;pair&lt;_T1, _T2&gt; &gt;
    : public integral_constant&lt;size_t, 2&gt; {};

template &lt;size_t <span class="ge">_Ip, class _</span>T1, class _T2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) tuple_element&lt;_Ip, pair&lt;_T1, _T2&gt; &gt;
{
    <span class="ge">_Static_</span>assert(_Ip &lt; 2, &quot;Index out of bounds in std::tuple_element&lt;std::pair&lt;T1, T2&gt;&gt;&quot;);
};

template &lt;class <span class="ge">_T1, class _</span>T2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) tuple_element&lt;0, pair&lt;_T1, _T2&gt; &gt;
{
    typedef _T1 type;
};

template &lt;class <span class="ge">_T1, class _</span>T2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) tuple_element&lt;1, pair&lt;_T1, _T2&gt; &gt;
{
    typedef _T2 type;
};

template &lt;size_t <span class="ge">_Ip&gt; struct __get_</span>pair;

template &lt;&gt;
struct __get_pair&lt;0&gt;
{
    template &lt;class <span class="ge">_T1, class _</span>T2&gt;
    static
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    _T1&amp;
    get(pair&lt;_T1, <span class="ge">_T2&gt;&amp; __p) throw() {return _</span>_p.first;}

    template &lt;class <span class="ge">_T1, class _</span>T2&gt;
    static
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const _T1&amp;
    get(const pair&lt;_T1, <span class="ge">_T2&gt;&amp; __p) throw() {return _</span>_p.first;}
};

template &lt;&gt;
struct __get_pair&lt;1&gt;
{
    template &lt;class <span class="ge">_T1, class _</span>T2&gt;
    static
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    _T2&amp;
    get(pair&lt;_T1, <span class="ge">_T2&gt;&amp; __p) throw() {return _</span>_p.second;}

    template &lt;class <span class="ge">_T1, class _</span>T2&gt;
    static
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const _T2&amp;
    get(const pair&lt;_T1, <span class="ge">_T2&gt;&amp; __p) throw() {return _</span>_p.second;}
};

template &lt;size_t <span class="ge">_Ip, class _</span>T1, class _T2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename tuple_element&lt;_Ip, pair&lt;_T1, _T2&gt; &gt;::type&amp;
get(pair&lt;_T1, <span class="ge">_T2&gt;&amp; _</span>_p) throw()
{
    return __get_pair&lt;_Ip&gt;::get(__p);
}

template &lt;size_t <span class="ge">_Ip, class _</span>T1, class _T2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
const typename tuple_element&lt;_Ip, pair&lt;_T1, _T2&gt; &gt;::type&amp;
get(const pair&lt;_T1, <span class="ge">_T2&gt;&amp; _</span>_p) throw()
{
    return __get_pair&lt;_Ip&gt;::get(__p);
}
template &lt;class <span class="ge">_Arg, class _</span>Result&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) unary_function
{
    typedef <span class="ge">_Arg argument_</span>type;
    typedef <span class="ge">_Result result_</span>type;
};

template &lt;class _Size&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Size
<span class="gs">__loadword(const void* __</span>p)
{
    <span class="ge">_Size _</span>_r;
    std::memcpy(&amp;__r, <span class="gs">__p, sizeof(__</span>r));
    return __r;
}




template &lt;class <span class="ge">_Size, size_</span>t = sizeof(_Size)*8&gt;
struct __murmur2_or_cityhash;

template &lt;class _Size&gt;
struct __murmur2_or_cityhash&lt;_Size, 32&gt;
{
    inline <span class="ge">_Size operator()(const void* __key, _</span>Size __len)
         <span class="gs">__attribute__</span>((__no_sanitize__(&quot;unsigned-integer-overflow&quot;)));
};


template &lt;class _Size&gt;
_Size
__murmur2_or_cityhash&lt;_Size, 32&gt;::operator()(const void* __key, <span class="ge">_Size _</span>_len)
{
    const <span class="ge">_Size _</span>_m = 0x5bd1e995;
    const <span class="ge">_Size _</span>_r = 24;
    <span class="ge">_Size __h = _</span>_len;
    const unsigned char* __data = static_cast&lt;const unsigned char*&gt;(__key);
    for (; <span class="gs">__len &gt;= 4; __</span>data += 4, __len -= 4)
    {
        <span class="ge">_Size __k = __loadword&lt;_</span>Size&gt;(__data);
        <span class="gs">__k *= __</span>m;
        <span class="gs">__k ^= __</span>k &gt;&gt; __r;
        <span class="gs">__k *= __</span>m;
        <span class="gs">__h *= __</span>m;
        <span class="gs">__h ^= __</span>k;
    }
    switch (__len)
    {
    case 3:
        <span class="gs">__h ^= __</span>data[2] &lt;&lt; 16;
        <span class="gs">__attribute__</span>((__fallthrough__));
    case 2:
        <span class="gs">__h ^= __</span>data[1] &lt;&lt; 8;
        <span class="gs">__attribute__</span>((__fallthrough__));
    case 1:
        <span class="gs">__h ^= __</span>data[0];
        <span class="gs">__h *= __</span>m;
    }
    <span class="gs">__h ^= __</span>h &gt;&gt; 13;
    <span class="gs">__h *= __</span>m;
    <span class="gs">__h ^= __</span>h &gt;&gt; 15;
    return __h;
}

template &lt;class _Size&gt;
struct __murmur2_or_cityhash&lt;_Size, 64&gt;
{
    inline <span class="ge">_Size operator()(const void* __key, _</span>Size <span class="gs">__len) __</span>attribute__((__no_sanitize__(&quot;unsigned-integer-overflow&quot;)));

 private:

  static const <span class="ge">_Size _</span>_k0 = 0xc3a5c85c97cb3127ULL;
  static const <span class="ge">_Size _</span>_k1 = 0xb492b66fbe98f273ULL;
  static const <span class="ge">_Size _</span>_k2 = 0x9ae16a3b2f90404fULL;
  static const <span class="ge">_Size _</span>_k3 = 0xc949d7c7509e6557ULL;

  static <span class="ge">_Size __rotate(_</span>Size <span class="gs">__val, int __</span>shift) {
    return <span class="gs">__shift == 0 ? __</span>val : ((__val &gt;&gt; <span class="gs">__shift) | (__</span>val &lt;&lt; (64 - __shift)));
  }

  static <span class="ge">_Size __rotate_</span>by_at_least_1(_Size <span class="gs">__val, int __</span>shift) {
    return (<span class="gs">__val &gt;&gt; __</span>shift) | (<span class="gs">__val &lt;&lt; (64 - __</span>shift));
  }

  static <span class="ge">_Size __shift_</span>mix(_Size __val) {
    return <span class="gs">__val ^ (__</span>val &gt;&gt; 47);
  }

  static <span class="ge">_Size __hash_</span>len_16(_Size __u, <span class="ge">_Size _</span>_v)
     <span class="gs">__attribute__</span>((__no_sanitize__(&quot;unsigned-integer-overflow&quot;)))
  {
    const <span class="ge">_Size _</span>_mul = 0x9ddfea08eb382d69ULL;
    <span class="ge">_Size __a = (__u ^ __v) * _</span>_mul;
    <span class="gs">__a ^= (__</span>a &gt;&gt; 47);
    <span class="ge">_Size __b = (__v ^ __a) * _</span>_mul;
    <span class="gs">__b ^= (__</span>b &gt;&gt; 47);
    <span class="gs">__b *= __</span>mul;
    return __b;
  }

  static <span class="ge">_Size __hash_</span>len_0_to_16(const char* __s, <span class="ge">_Size _</span>_len)
     <span class="gs">__attribute__</span>((__no_sanitize__(&quot;unsigned-integer-overflow&quot;)))
  {
    if (__len &gt; 8) {
      const <span class="ge">_Size __a = __loadword&lt;_</span>Size&gt;(__s);
      const <span class="ge">_Size __b = __loadword&lt;_</span>Size&gt;(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + <span class="gs">__len, __</span>len)) ^ __b;
    }
    if (__len &gt;= 4) {
      const uint32_t <span class="gs">__a = __</span>loadword&lt;uint32_t&gt;(__s);
      const uint32_t <span class="gs">__b = __</span>loadword&lt;uint32_t&gt;(__s + __len - 4);
      return __hash_len_16(__len + (<span class="gs">__a &lt;&lt; 3), __</span>b);
    }
    if (__len &gt; 0) {
      const unsigned char <span class="gs">__a = __</span>s[0];
      const unsigned char <span class="gs">__b = __</span>s[__len &gt;&gt; 1];
      const unsigned char <span class="gs">__c = __</span>s[__len - 1];
      const uint32_t __y = static_cast&lt;uint32_t&gt;(__a) +
                           (static_cast&lt;uint32_t&gt;(__b) &lt;&lt; 8);
      const uint32_t <span class="gs">__z = __</span>len + (static_cast&lt;uint32_t&gt;(__c) &lt;&lt; 2);
      return __shift_mix(__y * <span class="gs">__k2 ^ __</span>z * <span class="gs">__k3) * __</span>k2;
    }
    return __k2;
  }

  static <span class="ge">_Size __hash_</span>len_17_to_32(const char *__s, <span class="ge">_Size _</span>_len)
     <span class="gs">__attribute__</span>((__no_sanitize__(&quot;unsigned-integer-overflow&quot;)))
  {
    const <span class="ge">_Size __a = __loadword&lt;_</span>Size&gt;(__s) * __k1;
    const <span class="ge">_Size __b = __loadword&lt;_</span>Size&gt;(__s + 8);
    const <span class="ge">_Size __c = __loadword&lt;_</span>Size&gt;(__s + <span class="gs">__len - 8) * __</span>k2;
    const <span class="ge">_Size __d = __loadword&lt;_</span>Size&gt;(__s + <span class="gs">__len - 16) * __</span>k0;
    return __hash_len_16(__rotate(__a - <span class="gs">__b, 43) + __</span>rotate(__c, 30) + __d,
                         <span class="gs">__a + __</span>rotate(__b ^ <span class="gs">__k3, 20) - __</span>c + __len);
  }



  static pair&lt;_Size, <span class="ge">_Size&gt; __weak_</span>hash_len_32_with_seeds(
      <span class="ge">_Size __w, _</span>Size __x, <span class="ge">_Size __y, _</span>Size __z, <span class="ge">_Size __a, _</span>Size __b)
        <span class="gs">__attribute__</span>((__no_sanitize__(&quot;unsigned-integer-overflow&quot;)))
  {
    <span class="gs">__a += __</span>w;
    <span class="gs">__b = __</span>rotate(__b + <span class="gs">__a + __</span>z, 21);
    const <span class="ge">_Size __c = _</span>_a;
    <span class="gs">__a += __</span>x;
    <span class="gs">__a += __</span>y;
    <span class="gs">__b += __</span>rotate(__a, 44);
    return pair&lt;_Size, <span class="ge">_Size&gt;(__a + __z, __b + _</span>_c);
  }


  static pair&lt;_Size, <span class="ge">_Size&gt; __weak_</span>hash_len_32_with_seeds(
      const char* __s, <span class="ge">_Size __a, _</span>Size __b)
    <span class="gs">__attribute__</span>((__no_sanitize__(&quot;unsigned-integer-overflow&quot;)))
  {
    return __weak_hash_len_32_with_seeds(__loadword&lt;_Size&gt;(__s),
                                         __loadword&lt;_Size&gt;(__s + 8),
                                         __loadword&lt;_Size&gt;(__s + 16),
                                         __loadword&lt;_Size&gt;(__s + 24),
                                         __a,
                                         __b);
  }


  static <span class="ge">_Size __hash_</span>len_33_to_64(const char *__s, size_t __len)
    <span class="gs">__attribute__</span>((__no_sanitize__(&quot;unsigned-integer-overflow&quot;)))
  {
    <span class="ge">_Size __z = __loadword&lt;_</span>Size&gt;(__s + 24);
    <span class="ge">_Size __a = __loadword&lt;_</span>Size&gt;(__s) +
                (<span class="gs">__len + __</span>loadword&lt;_Size&gt;(__s + <span class="gs">__len - 16)) * __</span>k0;
    <span class="ge">_Size __b = __rotate(__a + _</span>_z, 52);
    <span class="ge">_Size __c = __rotate(_</span>_a, 37);
    <span class="gs">__a += __</span>loadword&lt;_Size&gt;(__s + 8);
    <span class="gs">__c += __</span>rotate(__a, 7);
    <span class="gs">__a += __</span>loadword&lt;_Size&gt;(__s + 16);
    <span class="ge">_Size __vf = __a + _</span>_z;
    <span class="ge">_Size __vs = __b + __rotate(__a, 31) + _</span>_c;
    <span class="gs">__a = __</span>loadword&lt;_Size&gt;(__s + 16) + __loadword&lt;_Size&gt;(__s + __len - 32);
    <span class="gs">__z += __</span>loadword&lt;_Size&gt;(__s + __len - 8);
    <span class="gs">__b = __</span>rotate(__a + __z, 52);
    <span class="gs">__c = __</span>rotate(__a, 37);
    <span class="gs">__a += __</span>loadword&lt;_Size&gt;(__s + __len - 24);
    <span class="gs">__c += __</span>rotate(__a, 7);
    <span class="gs">__a += __</span>loadword&lt;_Size&gt;(__s + __len - 16);
    <span class="ge">_Size __wf = __a + _</span>_z;
    <span class="ge">_Size __ws = __b + __rotate(__a, 31) + _</span>_c;
    <span class="ge">_Size __r = __shift_</span>mix((__vf + <span class="gs">__ws) * __</span>k2 + (<span class="gs">__wf + __</span>vs) * __k0);
    return __shift_mix(__r * <span class="gs">__k0 + __</span>vs) * __k2;
  }
};


template &lt;class _Size&gt;
_Size
__murmur2_or_cityhash&lt;_Size, 64&gt;::operator()(const void* __key, <span class="ge">_Size _</span>_len)
{
  const char* __s = static_cast&lt;const char*&gt;(__key);
  if (__len &lt;= 32) {
    if (__len &lt;= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len &lt;= 64) {
    return __hash_len_33_to_64(__s, __len);
  }



  <span class="ge">_Size __x = __loadword&lt;_</span>Size&gt;(__s + __len - 40);
  <span class="ge">_Size __y = __loadword&lt;_</span>Size&gt;(__s + __len - 16) +
              __loadword&lt;_Size&gt;(__s + __len - 56);
  <span class="ge">_Size __z = __hash_</span>len_16(__loadword&lt;_Size&gt;(__s + <span class="gs">__len - 48) + __</span>len,
                          __loadword&lt;_Size&gt;(__s + __len - 24));
  pair&lt;_Size, <span class="ge">_Size&gt; __v = __weak_</span>hash_len_32_with_seeds(__s + <span class="gs">__len - 64, __</span>len, __z);
  pair&lt;_Size, <span class="ge">_Size&gt; __w = __weak_</span>hash_len_32_with_seeds(__s + <span class="gs">__len - 32, __</span>y + <span class="gs">__k1, __</span>x);
  <span class="gs">__x = __</span>x * <span class="gs">__k1 + __</span>loadword&lt;_Size&gt;(__s);


  <span class="gs">__len = (__</span>len - 1) &amp; ~static_cast&lt;_Size&gt;(63);
  do {
    <span class="gs">__x = __</span>rotate(__x + <span class="gs">__y + __</span>v.first + __loadword&lt;_Size&gt;(__s + 8), 37) * __k1;
    <span class="gs">__y = __</span>rotate(__y + <span class="gs">__v.second + __</span>loadword&lt;_Size&gt;(__s + 48), 42) * __k1;
    <span class="gs">__x ^= __</span>w.second;
    <span class="gs">__y += __</span>v.first + __loadword&lt;_Size&gt;(__s + 40);
    <span class="gs">__z = __</span>rotate(__z + <span class="gs">__w.first, 33) * __</span>k1;
    <span class="gs">__v = __</span>weak_hash_len_32_with_seeds(__s, <span class="gs">__v.second * __</span>k1, <span class="gs">__x + __</span>w.first);
    <span class="gs">__w = __</span>weak_hash_len_32_with_seeds(__s + 32, <span class="gs">__z + __</span>w.second,
                                        <span class="gs">__y + __</span>loadword&lt;_Size&gt;(__s + 16));
    std::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(
      __hash_len_16(__v.first, <span class="gs">__w.first) + __</span>shift_mix(__y) * <span class="gs">__k1 + __</span>z,
      __hash_len_16(__v.second, <span class="gs">__w.second) + __</span>x);
}

template &lt;class <span class="ge">_Tp, size_</span>t = sizeof(_Tp) / sizeof(size_t)&gt;
struct __scalar_hash;

template &lt;class _Tp&gt;
struct __scalar_hash&lt;_Tp, 0&gt;
    : public unary_function&lt;_Tp, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            <span class="ge">_Tp _</span>_t;
            size_t __a;
        } __u;
        <span class="gs">__u.__</span>a = 0;
        <span class="gs">__u.__</span>t = __v;
        return <span class="gs">__u.__</span>a;
    }
};

template &lt;class _Tp&gt;
struct __scalar_hash&lt;_Tp, 1&gt;
    : public unary_function&lt;_Tp, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            <span class="ge">_Tp _</span>_t;
            size_t __a;
        } __u;
        <span class="gs">__u.__</span>t = __v;
        return <span class="gs">__u.__</span>a;
    }
};

template &lt;class _Tp&gt;
struct __scalar_hash&lt;_Tp, 2&gt;
    : public unary_function&lt;_Tp, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            <span class="ge">_Tp _</span>_t;
            struct
            {
                size_t __a;
                size_t __b;
            } __s;
        } __u;
        <span class="gs">__u.__</span>t = __v;
        return __murmur2_or_cityhash&lt;size_t&gt;()(&amp;__u, sizeof(__u));
    }
};

template &lt;class _Tp&gt;
struct __scalar_hash&lt;_Tp, 3&gt;
    : public unary_function&lt;_Tp, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            <span class="ge">_Tp _</span>_t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            } __s;
        } __u;
        <span class="gs">__u.__</span>t = __v;
        return __murmur2_or_cityhash&lt;size_t&gt;()(&amp;__u, sizeof(__u));
    }
};

template &lt;class _Tp&gt;
struct __scalar_hash&lt;_Tp, 4&gt;
    : public unary_function&lt;_Tp, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            <span class="ge">_Tp _</span>_t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            } __s;
        } __u;
        <span class="gs">__u.__</span>t = __v;
        return __murmur2_or_cityhash&lt;size_t&gt;()(&amp;__u, sizeof(__u));
    }
};

struct _PairT {
  size_t first;
  size_t second;
};

<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
inline size_t __hash_combine(size_t __lhs, size_t __rhs) throw() {
    typedef __scalar_hash&lt;_PairT&gt; _HashT;
    const <span class="ge">_PairT __p = {__lhs, _</span>_rhs};
    return <span class="ge">_HashT()(_</span>_p);
}

template&lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;_Tp*&gt;
    : public unary_function&lt;_Tp*, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(_Tp* __v) const throw()
    {
        union
        {
            <span class="ge">_Tp* _</span>_t;
            size_t __a;
        } __u;
        <span class="gs">__u.__</span>t = __v;
        return __murmur2_or_cityhash&lt;size_t&gt;()(&amp;__u, sizeof(__u));
    }
};


template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;bool&gt;
    : public unary_function&lt;bool, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(bool __v) const throw() {return static_cast&lt;size_t&gt;(__v);}
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;char&gt;
    : public unary_function&lt;char, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(char __v) const throw() {return static_cast&lt;size_t&gt;(__v);}
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;signed char&gt;
    : public unary_function&lt;signed char, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(signed char __v) const throw() {return static_cast&lt;size_t&gt;(__v);}
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;unsigned char&gt;
    : public unary_function&lt;unsigned char, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(unsigned char __v) const throw() {return static_cast&lt;size_t&gt;(__v);}
};



template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;char16_t&gt;
    : public unary_function&lt;char16_t, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(char16_t __v) const throw() {return static_cast&lt;size_t&gt;(__v);}
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;char32_t&gt;
    : public unary_function&lt;char32_t, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(char32_t __v) const throw() {return static_cast&lt;size_t&gt;(__v);}
};



template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;wchar_t&gt;
    : public unary_function&lt;wchar_t, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(wchar_t __v) const throw() {return static_cast&lt;size_t&gt;(__v);}
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;short&gt;
    : public unary_function&lt;short, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(short __v) const throw() {return static_cast&lt;size_t&gt;(__v);}
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;unsigned short&gt;
    : public unary_function&lt;unsigned short, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(unsigned short __v) const throw() {return static_cast&lt;size_t&gt;(__v);}
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;int&gt;
    : public unary_function&lt;int, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(int __v) const throw() {return static_cast&lt;size_t&gt;(__v);}
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;unsigned int&gt;
    : public unary_function&lt;unsigned int, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(unsigned int __v) const throw() {return static_cast&lt;size_t&gt;(__v);}
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;long&gt;
    : public unary_function&lt;long, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(long __v) const throw() {return static_cast&lt;size_t&gt;(__v);}
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;unsigned long&gt;
    : public unary_function&lt;unsigned long, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(unsigned long __v) const throw() {return static_cast&lt;size_t&gt;(__v);}
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;long long&gt;
    : public __scalar_hash&lt;long long&gt;
{
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;unsigned long long&gt;
    : public __scalar_hash&lt;unsigned long long&gt;
{
};



template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;__int128_t&gt;
    : public __scalar_hash&lt;__int128_t&gt;
{
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;__uint128_t&gt;
    : public __scalar_hash&lt;__uint128_t&gt;
{
};



template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;float&gt;
    : public __scalar_hash&lt;float&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(float __v) const throw()
    {

       if (__v == 0.0f)
           return 0;
        return __scalar_hash&lt;float&gt;::operator()(__v);
    }
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;double&gt;
    : public __scalar_hash&lt;double&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(double __v) const throw()
    {

       if (__v == 0.0)
           return 0;
        return __scalar_hash&lt;double&gt;::operator()(__v);
    }
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;long double&gt;
    : public __scalar_hash&lt;long double&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(long double __v) const throw()
    {

        if (__v == 0.0L)
            return 0;
        union
        {
            long double __t;
            struct
            {
                size_t __a;
                size_t __b;
            } __s;
        } __u;
        <span class="gs">__u.__</span>s.__a = 0;
        <span class="gs">__u.__</span>s.__b = 0;
        <span class="gs">__u.__</span>t = __v;
        return <span class="gs">__u.__</span>s.__a ^ <span class="gs">__u.__</span>s.__b;



    }
};
} }




typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;






typedef __darwin_pid_t pid_t;
typedef __darwin_id_t id_t;








typedef int sig_atomic_t;
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,





    __rc :2,






             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
struct __darwin_ymm_reg
{
 char __ymm_reg[32];
};
struct __darwin_zmm_reg
{
 char __zmm_reg[64];
};
struct __darwin_opmask_reg
{
 char __opmask_reg[8];
};
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};


struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
};


struct __darwin_i386_avx512_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_opmask_reg __fpu_k0;
 struct __darwin_opmask_reg __fpu_k1;
 struct __darwin_opmask_reg __fpu_k2;
 struct __darwin_opmask_reg __fpu_k3;
 struct __darwin_opmask_reg __fpu_k4;
 struct __darwin_opmask_reg __fpu_k5;
 struct __darwin_opmask_reg __fpu_k6;
 struct __darwin_opmask_reg __fpu_k7;
 struct __darwin_ymm_reg __fpu_zmmh0;
 struct __darwin_ymm_reg __fpu_zmmh1;
 struct __darwin_ymm_reg __fpu_zmmh2;
 struct __darwin_ymm_reg __fpu_zmmh3;
 struct __darwin_ymm_reg __fpu_zmmh4;
 struct __darwin_ymm_reg __fpu_zmmh5;
 struct __darwin_ymm_reg __fpu_zmmh6;
 struct __darwin_ymm_reg __fpu_zmmh7;
};
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};


struct __x86_instruction_state
{
        int __insn_stream_valid_bytes;
        int __insn_offset;
 int __out_of_synch;





        __uint8_t __insn_bytes[(2448 - 64 - 4)];

 __uint8_t __insn_cacheline[64];
};


struct __last_branch_record
{
 __uint64_t __from_ip;
 __uint64_t __to_ip;
 __uint32_t __mispredict : 1,
   __tsx_abort : 1,
   __in_tsx : 1,
   __cycle_count: 16,
   __reserved : 13;
};


struct __last_branch_state
{
        int __lbr_count;
 __uint32_t __lbr_supported_tsx : 1,
     __lbr_supported_cycle_count : 1,
     __reserved : 30;

 struct __last_branch_record __lbrs[32];
};
struct __x86_pagein_state
{
 int __pagein_error;
};







struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
struct __darwin_x86_thread_full_state64
{
 struct __darwin_x86_thread_state64 __ss64;
 __uint64_t __ds;
 __uint64_t __es;
 __uint64_t __ss;
 __uint64_t __gsbase;
};
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};


struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
};


struct __darwin_x86_avx512_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
 struct __darwin_opmask_reg __fpu_k0;
 struct __darwin_opmask_reg __fpu_k1;
 struct __darwin_opmask_reg __fpu_k2;
 struct __darwin_opmask_reg __fpu_k3;
 struct __darwin_opmask_reg __fpu_k4;
 struct __darwin_opmask_reg __fpu_k5;
 struct __darwin_opmask_reg __fpu_k6;
 struct __darwin_opmask_reg __fpu_k7;
 struct __darwin_ymm_reg __fpu_zmmh0;
 struct __darwin_ymm_reg __fpu_zmmh1;
 struct __darwin_ymm_reg __fpu_zmmh2;
 struct __darwin_ymm_reg __fpu_zmmh3;
 struct __darwin_ymm_reg __fpu_zmmh4;
 struct __darwin_ymm_reg __fpu_zmmh5;
 struct __darwin_ymm_reg __fpu_zmmh6;
 struct __darwin_ymm_reg __fpu_zmmh7;
 struct __darwin_ymm_reg __fpu_zmmh8;
 struct __darwin_ymm_reg __fpu_zmmh9;
 struct __darwin_ymm_reg __fpu_zmmh10;
 struct __darwin_ymm_reg __fpu_zmmh11;
 struct __darwin_ymm_reg __fpu_zmmh12;
 struct __darwin_ymm_reg __fpu_zmmh13;
 struct __darwin_ymm_reg __fpu_zmmh14;
 struct __darwin_ymm_reg __fpu_zmmh15;
 struct __darwin_zmm_reg __fpu_zmm16;
 struct __darwin_zmm_reg __fpu_zmm17;
 struct __darwin_zmm_reg __fpu_zmm18;
 struct __darwin_zmm_reg __fpu_zmm19;
 struct __darwin_zmm_reg __fpu_zmm20;
 struct __darwin_zmm_reg __fpu_zmm21;
 struct __darwin_zmm_reg __fpu_zmm22;
 struct __darwin_zmm_reg __fpu_zmm23;
 struct __darwin_zmm_reg __fpu_zmm24;
 struct __darwin_zmm_reg __fpu_zmm25;
 struct __darwin_zmm_reg __fpu_zmm26;
 struct __darwin_zmm_reg __fpu_zmm27;
 struct __darwin_zmm_reg __fpu_zmm28;
 struct __darwin_zmm_reg __fpu_zmm29;
 struct __darwin_zmm_reg __fpu_zmm30;
 struct __darwin_zmm_reg __fpu_zmm31;
};
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
struct __darwin_x86_cpmu_state64
{
 __uint64_t __ctrs[16];
};




struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};


struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};



struct __darwin_mcontext_avx512_32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx512_state __fs;
};
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};


struct __darwin_mcontext64_full
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_full_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};


struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};


struct __darwin_mcontext_avx64_full
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_full_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};



struct __darwin_mcontext_avx512_64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx512_state64 __fs;
};


struct __darwin_mcontext_avx512_64_full
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_full_state64 __ss;
 struct __darwin_x86_avx512_state64 __fs;
};
typedef struct __darwin_mcontext64 *mcontext_t;

typedef __darwin_pthread_attr_t pthread_attr_t;

struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;



struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;



};


typedef struct __darwin_ucontext ucontext_t;


typedef __darwin_sigset_t sigset_t;

typedef __darwin_uid_t uid_t;

union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
union __sigaction_u {
 void (*__sa_handler)(int);
 void (<span class="ge">*__sa_sigaction)(int, struct __siginfo *</span>,
     void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (<span class="ge">*sa_tramp)(void *</span>, int, int, siginfo_t <span class="ge">*, void *</span>);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
typedef void (*sig_t)(int);
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
extern &quot;C&quot; {
    void(*signal(int, void (*)(int)))(int);
}
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};








typedef __uint64_t rlim_t;
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
 long ru_maxrss;

 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;


};
typedef void *rusage_info_t;

struct rusage_info_v0 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
};

struct rusage_info_v1 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
};

struct rusage_info_v2 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
};

struct rusage_info_v3 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
};

struct rusage_info_v4 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
 uint64_t ri_logical_writes;
 uint64_t ri_lifetime_max_phys_footprint;
 uint64_t ri_instructions;
 uint64_t ri_cycles;
 uint64_t ri_billed_energy;
 uint64_t ri_serviced_energy;
 uint64_t ri_interval_max_phys_footprint;
 uint64_t ri_runnable_time;
};

struct rusage_info_v5 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
 uint64_t ri_logical_writes;
 uint64_t ri_lifetime_max_phys_footprint;
 uint64_t ri_instructions;
 uint64_t ri_cycles;
 uint64_t ri_billed_energy;
 uint64_t ri_serviced_energy;
 uint64_t ri_interval_max_phys_footprint;
 uint64_t ri_runnable_time;
 uint64_t ri_flags;
};

typedef struct rusage_info_v5 rusage_info_current;
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
struct proc_rlimit_control_wakeupmon {
 uint32_t wm_flags;
 int32_t wm_rate;
};
extern &quot;C&quot; {
int getpriority(int, id_t);

int getiopolicy_np(int, int) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.5)));

int getrlimit(int, struct rlimit *) __asm(&quot;_&quot; &quot;getrlimit&quot; );
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.5)));

int setrlimit(int, const struct rlimit *) __asm(&quot;_&quot; &quot;setrlimit&quot; );
}
static inline
__uint16_t
_OSSwapInt16(
 __uint16_t _data
 )
{
 return (__uint16_t)((_data &lt;&lt; 8) | (_data &gt;&gt; 8));
}

static inline
__uint32_t
_OSSwapInt32(
 __uint32_t _data
 )
{

 return __builtin_bswap32(_data);




}


static inline
__uint64_t
_OSSwapInt64(
 __uint64_t _data
 )
{
 return __builtin_bswap64(_data);
}







union wait {
 int w_status;



 struct {

  unsigned int w_Termsig:7,
      w_Coredump:1,
      w_Retcode:8,
      w_Filler:16;







 } w_T;





 struct {

  unsigned int w_Stopval:8,
      w_Stopsig:8,
      w_Filler:16;






 } w_S;
};
extern &quot;C&quot; {
pid_t wait(int *) __asm(&quot;_&quot; &quot;wait&quot; );
pid_t waitpid(pid_t, int *, int) __asm(&quot;_&quot; &quot;waitpid&quot; );

int waitid(idtype_t, id_t, siginfo_t *, int) __asm(&quot;_&quot; &quot;waitid&quot; );


pid_t wait3(int <span class="ge">*, int, struct rusage *</span>);
pid_t wait4(pid_t, int <span class="ge">*, int, struct rusage *</span>);

}

extern &quot;C&quot; {
void *alloca(size_t);
}

typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;
extern int __mb_cur_max;
extern &quot;C&quot; {

void *malloc(size_t <span class="gs">__size) __</span>attribute__((__warn_unused_result__)) <span class="gs">__attribute__</span>((alloc_size(1)));
void *calloc(size_t __count, size_t <span class="gs">__size) __</span>attribute__((__warn_unused_result__)) <span class="gs">__attribute__</span>((alloc_size(1,2)));
void free(void *);
void <span class="ge">*realloc(void *</span>__ptr, size_t <span class="gs">__size) __</span>attribute__((__warn_unused_result__)) <span class="gs">__attribute__</span>((alloc_size(2)));

void *valloc(size_t) <span class="gs">__attribute__</span>((alloc_size(1)));




void *aligned_alloc(size_t __alignment, size_t <span class="gs">__size) __</span>attribute__((__warn_unused_result__)) <span class="gs">__attribute__</span>((alloc_size(2))) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.15))) <span class="gs">__attribute__</span>((availability(ios,introduced=13.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=13.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=6.0)));

int posix_memalign(void **__memptr, size_t __alignment, size_t <span class="gs">__size) __</span>attribute__((availability(macosx,introduced=10.6)));

}

extern &quot;C&quot; {
void abort(void) <span class="gs">__attribute__</span>((__cold__)) <span class="gs">__attribute__</span>((__noreturn__));
int abs(int) <span class="gs">__attribute__</span>((__const__));
int atexit(void (* _Nonnull)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void <span class="ge">*bsearch(const void *</span><span class="gs">__key, const void *__</span>base, size_t __nel,
     size_t __width, int (* <span class="ge">_Nonnull _</span>_compar)(const void <span class="ge">*, const void *</span>));

div_t div(int, int) <span class="gs">__attribute__</span>((__const__));
void exit(int) <span class="gs">__attribute__</span>((__noreturn__));

char <span class="ge">*getenv(const char *</span>);
long labs(long) <span class="gs">__attribute__</span>((__const__));
ldiv_t ldiv(long, long) <span class="gs">__attribute__</span>((__const__));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);


int mblen(const char *__s, size_t __n);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);

void qsort(void *__base, size_t __nel, size_t __width,
     int (* <span class="ge">_Nonnull _</span>_compar)(const void <span class="ge">*, const void *</span>));
int rand(void) <span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use arc4random instead.&quot;)));

void srand(unsigned) <span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use arc4random instead.&quot;)));
double strtod(const char <span class="ge">*, char *</span>*) __asm(&quot;_&quot; &quot;strtod&quot; );
float strtof(const char <span class="ge">*, char *</span>*) __asm(&quot;_&quot; &quot;strtof&quot; );
long strtol(const char <span class="ge">*__str, char *</span>*<span class="gs">__endptr, int __</span>base);
long double
  strtold(const char <span class="ge">*, char *</span>*);

long long
  strtoll(const char <span class="ge">*__str, char *</span>*<span class="gs">__endptr, int __</span>base);

unsigned long
  strtoul(const char <span class="ge">*__str, char *</span>*<span class="gs">__endptr, int __</span>base);

unsigned long long
  strtoull(const char <span class="ge">*__str, char *</span>*<span class="gs">__endptr, int __</span>base);
<span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use posix_spawn APIs or NSTask instead.&quot;)))
<span class="gs">__attribute__</span>((availability(macos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(ios,unavailable)))
<span class="gs">__attribute__</span>((availability(watchos,unavailable))) <span class="gs">__attribute__</span>((availability(tvos,unavailable)))
int system(const char *) __asm(&quot;_&quot; &quot;system&quot; );



size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);


void <span class="ge">_Exit(int) __attribute__((__noreturn_</span>_));
long a64l(const char *);
double drand48(void);
char <span class="ge">*ecvt(double, int, int *</span>, int *);
double erand48(unsigned short[3]);
char <span class="ge">*fcvt(double, int, int *</span>, int *);
char <span class="ge">*gcvt(double, int, char *</span>);
int getsubopt(char **, char * const <span class="ge">*, char *</span>*);
int grantpt(int);

char <span class="ge">*initstate(unsigned, char *</span>, size_t);



long jrand48(unsigned short[3]) <span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use arc4random instead.&quot;)));
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void) <span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use arc4random instead.&quot;)));
char <span class="ge">*mktemp(char *</span>);
int mkstemp(char *);
long mrand48(void) <span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use arc4random instead.&quot;)));
long nrand48(unsigned short[3]) <span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use arc4random instead.&quot;)));
int posix_openpt(int);
char *ptsname(int);


int ptsname_r(int fildes, char *buffer, size_t buflen) <span class="gs">__attribute__</span>((availability(macos,introduced=10.13.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=11.3))) <span class="gs">__attribute__</span>((availability(tvos,introduced=11.3))) <span class="gs">__attribute__</span>((availability(watchos,introduced=4.3)));


int putenv(char *) __asm(&quot;_&quot; &quot;putenv&quot; );
long random(void) <span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use arc4random instead.&quot;)));
int rand_r(unsigned *) <span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use arc4random instead.&quot;)));

char <span class="ge">*realpath(const char *</span> , char * ) __asm(&quot;_&quot; &quot;realpath&quot; &quot;$DARWIN_EXTSN&quot;);



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char * <span class="gs">__name, const char * __</span>value, int <span class="gs">__overwrite) __</span>asm(&quot;_&quot; &quot;setenv&quot; );

void setkey(const char *) __asm(&quot;_&quot; &quot;setkey&quot; );



char <span class="ge">*setstate(const char *</span>);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm(&quot;_&quot; &quot;unsetenv&quot; );








typedef __darwin_dev_t dev_t;
typedef __darwin_mode_t mode_t;


uint32_t arc4random(void);
void arc4random_addrandom(unsigned char * , int )
    <span class="gs">__attribute__</span>((availability(macosx,introduced=10.0))) <span class="gs">__attribute__</span>((availability(macosx,deprecated=10.12,message=&quot;use arc4random_stir&quot;)))
    <span class="gs">__attribute__</span>((availability(ios,introduced=2.0))) <span class="gs">__attribute__</span>((availability(ios,deprecated=10.0,message=&quot;use arc4random_stir&quot;)))
    <span class="gs">__attribute__</span>((availability(tvos,introduced=2.0))) <span class="gs">__attribute__</span>((availability(tvos,deprecated=10.0,message=&quot;use arc4random_stir&quot;)))
    <span class="gs">__attribute__</span>((availability(watchos,introduced=1.0))) <span class="gs">__attribute__</span>((availability(watchos,deprecated=3.0,message=&quot;use arc4random_stir&quot;)));
void arc4random_buf(void * __buf, size_t <span class="gs">__nbytes) __</span>attribute__((availability(macosx,introduced=10.7)));
void arc4random_stir(void);
uint32_t
  arc4random_uniform(uint32_t __upper_bound) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));

int atexit_b(void (^ <span class="ge">_Nonnull)(void)) __attribute_</span>_((availability(macosx,introduced=10.6)));
void <span class="ge">*bsearch_b(const void *</span><span class="gs">__key, const void *__</span>base, size_t __nel,
     size_t __width, int (^ <span class="ge">_Nonnull __compar)(const void *, const void *)) __attribute_</span>_((availability(macosx,introduced=10.6)));



char <span class="ge">*cgetcap(char *</span>, const char *, int);
int cgetclose(void);
int cgetent(char <span class="gs">**, char **</span>, const char *);
int cgetfirst(char <span class="gs">**, char **</span>);
int cgetmatch(const char <span class="ge">*, const char *</span>);
int cgetnext(char <span class="gs">**, char **</span>);
int cgetnum(char <span class="ge">*, const char *</span>, long *);
int cgetset(const char *);
int cgetstr(char <span class="ge">*, const char *</span>, char **);
int cgetustr(char <span class="ge">*, const char *</span>, char **);

int daemon(int, int) __asm(&quot;_&quot; &quot;daemon&quot; &quot;$1050&quot;) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.0,deprecated=10.5,message=&quot;Use posix_spawn APIs instead.&quot;))) <span class="gs">__attribute__</span>((availability(watchos,unavailable))) <span class="gs">__attribute__</span>((availability(tvos,unavailable)));
char *devname(dev_t, mode_t);
char <span class="ge">*devname_r(dev_t, mode_t, char *</span>buf, int len);
char <span class="ge">*getbsize(int *</span>, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);
void setprogname(const char *);
int heapsort(void *__base, size_t __nel, size_t __width,
     int (* <span class="ge">_Nonnull _</span>_compar)(const void <span class="ge">*, const void *</span>));

int heapsort_b(void *__base, size_t __nel, size_t __width,
     int (^ <span class="ge">_Nonnull __compar)(const void *, const void *) __attribute__((__noescape_</span>_)))
     <span class="gs">__attribute__</span>((availability(macosx,introduced=10.6)));

int mergesort(void *__base, size_t __nel, size_t __width,
     int (* <span class="ge">_Nonnull _</span>_compar)(const void <span class="ge">*, const void *</span>));

int mergesort_b(void *__base, size_t __nel, size_t __width,
     int (^ <span class="ge">_Nonnull __compar)(const void *, const void *) __attribute__((__noescape_</span>_)))
     <span class="gs">__attribute__</span>((availability(macosx,introduced=10.6)));

void psort(void *__base, size_t __nel, size_t __width,
     int (* <span class="ge">_Nonnull _</span>_compar)(const void <span class="ge">*, const void *</span>))
     <span class="gs">__attribute__</span>((availability(macosx,introduced=10.6)));

void psort_b(void *__base, size_t __nel, size_t __width,
     int (^ <span class="ge">_Nonnull __compar)(const void *, const void *) __attribute__((__noescape_</span>_)))
     <span class="gs">__attribute__</span>((availability(macosx,introduced=10.6)));

void psort_r(void <span class="ge">*__base, size_t __nel, size_t __width, void *</span>,
     int (* <span class="ge">_Nonnull _</span>_compar)(void <span class="ge">*, const void *</span>, const void *))
     <span class="gs">__attribute__</span>((availability(macosx,introduced=10.6)));

void qsort_b(void *__base, size_t __nel, size_t __width,
     int (^ <span class="ge">_Nonnull __compar)(const void *, const void *) __attribute__((__noescape_</span>_)))
     <span class="gs">__attribute__</span>((availability(macosx,introduced=10.6)));

void qsort_r(void <span class="ge">*__base, size_t __nel, size_t __width, void *</span>,
     int (* <span class="ge">_Nonnull _</span>_compar)(void <span class="ge">*, const void *</span>, const void *));
int radixsort(const unsigned char **__base, int <span class="gs">__nel, const unsigned char *__</span>table,
     unsigned __endbyte);
int rpmatch(const char *)
 <span class="gs">__attribute__</span>((availability(macos,introduced=10.15))) <span class="gs">__attribute__</span>((availability(ios,introduced=13.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=13.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=6.0)));
int sradixsort(const unsigned char **__base, int <span class="gs">__nel, const unsigned char *__</span>table,
     unsigned __endbyte);
void sranddev(void);
void srandomdev(void);
void <span class="ge">*reallocf(void *</span>__ptr, size_t <span class="gs">__size) __</span>attribute__((alloc_size(2)));
long long
 strtonum(const char <span class="ge">*__numstr, long long __minval, long long __maxval, const char *</span>*__errstrp)
 <span class="gs">__attribute__</span>((availability(macos,introduced=11.0))) <span class="gs">__attribute__</span>((availability(ios,introduced=14.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=14.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=7.0)));

long long
  strtoq(const char <span class="ge">*__str, char *</span>*<span class="gs">__endptr, int __</span>base);
unsigned long long
  strtouq(const char <span class="ge">*__str, char *</span>*<span class="gs">__endptr, int __</span>base);

extern char *suboptarg;







}






extern &quot;C&quot; {
    typedef float float_t;
    typedef double double_t;
extern int __math_errhandling(void);
extern int __fpclassifyf(float);
extern int __fpclassifyd(double);
extern int __fpclassifyl(long double);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isfinitef(float);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isfinited(double);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isfinitel(long double);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isinff(float);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isinfd(double);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isinfl(long double);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isnanf(float);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isnand(double);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isnanl(long double);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isnormalf(float);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isnormald(double);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isnormall(long double);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_signbitf(float);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_signbitd(double);
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_signbitl(long double);

inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isfinitef(float __x) {
    return <span class="gs">__x == __</span>x &amp;&amp; __builtin_fabsf(__x) != __builtin_inff();
}
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isfinited(double __x) {
    return <span class="gs">__x == __</span>x &amp;&amp; __builtin_fabs(__x) != __builtin_inf();
}
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isfinitel(long double __x) {
    return <span class="gs">__x == __</span>x &amp;&amp; __builtin_fabsl(__x) != __builtin_infl();
}
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isinff(float __x) {
    return __builtin_fabsf(__x) == __builtin_inff();
}
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isinfd(double __x) {
    return __builtin_fabs(__x) == __builtin_inf();
}
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isinfl(long double __x) {
    return __builtin_fabsl(__x) == __builtin_infl();
}
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isnanf(float __x) {
    return <span class="gs">__x != __</span>x;
}
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isnand(double __x) {
    return <span class="gs">__x != __</span>x;
}
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isnanl(long double __x) {
    return <span class="gs">__x != __</span>x;
}
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_signbitf(float __x) {
    union { float <span class="gs">__f; unsigned int __</span>u; } __u;
    <span class="gs">__u.__</span>f = __x;
    return (int)(__u.__u &gt;&gt; 31);
}
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_signbitd(double __x) {
    union { double <span class="gs">__f; unsigned long long __</span>u; } __u;
    <span class="gs">__u.__</span>f = __x;
    return (int)(__u.__u &gt;&gt; 63);
}

inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_signbitl(long double __x) {
    union {
        long double __ld;
        struct{ unsigned long long <span class="gs">__m; unsigned short __</span>sexp; } __p;
    } __u;
    <span class="gs">__u.__</span>ld = __x;
    return (int)(__u.__p.__sexp &gt;&gt; 15);
}







inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isnormalf(float __x) {
    return __inline_isfinitef(__x) &amp;&amp; __builtin_fabsf(__x) &gt;= 1.17549435e-38F;
}
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isnormald(double __x) {
    return __inline_isfinited(__x) &amp;&amp; __builtin_fabs(__x) &gt;= 2.2250738585072014e-308;
}
inline <span class="gs">__attribute__</span> ((__always_inline__)) int __inline_isnormall(long double __x) {
    return __inline_isfinitel(__x) &amp;&amp; __builtin_fabsl(__x) &gt;= 3.36210314311209350626e-4932L;
}
extern float acosf(float);
extern double acos(double);
extern long double acosl(long double);

extern float asinf(float);
extern double asin(double);
extern long double asinl(long double);

extern float atanf(float);
extern double atan(double);
extern long double atanl(long double);

extern float atan2f(float, float);
extern double atan2(double, double);
extern long double atan2l(long double, long double);

extern float cosf(float);
extern double cos(double);
extern long double cosl(long double);

extern float sinf(float);
extern double sin(double);
extern long double sinl(long double);

extern float tanf(float);
extern double tan(double);
extern long double tanl(long double);

extern float acoshf(float);
extern double acosh(double);
extern long double acoshl(long double);

extern float asinhf(float);
extern double asinh(double);
extern long double asinhl(long double);

extern float atanhf(float);
extern double atanh(double);
extern long double atanhl(long double);

extern float coshf(float);
extern double cosh(double);
extern long double coshl(long double);

extern float sinhf(float);
extern double sinh(double);
extern long double sinhl(long double);

extern float tanhf(float);
extern double tanh(double);
extern long double tanhl(long double);

extern float expf(float);
extern double exp(double);
extern long double expl(long double);

extern float exp2f(float);
extern double exp2(double);
extern long double exp2l(long double);

extern float expm1f(float);
extern double expm1(double);
extern long double expm1l(long double);

extern float logf(float);
extern double log(double);
extern long double logl(long double);

extern float log10f(float);
extern double log10(double);
extern long double log10l(long double);

extern float log2f(float);
extern double log2(double);
extern long double log2l(long double);

extern float log1pf(float);
extern double log1p(double);
extern long double log1pl(long double);

extern float logbf(float);
extern double logb(double);
extern long double logbl(long double);

extern float modff(float, float *);
extern double modf(double, double *);
extern long double modfl(long double, long double *);

extern float ldexpf(float, int);
extern double ldexp(double, int);
extern long double ldexpl(long double, int);

extern float frexpf(float, int *);
extern double frexp(double, int *);
extern long double frexpl(long double, int *);

extern int ilogbf(float);
extern int ilogb(double);
extern int ilogbl(long double);

extern float scalbnf(float, int);
extern double scalbn(double, int);
extern long double scalbnl(long double, int);

extern float scalblnf(float, long int);
extern double scalbln(double, long int);
extern long double scalblnl(long double, long int);

extern float fabsf(float);
extern double fabs(double);
extern long double fabsl(long double);

extern float cbrtf(float);
extern double cbrt(double);
extern long double cbrtl(long double);

extern float hypotf(float, float);
extern double hypot(double, double);
extern long double hypotl(long double, long double);

extern float powf(float, float);
extern double pow(double, double);
extern long double powl(long double, long double);

extern float sqrtf(float);
extern double sqrt(double);
extern long double sqrtl(long double);

extern float erff(float);
extern double erf(double);
extern long double erfl(long double);

extern float erfcf(float);
extern double erfc(double);
extern long double erfcl(long double);




extern float lgammaf(float);
extern double lgamma(double);
extern long double lgammal(long double);

extern float tgammaf(float);
extern double tgamma(double);
extern long double tgammal(long double);

extern float ceilf(float);
extern double ceil(double);
extern long double ceill(long double);

extern float floorf(float);
extern double floor(double);
extern long double floorl(long double);

extern float nearbyintf(float);
extern double nearbyint(double);
extern long double nearbyintl(long double);

extern float rintf(float);
extern double rint(double);
extern long double rintl(long double);

extern long int lrintf(float);
extern long int lrint(double);
extern long int lrintl(long double);

extern float roundf(float);
extern double round(double);
extern long double roundl(long double);

extern long int lroundf(float);
extern long int lround(double);
extern long int lroundl(long double);




extern long long int llrintf(float);
extern long long int llrint(double);
extern long long int llrintl(long double);

extern long long int llroundf(float);
extern long long int llround(double);
extern long long int llroundl(long double);


extern float truncf(float);
extern double trunc(double);
extern long double truncl(long double);

extern float fmodf(float, float);
extern double fmod(double, double);
extern long double fmodl(long double, long double);

extern float remainderf(float, float);
extern double remainder(double, double);
extern long double remainderl(long double, long double);

extern float remquof(float, float, int *);
extern double remquo(double, double, int *);
extern long double remquol(long double, long double, int *);

extern float copysignf(float, float);
extern double copysign(double, double);
extern long double copysignl(long double, long double);

extern float nanf(const char *);
extern double nan(const char *);
extern long double nanl(const char *);

extern float nextafterf(float, float);
extern double nextafter(double, double);
extern long double nextafterl(long double, long double);

extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);

extern float fdimf(float, float);
extern double fdim(double, double);
extern long double fdiml(long double, long double);

extern float fmaxf(float, float);
extern double fmax(double, double);
extern long double fmaxl(long double, long double);

extern float fminf(float, float);
extern double fmin(double, double);
extern long double fminl(long double, long double);

extern float fmaf(float, float, float);
extern double fma(double, double, double);
extern long double fmal(long double, long double, long double);
extern float __inff(void)
<span class="gs">__attribute__</span>((availability(macos,introduced=10.0,deprecated=10.9,message=&quot;use <span class="sb">`(float)INFINITY`</span> instead&quot;))) <span class="gs">__attribute__</span>((availability(ios,unavailable))) <span class="gs">__attribute__</span>((availability(watchos,unavailable))) <span class="gs">__attribute__</span>((availability(tvos,unavailable)));
extern double __inf(void)
<span class="gs">__attribute__</span>((availability(macos,introduced=10.0,deprecated=10.9,message=&quot;use <span class="sb">`INFINITY`</span> instead&quot;))) <span class="gs">__attribute__</span>((availability(ios,unavailable))) <span class="gs">__attribute__</span>((availability(watchos,unavailable))) <span class="gs">__attribute__</span>((availability(tvos,unavailable)));
extern long double __infl(void)
<span class="gs">__attribute__</span>((availability(macos,introduced=10.0,deprecated=10.9,message=&quot;use <span class="sb">`(long double)INFINITY`</span> instead&quot;))) <span class="gs">__attribute__</span>((availability(ios,unavailable))) <span class="gs">__attribute__</span>((availability(watchos,unavailable))) <span class="gs">__attribute__</span>((availability(tvos,unavailable)));
extern float __nan(void)
<span class="gs">__attribute__</span>((availability(macos,introduced=10.0,deprecated=10.14,message=&quot;use <span class="sb">`NAN`</span> instead&quot;))) <span class="gs">__attribute__</span>((availability(ios,unavailable))) <span class="gs">__attribute__</span>((availability(watchos,unavailable))) <span class="gs">__attribute__</span>((availability(tvos,unavailable)));
extern float <span class="gs">__exp10f(float) __</span>attribute__((availability(macos,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,introduced=7.0)));
extern double <span class="gs">__exp10(double) __</span>attribute__((availability(macos,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,introduced=7.0)));





inline <span class="gs">__attribute__</span> ((__always_inline__)) void <span class="gs">__sincosf(float __</span>x, float <span class="ge">*__sinp, float *</span>__cosp);
inline <span class="gs">__attribute__</span> ((__always_inline__)) void <span class="gs">__sincos(double __</span>x, double <span class="ge">*__sinp, double *</span>__cosp);
extern float <span class="gs">__cospif(float) __</span>attribute__((availability(macos,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,introduced=7.0)));
extern double <span class="gs">__cospi(double) __</span>attribute__((availability(macos,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,introduced=7.0)));
extern float <span class="gs">__sinpif(float) __</span>attribute__((availability(macos,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,introduced=7.0)));
extern double <span class="gs">__sinpi(double) __</span>attribute__((availability(macos,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,introduced=7.0)));
extern float <span class="gs">__tanpif(float) __</span>attribute__((availability(macos,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,introduced=7.0)));
extern double <span class="gs">__tanpi(double) __</span>attribute__((availability(macos,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,introduced=7.0)));
inline <span class="gs">__attribute__</span> ((__always_inline__)) void <span class="gs">__sincospif(float __</span>x, float <span class="ge">*__sinp, float *</span>__cosp);
inline <span class="gs">__attribute__</span> ((__always_inline__)) void <span class="gs">__sincospi(double __</span>x, double <span class="ge">*__sinp, double *</span>__cosp);






struct <span class="gs">__float2 { float __</span>sinval; float __cosval; };
struct <span class="gs">__double2 { double __</span>sinval; double __cosval; };

extern struct <span class="gs">__float2 __</span>sincosf_stret(float);
extern struct <span class="gs">__double2 __</span>sincos_stret(double);
extern struct <span class="gs">__float2 __</span>sincospif_stret(float);
extern struct <span class="gs">__double2 __</span>sincospi_stret(double);

inline <span class="gs">__attribute__</span> ((__always_inline__)) void <span class="gs">__sincosf(float __</span>x, float <span class="ge">*__sinp, float *</span>__cosp) {
    const struct <span class="gs">__float2 __</span>stret = __sincosf_stret(__x);
    <span class="ge">*__sinp = __stret.__sinval; *</span><span class="gs">__cosp = __</span>stret.__cosval;
}

inline <span class="gs">__attribute__</span> ((__always_inline__)) void <span class="gs">__sincos(double __</span>x, double <span class="ge">*__sinp, double *</span>__cosp) {
    const struct <span class="gs">__double2 __</span>stret = __sincos_stret(__x);
    <span class="ge">*__sinp = __stret.__sinval; *</span><span class="gs">__cosp = __</span>stret.__cosval;
}

inline <span class="gs">__attribute__</span> ((__always_inline__)) void <span class="gs">__sincospif(float __</span>x, float <span class="ge">*__sinp, float *</span>__cosp) {
    const struct <span class="gs">__float2 __</span>stret = __sincospif_stret(__x);
    <span class="ge">*__sinp = __stret.__sinval; *</span><span class="gs">__cosp = __</span>stret.__cosval;
}

inline <span class="gs">__attribute__</span> ((__always_inline__)) void <span class="gs">__sincospi(double __</span>x, double <span class="ge">*__sinp, double *</span>__cosp) {
    const struct <span class="gs">__double2 __</span>stret = __sincospi_stret(__x);
    <span class="ge">*__sinp = __stret.__sinval; *</span><span class="gs">__cosp = __</span>stret.__cosval;
}







extern double j0(double) <span class="gs">__attribute__</span>((availability(macos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(ios,introduced=3.2)));
extern double j1(double) <span class="gs">__attribute__</span>((availability(macos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(ios,introduced=3.2)));
extern double jn(int, double) <span class="gs">__attribute__</span>((availability(macos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(ios,introduced=3.2)));
extern double y0(double) <span class="gs">__attribute__</span>((availability(macos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(ios,introduced=3.2)));
extern double y1(double) <span class="gs">__attribute__</span>((availability(macos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(ios,introduced=3.2)));
extern double yn(int, double) <span class="gs">__attribute__</span>((availability(macos,introduced=10.0))) <span class="gs">__attribute__</span>((availability(ios,introduced=3.2)));
extern double scalb(double, double);
extern int signgam;
extern long int rinttol(double)
<span class="gs">__attribute__</span>((availability(macos,introduced=10.0,deprecated=10.9,replacement=&quot;lrint&quot;))) <span class="gs">__attribute__</span>((availability(ios,unavailable))) <span class="gs">__attribute__</span>((availability(watchos,unavailable))) <span class="gs">__attribute__</span>((availability(tvos,unavailable)));

extern long int roundtol(double)
<span class="gs">__attribute__</span>((availability(macos,introduced=10.0,deprecated=10.9,replacement=&quot;lround&quot;))) <span class="gs">__attribute__</span>((availability(ios,unavailable))) <span class="gs">__attribute__</span>((availability(watchos,unavailable))) <span class="gs">__attribute__</span>((availability(tvos,unavailable)));

extern double drem(double, double)
<span class="gs">__attribute__</span>((availability(macos,introduced=10.0,deprecated=10.9,replacement=&quot;remainder&quot;))) <span class="gs">__attribute__</span>((availability(ios,unavailable))) <span class="gs">__attribute__</span>((availability(watchos,unavailable))) <span class="gs">__attribute__</span>((availability(tvos,unavailable)));

extern int finite(double)
<span class="gs">__attribute__</span>((availability(macos,introduced=10.0,deprecated=10.9,message=&quot;Use <span class="sb">`isfinite((double)x)`</span> instead.&quot;))) <span class="gs">__attribute__</span>((availability(ios,unavailable))) <span class="gs">__attribute__</span>((availability(watchos,unavailable))) <span class="gs">__attribute__</span>((availability(tvos,unavailable)));

extern double gamma(double)
<span class="gs">__attribute__</span>((availability(macos,introduced=10.0,deprecated=10.9,replacement=&quot;tgamma&quot;))) <span class="gs">__attribute__</span>((availability(ios,unavailable))) <span class="gs">__attribute__</span>((availability(watchos,unavailable))) <span class="gs">__attribute__</span>((availability(tvos,unavailable)));

extern double significand(double)
<span class="gs">__attribute__</span>((availability(macos,introduced=10.0,deprecated=10.9,message=&quot;Use <span class="sb">`2*frexp( )`</span> or <span class="sb">`scalbn(x, -ilogb(x))`</span> instead.&quot;))) <span class="gs">__attribute__</span>((availability(ios,unavailable))) <span class="gs">__attribute__</span>((availability(watchos,unavailable))) <span class="gs">__attribute__</span>((availability(tvos,unavailable)));
}





extern &quot;C++&quot; {









namespace std { inline namespace __1 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template &lt;class <span class="ge">_Tp, bool = is_</span>arithmetic&lt;_Tp&gt;::value&gt;
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static const bool is_specialized = false;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type min() throw() {return type();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type max() throw() {return type();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type lowest() throw() {return type();}

    static const int digits = 0;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 0;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type epsilon() throw() {return type();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type round_error() throw() {return type();}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type infinity() throw() {return type();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type quiet_NaN() throw() {return type();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type signaling_NaN() throw() {return type();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type denorm_min() throw() {return type();}

    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template &lt;class <span class="ge">_Tp, int __digits, bool _</span>IsSigned&gt;
struct __libcpp_compute_min
{
    static const <span class="ge">_Tp value = _</span>Tp(_Tp(1) &lt;&lt; __digits);
};

template &lt;class <span class="ge">_Tp, int _</span>_digits&gt;
struct __libcpp_compute_min&lt;_Tp, __digits, false&gt;
{
    static const <span class="ge">_Tp value = _</span>Tp(0);
};

template &lt;class _Tp&gt;
class __libcpp_numeric_limits&lt;_Tp, true&gt;
{
protected:
    typedef _Tp type;

    static const bool is_specialized = true;

    static const bool is_signed = type(-1) &lt; type(0);
    static const int digits = static_cast&lt;int&gt;(sizeof(type) * 8 - is_signed);
    static const int digits10 = digits * 3 / 10;
    static const int max_digits10 = 0;
    static const type <span class="gs">__min = __</span>libcpp_compute_min&lt;type, digits, is_signed&gt;::value;
    static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type min() throw() {return __min;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type max() throw() {return __max;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type lowest() throw() {return min();}

    static const bool is_integer = true;
    static const bool is_exact = true;
    static const int radix = 2;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type epsilon() throw() {return type(0);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type round_error() throw() {return type(0);}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type infinity() throw() {return type(0);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type quiet_NaN() throw() {return type(0);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type signaling_NaN() throw() {return type(0);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type denorm_min() throw() {return type(0);}

    static const bool is_iec559 = false;
    static const bool is_bounded = true;
    static const bool is_modulo = !std::__1::is_signed&lt;_Tp&gt;::value;



    static const bool traps = true;



    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template &lt;&gt;
class __libcpp_numeric_limits&lt;bool, true&gt;
{
protected:
    typedef bool type;

    static const bool is_specialized = true;

    static const bool is_signed = false;
    static const int digits = 1;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const type __min = false;
    static const type __max = true;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type min() throw() {return __min;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type max() throw() {return __max;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type lowest() throw() {return min();}

    static const bool is_integer = true;
    static const bool is_exact = true;
    static const int radix = 2;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type epsilon() throw() {return type(0);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type round_error() throw() {return type(0);}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type infinity() throw() {return type(0);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type quiet_NaN() throw() {return type(0);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type signaling_NaN() throw() {return type(0);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type denorm_min() throw() {return type(0);}

    static const bool is_iec559 = false;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template &lt;&gt;
class __libcpp_numeric_limits&lt;float, true&gt;
{
protected:
    typedef float type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 24;
    static const int digits10 = 6;
    static const int max_digits10 = 2+(digits * 30103l)/100000l;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type min() throw() {return 1.17549435e-38F;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type max() throw() {return 3.40282347e+38F;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type epsilon() throw() {return 1.19209290e-7F;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type round_error() throw() {return 0.5F;}

    static const int min_exponent = (-125);
    static const int min_exponent10 = (-37);
    static const int max_exponent = 128;
    static const int max_exponent10 = 38;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type infinity() throw() {return __builtin_huge_valf();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type quiet_NaN() throw() {return __builtin_nanf(&quot;&quot;);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type signaling_NaN() throw() {return __builtin_nansf(&quot;&quot;);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type denorm_min() throw() {return 1.40129846e-45F;}

    static const bool is_iec559 = true;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template &lt;&gt;
class __libcpp_numeric_limits&lt;double, true&gt;
{
protected:
    typedef double type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 53;
    static const int digits10 = 15;
    static const int max_digits10 = 2+(digits * 30103l)/100000l;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type min() throw() {return 2.2250738585072014e-308;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type max() throw() {return 1.7976931348623157e+308;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type epsilon() throw() {return 2.2204460492503131e-16;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type round_error() throw() {return 0.5;}

    static const int min_exponent = (-1021);
    static const int min_exponent10 = (-307);
    static const int max_exponent = 1024;
    static const int max_exponent10 = 308;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type infinity() throw() {return __builtin_huge_val();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type quiet_NaN() throw() {return __builtin_nan(&quot;&quot;);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type signaling_NaN() throw() {return __builtin_nans(&quot;&quot;);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type denorm_min() throw() {return 4.9406564584124654e-324;}

    static const bool is_iec559 = true;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template &lt;&gt;
class __libcpp_numeric_limits&lt;long double, true&gt;
{
protected:
    typedef long double type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 64;
    static const int digits10 = 18;
    static const int max_digits10 = 2+(digits * 30103l)/100000l;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type min() throw() {return 3.36210314311209350626e-4932L;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type max() throw() {return 1.18973149535723176502e+4932L;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type epsilon() throw() {return 1.08420217248550443401e-19L;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type round_error() throw() {return 0.5L;}

    static const int min_exponent = (-16381);
    static const int min_exponent10 = (-4931);
    static const int max_exponent = 16384;
    static const int max_exponent10 = 4932;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type infinity() throw() {return __builtin_huge_vall();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type quiet_NaN() throw() {return __builtin_nanl(&quot;&quot;);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type signaling_NaN() throw() {return __builtin_nansl(&quot;&quot;);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type denorm_min() throw() {return 3.64519953188247460253e-4951L;}




    static const bool is_iec559 = true;

    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template &lt;class _Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) numeric_limits
    : private __libcpp_numeric_limits&lt;typename remove_cv&lt;_Tp&gt;::type&gt;
{
    typedef __libcpp_numeric_limits&lt;typename remove_cv&lt;_Tp&gt;::type&gt; __base;
    typedef typename __base::type type;
public:
    static const bool is_specialized = __base::is_specialized;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type min() throw() {return __base::min();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type max() throw() {return __base::max();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type epsilon() throw() {return __base::epsilon();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type infinity() throw() {return __base::infinity();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;_Tp&gt;::is_specialized;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;_Tp&gt;::digits;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;_Tp&gt;::digits10;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;_Tp&gt;::max_digits10;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;_Tp&gt;::is_signed;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;_Tp&gt;::is_integer;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;_Tp&gt;::is_exact;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;_Tp&gt;::radix;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;_Tp&gt;::min_exponent;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;_Tp&gt;::min_exponent10;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;_Tp&gt;::max_exponent;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;_Tp&gt;::max_exponent10;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;_Tp&gt;::has_infinity;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;_Tp&gt;::has_quiet_NaN;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;_Tp&gt;::has_signaling_NaN;
template &lt;class _Tp&gt;
                      const float_denorm_style numeric_limits&lt;_Tp&gt;::has_denorm;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;_Tp&gt;::has_denorm_loss;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;_Tp&gt;::is_iec559;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;_Tp&gt;::is_bounded;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;_Tp&gt;::is_modulo;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;_Tp&gt;::traps;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;_Tp&gt;::tinyness_before;
template &lt;class _Tp&gt;
                      const float_round_style numeric_limits&lt;_Tp&gt;::round_style;

template &lt;class _Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) numeric_limits&lt;const _Tp&gt;
    : private numeric_limits&lt;_Tp&gt;
{
    typedef numeric_limits&lt;_Tp&gt; __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type min() throw() {return __base::min();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type max() throw() {return __base::max();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type epsilon() throw() {return __base::epsilon();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type infinity() throw() {return __base::infinity();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const <span class="ge">_Tp&gt;::is_</span>specialized;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const _Tp&gt;::digits;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const _Tp&gt;::digits10;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const <span class="ge">_Tp&gt;::max_</span>digits10;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const <span class="ge">_Tp&gt;::is_</span>signed;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const <span class="ge">_Tp&gt;::is_</span>integer;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const <span class="ge">_Tp&gt;::is_</span>exact;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const _Tp&gt;::radix;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const <span class="ge">_Tp&gt;::min_</span>exponent;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const <span class="ge">_Tp&gt;::min_</span>exponent10;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const <span class="ge">_Tp&gt;::max_</span>exponent;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const <span class="ge">_Tp&gt;::max_</span>exponent10;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const <span class="ge">_Tp&gt;::has_</span>infinity;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const <span class="ge">_Tp&gt;::has_</span>quiet_NaN;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const <span class="ge">_Tp&gt;::has_</span>signaling_NaN;
template &lt;class _Tp&gt;
                      const float_denorm_style numeric_limits&lt;const <span class="ge">_Tp&gt;::has_</span>denorm;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const <span class="ge">_Tp&gt;::has_</span>denorm_loss;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const <span class="ge">_Tp&gt;::is_</span>iec559;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const <span class="ge">_Tp&gt;::is_</span>bounded;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const <span class="ge">_Tp&gt;::is_</span>modulo;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const _Tp&gt;::traps;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const <span class="ge">_Tp&gt;::tinyness_</span>before;
template &lt;class _Tp&gt;
                      const float_round_style numeric_limits&lt;const <span class="ge">_Tp&gt;::round_</span>style;

template &lt;class _Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) numeric_limits&lt;volatile _Tp&gt;
    : private numeric_limits&lt;_Tp&gt;
{
    typedef numeric_limits&lt;_Tp&gt; __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type min() throw() {return __base::min();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type max() throw() {return __base::max();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type epsilon() throw() {return __base::epsilon();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type infinity() throw() {return __base::infinity();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;volatile <span class="ge">_Tp&gt;::is_</span>specialized;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;volatile _Tp&gt;::digits;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;volatile _Tp&gt;::digits10;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;volatile <span class="ge">_Tp&gt;::max_</span>digits10;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;volatile <span class="ge">_Tp&gt;::is_</span>signed;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;volatile <span class="ge">_Tp&gt;::is_</span>integer;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;volatile <span class="ge">_Tp&gt;::is_</span>exact;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;volatile _Tp&gt;::radix;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;volatile <span class="ge">_Tp&gt;::min_</span>exponent;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;volatile <span class="ge">_Tp&gt;::min_</span>exponent10;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;volatile <span class="ge">_Tp&gt;::max_</span>exponent;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;volatile <span class="ge">_Tp&gt;::max_</span>exponent10;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;volatile <span class="ge">_Tp&gt;::has_</span>infinity;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;volatile <span class="ge">_Tp&gt;::has_</span>quiet_NaN;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;volatile <span class="ge">_Tp&gt;::has_</span>signaling_NaN;
template &lt;class _Tp&gt;
                      const float_denorm_style numeric_limits&lt;volatile <span class="ge">_Tp&gt;::has_</span>denorm;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;volatile <span class="ge">_Tp&gt;::has_</span>denorm_loss;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;volatile <span class="ge">_Tp&gt;::is_</span>iec559;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;volatile <span class="ge">_Tp&gt;::is_</span>bounded;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;volatile <span class="ge">_Tp&gt;::is_</span>modulo;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;volatile _Tp&gt;::traps;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;volatile <span class="ge">_Tp&gt;::tinyness_</span>before;
template &lt;class _Tp&gt;
                      const float_round_style numeric_limits&lt;volatile <span class="ge">_Tp&gt;::round_</span>style;

template &lt;class _Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) numeric_limits&lt;const volatile _Tp&gt;
    : private numeric_limits&lt;_Tp&gt;
{
    typedef numeric_limits&lt;_Tp&gt; __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type min() throw() {return __base::min();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type max() throw() {return __base::max();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type epsilon() throw() {return __base::epsilon();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type infinity() throw() {return __base::infinity();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::is_</span>specialized;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const volatile _Tp&gt;::digits;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const volatile _Tp&gt;::digits10;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::max_</span>digits10;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::is_</span>signed;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::is_</span>integer;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::is_</span>exact;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const volatile _Tp&gt;::radix;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::min_</span>exponent;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::min_</span>exponent10;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::max_</span>exponent;
template &lt;class _Tp&gt;
                      const int numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::max_</span>exponent10;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::has_</span>infinity;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::has_</span>quiet_NaN;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::has_</span>signaling_NaN;
template &lt;class _Tp&gt;
                      const float_denorm_style numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::has_</span>denorm;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::has_</span>denorm_loss;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::is_</span>iec559;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::is_</span>bounded;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::is_</span>modulo;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const volatile _Tp&gt;::traps;
template &lt;class _Tp&gt;
                      const bool numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::tinyness_</span>before;
template &lt;class _Tp&gt;
                      const float_round_style numeric_limits&lt;const volatile <span class="ge">_Tp&gt;::round_</span>style;

} }





template &lt;class _A1&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
__libcpp_signbit(_A1 __lcpp_x) throw()
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? __inline_signbitf((float)(__lcpp_x)) : sizeof(__lcpp_x) == sizeof(double) ? __inline_signbitd((double)(__lcpp_x)) : __inline_signbitl((long double)(__lcpp_x)));
}



template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_floating_point&lt;_A1&gt;::value, bool&gt;::type
signbit(_A1 __lcpp_x) throw()
{
    return __libcpp_signbit((typename std::__promote&lt;_A1&gt;::type)__lcpp_x);
}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;
    std::is_integral&lt;_A1&gt;::value &amp;&amp; std::is_signed&lt;_A1&gt;::value, bool&gt;::type
signbit(_A1 __lcpp_x) throw()
{ return __lcpp_x &lt; 0; }

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;
    std::is_integral&lt;_A1&gt;::value &amp;&amp; !std::is_signed&lt;_A1&gt;::value, bool&gt;::type
signbit(_A1) throw()
{ return false; }
template &lt;class _A1&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int
__libcpp_fpclassify(_A1 __lcpp_x) throw()
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? <span class="gs">__fpclassifyf((float)(__</span>lcpp_x)) : sizeof(__lcpp_x) == sizeof(double) ? <span class="gs">__fpclassifyd((double)(__</span>lcpp_x)) : <span class="gs">__fpclassifyl((long double)(__</span>lcpp_x)));
}



template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_floating_point&lt;_A1&gt;::value, int&gt;::type
fpclassify(_A1 __lcpp_x) throw()
{
    return __libcpp_fpclassify((typename std::__promote&lt;_A1&gt;::type)__lcpp_x);
}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, int&gt;::type
fpclassify(_A1 __lcpp_x) throw()
{ return __lcpp_x == 0 ? 3 : 4; }
template &lt;class _A1&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
__libcpp_isfinite(_A1 __lcpp_x) throw()
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? __inline_isfinitef((float)(__lcpp_x)) : sizeof(__lcpp_x) == sizeof(double) ? __inline_isfinited((double)(__lcpp_x)) : __inline_isfinitel((long double)(__lcpp_x)));
}



template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp; std::numeric_limits&lt;_A1&gt;::has_infinity,
    bool&gt;::type
isfinite(_A1 __lcpp_x) throw()
{
    return __libcpp_isfinite((typename std::__promote&lt;_A1&gt;::type)__lcpp_x);
}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp; !std::numeric_limits&lt;_A1&gt;::has_infinity,
    bool&gt;::type
isfinite(_A1) throw()
{ return true; }







template &lt;class _A1&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
__libcpp_isinf(_A1 __lcpp_x) throw()
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? __inline_isinff((float)(__lcpp_x)) : sizeof(__lcpp_x) == sizeof(double) ? __inline_isinfd((double)(__lcpp_x)) : __inline_isinfl((long double)(__lcpp_x)));
}



template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp; std::numeric_limits&lt;_A1&gt;::has_infinity,
    bool&gt;::type
isinf(_A1 __lcpp_x) throw()
{
    return __libcpp_isinf((typename std::__promote&lt;_A1&gt;::type)__lcpp_x);
}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp; !std::numeric_limits&lt;_A1&gt;::has_infinity,
    bool&gt;::type
isinf(_A1) throw()
{ return false; }


inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
isinf(float __lcpp_x) throw() { return __libcpp_isinf(__lcpp_x); }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
bool
isinf(double __lcpp_x) throw() { return __libcpp_isinf(__lcpp_x); }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
isinf(long double __lcpp_x) throw() { return __libcpp_isinf(__lcpp_x); }
template &lt;class _A1&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
__libcpp_isnan(_A1 __lcpp_x) throw()
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? __inline_isnanf((float)(__lcpp_x)) : sizeof(__lcpp_x) == sizeof(double) ? __inline_isnand((double)(__lcpp_x)) : __inline_isnanl((long double)(__lcpp_x)));
}



template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_floating_point&lt;_A1&gt;::value, bool&gt;::type
isnan(_A1 __lcpp_x) throw()
{
    return __libcpp_isnan((typename std::__promote&lt;_A1&gt;::type)__lcpp_x);
}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, bool&gt;::type
isnan(_A1) throw()
{ return false; }


inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
isnan(float __lcpp_x) throw() { return __libcpp_isnan(__lcpp_x); }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__enable_if__(true, &quot;&quot;)))
bool
isnan(double __lcpp_x) throw() { return __libcpp_isnan(__lcpp_x); }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
isnan(long double __lcpp_x) throw() { return __libcpp_isnan(__lcpp_x); }
template &lt;class _A1&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
__libcpp_isnormal(_A1 __lcpp_x) throw()
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? __inline_isnormalf((float)(__lcpp_x)) : sizeof(__lcpp_x) == sizeof(double) ? __inline_isnormald((double)(__lcpp_x)) : __inline_isnormall((long double)(__lcpp_x)));
}



template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_floating_point&lt;_A1&gt;::value, bool&gt;::type
isnormal(_A1 __lcpp_x) throw()
{
    return __libcpp_isnormal((typename std::__promote&lt;_A1&gt;::type)__lcpp_x);
}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, bool&gt;::type
isnormal(_A1 __lcpp_x) throw()
{ return __lcpp_x != 0; }







template &lt;class <span class="ge">_A1, class _</span>A2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
__libcpp_isgreater(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    return __builtin_isgreater((__lcpp_x),(__lcpp_y));
}



template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    bool
&gt;::type
isgreater(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, _A2&gt;::type type;
    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);
}







template &lt;class <span class="ge">_A1, class _</span>A2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
__libcpp_isgreaterequal(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    return __builtin_isgreaterequal((__lcpp_x),(__lcpp_y));
}



template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    bool
&gt;::type
isgreaterequal(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, _A2&gt;::type type;
    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);
}







template &lt;class <span class="ge">_A1, class _</span>A2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
__libcpp_isless(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    return __builtin_isless((__lcpp_x),(__lcpp_y));
}



template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    bool
&gt;::type
isless(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, _A2&gt;::type type;
    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);
}







template &lt;class <span class="ge">_A1, class _</span>A2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
__libcpp_islessequal(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    return __builtin_islessequal((__lcpp_x),(__lcpp_y));
}



template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    bool
&gt;::type
islessequal(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, _A2&gt;::type type;
    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);
}







template &lt;class <span class="ge">_A1, class _</span>A2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
__libcpp_islessgreater(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    return __builtin_islessgreater((__lcpp_x),(__lcpp_y));
}



template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    bool
&gt;::type
islessgreater(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, _A2&gt;::type type;
    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);
}







template &lt;class <span class="ge">_A1, class _</span>A2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
__libcpp_isunordered(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    return __builtin_isunordered((__lcpp_x),(__lcpp_y));
}



template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    bool
&gt;::type
isunordered(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, _A2&gt;::type type;
    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);
}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long abs(long __x) throw() {
  return ::labs(__x);
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long long abs(long long __x) throw() {
  return ::llabs(__x);
}





inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float abs(float __lcpp_x) throw() {
  return ::fabsf(__lcpp_x);
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) double abs(double __lcpp_x) throw() {
  return ::fabs(__lcpp_x);
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double
abs(long double __lcpp_x) throw() {
  return ::fabsl(__lcpp_x);
}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ldiv_t div(long <span class="gs">__x, long __</span>y) throw() {
  return ::ldiv(__x, __y);
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) lldiv_t div(long long __x,
                                             long long __y) throw() {
  return ::lldiv(__x, __y);
}






inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float acos(float __lcpp_x) throw() {return ::acosf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double acos(long double __lcpp_x) throw() {return ::acosl(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
acos(_A1 __lcpp_x) throw() {return ::acos((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float asin(float __lcpp_x) throw() {return ::asinf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double asin(long double __lcpp_x) throw() {return ::asinl(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
asin(_A1 __lcpp_x) throw() {return ::asin((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float atan(float __lcpp_x) throw() {return ::atanf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double atan(long double __lcpp_x) throw() {return ::atanl(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
atan(_A1 __lcpp_x) throw() {return ::atan((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float atan2(float __lcpp_y, float __lcpp_x) throw() {return ::atan2f(__lcpp_y, __lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double atan2(long double __lcpp_y, long double __lcpp_x) throw() {return ::atan2l(__lcpp_y, __lcpp_x);}


template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::_EnableIf
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    std::__promote&lt;_A1, _A2&gt;
&gt;::type
atan2(_A1 __lcpp_y, <span class="ge">_A2 __lcpp_</span>x) throw()
{
    typedef typename std::__promote&lt;_A1, <span class="ge">_A2&gt;::type __result_</span>type;
    <span class="ge">_Static_</span>assert((!(std::_IsSame&lt;_A1, __result_type&gt;::value &amp;&amp; std::_IsSame&lt;_A2, __result_type&gt;::value)), &quot;&quot;);

    return ::atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);
}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float ceil(float __lcpp_x) throw() {return ::ceilf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double ceil(long double __lcpp_x) throw() {return ::ceill(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
ceil(_A1 __lcpp_x) throw() {return ::ceil((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float cos(float __lcpp_x) throw() {return ::cosf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double cos(long double __lcpp_x) throw() {return ::cosl(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
cos(_A1 __lcpp_x) throw() {return ::cos((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float cosh(float __lcpp_x) throw() {return ::coshf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double cosh(long double __lcpp_x) throw() {return ::coshl(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
cosh(_A1 __lcpp_x) throw() {return ::cosh((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float exp(float __lcpp_x) throw() {return ::expf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double exp(long double __lcpp_x) throw() {return ::expl(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
exp(_A1 __lcpp_x) throw() {return ::exp((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float fabs(float __lcpp_x) throw() {return ::fabsf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double fabs(long double __lcpp_x) throw() {return ::fabsl(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
fabs(_A1 __lcpp_x) throw() {return ::fabs((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float floor(float __lcpp_x) throw() {return ::floorf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double floor(long double __lcpp_x) throw() {return ::floorl(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
floor(_A1 __lcpp_x) throw() {return ::floor((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float fmod(float __lcpp_x, float __lcpp_y) throw() {return ::fmodf(__lcpp_x, __lcpp_y);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double fmod(long double __lcpp_x, long double __lcpp_y) throw() {return ::fmodl(__lcpp_x, __lcpp_y);}


template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::_EnableIf
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    std::__promote&lt;_A1, _A2&gt;
&gt;::type
fmod(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, <span class="ge">_A2&gt;::type __result_</span>type;
    <span class="ge">_Static_</span>assert((!(std::_IsSame&lt;_A1, __result_type&gt;::value &amp;&amp; std::_IsSame&lt;_A2, __result_type&gt;::value)), &quot;&quot;);

    return ::fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float frexp(float __lcpp_x, int* __lcpp_e) throw() {return ::frexpf(__lcpp_x, __lcpp_e);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double frexp(long double __lcpp_x, int* __lcpp_e) throw() {return ::frexpl(__lcpp_x, __lcpp_e);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
frexp(_A1 __lcpp_x, int* __lcpp_e) throw() {return ::frexp((double)__lcpp_x, __lcpp_e);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float ldexp(float __lcpp_x, int __lcpp_e) throw() {return ::ldexpf(__lcpp_x, __lcpp_e);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double ldexp(long double __lcpp_x, int __lcpp_e) throw() {return ::ldexpl(__lcpp_x, __lcpp_e);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
ldexp(_A1 __lcpp_x, int __lcpp_e) throw() {return ::ldexp((double)__lcpp_x, __lcpp_e);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float log(float __lcpp_x) throw() {return ::logf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double log(long double __lcpp_x) throw() {return ::logl(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
log(_A1 __lcpp_x) throw() {return ::log((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float log10(float __lcpp_x) throw() {return ::log10f(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double log10(long double __lcpp_x) throw() {return ::log10l(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
log10(_A1 __lcpp_x) throw() {return ::log10((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float modf(float __lcpp_x, float* __lcpp_y) throw() {return ::modff(__lcpp_x, __lcpp_y);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double modf(long double __lcpp_x, long double* __lcpp_y) throw() {return ::modfl(__lcpp_x, __lcpp_y);}





inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float pow(float __lcpp_x, float __lcpp_y) throw() {return ::powf(__lcpp_x, __lcpp_y);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double pow(long double __lcpp_x, long double __lcpp_y) throw() {return ::powl(__lcpp_x, __lcpp_y);}


template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::_EnableIf
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    std::__promote&lt;_A1, _A2&gt;
&gt;::type
pow(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, <span class="ge">_A2&gt;::type __result_</span>type;
    <span class="ge">_Static_</span>assert((!(std::_IsSame&lt;_A1, __result_type&gt;::value &amp;&amp; std::_IsSame&lt;_A2, __result_type&gt;::value)), &quot;&quot;);

    return ::pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float sin(float __lcpp_x) throw() {return ::sinf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double sin(long double __lcpp_x) throw() {return ::sinl(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
sin(_A1 __lcpp_x) throw() {return ::sin((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float sinh(float __lcpp_x) throw() {return ::sinhf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double sinh(long double __lcpp_x) throw() {return ::sinhl(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
sinh(_A1 __lcpp_x) throw() {return ::sinh((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float sqrt(float __lcpp_x) throw() {return ::sqrtf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double sqrt(long double __lcpp_x) throw() {return ::sqrtl(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
sqrt(_A1 __lcpp_x) throw() {return ::sqrt((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float tan(float __lcpp_x) throw() {return ::tanf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double tan(long double __lcpp_x) throw() {return ::tanl(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
tan(_A1 __lcpp_x) throw() {return ::tan((double)__lcpp_x);}




inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float tanh(float __lcpp_x) throw() {return ::tanhf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double tanh(long double __lcpp_x) throw() {return ::tanhl(__lcpp_x);}


template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
tanh(_A1 __lcpp_x) throw() {return ::tanh((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float acosh(float __lcpp_x) throw() {return ::acoshf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double acosh(long double __lcpp_x) throw() {return ::acoshl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
acosh(_A1 __lcpp_x) throw() {return ::acosh((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float asinh(float __lcpp_x) throw() {return ::asinhf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double asinh(long double __lcpp_x) throw() {return ::asinhl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
asinh(_A1 __lcpp_x) throw() {return ::asinh((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float atanh(float __lcpp_x) throw() {return ::atanhf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double atanh(long double __lcpp_x) throw() {return ::atanhl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
atanh(_A1 __lcpp_x) throw() {return ::atanh((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float cbrt(float __lcpp_x) throw() {return ::cbrtf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double cbrt(long double __lcpp_x) throw() {return ::cbrtl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
cbrt(_A1 __lcpp_x) throw() {return ::cbrt((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float copysign(float __lcpp_x,
                                                float __lcpp_y) throw() {
  return ::copysignf(__lcpp_x, __lcpp_y);
}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double
copysign(long double __lcpp_x, long double __lcpp_y) throw() {
  return ::copysignl(__lcpp_x, __lcpp_y);
}

template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::_EnableIf
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    std::__promote&lt;_A1, _A2&gt;
&gt;::type
copysign(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, <span class="ge">_A2&gt;::type __result_</span>type;
    <span class="ge">_Static_</span>assert((!(std::_IsSame&lt;_A1, __result_type&gt;::value &amp;&amp; std::_IsSame&lt;_A2, __result_type&gt;::value)), &quot;&quot;);

    return ::copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float erf(float __lcpp_x) throw() {return ::erff(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double erf(long double __lcpp_x) throw() {return ::erfl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
erf(_A1 __lcpp_x) throw() {return ::erf((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float erfc(float __lcpp_x) throw() {return ::erfcf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double erfc(long double __lcpp_x) throw() {return ::erfcl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
erfc(_A1 __lcpp_x) throw() {return ::erfc((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float exp2(float __lcpp_x) throw() {return ::exp2f(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double exp2(long double __lcpp_x) throw() {return ::exp2l(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
exp2(_A1 __lcpp_x) throw() {return ::exp2((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float expm1(float __lcpp_x) throw() {return ::expm1f(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double expm1(long double __lcpp_x) throw() {return ::expm1l(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
expm1(_A1 __lcpp_x) throw() {return ::expm1((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float fdim(float __lcpp_x, float __lcpp_y) throw() {return ::fdimf(__lcpp_x, __lcpp_y);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double fdim(long double __lcpp_x, long double __lcpp_y) throw() {return ::fdiml(__lcpp_x, __lcpp_y);}

template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::_EnableIf
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    std::__promote&lt;_A1, _A2&gt;
&gt;::type
fdim(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, <span class="ge">_A2&gt;::type __result_</span>type;
    <span class="ge">_Static_</span>assert((!(std::_IsSame&lt;_A1, __result_type&gt;::value &amp;&amp; std::_IsSame&lt;_A2, __result_type&gt;::value)), &quot;&quot;);

    return ::fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) throw() {return ::fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) throw() {return ::fmal(__lcpp_x, __lcpp_y, __lcpp_z);}

template &lt;class <span class="ge">_A1, class _</span>A2, class _A3&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::_EnableIf
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A3&gt;::value,
    std::__promote&lt;_A1, <span class="ge">_A2, _</span>A3&gt;
&gt;::type
fma(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y, <span class="ge">_A3 __lcpp_</span>z) throw()
{
    typedef typename std::__promote&lt;_A1, <span class="ge">_A2, _</span>A3&gt;::type __result_type;
    <span class="ge">_Static_</span>assert((!(std::_IsSame&lt;_A1, __result_type&gt;::value &amp;&amp; std::_IsSame&lt;_A2, __result_type&gt;::value &amp;&amp; std::_IsSame&lt;_A3, __result_type&gt;::value)), &quot;&quot;);


    return ::fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float fmax(float __lcpp_x, float __lcpp_y) throw() {return ::fmaxf(__lcpp_x, __lcpp_y);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double fmax(long double __lcpp_x, long double __lcpp_y) throw() {return ::fmaxl(__lcpp_x, __lcpp_y);}

template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::_EnableIf
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    std::__promote&lt;_A1, _A2&gt;
&gt;::type
fmax(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, <span class="ge">_A2&gt;::type __result_</span>type;
    <span class="ge">_Static_</span>assert((!(std::_IsSame&lt;_A1, __result_type&gt;::value &amp;&amp; std::_IsSame&lt;_A2, __result_type&gt;::value)), &quot;&quot;);

    return ::fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float fmin(float __lcpp_x, float __lcpp_y) throw() {return ::fminf(__lcpp_x, __lcpp_y);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double fmin(long double __lcpp_x, long double __lcpp_y) throw() {return ::fminl(__lcpp_x, __lcpp_y);}

template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::_EnableIf
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    std::__promote&lt;_A1, _A2&gt;
&gt;::type
fmin(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, <span class="ge">_A2&gt;::type __result_</span>type;
    <span class="ge">_Static_</span>assert((!(std::_IsSame&lt;_A1, __result_type&gt;::value &amp;&amp; std::_IsSame&lt;_A2, __result_type&gt;::value)), &quot;&quot;);

    return ::fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float hypot(float __lcpp_x, float __lcpp_y) throw() {return ::hypotf(__lcpp_x, __lcpp_y);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double hypot(long double __lcpp_x, long double __lcpp_y) throw() {return ::hypotl(__lcpp_x, __lcpp_y);}

template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::_EnableIf
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    std::__promote&lt;_A1, _A2&gt;
&gt;::type
hypot(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, <span class="ge">_A2&gt;::type __result_</span>type;
    <span class="ge">_Static_</span>assert((!(std::_IsSame&lt;_A1, __result_type&gt;::value &amp;&amp; std::_IsSame&lt;_A2, __result_type&gt;::value)), &quot;&quot;);

    return ::hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) int ilogb(float __lcpp_x) throw() {return ::ilogbf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) int ilogb(long double __lcpp_x) throw() {return ::ilogbl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, int&gt;::type
ilogb(_A1 __lcpp_x) throw() {return ::ilogb((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float lgamma(float __lcpp_x) throw() {return ::lgammaf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double lgamma(long double __lcpp_x) throw() {return ::lgammal(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
lgamma(_A1 __lcpp_x) throw() {return ::lgamma((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long long llrint(float __lcpp_x) throw() {return ::llrintf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long long llrint(long double __lcpp_x) throw() {return ::llrintl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, long long&gt;::type
llrint(_A1 __lcpp_x) throw() {return ::llrint((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long long llround(float __lcpp_x) throw() {return ::llroundf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long long llround(long double __lcpp_x) throw() {return ::llroundl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, long long&gt;::type
llround(_A1 __lcpp_x) throw() {return ::llround((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float log1p(float __lcpp_x) throw() {return ::log1pf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double log1p(long double __lcpp_x) throw() {return ::log1pl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
log1p(_A1 __lcpp_x) throw() {return ::log1p((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float log2(float __lcpp_x) throw() {return ::log2f(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double log2(long double __lcpp_x) throw() {return ::log2l(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
log2(_A1 __lcpp_x) throw() {return ::log2((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float logb(float __lcpp_x) throw() {return ::logbf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double logb(long double __lcpp_x) throw() {return ::logbl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
logb(_A1 __lcpp_x) throw() {return ::logb((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long lrint(float __lcpp_x) throw() {return ::lrintf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long lrint(long double __lcpp_x) throw() {return ::lrintl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, long&gt;::type
lrint(_A1 __lcpp_x) throw() {return ::lrint((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long lround(float __lcpp_x) throw() {return ::lroundf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long lround(long double __lcpp_x) throw() {return ::lroundl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, long&gt;::type
lround(_A1 __lcpp_x) throw() {return ::lround((double)__lcpp_x);}





inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float nearbyint(float __lcpp_x) throw() {return ::nearbyintf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double nearbyint(long double __lcpp_x) throw() {return ::nearbyintl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
nearbyint(_A1 __lcpp_x) throw() {return ::nearbyint((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float nextafter(float __lcpp_x, float __lcpp_y) throw() {return ::nextafterf(__lcpp_x, __lcpp_y);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double nextafter(long double __lcpp_x, long double __lcpp_y) throw() {return ::nextafterl(__lcpp_x, __lcpp_y);}

template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::_EnableIf
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    std::__promote&lt;_A1, _A2&gt;
&gt;::type
nextafter(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, <span class="ge">_A2&gt;::type __result_</span>type;
    <span class="ge">_Static_</span>assert((!(std::_IsSame&lt;_A1, __result_type&gt;::value &amp;&amp; std::_IsSame&lt;_A2, __result_type&gt;::value)), &quot;&quot;);

    return ::nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float nexttoward(float __lcpp_x, long double __lcpp_y) throw() {return ::nexttowardf(__lcpp_x, __lcpp_y);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double nexttoward(long double __lcpp_x, long double __lcpp_y) throw() {return ::nexttowardl(__lcpp_x, __lcpp_y);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
nexttoward(_A1 __lcpp_x, long double __lcpp_y) throw() {return ::nexttoward((double)__lcpp_x, __lcpp_y);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float remainder(float __lcpp_x, float __lcpp_y) throw() {return ::remainderf(__lcpp_x, __lcpp_y);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double remainder(long double __lcpp_x, long double __lcpp_y) throw() {return ::remainderl(__lcpp_x, __lcpp_y);}

template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::_EnableIf
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    std::__promote&lt;_A1, _A2&gt;
&gt;::type
remainder(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y) throw()
{
    typedef typename std::__promote&lt;_A1, <span class="ge">_A2&gt;::type __result_</span>type;
    <span class="ge">_Static_</span>assert((!(std::_IsSame&lt;_A1, __result_type&gt;::value &amp;&amp; std::_IsSame&lt;_A2, __result_type&gt;::value)), &quot;&quot;);

    return ::remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) throw() {return ::remquof(__lcpp_x, __lcpp_y, __lcpp_z);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) throw() {return ::remquol(__lcpp_x, __lcpp_y, __lcpp_z);}

template &lt;class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::_EnableIf
&lt;
    std::is_arithmetic&lt;_A1&gt;::value &amp;&amp;
    std::is_arithmetic&lt;_A2&gt;::value,
    std::__promote&lt;_A1, _A2&gt;
&gt;::type
remquo(_A1 __lcpp_x, <span class="ge">_A2 __lcpp_</span>y, int* __lcpp_z) throw()
{
    typedef typename std::__promote&lt;_A1, <span class="ge">_A2&gt;::type __result_</span>type;
    <span class="ge">_Static_</span>assert((!(std::_IsSame&lt;_A1, __result_type&gt;::value &amp;&amp; std::_IsSame&lt;_A2, __result_type&gt;::value)), &quot;&quot;);

    return ::remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);
}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float rint(float __lcpp_x) throw() {return ::rintf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double rint(long double __lcpp_x) throw() {return ::rintl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
rint(_A1 __lcpp_x) throw() {return ::rint((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float round(float __lcpp_x) throw() {return ::roundf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double round(long double __lcpp_x) throw() {return ::roundl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
round(_A1 __lcpp_x) throw() {return ::round((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float scalbln(float __lcpp_x, long __lcpp_y) throw() {return ::scalblnf(__lcpp_x, __lcpp_y);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double scalbln(long double __lcpp_x, long __lcpp_y) throw() {return ::scalblnl(__lcpp_x, __lcpp_y);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
scalbln(_A1 __lcpp_x, long __lcpp_y) throw() {return ::scalbln((double)__lcpp_x, __lcpp_y);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float scalbn(float __lcpp_x, int __lcpp_y) throw() {return ::scalbnf(__lcpp_x, __lcpp_y);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double scalbn(long double __lcpp_x, int __lcpp_y) throw() {return ::scalbnl(__lcpp_x, __lcpp_y);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
scalbn(_A1 __lcpp_x, int __lcpp_y) throw() {return ::scalbn((double)__lcpp_x, __lcpp_y);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float tgamma(float __lcpp_x) throw() {return ::tgammaf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double tgamma(long double __lcpp_x) throw() {return ::tgammal(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
tgamma(_A1 __lcpp_x) throw() {return ::tgamma((double)__lcpp_x);}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) float trunc(float __lcpp_x) throw() {return ::truncf(__lcpp_x);}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) long double trunc(long double __lcpp_x) throw() {return ::truncl(__lcpp_x);}

template &lt;class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename std::enable_if&lt;std::is_integral&lt;_A1&gt;::value, double&gt;::type
trunc(_A1 __lcpp_x) throw() {return ::trunc((double)__lcpp_x);}

}








namespace std { inline namespace __1 {

using ::size_t;
using ::div_t;
using ::ldiv_t;

using ::lldiv_t;

using ::atof;
using ::atoi;
using ::atol;

using ::atoll;

using ::strtod;
using ::strtof;
using ::strtold;
using ::strtol;

using ::strtoll;

using ::strtoul;

using ::strtoull;




using ::rand;
using ::srand;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;



using ::abort;



using ::atexit;
using ::exit;
using ::_Exit;

using ::getenv;
using ::system;




using ::bsearch;
using ::qsort;
using ::abs;
using ::labs;

using ::llabs;

using ::div;
using ::ldiv;

using ::lldiv;

using ::mblen;
using ::mbtowc;
using ::wctomb;
using ::mbstowcs;
using ::wcstombs;
} }


namespace std
{


class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) exception
{
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) exception() throw() {}
    virtual ~exception() throw();
    virtual const char* what() const throw();
};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bad_exception
    : public exception
{
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bad_exception() throw() {}
    virtual ~bad_exception() throw();
    virtual const char* what() const throw();
};





typedef void (*unexpected_handler)();
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) unexpected_handler set_unexpected(unexpected_handler) throw();
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) unexpected_handler get_unexpected() throw();
<span class="gs">__attribute__</span> ((noreturn)) <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void unexpected();


typedef void (*terminate_handler)();
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) terminate_handler set_terminate(terminate_handler) throw();
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) terminate_handler get_terminate() throw();
<span class="gs">__attribute__</span> ((noreturn)) <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void terminate() throw();

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool uncaught_exception() throw();
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) <span class="gs">__attribute__</span>((availability(macosx,strict,introduced=10.12))) <span class="gs">__attribute__</span>((availability(ios,strict,introduced=10.0))) <span class="gs">__attribute__</span>((availability(tvos,strict,introduced=10.0))) <span class="gs">__attribute__</span>((availability(watchos,strict,introduced=3.0))) int uncaught_exceptions() throw();

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) exception_ptr;

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) exception_ptr current_exception() throw();
<span class="gs">__attribute__</span> ((noreturn)) <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void rethrow_exception(exception_ptr);



class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) exception_ptr
{
    void* __ptr_;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) exception_ptr() throw() : __ptr_() {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) exception_ptr(nullptr_t) throw() : __ptr_() {}

    exception_ptr(const exception_ptr&amp;) throw();
    exception_ptr&amp; operator=(const exception_ptr&amp;) throw();
    ~exception_ptr() throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) operator bool() const throw()
    {return __ptr_ != std::__1::__get_nullptr_t();}

    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator==(const exception_ptr&amp; __x, const exception_ptr&amp; __y) throw()
        {return <span class="gs">__x.__</span>ptr_ == <span class="gs">__y.__</span>ptr_;}

    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator!=(const exception_ptr&amp; __x, const exception_ptr&amp; __y) throw()
        {return !(__x == __y);}

    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) exception_ptr current_exception() throw();
    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void rethrow_exception(exception_ptr);
};

template&lt;class _Ep&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) exception_ptr
make_exception_ptr(_Ep __e) throw()
{

    try
    {
        throw __e;
    }
    catch (...)
    {
        return current_exception();
    }




}
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) nested_exception
{
    exception_ptr __ptr_;
public:
    nested_exception() throw();


    virtual ~nested_exception() throw();


    <span class="gs">__attribute__</span> ((noreturn)) void rethrow_nested() const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) exception_ptr nested_ptr() const throw() {return __ptr_;}
};

template &lt;class _Tp&gt;
struct __nested
    : public _Tp,
      public nested_exception
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit __nested(const <span class="ge">_Tp&amp; __t) : _</span>Tp(__t) {}
};


template &lt;class <span class="ge">_Tp, class _</span>Up, bool&gt;
struct __throw_with_nested;

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __throw_with_nested&lt;_Tp, _Up, true&gt; {
    <span class="gs">__attribute__</span> ((noreturn)) static inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void
    __do_throw(_Tp&amp;&amp; __t)
    {
        throw __nested&lt;_Up&gt;(std::__1::forward&lt;_Tp&gt;(__t));
    }
};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __throw_with_nested&lt;_Tp, _Up, false&gt; {
    <span class="gs">__attribute__</span> ((noreturn)) static inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void



    __do_throw (<span class="ge">_Tp&amp; _</span>_t)

    {
        throw std::__1::forward&lt;_Tp&gt;(__t);
    }
};


template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((noreturn))
void
throw_with_nested(_Tp&amp;&amp; __t)
{

    typedef typename decay&lt;_Tp&gt;::type _Up;
    <span class="ge">_Static_</span>assert(is_copy_constructible&lt;_Up&gt;::value, &quot;type thrown must be CopyConstructible&quot;);
    __throw_with_nested&lt;_Tp, _Up,
        is_class&lt;_Up&gt;::value &amp;&amp;
        !is_base_of&lt;nested_exception, _Up&gt;::value &amp;&amp;
        !__libcpp_is_final&lt;_Up&gt;::value&gt;::
            __do_throw(std::__1::forward&lt;_Tp&gt;(__t));




}

template &lt;class <span class="ge">_From, class _</span>To&gt;
struct __can_dynamic_cast : public integral_constant&lt;bool,(is_polymorphic&lt;_From&gt;::value &amp;&amp; (!is_base_of&lt;_To, <span class="ge">_From&gt;::value || is_</span>convertible&lt;const <span class="ge">_From*, const _</span>To*&gt;::value))&gt; {};




template &lt;class _Ep&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
rethrow_if_nested(const <span class="ge">_Ep&amp; _</span>_e,
                  typename enable_if&lt; __can_dynamic_cast&lt;_Ep, nested_exception&gt;::value&gt;::type* = 0)
{
    const nested_exception* __nep = dynamic_cast&lt;const nested_exception*&gt;(std::__1::addressof(__e));
    if (__nep)
        __nep-&gt;rethrow_nested();
}

template &lt;class _Ep&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
rethrow_if_nested(const _Ep&amp;,
                  typename enable_if&lt;!__can_dynamic_cast&lt;_Ep, nested_exception&gt;::value&gt;::type* = 0)
{
}

}






namespace std
{
struct __type_info_implementations {
  struct __string_impl_base {
    typedef const char* __type_name_t;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__always_inline__))
                      static const char* __type_name_to_string(__type_name_t __v) throw() {
      return __v;
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__always_inline__))
                      static __type_name_t __string_to_type_name(const char* __v) throw() {
      return __v;
    }
  };

  struct __unique_impl : __string_impl_base {
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__always_inline__))
    static size_t <span class="gs">__hash(__</span>type_name_t __v) throw() {
      return reinterpret_cast&lt;size_t&gt;(__v);
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__always_inline__))
    static bool <span class="gs">__eq(__</span>type_name_t <span class="gs">__lhs, __</span>type_name_t __rhs) throw() {
      return <span class="gs">__lhs == __</span>rhs;
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__always_inline__))
    static bool <span class="gs">__lt(__</span>type_name_t <span class="gs">__lhs, __</span>type_name_t __rhs) throw() {
      return <span class="gs">__lhs &lt; __</span>rhs;
    }
  };

  struct __non_unique_impl : __string_impl_base {
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__always_inline__))
    static size_t <span class="gs">__hash(__</span>type_name_t __ptr) throw() {
      size_t __hash = 5381;
      while (unsigned char __c = static_cast&lt;unsigned char&gt;(*__ptr++))
        <span class="gs">__hash = (__</span>hash * 33) ^ __c;
      return __hash;
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__always_inline__))
    static bool <span class="gs">__eq(__</span>type_name_t <span class="gs">__lhs, __</span>type_name_t __rhs) throw() {
      return <span class="gs">__lhs == __</span>rhs || __builtin_strcmp(__lhs, __rhs) == 0;
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__always_inline__))
    static bool <span class="gs">__lt(__</span>type_name_t <span class="gs">__lhs, __</span>type_name_t __rhs) throw() {
      return __builtin_strcmp(__lhs, __rhs) &lt; 0;
    }
  };

  struct __non_unique_arm_rtti_bit_impl {
    typedef uintptr_t __type_name_t;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__always_inline__))
    static const char* __type_name_to_string(__type_name_t __v) throw() {
      return reinterpret_cast&lt;const char*&gt;(__v &amp;
          ~__non_unique_rtti_bit::value);
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__always_inline__))
    static __type_name_t __string_to_type_name(const char* __v) throw() {
      return reinterpret_cast&lt;__type_name_t&gt;(__v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__always_inline__))
    static size_t <span class="gs">__hash(__</span>type_name_t __v) throw() {
      if (__is_type_name_unique(__v))
        return reinterpret_cast&lt;size_t&gt;(__v);
      return __non_unique_impl::__hash(__type_name_to_string(__v));
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__always_inline__))
    static bool <span class="gs">__eq(__</span>type_name_t <span class="gs">__lhs, __</span>type_name_t __rhs) throw() {
      if (<span class="gs">__lhs == __</span>rhs)
        return true;
      if (__is_type_name_unique(__lhs, __rhs))
        return false;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) == 0;
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="gs">__attribute__</span> ((__always_inline__))
    static bool <span class="gs">__lt(__</span>type_name_t <span class="gs">__lhs, __</span>type_name_t __rhs) throw() {
      if (__is_type_name_unique(__lhs, __rhs))
        return <span class="gs">__lhs &lt; __</span>rhs;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) &lt; 0;
    }

   private:


    typedef std::integral_constant&lt;__type_name_t,
      (1ULL &lt;&lt; ((8 * sizeof(__type_name_t)) - 1))&gt; __non_unique_rtti_bit;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static bool __is_type_name_unique(__type_name_t __lhs) throw() {
      return !(__lhs &amp; __non_unique_rtti_bit::value);
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static bool __is_type_name_unique(__type_name_t <span class="gs">__lhs, __</span>type_name_t __rhs) throw() {
      return !((__lhs &amp; <span class="gs">__rhs) &amp; __</span>non_unique_rtti_bit::value);
    }
  };

  typedef





    __unique_impl



     __impl;
};
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) type_info
{
  type_info&amp; operator=(const type_info&amp;);
  type_info(const type_info&amp;);

 protected:
    typedef __type_info_implementations::__impl __impl;

    <span class="gs">__impl::__</span>type_name_t __type_name;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit type_info(const char* __n)
      : __type_name(__impl::__string_to_type_name(__n)) {}

public:
    <span class="gs">__attribute__</span>((availability(macosx,strict,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,strict,introduced=7.0)))
    virtual ~type_info();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char* name() const throw()
    {
      return <span class="gs">__impl::__</span>type_name_to_string(__type_name);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool before(const type_info&amp; __arg) const throw()
    {
      return <span class="gs">__impl::__</span>lt(__type_name, <span class="gs">__arg.__</span>type_name);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t hash_code() const throw()
    {
      return <span class="gs">__impl::__</span>hash(__type_name);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator==(const type_info&amp; __arg) const throw()
    {
      return <span class="gs">__impl::__</span>eq(__type_name, <span class="gs">__arg.__</span>type_name);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator!=(const type_info&amp; __arg) const throw()
    { return !operator==(__arg); }
};


class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bad_cast
    : public exception
{
 public:
  bad_cast() throw();
  virtual ~bad_cast() throw();
  virtual const char* what() const throw();
};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bad_typeid
    : public exception
{
 public:
  bad_typeid() throw();
  virtual ~bad_typeid() throw();
  virtual const char* what() const throw();
};

}



namespace std { inline namespace __1 {
<span class="gs">__attribute__</span> ((noreturn)) inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __throw_bad_cast()
{

    throw bad_cast();



}
} }


namespace std
{


struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) nothrow_t { explicit nothrow_t() = default; };
extern <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const nothrow_t nothrow;

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bad_alloc
    : public exception
{
public:
    bad_alloc() throw();
    virtual ~bad_alloc() throw();
    virtual const char* what() const throw();
};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() throw();
    virtual ~bad_array_new_length() throw();
    virtual const char* what() const throw();
};

typedef void (*new_handler)();
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) new_handler set_new_handler(new_handler) throw();
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) new_handler get_new_handler() throw();



<span class="gs">__attribute__</span> ((noreturn)) <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void __throw_bad_alloc();






enum align_val_t { <span class="gs">__zero = 0, __</span>max = (size_t)-1 };
}
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void* operator new(std::size_t __sz) throw(std::bad_alloc);
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void* operator new(std::size_t __sz, const std::nothrow_t&amp;) throw() <span class="gs">__attribute__</span>((__malloc__));
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void operator delete(void* __p) throw();
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void operator delete(void* __p, const std::nothrow_t&amp;) throw();




                              <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void* operator new[](std::size_t __sz) throw(std::bad_alloc);
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void* operator new[](std::size_t __sz, const std::nothrow_t&amp;) throw() <span class="gs">__attribute__</span>((__malloc__));
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void operator delete[](void* __p) throw();
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void operator delete[](void* __p, const std::nothrow_t&amp;) throw();





                              <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void* operator new(std::size_t __sz, std::align_val_t) throw(std::bad_alloc);
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&amp;) throw() <span class="gs">__attribute__</span>((__malloc__));
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void operator delete(void* __p, std::align_val_t) throw();
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void operator delete(void* __p, std::align_val_t, const std::nothrow_t&amp;) throw();




                              <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void* operator new[](std::size_t __sz, std::align_val_t) throw(std::bad_alloc);
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&amp;) throw() <span class="gs">__attribute__</span>((__malloc__));
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void operator delete[](void* __p, std::align_val_t) throw();
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void operator delete[](void* __p, std::align_val_t, const std::nothrow_t&amp;) throw();





                              inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void* operator new (std::size_t, void* <span class="gs">__p) throw() {return __</span>p;}
                              inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void* operator new[](std::size_t, void* <span class="gs">__p) throw() {return __</span>p;}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void operator delete (void*, void*) throw() {}
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void operator delete[](void*, void*) throw() {}



namespace std { inline namespace __1 {

                  inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool __is_overaligned_for_new(size_t __align) throw() {

  return __align &gt; 16UL;



}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void *__libcpp_allocate(size_t __size, size_t __align) {
  ((void)__align);




  return __builtin_operator_new(__size);

}

struct _DeallocateCaller {
  static inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  void __do_deallocate_handle_size_align(void *__ptr, size_t __size, size_t __align) {

    ((void)__align);
    return __do_deallocate_handle_size(__ptr, __size);
  }

  static inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  void __do_deallocate_handle_align(void *__ptr, size_t __align) {

    ((void)__align);
    return __do_call(__ptr);
  }

 private:
  static inline void __do_deallocate_handle_size(void *__ptr, size_t __size) {

    ((void)__size);
    return __do_call(__ptr);



  }
private:
  template &lt;class <span class="ge">_A1, class _</span>A2&gt;
  static inline void __do_call(void *__ptr, <span class="ge">_A1 __a1, _</span>A2 __a2) {




    return __builtin_operator_delete(__ptr, <span class="gs">__a1, __</span>a2);

  }

  template &lt;class _A1&gt;
  static inline void __do_call(void *__ptr, <span class="ge">_A1 _</span>_a1) {




    return __builtin_operator_delete(__ptr, __a1);

  }

  static inline void __do_call(void *__ptr) {



    return __builtin_operator_delete(__ptr);

  }
};

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __libcpp_deallocate(void* __ptr, size_t __size, size_t __align) {
  <span class="ge">_DeallocateCaller::__do_</span>deallocate_handle_size_align(__ptr, <span class="gs">__size, __</span>align);
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __libcpp_deallocate_unsized(void* __ptr, size_t __align) {
  <span class="ge">_DeallocateCaller::__do_</span>deallocate_handle_align(__ptr, __align);
}

template &lt;class _Tp&gt;
                              inline
                  <span class="ge">_Tp* __launder(_</span>Tp* __p) throw()
{
    <span class="ge">_Static_</span>assert(!(is_function&lt;_Tp&gt;::value), &quot;can&#39;t launder functions&quot;);
    <span class="ge">_Static_</span>assert(!(is_same&lt;void, typename remove_cv&lt;_Tp&gt;::type&gt;::value), &quot;can&#39;t launder cv-void&quot;);

    return __builtin_launder(__p);



}
} }





namespace std { inline namespace __1 {

template &lt;class <span class="ge">_Arg1, class _</span>Arg2, class _Result&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) binary_function
{
    typedef <span class="ge">_Arg1 first_</span>argument_type;
    typedef <span class="ge">_Arg2 second_</span>argument_type;
    typedef <span class="ge">_Result result_</span>type;
};

template &lt;class _Tp&gt;
struct __has_result_type
{
private:
    struct <span class="gs">__two {char __</span>lx; char __lxx;};
    template &lt;class <span class="ge">_Up&gt; static __two _</span>_test(...);
    template &lt;class <span class="ge">_Up&gt; static char __test(typename _</span>Up::result_type* = 0);
public:
    static const bool value = sizeof(__test&lt;_Tp&gt;(0)) == 1;
};




template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) less : binary_function&lt;_Tp, _Tp, bool&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_Tp&amp; __x, const _</span>Tp&amp; __y) const
        {return <span class="gs">__x &lt; __</span>y;}
};
template &lt;class _Tp&gt;
struct __derives_from_unary_function
{
private:
    struct <span class="gs">__two {char __</span>lx; char __lxx;};
    static <span class="gs">__two __</span>test(...);
    template &lt;class <span class="ge">_Ap, class _</span>Rp&gt;
        static unary_function&lt;_Ap, _Rp&gt;
        __test(const volatile unary_function&lt;_Ap, _Rp&gt;*);
public:
    static const bool value = !is_same&lt;__decltype(__test((_Tp*)0)), __two&gt;::value;
    typedef <span class="gs">__decltype(__</span>test((_Tp*)0)) type;
};

template &lt;class _Tp&gt;
struct __derives_from_binary_function
{
private:
    struct <span class="gs">__two {char __</span>lx; char __lxx;};
    static <span class="gs">__two __</span>test(...);
    template &lt;class <span class="ge">_A1, class _</span>A2, class _Rp&gt;
        static binary_function&lt;_A1, <span class="ge">_A2, _</span>Rp&gt;
        __test(const volatile binary_function&lt;_A1, <span class="ge">_A2, _</span>Rp&gt;*);
public:
    static const bool value = !is_same&lt;__decltype(__test((_Tp*)0)), __two&gt;::value;
    typedef <span class="gs">__decltype(__</span>test((_Tp*)0)) type;
};

template &lt;class <span class="ge">_Tp, bool = __derives_</span>from_unary_function&lt;_Tp&gt;::value&gt;
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function&lt;_Tp&gt;::type
{
};

template &lt;class _Tp&gt;
struct __maybe_derive_from_unary_function&lt;_Tp, false&gt;
{
};

template &lt;class <span class="ge">_Tp, bool = __derives_</span>from_binary_function&lt;_Tp&gt;::value&gt;
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function&lt;_Tp&gt;::type
{
};

template &lt;class _Tp&gt;
struct __maybe_derive_from_binary_function&lt;_Tp, false&gt;
{
};

template &lt;class <span class="ge">_Tp, bool = __has_</span>result_type&lt;_Tp&gt;::value&gt;
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function&lt;_Tp&gt;,
      public __maybe_derive_from_binary_function&lt;_Tp&gt;
{
    typedef typename <span class="ge">_Tp::result_</span>type result_type;
};

template &lt;class _Tp&gt;
struct __weak_result_type_imp&lt;_Tp, false&gt;
    : public __maybe_derive_from_unary_function&lt;_Tp&gt;,
      public __maybe_derive_from_binary_function&lt;_Tp&gt;
{
};

template &lt;class _Tp&gt;
struct __weak_result_type
    : public __weak_result_type_imp&lt;_Tp&gt;
{
};



template &lt;class _Rp&gt;
struct __weak_result_type&lt;_Rp ()&gt;
{
    typedef <span class="ge">_Rp result_</span>type;
};

template &lt;class _Rp&gt;
struct __weak_result_type&lt;_Rp (&amp;)()&gt;
{
    typedef <span class="ge">_Rp result_</span>type;
};

template &lt;class _Rp&gt;
struct __weak_result_type&lt;_Rp (*)()&gt;
{
    typedef <span class="ge">_Rp result_</span>type;
};



template &lt;class <span class="ge">_Rp, class _</span>A1&gt;
struct __weak_result_type&lt;_Rp (_A1)&gt;
    : public unary_function&lt;_A1, _Rp&gt;
{
};

template &lt;class <span class="ge">_Rp, class _</span>A1&gt;
struct __weak_result_type&lt;_Rp (&amp;)(_A1)&gt;
    : public unary_function&lt;_A1, _Rp&gt;
{
};

template &lt;class <span class="ge">_Rp, class _</span>A1&gt;
struct __weak_result_type&lt;_Rp (*)(_A1)&gt;
    : public unary_function&lt;_A1, _Rp&gt;
{
};

template &lt;class <span class="ge">_Rp, class _</span>Cp&gt;
struct __weak_result_type&lt;_Rp (_Cp::*)()&gt;
    : public unary_function&lt;_Cp*, _Rp&gt;
{
};

template &lt;class <span class="ge">_Rp, class _</span>Cp&gt;
struct __weak_result_type&lt;_Rp (_Cp::*)() const&gt;
    : public unary_function&lt;const <span class="ge">_Cp*, _</span>Rp&gt;
{
};

template &lt;class <span class="ge">_Rp, class _</span>Cp&gt;
struct __weak_result_type&lt;_Rp (_Cp::*)() volatile&gt;
    : public unary_function&lt;volatile <span class="ge">_Cp*, _</span>Rp&gt;
{
};

template &lt;class <span class="ge">_Rp, class _</span>Cp&gt;
struct __weak_result_type&lt;_Rp (_Cp::*)() const volatile&gt;
    : public unary_function&lt;const volatile <span class="ge">_Cp*, _</span>Rp&gt;
{
};



template &lt;class <span class="ge">_Rp, class _</span>A1, class _A2&gt;
struct __weak_result_type&lt;_Rp (<span class="ge">_A1, _</span>A2)&gt;
    : public binary_function&lt;_A1, <span class="ge">_A2, _</span>Rp&gt;
{
};

template &lt;class <span class="ge">_Rp, class _</span>A1, class _A2&gt;
struct __weak_result_type&lt;_Rp (*)(_A1, _A2)&gt;
    : public binary_function&lt;_A1, <span class="ge">_A2, _</span>Rp&gt;
{
};

template &lt;class <span class="ge">_Rp, class _</span>A1, class _A2&gt;
struct __weak_result_type&lt;_Rp (&amp;)(_A1, _A2)&gt;
    : public binary_function&lt;_A1, <span class="ge">_A2, _</span>Rp&gt;
{
};

template &lt;class <span class="ge">_Rp, class _</span>Cp, class _A1&gt;
struct __weak_result_type&lt;_Rp (<span class="ge">_Cp::*)(_</span>A1)&gt;
    : public binary_function&lt;_Cp*, <span class="ge">_A1, _</span>Rp&gt;
{
};

template &lt;class <span class="ge">_Rp, class _</span>Cp, class _A1&gt;
struct __weak_result_type&lt;_Rp (<span class="ge">_Cp::*)(_</span>A1) const&gt;
    : public binary_function&lt;const <span class="ge">_Cp*, _</span>A1, _Rp&gt;
{
};

template &lt;class <span class="ge">_Rp, class _</span>Cp, class _A1&gt;
struct __weak_result_type&lt;_Rp (<span class="ge">_Cp::*)(_</span>A1) volatile&gt;
    : public binary_function&lt;volatile <span class="ge">_Cp*, _</span>A1, _Rp&gt;
{
};

template &lt;class <span class="ge">_Rp, class _</span>Cp, class _A1&gt;
struct __weak_result_type&lt;_Rp (<span class="ge">_Cp::*)(_</span>A1) const volatile&gt;
    : public binary_function&lt;const volatile <span class="ge">_Cp*, _</span>A1, _Rp&gt;
{
};
template &lt;class <span class="ge">_Ret, class _</span>T1, bool <span class="ge">_IsFunc, bool _</span>IsBase&gt;
struct __enable_invoke_imp;

template &lt;class <span class="ge">_Ret, class _</span>T1&gt;
struct __enable_invoke_imp&lt;_Ret, _T1, true, true&gt; {
    typedef <span class="ge">_Ret _</span>Bullet1;
    typedef _Bullet1 type;
};

template &lt;class <span class="ge">_Ret, class _</span>T1&gt;
struct __enable_invoke_imp&lt;_Ret, _T1, true, false&gt; {
    typedef <span class="ge">_Ret _</span>Bullet2;
    typedef _Bullet2 type;
};

template &lt;class <span class="ge">_Ret, class _</span>T1&gt;
struct __enable_invoke_imp&lt;_Ret, _T1, false, true&gt; {
    typedef typename add_lvalue_reference&lt;
                typename __apply_cv&lt;_T1, _Ret&gt;::type
            &gt;::type _Bullet3;
    typedef _Bullet3 type;
};

template &lt;class <span class="ge">_Ret, class _</span>T1&gt;
struct __enable_invoke_imp&lt;_Ret, _T1, false, false&gt; {
    typedef typename add_lvalue_reference&lt;
                typename __apply_cv&lt;__decltype(*std::__1::declval&lt;_T1&gt;()), _Ret&gt;::type
            &gt;::type _Bullet4;
    typedef _Bullet4 type;
};

template &lt;class <span class="ge">_Ret, class _</span>T1&gt;
struct __enable_invoke_imp&lt;_Ret, _T1*, false, false&gt; {
    typedef typename add_lvalue_reference&lt;
                typename __apply_cv&lt;_T1, _Ret&gt;::type
            &gt;::type _Bullet4;
    typedef _Bullet4 type;
};

template &lt;class <span class="ge">_Fn, class _</span>T1,
          class <span class="ge">_Traits = __member_</span>pointer_traits&lt;_Fn&gt;,
          class <span class="ge">_Ret = typename _</span>Traits::_ReturnType,
          class <span class="ge">_Class = typename _</span>Traits::_ClassType&gt;
struct __enable_invoke : __enable_invoke_imp&lt;
    <span class="ge">_Ret, _</span>T1,
    is_member_function_pointer&lt;_Fn&gt;::value,
    is_base_of&lt;_Class, typename remove_reference&lt;_T1&gt;::type&gt;::value&gt;
{
};

<span class="gs">__nat __</span>invoke(__any, ...);



template &lt;class <span class="ge">_Fn, class _</span>T1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __enable_invoke&lt;_Fn, <span class="ge">_T1&gt;::_</span>Bullet1
__invoke(_Fn __f, <span class="ge">_T1&amp; _</span>_t1) {
    return (<span class="gs">__t1.*__</span>f)();
}

template &lt;class <span class="ge">_Fn, class _</span>T1, class _A0&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __enable_invoke&lt;_Fn, <span class="ge">_T1&gt;::_</span>Bullet1
__invoke(_Fn __f, <span class="ge">_T1&amp; __t1, _</span>A0&amp; __a0) {
    return (<span class="gs">__t1.*__</span>f)(__a0);
}

template &lt;class <span class="ge">_Fn, class _</span>T1, class <span class="ge">_A0, class _</span>A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __enable_invoke&lt;_Fn, <span class="ge">_T1&gt;::_</span>Bullet1
__invoke(_Fn __f, <span class="ge">_T1&amp; __t1, _</span>A0&amp; __a0, <span class="ge">_A1&amp; _</span>_a1) {
    return (<span class="gs">__t1.*__</span>f)(__a0, __a1);
}

template &lt;class <span class="ge">_Fn, class _</span>T1, class <span class="ge">_A0, class _</span>A1, class _A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __enable_invoke&lt;_Fn, <span class="ge">_T1&gt;::_</span>Bullet1
__invoke(_Fn __f, <span class="ge">_T1&amp; __t1, _</span>A0&amp; __a0, <span class="ge">_A1&amp; __a1, _</span>A2&amp; __a2) {
    return (<span class="gs">__t1.*__</span>f)(__a0, <span class="gs">__a1, __</span>a2);
}

template &lt;class <span class="ge">_Fn, class _</span>T1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __enable_invoke&lt;_Fn, <span class="ge">_T1&gt;::_</span>Bullet2
__invoke(_Fn __f, <span class="ge">_T1&amp; _</span>_t1) {
    return ((*__t1).*__f)();
}

template &lt;class <span class="ge">_Fn, class _</span>T1, class _A0&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __enable_invoke&lt;_Fn, <span class="ge">_T1&gt;::_</span>Bullet2
__invoke(_Fn __f, <span class="ge">_T1&amp; __t1, _</span>A0&amp; __a0) {
    return ((*__t1).*__f)(__a0);
}

template &lt;class <span class="ge">_Fn, class _</span>T1, class <span class="ge">_A0, class _</span>A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __enable_invoke&lt;_Fn, <span class="ge">_T1&gt;::_</span>Bullet2
__invoke(_Fn __f, <span class="ge">_T1&amp; __t1, _</span>A0&amp; __a0, <span class="ge">_A1&amp; _</span>_a1) {
    return ((*__t1).*__f)(__a0, __a1);
}

template &lt;class <span class="ge">_Fn, class _</span>T1, class <span class="ge">_A0, class _</span>A1, class _A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __enable_invoke&lt;_Fn, <span class="ge">_T1&gt;::_</span>Bullet2
__invoke(_Fn __f, <span class="ge">_T1&amp; __t1, _</span>A0&amp; __a0, <span class="ge">_A1&amp; __a1, _</span>A2&amp; __a2) {
    return ((*__t1).*__f)(__a0, <span class="gs">__a1, __</span>a2);
}

template &lt;class <span class="ge">_Fn, class _</span>T1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __enable_invoke&lt;_Fn, <span class="ge">_T1&gt;::_</span>Bullet3
__invoke(_Fn __f, <span class="ge">_T1&amp; _</span>_t1) {
    return <span class="gs">__t1.*__</span>f;
}

template &lt;class <span class="ge">_Fn, class _</span>T1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __enable_invoke&lt;_Fn, <span class="ge">_T1&gt;::_</span>Bullet4
__invoke(_Fn __f, <span class="ge">_T1&amp; _</span>_t1) {
    return (<span class="ge">*__t1).*</span>__f;
}



template &lt;class _Fp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="gs">__decltype(std::__</span>1::declval&lt;_Fp&amp;&gt;()())
__invoke(_Fp&amp; __f)
{
    return __f();
}

template &lt;class <span class="ge">_Fp, class _</span>A0&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="gs">__decltype(std::__</span>1::declval&lt;_Fp&amp;&gt;()(std::__1::declval&lt;_A0&amp;&gt;()))
__invoke(_Fp&amp; __f, <span class="ge">_A0&amp; _</span>_a0)
{
    return <span class="gs">__f(__</span>a0);
}

template &lt;class <span class="ge">_Fp, class _</span>A0, class _A1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="gs">__decltype(std::__</span>1::declval&lt;_Fp&amp;&gt;()(std::__1::declval&lt;_A0&amp;&gt;(), std::__1::declval&lt;_A1&amp;&gt;()))
__invoke(_Fp&amp; __f, <span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1)
{
    return <span class="gs">__f(__</span>a0, __a1);
}

template &lt;class <span class="ge">_Fp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="gs">__decltype(std::__</span>1::declval&lt;_Fp&amp;&gt;()(std::__1::declval&lt;_A0&amp;&gt;(), std::__1::declval&lt;_A1&amp;&gt;(), std::__1::declval&lt;_A2&amp;&gt;()))
__invoke(_Fp&amp; __f, <span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1, <span class="ge">_A2&amp; _</span>_a2)
{
    return <span class="gs">__f(__</span>a0, <span class="gs">__a1, __</span>a2);
}

template &lt;class <span class="ge">_Fp, bool = __has_</span>result_type&lt;__weak_result_type&lt;_Fp&gt; &gt;::value&gt;
struct __invoke_return
{
    typedef typename __weak_result_type&lt;_Fp&gt;::result_type type;
};

template &lt;class _Fp&gt;
struct __invoke_return&lt;_Fp, false&gt;
{
    typedef <span class="gs">__decltype(__</span>invoke(std::__1::declval&lt;_Fp&amp;&gt;())) type;
};

template &lt;class <span class="ge">_Tp, class _</span>A0&gt;
struct __invoke_return0
{
    typedef <span class="gs">__decltype(__</span>invoke(std::__1::declval&lt;_Tp&amp;&gt;(), std::__1::declval&lt;_A0&amp;&gt;())) type;
};

template &lt;class <span class="ge">_Rp, class _</span>Tp, class _A0&gt;
struct __invoke_return0&lt;_Rp <span class="ge">_Tp::*, _</span>A0&gt;
{
    typedef typename __enable_invoke&lt;_Rp <span class="ge">_Tp::*, _</span>A0&gt;::type type;
};

template &lt;class <span class="ge">_Tp, class _</span>A0, class _A1&gt;
struct __invoke_return1
{
    typedef <span class="gs">__decltype(__</span>invoke(std::__1::declval&lt;_Tp&amp;&gt;(), std::__1::declval&lt;_A0&amp;&gt;(), std::__1::declval&lt;_A1&amp;&gt;())) type;

};

template &lt;class <span class="ge">_Rp, class _</span>Class, class <span class="ge">_A0, class _</span>A1&gt;
struct __invoke_return1&lt;_Rp <span class="ge">_Class::*, _</span>A0, _A1&gt; {
    typedef typename __enable_invoke&lt;_Rp <span class="ge">_Class::*, _</span>A0&gt;::type type;
};

template &lt;class <span class="ge">_Tp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
struct __invoke_return2
{
    typedef <span class="gs">__decltype(__</span>invoke(std::__1::declval&lt;_Tp&amp;&gt;(), std::__1::declval&lt;_A0&amp;&gt;(), std::__1::declval&lt;_A1&amp;&gt;(), std::__1::declval&lt;_A2&amp;&gt;())) type;


};

template &lt;class <span class="ge">_Ret, class _</span>Class, class <span class="ge">_A0, class _</span>A1, class _A2&gt;
struct __invoke_return2&lt;_Ret <span class="ge">_Class::*, _</span>A0, <span class="ge">_A1, _</span>A2&gt; {
    typedef typename __enable_invoke&lt;_Ret <span class="ge">_Class::*, _</span>A0&gt;::type type;
};




template &lt;class _Ret&gt;
struct __invoke_void_return_wrapper
{






    template &lt;class _Fn&gt;
    static <span class="ge">_Ret __call(_</span>Fn __f) {
        return <span class="gs">__invoke(__</span>f);
    }

    template &lt;class <span class="ge">_Fn, class _</span>A0&gt;
    static <span class="ge">_Ret __call(_</span>Fn __f, <span class="ge">_A0&amp; _</span>_a0) {
        return <span class="gs">__invoke(__</span>f, __a0);
    }

    template &lt;class <span class="ge">_Fn, class _</span>A0, class _A1&gt;
    static <span class="ge">_Ret __call(_</span>Fn __f, <span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1) {
        return <span class="gs">__invoke(__</span>f, <span class="gs">__a0, __</span>a1);
    }

    template &lt;class <span class="ge">_Fn, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
    static <span class="ge">_Ret __call(_</span>Fn __f, <span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1, <span class="ge">_A2&amp; _</span>_a2){
        return <span class="gs">__invoke(__</span>f, <span class="gs">__a0, __</span>a1, __a2);
    }

};

template &lt;&gt;
struct __invoke_void_return_wrapper&lt;void&gt;
{






    template &lt;class _Fn&gt;
    static void __call(_Fn __f) {
        <span class="gs">__invoke(__</span>f);
    }

    template &lt;class <span class="ge">_Fn, class _</span>A0&gt;
    static void __call(_Fn __f, <span class="ge">_A0&amp; _</span>_a0) {
        <span class="gs">__invoke(__</span>f, __a0);
    }

    template &lt;class <span class="ge">_Fn, class _</span>A0, class _A1&gt;
    static void __call(_Fn __f, <span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1) {
        <span class="gs">__invoke(__</span>f, <span class="gs">__a0, __</span>a1);
    }

    template &lt;class <span class="ge">_Fn, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
    static void __call(_Fn __f, <span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1, <span class="ge">_A2&amp; _</span>_a2) {
        <span class="gs">__invoke(__</span>f, <span class="gs">__a0, __</span>a1, __a2);
    }

};

template &lt;class _Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) reference_wrapper
    : public __weak_result_type&lt;_Tp&gt;
{
public:

    typedef _Tp type;
private:
    type* __f_;

public:

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) reference_wrapper(type&amp; __f) throw()
        : __f_(std::__1::addressof(__f)) {}





    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) operator type&amp; () const throw() {return *__f_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) type&amp; get() const throw() {return *__f_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return&lt;type&gt;::type
    operator() () const {
        return __invoke(get());
    }

    template &lt;class _A0&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return0&lt;type, _A0&gt;::type
    operator() (<span class="ge">_A0&amp; _</span>_a0) const {
        return <span class="gs">__invoke(get(), __</span>a0);
    }

    template &lt;class _A0&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return0&lt;type, _A0 const&gt;::type
    operator() (<span class="ge">_A0 const&amp; _</span>_a0) const {
        return <span class="gs">__invoke(get(), __</span>a0);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return1&lt;type, <span class="ge">_A0, _</span>A1&gt;::type
    operator() (<span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1) const {
        return <span class="gs">__invoke(get(), __</span>a0, __a1);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return1&lt;type, <span class="ge">_A0 const, _</span>A1&gt;::type
    operator() (<span class="ge">_A0 const&amp; __a0, _</span>A1&amp; __a1) const {
        return <span class="gs">__invoke(get(), __</span>a0, __a1);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return1&lt;type, <span class="ge">_A0, _</span>A1 const&gt;::type
    operator() (<span class="ge">_A0&amp; __a0, _</span>A1 const&amp; __a1) const {
        return <span class="gs">__invoke(get(), __</span>a0, __a1);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return1&lt;type, <span class="ge">_A0 const, _</span>A1 const&gt;::type
    operator() (<span class="ge">_A0 const&amp; __a0, _</span>A1 const&amp; __a1) const {
        return <span class="gs">__invoke(get(), __</span>a0, __a1);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0, _</span>A1, _A2&gt;::type
    operator() (<span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1, <span class="ge">_A2&amp; _</span>_a2) const {
        return <span class="gs">__invoke(get(), __</span>a0, <span class="gs">__a1, __</span>a2);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0 const, _</span>A1, _A2&gt;::type
    operator() (<span class="ge">_A0 const&amp; __a0, _</span>A1&amp; __a1, <span class="ge">_A2&amp; _</span>_a2) const {
        return <span class="gs">__invoke(get(), __</span>a0, <span class="gs">__a1, __</span>a2);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0, _</span>A1 const, _A2&gt;::type
    operator() (<span class="ge">_A0&amp; __a0, _</span>A1 const&amp; __a1, <span class="ge">_A2&amp; _</span>_a2) const {
        return <span class="gs">__invoke(get(), __</span>a0, <span class="gs">__a1, __</span>a2);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0, _</span>A1, _A2 const&gt;::type
    operator() (<span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1, <span class="ge">_A2 const&amp; _</span>_a2) const {
        return <span class="gs">__invoke(get(), __</span>a0, <span class="gs">__a1, __</span>a2);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0 const, _</span>A1 const, _A2&gt;::type
    operator() (<span class="ge">_A0 const&amp; __a0, _</span>A1 const&amp; __a1, <span class="ge">_A2&amp; _</span>_a2) const {
        return <span class="gs">__invoke(get(), __</span>a0, <span class="gs">__a1, __</span>a2);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0 const, _</span>A1, _A2 const&gt;::type
    operator() (<span class="ge">_A0 const&amp; __a0, _</span>A1&amp; __a1, <span class="ge">_A2 const&amp; _</span>_a2) const {
        return <span class="gs">__invoke(get(), __</span>a0, <span class="gs">__a1, __</span>a2);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0, _</span>A1 const, _A2 const&gt;::type
    operator() (<span class="ge">_A0&amp; __a0, _</span>A1 const&amp; __a1, <span class="ge">_A2 const&amp; _</span>_a2) const {
        return <span class="gs">__invoke(get(), __</span>a0, <span class="gs">__a1, __</span>a2);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0 const, _</span>A1 const, _A2 const&gt;::type
    operator() (<span class="ge">_A0 const&amp; __a0, _</span>A1 const&amp; __a1, <span class="ge">_A2 const&amp; _</span>_a2) const {
        return <span class="gs">__invoke(get(), __</span>a0, <span class="gs">__a1, __</span>a2);
    }

};


template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
reference_wrapper&lt;_Tp&gt;
ref(_Tp&amp; __t) throw()
{
    return reference_wrapper&lt;_Tp&gt;(__t);
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
reference_wrapper&lt;_Tp&gt;
ref(reference_wrapper&lt;_Tp&gt; __t) throw()
{
    return ref(__t.get());
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
reference_wrapper&lt;const _Tp&gt;
cref(const <span class="ge">_Tp&amp; _</span>_t) throw()
{
    return reference_wrapper&lt;const <span class="ge">_Tp&gt;(_</span>_t);
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
reference_wrapper&lt;const _Tp&gt;
cref(reference_wrapper&lt;_Tp&gt; __t) throw()
{
    return cref(__t.get());
}
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) allocator_arg_t { explicit allocator_arg_t() = default; };


extern <span class="gs">__attribute__</span>((__visibility__(&quot;default&quot;))) const allocator_arg_t allocator_arg;






template &lt;class _Tp&gt;
struct __has_allocator_type
{
private:
    struct <span class="gs">__two {char __</span>lx; char __lxx;};
    template &lt;class <span class="ge">_Up&gt; static __two _</span>_test(...);
    template &lt;class <span class="ge">_Up&gt; static char __test(typename _</span>Up::allocator_type* = 0);
public:
    static const bool value = sizeof(__test&lt;_Tp&gt;(0)) == 1;
};

template &lt;class <span class="ge">_Tp, class _</span>Alloc, bool = __has_allocator_type&lt;_Tp&gt;::value&gt;
struct __uses_allocator
    : public integral_constant&lt;bool,
        is_convertible&lt;_Alloc, typename <span class="ge">_Tp::allocator_</span>type&gt;::value&gt;
{
};

template &lt;class <span class="ge">_Tp, class _</span>Alloc&gt;
struct __uses_allocator&lt;_Tp, _Alloc, false&gt;
    : public false_type
{
};

template &lt;class <span class="ge">_Tp, class _</span>Alloc&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) uses_allocator
    : public __uses_allocator&lt;_Tp, _Alloc&gt;
{
};
} }


namespace std { inline namespace __1 {
template &lt;class _Iter&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) iterator_traits;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) input_iterator_tag {};
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) output_iterator_tag {};
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) forward_iterator_tag : public input_iterator_tag {};
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) bidirectional_iterator_tag : public forward_iterator_tag {};
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) random_access_iterator_tag : public bidirectional_iterator_tag {};






template &lt;class _Iter&gt;
struct __iter_traits_cache {
  using type = _If&lt;
    __is_primary_template&lt;iterator_traits&lt;_Iter&gt; &gt;::value,
    _Iter,
    iterator_traits&lt;_Iter&gt;
  &gt;;
};
template &lt;class _Iter&gt;
using <span class="ge">_ITER_</span>TRAITS = typename __iter_traits_cache&lt;_Iter&gt;::type;

struct __iter_concept_concept_test {
  template &lt;class _Iter&gt;
  using <span class="ge">_Apply = typename _</span>ITER_TRAITS&lt;_Iter&gt;::iterator_concept;
};
struct __iter_concept_category_test {
  template &lt;class _Iter&gt;
  using <span class="ge">_Apply = typename _</span>ITER_TRAITS&lt;_Iter&gt;::iterator_category;
};
struct __iter_concept_random_fallback {
  template &lt;class _Iter&gt;
  using <span class="ge">_Apply = _</span>EnableIf&lt;
                          __is_primary_template&lt;iterator_traits&lt;_Iter&gt; &gt;::value,
                          random_access_iterator_tag
                        &gt;;
};

template &lt;class <span class="ge">_Iter, class _</span>Tester&gt; struct __test_iter_concept
    : <span class="ge">_IsValidExpansion&lt;_</span>Tester::template <span class="ge">_Apply, _</span>Iter&gt;,
      _Tester
{
};

template &lt;class _Iter&gt;
struct __iter_concept_cache {
  using type = _Or&lt;
    __test_iter_concept&lt;_Iter, __iter_concept_concept_test&gt;,
    __test_iter_concept&lt;_Iter, __iter_concept_category_test&gt;,
    __test_iter_concept&lt;_Iter, __iter_concept_random_fallback&gt;
  &gt;;
};

template &lt;class _Iter&gt;
using <span class="ge">_ITER_</span>CONCEPT = typename __iter_concept_cache&lt;_Iter&gt;::type::template <span class="ge">_Apply&lt;_</span>Iter&gt;;


template &lt;class _Tp&gt;
struct __has_iterator_typedefs
{
private:
    struct <span class="gs">__two {char __</span>lx; char __lxx;};
    template &lt;class <span class="ge">_Up&gt; static __two _</span>_test(...);
    template &lt;class <span class="ge">_Up&gt; static char __test(typename std::__void_</span>t&lt;typename <span class="ge">_Up::iterator_</span>category&gt;::type* = 0,
              typename std::__void_t&lt;typename <span class="ge">_Up::difference_</span>type&gt;::type* = 0,
              typename std::__void_t&lt;typename <span class="ge">_Up::value_</span>type&gt;::type* = 0,
              typename std::__void_t&lt;typename _Up::reference&gt;::type* = 0,
              typename std::__void_t&lt;typename _Up::pointer&gt;::type* = 0
              );
public:
    static const bool value = sizeof(__test&lt;_Tp&gt;(0,0,0,0,0)) == 1;
};


template &lt;class _Tp&gt;
struct __has_iterator_category
{
private:
    struct <span class="gs">__two {char __</span>lx; char __lxx;};
    template &lt;class <span class="ge">_Up&gt; static __two _</span>_test(...);
    template &lt;class <span class="ge">_Up&gt; static char __test(typename _</span>Up::iterator_category* = 0);
public:
    static const bool value = sizeof(__test&lt;_Tp&gt;(0)) == 1;
};

template &lt;class <span class="ge">_Iter, bool&gt; struct __iterator_</span>traits_impl {};

template &lt;class _Iter&gt;
struct __iterator_traits_impl&lt;_Iter, true&gt;
{
    typedef typename <span class="ge">_Iter::difference_</span>type difference_type;
    typedef typename <span class="ge">_Iter::value_</span>type value_type;
    typedef typename _Iter::pointer pointer;
    typedef typename _Iter::reference reference;
    typedef typename <span class="ge">_Iter::iterator_</span>category iterator_category;
};

template &lt;class <span class="ge">_Iter, bool&gt; struct __iterator_</span>traits {};

template &lt;class _Iter&gt;
struct __iterator_traits&lt;_Iter, true&gt;
    : __iterator_traits_impl
      &lt;
        _Iter,
        is_convertible&lt;typename <span class="ge">_Iter::iterator_</span>category, input_iterator_tag&gt;::value ||
        is_convertible&lt;typename <span class="ge">_Iter::iterator_</span>category, output_iterator_tag&gt;::value
<span class="k">      &gt;</span>
<span class="ge">{};</span>






template &lt;class _Iter&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) iterator_traits
    : __iterator_traits&lt;_Iter, __has_iterator_typedefs&lt;_Iter&gt;::value&gt; {

  using __primary_template = iterator_traits;
};

template&lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) iterator_traits&lt;_Tp*&gt;
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_cv&lt;_Tp&gt;::type value_type;
    typedef _Tp* pointer;
    typedef _Tp&amp; reference;
    typedef random_access_iterator_tag iterator_category;



};

template &lt;class <span class="ge">_Tp, class _</span>Up, bool = __has_iterator_category&lt;iterator_traits&lt;_Tp&gt; &gt;::value&gt;
struct __has_iterator_category_convertible_to
    : public integral_constant&lt;bool, is_convertible&lt;typename iterator_traits&lt;_Tp&gt;::iterator_category, _Up&gt;::value&gt;
{};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __has_iterator_category_convertible_to&lt;_Tp, <span class="ge">_Up, false&gt; : public false_</span>type {};

template &lt;class _Tp&gt;
struct __is_cpp17_input_iterator : public __has_iterator_category_convertible_to&lt;_Tp, input_iterator_tag&gt; {};

template &lt;class _Tp&gt;
struct __is_cpp17_forward_iterator : public __has_iterator_category_convertible_to&lt;_Tp, forward_iterator_tag&gt; {};

template &lt;class _Tp&gt;
struct __is_cpp17_bidirectional_iterator : public __has_iterator_category_convertible_to&lt;_Tp, bidirectional_iterator_tag&gt; {};

template &lt;class _Tp&gt;
struct __is_cpp17_random_access_iterator : public __has_iterator_category_convertible_to&lt;_Tp, random_access_iterator_tag&gt; {};





template &lt;class _Tp&gt;
struct __is_cpp17_contiguous_iterator : public false_type {};



template &lt;class _Tp&gt;
struct __is_exactly_cpp17_input_iterator
    : public integral_constant&lt;bool,
         __has_iterator_category_convertible_to&lt;_Tp, input_iterator_tag&gt;::value &amp;&amp;
        !__has_iterator_category_convertible_to&lt;_Tp, forward_iterator_tag&gt;::value&gt; {};
template&lt;class <span class="ge">_Category, class _</span>Tp, class <span class="ge">_Distance = ptrdiff_</span>t,
         class <span class="ge">_Pointer = _</span>Tp*, class <span class="ge">_Reference = _</span>Tp&amp;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) iterator
{
    typedef <span class="ge">_Tp value_</span>type;
    typedef <span class="ge">_Distance difference_</span>type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef <span class="ge">_Category iterator_</span>category;
};

template &lt;class _InputIter&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __advance(_InputIter&amp; __i,
             typename iterator_traits&lt;_InputIter&gt;::difference_type __n, input_iterator_tag)
{
    for (; <span class="gs">__n &gt; 0; --__</span>n)
        ++__i;
}

template &lt;class _BiDirIter&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __advance(_BiDirIter&amp; __i,
             typename iterator_traits&lt;_BiDirIter&gt;::difference_type __n, bidirectional_iterator_tag)
{
    if (__n &gt;= 0)
        for (; <span class="gs">__n &gt; 0; --__</span>n)
            ++__i;
    else
        for (; <span class="gs">__n &lt; 0; ++__</span>n)
            --__i;
}

template &lt;class _RandIter&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __advance(_RandIter&amp; __i,
             typename iterator_traits&lt;_RandIter&gt;::difference_type __n, random_access_iterator_tag)
{
   <span class="gs">__i += __</span>n;
}

template &lt;class _InputIter&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void advance(_InputIter&amp; __i,
             typename iterator_traits&lt;_InputIter&gt;::difference_type __n)
{
    ((void)0);

    <span class="gs">__advance(__</span>i, __n, typename iterator_traits&lt;_InputIter&gt;::iterator_category());
}

template &lt;class _InputIter&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename iterator_traits&lt;_InputIter&gt;::difference_type
__distance(_InputIter __first, <span class="ge">_InputIter __last, input_</span>iterator_tag)
{
    typename iterator_traits&lt;_InputIter&gt;::difference_type __r(0);
    for (; <span class="gs">__first != __</span>last; ++__first)
        ++__r;
    return __r;
}

template &lt;class _RandIter&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename iterator_traits&lt;_RandIter&gt;::difference_type
__distance(_RandIter __first, <span class="ge">_RandIter __last, random_</span>access_iterator_tag)
{
    return <span class="gs">__last - __</span>first;
}

template &lt;class _InputIter&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename iterator_traits&lt;_InputIter&gt;::difference_type
distance(_InputIter __first, <span class="ge">_InputIter _</span>_last)
{
    return <span class="gs">__distance(__</span>first, __last, typename iterator_traits&lt;_InputIter&gt;::iterator_category());
}

template &lt;class _InputIter&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    __is_cpp17_input_iterator&lt;_InputIter&gt;::value,
    _InputIter
&gt;::type
next(_InputIter __x,
     typename iterator_traits&lt;_InputIter&gt;::difference_type __n = 1)
{
    ((void)0);


    std::__1::advance(__x, __n);
    return __x;
}

template &lt;class _InputIter&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    __is_cpp17_input_iterator&lt;_InputIter&gt;::value,
    _InputIter
&gt;::type
prev(_InputIter __x,
     typename iterator_traits&lt;_InputIter&gt;::difference_type __n = 1)
{
    ((void)0);

    std::__1::advance(__x, -__n);
    return __x;
}


template &lt;class _Tp, class = void&gt;
struct __is_stashing_iterator : false_type {};

template &lt;class _Tp&gt;
struct __is_stashing_iterator&lt;_Tp, typename __void_t&lt;typename <span class="ge">_Tp::__stashing_</span>iterator_tag&gt;::type&gt;
  : true_type {};

template &lt;class _Iter&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) reverse_iterator
    : public iterator&lt;typename iterator_traits&lt;_Iter&gt;::iterator_category,
                      typename iterator_traits&lt;_Iter&gt;::value_type,
                      typename iterator_traits&lt;_Iter&gt;::difference_type,
                      typename iterator_traits&lt;_Iter&gt;::pointer,
                      typename iterator_traits&lt;_Iter&gt;::reference&gt;
{
private:
                <span class="ge">_Iter _</span>_t;

    <span class="ge">_Static_</span>assert(!__is_stashing_iterator&lt;_Iter&gt;::value, &quot;The specified iterator type cannot be used with reverse_iterator; &quot; &quot;Using stashing iterators with reverse_iterator causes undefined behavior&quot;);



protected:
    _Iter current;
public:
    typedef <span class="ge">_Iter iterator_</span>type;
    typedef typename iterator_traits&lt;_Iter&gt;::difference_type difference_type;
    typedef typename iterator_traits&lt;_Iter&gt;::reference reference;
    typedef typename iterator_traits&lt;_Iter&gt;::pointer pointer;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reverse_iterator() : __t(), current() {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit reverse_iterator(_Iter <span class="gs">__x) : __</span>t(__x), current(__x) {}
    template &lt;class _Up&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        reverse_iterator(const reverse_iterator&lt;_Up&gt;&amp; <span class="gs">__u) : __</span>t(__u.base()), current(__u.base()) {}
    template &lt;class _Up&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        reverse_iterator&amp; operator=(const reverse_iterator&lt;_Up&gt;&amp; __u)
            { <span class="gs">__t = current = __</span>u.base(); return *this; }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    _Iter base() const {return current;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reference operator*() const {<span class="ge">_Iter __tmp = current; return *--_</span>_tmp;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pointer operator-&gt;() const {return std::__1::addressof(operator*());}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reverse_iterator&amp; operator++() {--current; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reverse_iterator operator++(int) {reverse_iterator <span class="gs">__tmp(*this); --current; return __</span>tmp;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reverse_iterator&amp; operator--() {++current; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reverse_iterator operator--(int) {reverse_iterator <span class="gs">__tmp(*this); ++current; return __</span>tmp;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reverse_iterator operator+ (difference_type __n) const {return reverse_iterator(current - __n);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reverse_iterator&amp; operator+=(difference_type <span class="gs">__n) {current -= __</span>n; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reverse_iterator operator- (difference_type __n) const {return reverse_iterator(current + __n);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reverse_iterator&amp; operator-=(difference_type <span class="gs">__n) {current += __</span>n; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reference operator[](difference_type <span class="gs">__n) const {return *(*this + __</span>n);}
};

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const reverse_iterator&lt;_Iter1&gt;&amp; __x, const reverse_iterator&lt;_Iter2&gt;&amp; __y)
{
    return <span class="gs">__x.base() == __</span>y.base();
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;(const reverse_iterator&lt;_Iter1&gt;&amp; __x, const reverse_iterator&lt;_Iter2&gt;&amp; __y)
{
    return <span class="gs">__x.base() &gt; __</span>y.base();
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const reverse_iterator&lt;_Iter1&gt;&amp; __x, const reverse_iterator&lt;_Iter2&gt;&amp; __y)
{
    return <span class="gs">__x.base() != __</span>y.base();
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;(const reverse_iterator&lt;_Iter1&gt;&amp; __x, const reverse_iterator&lt;_Iter2&gt;&amp; __y)
{
    return <span class="gs">__x.base() &lt; __</span>y.base();
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const reverse_iterator&lt;_Iter1&gt;&amp; __x, const reverse_iterator&lt;_Iter2&gt;&amp; __y)
{
    return <span class="gs">__x.base() &lt;= __</span>y.base();
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const reverse_iterator&lt;_Iter1&gt;&amp; __x, const reverse_iterator&lt;_Iter2&gt;&amp; __y)
{
    return <span class="gs">__x.base() &gt;= __</span>y.base();
}
template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename reverse_iterator&lt;_Iter1&gt;::difference_type
operator-(const reverse_iterator&lt;_Iter1&gt;&amp; __x, const reverse_iterator&lt;_Iter2&gt;&amp; __y)
{
    return <span class="gs">__y.base() - __</span>x.base();
}


template &lt;class _Iter&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
reverse_iterator&lt;_Iter&gt;
operator+(typename reverse_iterator&lt;_Iter&gt;::difference_type __n, const reverse_iterator&lt;_Iter&gt;&amp; __x)
{
    return reverse_iterator&lt;_Iter&gt;(__x.base() - __n);
}
template &lt;class _Container&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) back_insert_iterator
    : public iterator&lt;output_iterator_tag,
                      void,
                      void,
                      void,
                      void&gt;
{
protected:
    _Container* container;
public:
    typedef <span class="ge">_Container container_</span>type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit back_insert_iterator(_Container&amp; <span class="gs">__x) : container(std::__</span>1::addressof(__x)) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) back_insert_iterator&amp; operator=(const typename <span class="ge">_Container::value_</span>type&amp; __value_)
        {container-&gt;push_back(__value_); return *this;}




    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) back_insert_iterator&amp; operator*() {return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) back_insert_iterator&amp; operator++() {return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) back_insert_iterator operator++(int) {return *this;}
};

template &lt;class _Container&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
back_insert_iterator&lt;_Container&gt;
back_inserter(_Container&amp; __x)
{
    return back_insert_iterator&lt;_Container&gt;(__x);
}

template &lt;class _Container&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) front_insert_iterator
    : public iterator&lt;output_iterator_tag,
                      void,
                      void,
                      void,
                      void&gt;
{
protected:
    _Container* container;
public:
    typedef <span class="ge">_Container container_</span>type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit front_insert_iterator(_Container&amp; <span class="gs">__x) : container(std::__</span>1::addressof(__x)) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) front_insert_iterator&amp; operator=(const typename <span class="ge">_Container::value_</span>type&amp; __value_)
        {container-&gt;push_front(__value_); return *this;}




    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) front_insert_iterator&amp; operator*() {return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) front_insert_iterator&amp; operator++() {return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) front_insert_iterator operator++(int) {return *this;}
};

template &lt;class _Container&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
front_insert_iterator&lt;_Container&gt;
front_inserter(_Container&amp; __x)
{
    return front_insert_iterator&lt;_Container&gt;(__x);
}

template &lt;class _Container&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) insert_iterator
    : public iterator&lt;output_iterator_tag,
                      void,
                      void,
                      void,
                      void&gt;
{
protected:
    _Container* container;
    typename _Container::iterator iter;
public:
    typedef <span class="ge">_Container container_</span>type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) insert_iterator(_Container&amp; __x, typename <span class="ge">_Container::iterator _</span>_i)
        : container(std::__1::addressof(__x)), iter(__i) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) insert_iterator&amp; operator=(const typename <span class="ge">_Container::value_</span>type&amp; __value_)
        {iter = container-&gt;insert(iter, __value_); ++iter; return *this;}




    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) insert_iterator&amp; operator*() {return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) insert_iterator&amp; operator++() {return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) insert_iterator&amp; operator++(int) {return *this;}
};

template &lt;class _Container&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
insert_iterator&lt;_Container&gt;
inserter(_Container&amp; __x, typename <span class="ge">_Container::iterator _</span>_i)
{
    return insert_iterator&lt;_Container&gt;(__x, __i);
}

template &lt;class <span class="ge">_Tp, class _</span>CharT = char,
          class <span class="ge">_Traits = char_</span>traits&lt;_CharT&gt;, class <span class="ge">_Distance = ptrdiff_</span>t&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) istream_iterator
    : public iterator&lt;input_iterator_tag, <span class="ge">_Tp, _</span>Distance, const <span class="ge">_Tp*, const _</span>Tp&amp;&gt;
{
public:
    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_Traits traits_</span>type;
    typedef basic_istream&lt;_CharT,_Traits&gt; istream_type;
private:
    istream_type* __in_stream_;
    <span class="ge">_Tp __value_</span>;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) istream_iterator() : __in_stream_(0), __value_() {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) istream_iterator(istream_type&amp; <span class="gs">__s) : __</span>in_stream_(std::__1::addressof(__s))
        {
            if (!(*__in_stream_ &gt;&gt; __value_))
                __in_stream_ = 0;
        }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) const <span class="ge">_Tp&amp; operator*() const {return __value_</span>;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) const <span class="ge">_Tp* operator-&gt;() const {return std::_</span>_1::addressof((operator*()));}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) istream_iterator&amp; operator++()
        {
            if (!(*__in_stream_ &gt;&gt; __value_))
                __in_stream_ = 0;
            return *this;
        }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) istream_iterator operator++(int)
        {istream_iterator <span class="gs">__t(*this); ++(*this); return __</span>t;}

    template &lt;class <span class="ge">_Up, class _</span>CharU, class <span class="ge">_TraitsU, class _</span>DistanceU&gt;
    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool
    operator==(const istream_iterator&lt;_Up, <span class="ge">_CharU, _</span>TraitsU, <span class="ge">_DistanceU&gt;&amp; _</span>_x,
               const istream_iterator&lt;_Up, <span class="ge">_CharU, _</span>TraitsU, <span class="ge">_DistanceU&gt;&amp; _</span>_y);

    template &lt;class <span class="ge">_Up, class _</span>CharU, class <span class="ge">_TraitsU, class _</span>DistanceU&gt;
    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool
    operator==(const istream_iterator&lt;_Up, <span class="ge">_CharU, _</span>TraitsU, <span class="ge">_DistanceU&gt;&amp; _</span>_x,
               const istream_iterator&lt;_Up, <span class="ge">_CharU, _</span>TraitsU, <span class="ge">_DistanceU&gt;&amp; _</span>_y);
};

template &lt;class <span class="ge">_Tp, class _</span>CharT, class <span class="ge">_Traits, class _</span>Distance&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const istream_iterator&lt;_Tp, <span class="ge">_CharT, _</span>Traits, <span class="ge">_Distance&gt;&amp; _</span>_x,
           const istream_iterator&lt;_Tp, <span class="ge">_CharT, _</span>Traits, <span class="ge">_Distance&gt;&amp; _</span>_y)
{
    return <span class="gs">__x.__</span>in_stream_ == <span class="gs">__y.__</span>in_stream_;
}

template &lt;class <span class="ge">_Tp, class _</span>CharT, class <span class="ge">_Traits, class _</span>Distance&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const istream_iterator&lt;_Tp, <span class="ge">_CharT, _</span>Traits, <span class="ge">_Distance&gt;&amp; _</span>_x,
           const istream_iterator&lt;_Tp, <span class="ge">_CharT, _</span>Traits, <span class="ge">_Distance&gt;&amp; _</span>_y)
{
    return !(__x == __y);
}

template &lt;class <span class="ge">_Tp, class _</span>CharT = char, class <span class="ge">_Traits = char_</span>traits&lt;_CharT&gt; &gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) ostream_iterator
    : public iterator&lt;output_iterator_tag, void, void, void, void&gt;
{
public:
    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_Traits traits_</span>type;
    typedef basic_ostream&lt;_CharT,_Traits&gt; ostream_type;
private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ostream_iterator(ostream_type&amp; __s) throw()
        : __out_stream_(std::__1::addressof(__s)), __delim_(0) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ostream_iterator(ostream_type&amp; __s, const <span class="ge">_CharT* _</span>_delimiter) throw()
        : __out_stream_(std::__1::addressof(__s)), __delim_(__delimiter) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ostream_iterator&amp; operator=(const <span class="ge">_Tp&amp; __value_</span>)
        {
            *__out_stream_ &lt;&lt; __value_;
            if (__delim_)
                *__out_stream_ &lt;&lt; __delim_;
            return *this;
        }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ostream_iterator&amp; operator*() {return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ostream_iterator&amp; operator++() {return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ostream_iterator&amp; operator++(int) {return *this;}
};

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) istreambuf_iterator
    : public iterator&lt;input_iterator_tag, _CharT,
                      typename <span class="ge">_Traits::off_</span>type, _CharT*,
                      _CharT&gt;
{
public:
    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_Traits traits_</span>type;
    typedef typename <span class="ge">_Traits::int_</span>type int_type;
    typedef basic_streambuf&lt;_CharT,_Traits&gt; streambuf_type;
    typedef basic_istream&lt;_CharT,_Traits&gt; istream_type;
private:
    mutable streambuf_type* __sbuf_;

    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) char_type operator*() const {return __keep_;}
    };

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool __test_for_eof() const
    {
        if (__sbuf_ &amp;&amp; traits_type::eq_int_type(__sbuf_-&gt;sgetc(), traits_type::eof()))
            __sbuf_ = 0;
        return __sbuf_ == 0;
    }
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) istreambuf_iterator() throw() : __sbuf_(0) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) istreambuf_iterator(istream_type&amp; __s) throw()
        : __sbuf_(__s.rdbuf()) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) istreambuf_iterator(streambuf_type* __s) throw()
        : __sbuf_(__s) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) istreambuf_iterator(const <span class="gs">__proxy&amp; __</span>p) throw()
        : __sbuf_(__p.__sbuf_) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) char_type operator*() const
        {return static_cast&lt;char_type&gt;(__sbuf_-&gt;sgetc());}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) istreambuf_iterator&amp; operator++()
        {
            __sbuf_-&gt;sbumpc();
            return *this;
        }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __proxy operator++(int)
        {
            return <span class="gs">__proxy(__</span>sbuf_-&gt;sbumpc(), __sbuf_);
        }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool equal(const istreambuf_iterator&amp; __b) const
        {return __test_for_eof() == <span class="gs">__b.__</span>test_for_eof();}
};

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator==(const istreambuf_iterator&lt;_CharT,_Traits&gt;&amp; __a,
                const istreambuf_iterator&lt;_CharT,_Traits&gt;&amp; __b)
                {return <span class="gs">__a.equal(__</span>b);}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator!=(const istreambuf_iterator&lt;_CharT,_Traits&gt;&amp; __a,
                const istreambuf_iterator&lt;_CharT,_Traits&gt;&amp; __b)
                {return !<span class="gs">__a.equal(__</span>b);}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) ostreambuf_iterator
    : public iterator&lt;output_iterator_tag, void, void, void, void&gt;
{
public:
    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_Traits traits_</span>type;
    typedef basic_streambuf&lt;_CharT,_Traits&gt; streambuf_type;
    typedef basic_ostream&lt;_CharT,_Traits&gt; ostream_type;
private:
    streambuf_type* __sbuf_;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ostreambuf_iterator(ostream_type&amp; __s) throw()
        : __sbuf_(__s.rdbuf()) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ostreambuf_iterator(streambuf_type* __s) throw()
        : __sbuf_(__s) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ostreambuf_iterator&amp; operator=(_CharT __c)
        {
            if (__sbuf_ &amp;&amp; traits_type::eq_int_type(__sbuf_-&gt;sputc(__c), traits_type::eof()))
                __sbuf_ = 0;
            return *this;
        }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ostreambuf_iterator&amp; operator*() {return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ostreambuf_iterator&amp; operator++() {return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ostreambuf_iterator&amp; operator++(int) {return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool failed() const throw() {return __sbuf_ == 0;}

    template &lt;class <span class="ge">_Ch, class _</span>Tr&gt;
    friend
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    ostreambuf_iterator&lt;_Ch, _Tr&gt;
    __pad_and_output(ostreambuf_iterator&lt;_Ch, <span class="ge">_Tr&gt; _</span>_s,
                     const <span class="ge">_Ch* __ob, const _</span>Ch* __op, const <span class="ge">_Ch* _</span>_oe,
                     ios_base&amp; __iob, <span class="ge">_Ch _</span>_fl);
};

template &lt;class _Iter&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) move_iterator
{
private:
    <span class="ge">_Iter _</span>_i;
public:
    typedef <span class="ge">_Iter iterator_</span>type;
    typedef typename iterator_traits&lt;iterator_type&gt;::iterator_category iterator_category;
    typedef typename iterator_traits&lt;iterator_type&gt;::value_type value_type;
    typedef typename iterator_traits&lt;iterator_type&gt;::difference_type difference_type;
    typedef iterator_type pointer;
    typedef typename iterator_traits&lt;iterator_type&gt;::reference reference;


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    move_iterator() : __i() {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit move_iterator(_Iter <span class="gs">__x) : __</span>i(__x) {}
    template &lt;class _Up&gt;
      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
      move_iterator(const move_iterator&lt;_Up&gt;&amp; <span class="gs">__u) : __</span>i(__u.base()) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="ge">_Iter base() const {return _</span>_i;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reference operator*() const { return static_cast&lt;reference&gt;(*__i); }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pointer operator-&gt;() const { return __i;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    move_iterator&amp; operator++() {++__i; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    move_iterator operator++(int) {move_iterator <span class="gs">__tmp(*this); ++__</span>i; return __tmp;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    move_iterator&amp; operator--() {--__i; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    move_iterator operator--(int) {move_iterator <span class="gs">__tmp(*this); --__</span>i; return __tmp;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    move_iterator operator+ (difference_type __n) const {return move_iterator(__i + __n);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    move_iterator&amp; operator+=(difference_type <span class="gs">__n) {__</span>i += __n; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    move_iterator operator- (difference_type __n) const {return move_iterator(__i - __n);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    move_iterator&amp; operator-=(difference_type <span class="gs">__n) {__</span>i -= __n; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reference operator[](difference_type __n) const { return static_cast&lt;reference&gt;(__i[__n]); }
};

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const move_iterator&lt;_Iter1&gt;&amp; __x, const move_iterator&lt;_Iter2&gt;&amp; __y)
{
    return <span class="gs">__x.base() == __</span>y.base();
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;(const move_iterator&lt;_Iter1&gt;&amp; __x, const move_iterator&lt;_Iter2&gt;&amp; __y)
{
    return <span class="gs">__x.base() &lt; __</span>y.base();
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const move_iterator&lt;_Iter1&gt;&amp; __x, const move_iterator&lt;_Iter2&gt;&amp; __y)
{
    return <span class="gs">__x.base() != __</span>y.base();
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;(const move_iterator&lt;_Iter1&gt;&amp; __x, const move_iterator&lt;_Iter2&gt;&amp; __y)
{
    return <span class="gs">__x.base() &gt; __</span>y.base();
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const move_iterator&lt;_Iter1&gt;&amp; __x, const move_iterator&lt;_Iter2&gt;&amp; __y)
{
    return <span class="gs">__x.base() &gt;= __</span>y.base();
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const move_iterator&lt;_Iter1&gt;&amp; __x, const move_iterator&lt;_Iter2&gt;&amp; __y)
{
    return <span class="gs">__x.base() &lt;= __</span>y.base();
}
template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename move_iterator&lt;_Iter1&gt;::difference_type
operator-(const move_iterator&lt;_Iter1&gt;&amp; __x, const move_iterator&lt;_Iter2&gt;&amp; __y)
{
    return <span class="gs">__x.base() - __</span>y.base();
}


template &lt;class _Iter&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
move_iterator&lt;_Iter&gt;
operator+(typename move_iterator&lt;_Iter&gt;::difference_type __n, const move_iterator&lt;_Iter&gt;&amp; __x)
{
    return move_iterator&lt;_Iter&gt;(__x.base() + __n);
}

template &lt;class _Iter&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
move_iterator&lt;_Iter&gt;
make_move_iterator(_Iter __i)
{
    return move_iterator&lt;_Iter&gt;(__i);
}



template &lt;class <span class="ge">_Iter&gt; class __wrap_</span>iter;

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const __wrap_iter&lt;_Iter1&gt;&amp;, const __wrap_iter&lt;_Iter2&gt;&amp;) throw();

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;(const __wrap_iter&lt;_Iter1&gt;&amp;, const __wrap_iter&lt;_Iter2&gt;&amp;) throw();

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const __wrap_iter&lt;_Iter1&gt;&amp;, const __wrap_iter&lt;_Iter2&gt;&amp;) throw();

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;(const __wrap_iter&lt;_Iter1&gt;&amp;, const __wrap_iter&lt;_Iter2&gt;&amp;) throw();

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const __wrap_iter&lt;_Iter1&gt;&amp;, const __wrap_iter&lt;_Iter2&gt;&amp;) throw();

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const __wrap_iter&lt;_Iter1&gt;&amp;, const __wrap_iter&lt;_Iter2&gt;&amp;) throw();
template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __wrap_iter&lt;_Iter1&gt;::difference_type
operator-(const __wrap_iter&lt;_Iter1&gt;&amp;, const __wrap_iter&lt;_Iter2&gt;&amp;) throw();


template &lt;class _Iter&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__wrap_iter&lt;_Iter&gt;
operator+(typename __wrap_iter&lt;_Iter&gt;::difference_type, __wrap_iter&lt;_Iter&gt;) throw();

template &lt;class <span class="ge">_Ip, class _</span>Op&gt; <span class="ge">_Op __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) copy(_Ip, <span class="ge">_Ip, _</span>Op);
template &lt;class <span class="ge">_B1, class _</span>B2&gt; <span class="ge">_B2 __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) copy_backward(_B1, <span class="ge">_B1, _</span>B2);
template &lt;class <span class="ge">_Ip, class _</span>Op&gt; <span class="ge">_Op __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) move(_Ip, <span class="ge">_Ip, _</span>Op);
template &lt;class <span class="ge">_B1, class _</span>B2&gt; <span class="ge">_B2 __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) move_backward(_B1, <span class="ge">_B1, _</span>B2);



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_trivially_copy_assignable&lt;_Tp&gt;::value,
    _Tp*
&gt;::type
__unwrap_iter(__wrap_iter&lt;_Tp*&gt;);
template &lt;class _Iter&gt;
class __wrap_iter
{
public:
    typedef <span class="ge">_Iter iterator_</span>type;
    typedef typename iterator_traits&lt;iterator_type&gt;::iterator_category iterator_category;
    typedef typename iterator_traits&lt;iterator_type&gt;::value_type value_type;
    typedef typename iterator_traits&lt;iterator_type&gt;::difference_type difference_type;
    typedef typename iterator_traits&lt;iterator_type&gt;::pointer pointer;
    typedef typename iterator_traits&lt;iterator_type&gt;::reference reference;
private:
    iterator_type __i;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __wrap_iter() throw()



    {



    }
    template &lt;class <span class="ge">_Up&gt; __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        __wrap_iter(const __wrap_iter&lt;_Up&gt;&amp; __u,
            typename enable_if&lt;is_convertible&lt;_Up, iterator_type&gt;::value&gt;::type* = 0) throw()
            : <span class="gs">__i(__</span>u.base())
    {



    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) reference operator*() const throw()
    {




        return *__i;
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) pointer operator-&gt;() const throw()
    {




        return (pointer)std::__1::addressof(*__i);
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __wrap_iter&amp; operator++() throw()
    {




        ++__i;
        return *this;
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __wrap_iter operator++(int) throw()
        {__wrap_iter <span class="gs">__tmp(*this); ++(*this); return __</span>tmp;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __wrap_iter&amp; operator--() throw()
    {




        --__i;
        return *this;
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __wrap_iter operator--(int) throw()
        {__wrap_iter <span class="gs">__tmp(*this); --(*this); return __</span>tmp;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __wrap_iter operator+ (difference_type __n) const throw()
        {__wrap_iter <span class="gs">__w(*this); __</span>w += <span class="gs">__n; return __</span>w;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __wrap_iter&amp; operator+=(difference_type __n) throw()
    {




        <span class="gs">__i += __</span>n;
        return *this;
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __wrap_iter operator- (difference_type __n) const throw()
        {return *this + (-__n);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __wrap_iter&amp; operator-=(difference_type __n) throw()
        {<span class="ge">*this += -__n; return *</span>this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) reference operator[](difference_type __n) const throw()
    {




        return <span class="gs">__i[__</span>n];
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) iterator_type base() const throw() {return __i;}

private:






    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __wrap_iter(iterator_type <span class="gs">__x) throw() : __</span>i(__x) {}


    template &lt;class <span class="ge">_Up&gt; friend class __wrap_</span>iter;
    template &lt;class <span class="ge">_CharT, class _</span>Traits, class <span class="ge">_Alloc&gt; friend class basic_</span>string;
    template &lt;class <span class="ge">_Tp, class _</span>Alloc&gt; friend class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) vector;
    template &lt;class <span class="ge">_Tp, size_</span>t&gt; friend class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) span;

    template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
                                 friend
    bool
    operator==(const __wrap_iter&lt;_Iter1&gt;&amp;, const __wrap_iter&lt;_Iter2&gt;&amp;) throw();

    template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
                                 friend
    bool
    operator&lt;(const __wrap_iter&lt;_Iter1&gt;&amp;, const __wrap_iter&lt;_Iter2&gt;&amp;) throw();

    template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
                                 friend
    bool
    operator!=(const __wrap_iter&lt;_Iter1&gt;&amp;, const __wrap_iter&lt;_Iter2&gt;&amp;) throw();

    template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
                                 friend
    bool
    operator&gt;(const __wrap_iter&lt;_Iter1&gt;&amp;, const __wrap_iter&lt;_Iter2&gt;&amp;) throw();

    template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
                                 friend
    bool
    operator&gt;=(const __wrap_iter&lt;_Iter1&gt;&amp;, const __wrap_iter&lt;_Iter2&gt;&amp;) throw();

    template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
                                 friend
    bool
    operator&lt;=(const __wrap_iter&lt;_Iter1&gt;&amp;, const __wrap_iter&lt;_Iter2&gt;&amp;) throw();
    template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
                                 friend
    typename __wrap_iter&lt;_Iter1&gt;::difference_type
    operator-(const __wrap_iter&lt;_Iter1&gt;&amp;, const __wrap_iter&lt;_Iter2&gt;&amp;) throw();


    template &lt;class _Iter1&gt;
                                 friend
    __wrap_iter&lt;_Iter1&gt;
    operator+(typename __wrap_iter&lt;_Iter1&gt;::difference_type, __wrap_iter&lt;_Iter1&gt;) throw();

    template &lt;class <span class="ge">_Ip, class _</span>Op&gt; friend <span class="ge">_Op copy(_</span>Ip, <span class="ge">_Ip, _</span>Op);
    template &lt;class <span class="ge">_B1, class _</span>B2&gt; friend <span class="ge">_B2 copy_</span>backward(_B1, <span class="ge">_B1, _</span>B2);
    template &lt;class <span class="ge">_Ip, class _</span>Op&gt; friend <span class="ge">_Op move(_</span>Ip, <span class="ge">_Ip, _</span>Op);
    template &lt;class <span class="ge">_B1, class _</span>B2&gt; friend <span class="ge">_B2 move_</span>backward(_B1, <span class="ge">_B1, _</span>B2);


    template &lt;class _Tp&gt;
                                 friend
    typename enable_if
    &lt;
        is_trivially_copy_assignable&lt;_Tp&gt;::value,
        _Tp*
    &gt;::type
    __unwrap_iter(__wrap_iter&lt;_Tp*&gt;);
};

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const __wrap_iter&lt;_Iter1&gt;&amp; <span class="gs">__x, const __</span>wrap_iter&lt;_Iter2&gt;&amp; __y) throw()
{
    return <span class="gs">__x.base() == __</span>y.base();
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;(const __wrap_iter&lt;_Iter1&gt;&amp; <span class="gs">__x, const __</span>wrap_iter&lt;_Iter2&gt;&amp; __y) throw()
{




    return <span class="gs">__x.base() &lt; __</span>y.base();
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const __wrap_iter&lt;_Iter1&gt;&amp; <span class="gs">__x, const __</span>wrap_iter&lt;_Iter2&gt;&amp; __y) throw()
{
    return !(__x == __y);
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;(const __wrap_iter&lt;_Iter1&gt;&amp; <span class="gs">__x, const __</span>wrap_iter&lt;_Iter2&gt;&amp; __y) throw()
{
    return <span class="gs">__y &lt; __</span>x;
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const __wrap_iter&lt;_Iter1&gt;&amp; <span class="gs">__x, const __</span>wrap_iter&lt;_Iter2&gt;&amp; __y) throw()
{
    return !(__x &lt; __y);
}

template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const __wrap_iter&lt;_Iter1&gt;&amp; <span class="gs">__x, const __</span>wrap_iter&lt;_Iter2&gt;&amp; __y) throw()
{
    return !(__y &lt; __x);
}

template &lt;class _Iter1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const __wrap_iter&lt;_Iter1&gt;&amp; <span class="gs">__x, const __</span>wrap_iter&lt;_Iter1&gt;&amp; __y) throw()
{
    return !(__x == __y);
}

template &lt;class _Iter1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;(const __wrap_iter&lt;_Iter1&gt;&amp; <span class="gs">__x, const __</span>wrap_iter&lt;_Iter1&gt;&amp; __y) throw()
{
    return <span class="gs">__y &lt; __</span>x;
}

template &lt;class _Iter1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const __wrap_iter&lt;_Iter1&gt;&amp; <span class="gs">__x, const __</span>wrap_iter&lt;_Iter1&gt;&amp; __y) throw()
{
    return !(__x &lt; __y);
}

template &lt;class _Iter1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const __wrap_iter&lt;_Iter1&gt;&amp; <span class="gs">__x, const __</span>wrap_iter&lt;_Iter1&gt;&amp; __y) throw()
{
    return !(__y &lt; __x);
}
template &lt;class <span class="ge">_Iter1, class _</span>Iter2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __wrap_iter&lt;_Iter1&gt;::difference_type
operator-(const __wrap_iter&lt;_Iter1&gt;&amp; <span class="gs">__x, const __</span>wrap_iter&lt;_Iter2&gt;&amp; __y) throw()
{




    return <span class="gs">__x.base() - __</span>y.base();
}


template &lt;class _Iter&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__wrap_iter&lt;_Iter&gt;
operator+(typename __wrap_iter&lt;_Iter&gt;::difference_type __n,
          __wrap_iter&lt;_Iter&gt; __x) throw()
{
    <span class="gs">__x += __</span>n;
    return __x;
}

template &lt;class _Iter&gt;
struct __libcpp_is_trivial_iterator
    : public integral_constant&lt;bool,(is_pointer&lt;_Iter&gt;::value)&gt; {};

template &lt;class _Iter&gt;
struct __libcpp_is_trivial_iterator&lt;move_iterator&lt;_Iter&gt; &gt;
    : public integral_constant&lt;bool,(__libcpp_is_trivial_iterator&lt;_Iter&gt;::value)&gt; {};

template &lt;class _Iter&gt;
struct __libcpp_is_trivial_iterator&lt;reverse_iterator&lt;_Iter&gt; &gt;
    : public integral_constant&lt;bool,(__libcpp_is_trivial_iterator&lt;_Iter&gt;::value)&gt; {};

template &lt;class _Iter&gt;
struct __libcpp_is_trivial_iterator&lt;__wrap_iter&lt;_Iter&gt; &gt;
    : public integral_constant&lt;bool,(__libcpp_is_trivial_iterator&lt;_Iter&gt;::value)&gt; {};


template &lt;class <span class="ge">_Tp, size_</span>t _Np&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp*
begin(_Tp (&amp;__array)[_Np])
{
    return __array;
}

template &lt;class <span class="ge">_Tp, size_</span>t _Np&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp*
end(_Tp (&amp;__array)[_Np])
{
    return __array + _Np;
}
template &lt;class _Cp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename _Cp::iterator
begin(_Cp&amp; __c)
{
    return __c.begin();
}

template &lt;class _Cp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename <span class="ge">_Cp::const_</span>iterator
begin(const <span class="ge">_Cp&amp; _</span>_c)
{
    return __c.begin();
}

template &lt;class _Cp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename _Cp::iterator
end(_Cp&amp; __c)
{
    return __c.end();
}

template &lt;class _Cp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename <span class="ge">_Cp::const_</span>iterator
end(const <span class="ge">_Cp&amp; _</span>_c)
{
    return __c.end();
}
} }




namespace std { inline namespace __1 {
} }


namespace std { inline namespace __1 {


class <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) __libcpp_refstring
{
    const char* __imp_;

    bool __uses_refcount() const;
public:
    explicit __libcpp_refstring(const char* __msg);
    __libcpp_refstring(const __libcpp_refstring&amp; __s) throw();
    __libcpp_refstring&amp; operator=(const __libcpp_refstring&amp; __s) throw();
    ~__libcpp_refstring();

    const char* c<span class="ge">_str() const throw() {return __imp_</span>;}
};


} }

namespace std
{

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) logic_error
    : public exception
{

private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit logic_error(const string&amp;);
    explicit logic_error(const char*);

    logic_error(const logic_error&amp;) throw();
    logic_error&amp; operator=(const logic_error&amp;) throw();

    virtual ~logic_error() throw();

    virtual const char* what() const throw();





};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) runtime_error
    : public exception
{

private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit runtime_error(const string&amp;);
    explicit runtime_error(const char*);

    runtime_error(const runtime_error&amp;) throw();
    runtime_error&amp; operator=(const runtime_error&amp;) throw();

    virtual ~runtime_error() throw();

    virtual const char* what() const throw();





};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) domain_error
    : public logic_error
{
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit domain_error(const string&amp; __s) : logic_error(__s) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit domain_error(const char* __s) : logic_error(__s) {}


    virtual ~domain_error() throw();

};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) invalid_argument
    : public logic_error
{
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit invalid_argument(const string&amp; __s) : logic_error(__s) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit invalid_argument(const char* __s) : logic_error(__s) {}


    virtual ~invalid_argument() throw();

};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) length_error
    : public logic_error
{
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit length_error(const string&amp; __s) : logic_error(__s) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit length_error(const char* __s) : logic_error(__s) {}

    virtual ~length_error() throw();

};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) out_of_range
    : public logic_error
{
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit out_of_range(const string&amp; __s) : logic_error(__s) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit out_of_range(const char* __s) : logic_error(__s) {}


    virtual ~out_of_range() throw();

};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) range_error
    : public runtime_error
{
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit range_error(const string&amp; __s) : runtime_error(__s) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit range_error(const char* __s) : runtime_error(__s) {}


    virtual ~range_error() throw();

};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) overflow_error
    : public runtime_error
{
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit overflow_error(const string&amp; __s) : runtime_error(__s) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit overflow_error(const char* __s) : runtime_error(__s) {}


    virtual ~overflow_error() throw();

};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) underflow_error
    : public runtime_error
{
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit underflow_error(const string&amp; __s) : runtime_error(__s) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit underflow_error(const char* __s) : runtime_error(__s) {}


    virtual ~underflow_error() throw();

};

}

namespace std { inline namespace __1 {


<span class="gs">__attribute__</span> ((noreturn)) <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void __throw_runtime_error(const char*);

<span class="gs">__attribute__</span> ((noreturn)) inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __throw_logic_error(const char*__msg)
{

    throw logic_error(__msg);




}

<span class="gs">__attribute__</span> ((noreturn)) inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __throw_domain_error(const char*__msg)
{

    throw domain_error(__msg);




}

<span class="gs">__attribute__</span> ((noreturn)) inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __throw_invalid_argument(const char*__msg)
{

    throw invalid_argument(__msg);




}

<span class="gs">__attribute__</span> ((noreturn)) inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __throw_length_error(const char*__msg)
{

    throw length_error(__msg);




}

<span class="gs">__attribute__</span> ((noreturn)) inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __throw_out_of_range(const char*__msg)
{

    throw out_of_range(__msg);




}

<span class="gs">__attribute__</span> ((noreturn)) inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __throw_range_error(const char*__msg)
{

    throw range_error(__msg);




}

<span class="gs">__attribute__</span> ((noreturn)) inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __throw_overflow_error(const char*__msg)
{

    throw overflow_error(__msg);




}

<span class="gs">__attribute__</span> ((noreturn)) inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __throw_underflow_error(const char*__msg)
{

    throw underflow_error(__msg);




}

} }


namespace std { inline namespace __1 {




enum __legacy_memory_order {
    __mo_relaxed,
    __mo_consume,
    __mo_acquire,
    __mo_release,
    __mo_acq_rel,
    __mo_seq_cst
};

typedef underlying_type&lt;__legacy_memory_order&gt;::type __memory_order_underlying_t;
typedef enum memory_order {
  memory_order_relaxed = __mo_relaxed,
  memory_order_consume = __mo_consume,
  memory_order_acquire = __mo_acquire,
  memory_order_release = __mo_release,
  memory_order_acq_rel = __mo_acq_rel,
  memory_order_seq_cst = __mo_seq_cst,
} memory_order;



<span class="ge">_Static_</span>assert((is_same&lt;underlying_type&lt;memory_order&gt;::type, __memory_order_underlying_t&gt;::value), &quot;unexpected underlying type for std::memory_order&quot;);
template &lt;typename _Tp&gt;
struct __cxx_atomic_base_impl {

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))



    __cxx_atomic_base_impl() throw() : __a_value() {}

                    explicit __cxx_atomic_base_impl(_Tp value) throw()
    : __a_value(value) {}
  <span class="gs">__extension__</span> <span class="ge">_Atomic(_</span>Tp) __a_value;
};



<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) inline
void __cxx_atomic_thread_fence(memory_order __order) throw() {
    __c11_atomic_thread_fence(static_cast&lt;__memory_order_underlying_t&gt;(__order));
}

<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) inline
void __cxx_atomic_signal_fence(memory_order __order) throw() {
    __c11_atomic_signal_fence(static_cast&lt;__memory_order_underlying_t&gt;(__order));
}

template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __cxx_atomic_init(__cxx_atomic_base_impl&lt;_Tp&gt; volatile* __a, <span class="ge">_Tp _</span>_val) throw() {
    __c11_atomic_init(&amp;__a-&gt;__a_value, __val);
}
template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __cxx_atomic_init(__cxx_atomic_base_impl&lt;_Tp&gt; * __a, <span class="ge">_Tp _</span>_val) throw() {
    __c11_atomic_init(&amp;__a-&gt;__a_value, __val);
}

template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __cxx_atomic_store(__cxx_atomic_base_impl&lt;_Tp&gt; volatile* __a, <span class="ge">_Tp __val, memory_</span>order __order) throw() {
    __c11_atomic_store(&amp;__a-&gt;__a_value, __val, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}
template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __cxx_atomic_store(__cxx_atomic_base_impl&lt;_Tp&gt; * __a, <span class="ge">_Tp __val, memory_</span>order __order) throw() {
    __c11_atomic_store(&amp;__a-&gt;__a_value, __val, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}

template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __cxx_</span>atomic_load(__cxx_atomic_base_impl&lt;_Tp&gt; const volatile* __a, memory_order __order) throw() {
    using __ptr_type = typename remove_const&lt;__decltype(__a-&gt;__a_value)&gt;::type*;
    return __c11_atomic_load(const_cast&lt;__ptr_type&gt;(&amp;__a-&gt;__a_value), static_cast&lt;__memory_order_underlying_t&gt;(__order));
}
template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __cxx_</span>atomic_load(__cxx_atomic_base_impl&lt;_Tp&gt; const* __a, memory_order __order) throw() {
    using __ptr_type = typename remove_const&lt;__decltype(__a-&gt;__a_value)&gt;::type*;
    return __c11_atomic_load(const_cast&lt;__ptr_type&gt;(&amp;__a-&gt;__a_value), static_cast&lt;__memory_order_underlying_t&gt;(__order));
}

template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __cxx_</span>atomic_exchange(__cxx_atomic_base_impl&lt;_Tp&gt; volatile* __a, <span class="ge">_Tp __value, memory_</span>order __order) throw() {
    return __c11_atomic_exchange(&amp;__a-&gt;__a_value, __value, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}
template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __cxx_</span>atomic_exchange(__cxx_atomic_base_impl&lt;_Tp&gt; * __a, <span class="ge">_Tp __value, memory_</span>order __order) throw() {
    return __c11_atomic_exchange(&amp;__a-&gt;__a_value, __value, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}

template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl&lt;_Tp&gt; volatile* __a, <span class="ge">_Tp* __expected, _</span>Tp __value, memory_order __success, memory_order __failure) throw() {
    return __c11_atomic_compare_exchange_strong(&amp;__a-&gt;__a_value, <span class="gs">__expected, __</span>value, static_cast&lt;__memory_order_underlying_t&gt;(__success), static_cast&lt;__memory_order_underlying_t&gt;(__failure));
}
template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl&lt;_Tp&gt; * __a, <span class="ge">_Tp* __expected, _</span>Tp __value, memory_order __success, memory_order __failure) throw() {
    return __c11_atomic_compare_exchange_strong(&amp;__a-&gt;__a_value, <span class="gs">__expected, __</span>value, static_cast&lt;__memory_order_underlying_t&gt;(__success), static_cast&lt;__memory_order_underlying_t&gt;(__failure));
}

template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl&lt;_Tp&gt; volatile* __a, <span class="ge">_Tp* __expected, _</span>Tp __value, memory_order __success, memory_order __failure) throw() {
    return __c11_atomic_compare_exchange_weak(&amp;__a-&gt;__a_value, <span class="gs">__expected, __</span>value, static_cast&lt;__memory_order_underlying_t&gt;(__success), static_cast&lt;__memory_order_underlying_t&gt;(__failure));
}
template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl&lt;_Tp&gt; * __a, <span class="ge">_Tp* __expected, _</span>Tp __value, memory_order __success, memory_order __failure) throw() {
    return __c11_atomic_compare_exchange_weak(&amp;__a-&gt;__a_value, <span class="gs">__expected, __</span>value, static_cast&lt;__memory_order_underlying_t&gt;(__success), static_cast&lt;__memory_order_underlying_t&gt;(__failure));
}

template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __cxx_</span>atomic_fetch_add(__cxx_atomic_base_impl&lt;_Tp&gt; volatile* __a, <span class="ge">_Tp __delta, memory_</span>order __order) throw() {
    return __c11_atomic_fetch_add(&amp;__a-&gt;__a_value, __delta, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}
template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __cxx_</span>atomic_fetch_add(__cxx_atomic_base_impl&lt;_Tp&gt; * __a, <span class="ge">_Tp __delta, memory_</span>order __order) throw() {
    return __c11_atomic_fetch_add(&amp;__a-&gt;__a_value, __delta, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}

template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp* __cxx_</span>atomic_fetch_add(__cxx_atomic_base_impl&lt;_Tp*&gt; volatile* __a, ptrdiff_t __delta, memory_order __order) throw() {
    return __c11_atomic_fetch_add(&amp;__a-&gt;__a_value, __delta, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}
template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp* __cxx_</span>atomic_fetch_add(__cxx_atomic_base_impl&lt;_Tp*&gt; * __a, ptrdiff_t __delta, memory_order __order) throw() {
    return __c11_atomic_fetch_add(&amp;__a-&gt;__a_value, __delta, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}

template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __cxx_</span>atomic_fetch_sub(__cxx_atomic_base_impl&lt;_Tp&gt; volatile* __a, <span class="ge">_Tp __delta, memory_</span>order __order) throw() {
    return __c11_atomic_fetch_sub(&amp;__a-&gt;__a_value, __delta, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}
template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __cxx_</span>atomic_fetch_sub(__cxx_atomic_base_impl&lt;_Tp&gt; * __a, <span class="ge">_Tp __delta, memory_</span>order __order) throw() {
    return __c11_atomic_fetch_sub(&amp;__a-&gt;__a_value, __delta, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}
template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp* __cxx_</span>atomic_fetch_sub(__cxx_atomic_base_impl&lt;_Tp*&gt; volatile* __a, ptrdiff_t __delta, memory_order __order) throw() {
    return __c11_atomic_fetch_sub(&amp;__a-&gt;__a_value, __delta, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}
template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp* __cxx_</span>atomic_fetch_sub(__cxx_atomic_base_impl&lt;_Tp*&gt; * __a, ptrdiff_t __delta, memory_order __order) throw() {
    return __c11_atomic_fetch_sub(&amp;__a-&gt;__a_value, __delta, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}

template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __cxx_</span>atomic_fetch_and(__cxx_atomic_base_impl&lt;_Tp&gt; volatile* __a, <span class="ge">_Tp __pattern, memory_</span>order __order) throw() {
    return __c11_atomic_fetch_and(&amp;__a-&gt;__a_value, __pattern, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}
template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __cxx_</span>atomic_fetch_and(__cxx_atomic_base_impl&lt;_Tp&gt; * __a, <span class="ge">_Tp __pattern, memory_</span>order __order) throw() {
    return __c11_atomic_fetch_and(&amp;__a-&gt;__a_value, __pattern, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}

template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __cxx_</span>atomic_fetch_or(__cxx_atomic_base_impl&lt;_Tp&gt; volatile* __a, <span class="ge">_Tp __pattern, memory_</span>order __order) throw() {
    return __c11_atomic_fetch_or(&amp;__a-&gt;__a_value, __pattern, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}
template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __cxx_</span>atomic_fetch_or(__cxx_atomic_base_impl&lt;_Tp&gt; * __a, <span class="ge">_Tp __pattern, memory_</span>order __order) throw() {
    return __c11_atomic_fetch_or(&amp;__a-&gt;__a_value, __pattern, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}

template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __cxx_</span>atomic_fetch_xor(__cxx_atomic_base_impl&lt;_Tp&gt; volatile* __a, <span class="ge">_Tp __pattern, memory_</span>order __order) throw() {
    return __c11_atomic_fetch_xor(&amp;__a-&gt;__a_value, __pattern, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}
template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __cxx_</span>atomic_fetch_xor(__cxx_atomic_base_impl&lt;_Tp&gt; * __a, <span class="ge">_Tp __pattern, memory_</span>order __order) throw() {
    return __c11_atomic_fetch_xor(&amp;__a-&gt;__a_value, __pattern, static_cast&lt;__memory_order_underlying_t&gt;(__order));
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp kill_</span>dependency(_Tp __y) throw()
{
    return __y;
}
template &lt;typename _Tp,
          typename <span class="ge">_Base = __cxx_</span>atomic_base_impl&lt;_Tp&gt; &gt;

struct __cxx_atomic_impl : public _Base {






  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __cxx_atomic_impl() throw() {}
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit __cxx_atomic_impl(_Tp value) throw()
    : _Base(value) {}
};



template &lt;class <span class="ge">_Tp, bool = is_</span>integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value&gt;
struct __atomic_base
{
    mutable __cxx_atomic_impl&lt;_Tp&gt; __a_;





    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool is_lock_free() const volatile throw()
        {return __c11_atomic_is_lock_free(sizeof(_Tp));}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool is_lock_free() const throw()
        {return static_cast&lt;__atomic_base const volatile*&gt;(this)-&gt;is_lock_free();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile throw()
      <span class="gs">__attribute__</span>((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
        {__cxx_atomic_store(&amp;__a_, <span class="gs">__d, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) throw()
      <span class="gs">__attribute__</span>((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
        {__cxx_atomic_store(&amp;__a_, <span class="gs">__d, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp load(memory_</span>order __m = memory_order_seq_cst) const volatile throw()
      <span class="gs">__attribute__</span>((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
        {return __cxx_atomic_load(&amp;__a_, __m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp load(memory_</span>order __m = memory_order_seq_cst) const throw()
      <span class="gs">__attribute__</span>((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
        {return __cxx_atomic_load(&amp;__a_, __m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    operator _Tp() const volatile throw() {return load();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    operator _Tp() const throw() {return load();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp exchange(_</span>Tp __d, memory_order __m = memory_order_seq_cst) volatile throw()
        {return __cxx_atomic_exchange(&amp;__a_, <span class="gs">__d, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp exchange(_</span>Tp __d, memory_order __m = memory_order_seq_cst) throw()
        {return __cxx_atomic_exchange(&amp;__a_, <span class="gs">__d, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool compare_exchange_weak(_Tp&amp; __e, <span class="ge">_Tp _</span>_d,
                               memory_order __s, memory_order __f) volatile throw()
      <span class="gs">__attribute__</span>((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
        {return __cxx_atomic_compare_exchange_weak(&amp;__a_, &amp;<span class="gs">__e, __</span>d, <span class="gs">__s, __</span>f);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool compare_exchange_weak(_Tp&amp; __e, <span class="ge">_Tp _</span>_d,
                               memory_order __s, memory_order __f) throw()
      <span class="gs">__attribute__</span>((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
        {return __cxx_atomic_compare_exchange_weak(&amp;__a_, &amp;<span class="gs">__e, __</span>d, <span class="gs">__s, __</span>f);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool compare_exchange_strong(_Tp&amp; __e, <span class="ge">_Tp _</span>_d,
                                 memory_order __s, memory_order __f) volatile throw()
      <span class="gs">__attribute__</span>((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
        {return __cxx_atomic_compare_exchange_strong(&amp;__a_, &amp;<span class="gs">__e, __</span>d, <span class="gs">__s, __</span>f);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool compare_exchange_strong(_Tp&amp; __e, <span class="ge">_Tp _</span>_d,
                                 memory_order __s, memory_order __f) throw()
      <span class="gs">__attribute__</span>((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
        {return __cxx_atomic_compare_exchange_strong(&amp;__a_, &amp;<span class="gs">__e, __</span>d, <span class="gs">__s, __</span>f);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool compare_exchange_weak(_Tp&amp; __e, <span class="ge">_Tp _</span>_d,
                              memory_order __m = memory_order_seq_cst) volatile throw()
        {return __cxx_atomic_compare_exchange_weak(&amp;__a_, &amp;<span class="gs">__e, __</span>d, <span class="gs">__m, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool compare_exchange_weak(_Tp&amp; __e, <span class="ge">_Tp _</span>_d,
                               memory_order __m = memory_order_seq_cst) throw()
        {return __cxx_atomic_compare_exchange_weak(&amp;__a_, &amp;<span class="gs">__e, __</span>d, <span class="gs">__m, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool compare_exchange_strong(_Tp&amp; __e, <span class="ge">_Tp _</span>_d,
                              memory_order __m = memory_order_seq_cst) volatile throw()
        {return __cxx_atomic_compare_exchange_strong(&amp;__a_, &amp;<span class="gs">__e, __</span>d, <span class="gs">__m, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool compare_exchange_strong(_Tp&amp; __e, <span class="ge">_Tp _</span>_d,
                                 memory_order __m = memory_order_seq_cst) throw()
        {return __cxx_atomic_compare_exchange_strong(&amp;__a_, &amp;<span class="gs">__e, __</span>d, <span class="gs">__m, __</span>m);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __atomic_base() throw() {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __atomic_base(_Tp <span class="gs">__d) throw() : __</span>a<span class="ge">_(_</span>_d) {}






private:
    __atomic_base(const __atomic_base&amp;);
    __atomic_base&amp; operator=(const __atomic_base&amp;);
    __atomic_base&amp; operator=(const __atomic_base&amp;) volatile;

};
template &lt;class _Tp&gt;
struct __atomic_base&lt;_Tp, true&gt;
    : public __atomic_base&lt;_Tp, false&gt;
{
    typedef __atomic_base&lt;_Tp, false&gt; __base;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __atomic_base() throw() {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                      __atomic_base(_Tp <span class="gs">__d) throw() : __</span>base(__d) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp fetch_</span>add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
        {return __cxx_atomic_fetch_add(&amp;this-&gt;__a_, <span class="gs">__op, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp fetch_</span>add(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
        {return __cxx_atomic_fetch_add(&amp;this-&gt;__a_, <span class="gs">__op, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp fetch_</span>sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
        {return __cxx_atomic_fetch_sub(&amp;this-&gt;__a_, <span class="gs">__op, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp fetch_</span>sub(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
        {return __cxx_atomic_fetch_sub(&amp;this-&gt;__a_, <span class="gs">__op, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp fetch_</span>and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
        {return __cxx_atomic_fetch_and(&amp;this-&gt;__a_, <span class="gs">__op, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp fetch_</span>and(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
        {return __cxx_atomic_fetch_and(&amp;this-&gt;__a_, <span class="gs">__op, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp fetch_</span>or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
        {return __cxx_atomic_fetch_or(&amp;this-&gt;__a_, <span class="gs">__op, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp fetch_</span>or(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
        {return __cxx_atomic_fetch_or(&amp;this-&gt;__a_, <span class="gs">__op, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp fetch_</span>xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
        {return __cxx_atomic_fetch_xor(&amp;this-&gt;__a_, <span class="gs">__op, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp fetch_</span>xor(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
        {return __cxx_atomic_fetch_xor(&amp;this-&gt;__a_, <span class="gs">__op, __</span>m);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator++(int) volatile throw() {return fetch_</span>add(_Tp(1));}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator++(int) throw() {return fetch_</span>add(_Tp(1));}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator--(int) volatile throw() {return fetch_</span>sub(_Tp(1));}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator--(int) throw() {return fetch_</span>sub(_Tp(1));}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator++() volatile throw() {return fetch_</span>add(_Tp(1)) + _Tp(1);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator++() throw() {return fetch_</span>add(_Tp(1)) + _Tp(1);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator--() volatile throw() {return fetch_</span>sub(_Tp(1)) - _Tp(1);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator--() throw() {return fetch_</span>sub(_Tp(1)) - _Tp(1);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator+=(_</span>Tp __op) volatile throw() {return fetch_add(__op) + __op;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator+=(_</span>Tp __op) throw() {return fetch_add(__op) + __op;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator-=(_</span>Tp __op) volatile throw() {return fetch_sub(__op) - __op;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator-=(_</span>Tp __op) throw() {return fetch_sub(__op) - __op;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator&amp;=(_</span>Tp __op) volatile throw() {return fetch_and(__op) &amp; __op;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator&amp;=(_</span>Tp __op) throw() {return fetch_and(__op) &amp; __op;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator|=(_</span>Tp __op) volatile throw() {return fetch_or(__op) | __op;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator|=(_</span>Tp __op) throw() {return fetch_or(__op) | __op;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator^=(_</span>Tp __op) volatile throw() {return fetch_xor(__op) ^ __op;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator^=(_</span>Tp __op) throw() {return fetch_xor(__op) ^ __op;}
};



template &lt;class _Tp&gt;
struct atomic
    : public __atomic_base&lt;_Tp&gt;
{
    typedef __atomic_base&lt;_Tp&gt; __base;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    atomic() throw() {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                      atomic(_Tp <span class="gs">__d) throw() : __</span>base(__d) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator=(_</span>Tp __d) volatile throw()
        {<span class="gs">__base::store(__</span>d); return __d;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator=(_</span>Tp __d) throw()
        {<span class="gs">__base::store(__</span>d); return __d;}
};



template &lt;class _Tp&gt;
struct atomic&lt;_Tp*&gt;
    : public __atomic_base&lt;_Tp*&gt;
{
    typedef __atomic_base&lt;_Tp*&gt; __base;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    atomic() throw() {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                      atomic(_Tp* <span class="gs">__d) throw() : __</span>base(__d) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* operator=(_</span>Tp* __d) volatile throw()
        {<span class="gs">__base::store(__</span>d); return __d;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* operator=(_</span>Tp* __d) throw()
        {<span class="gs">__base::store(__</span>d); return __d;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* fetch_</span>add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
                                                                        volatile throw()
        {return __cxx_atomic_fetch_add(&amp;this-&gt;__a_, <span class="gs">__op, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* fetch_</span>add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) throw()
        {return __cxx_atomic_fetch_add(&amp;this-&gt;__a_, <span class="gs">__op, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* fetch_</span>sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
                                                                        volatile throw()
        {return __cxx_atomic_fetch_sub(&amp;this-&gt;__a_, <span class="gs">__op, __</span>m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* fetch_</span>sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) throw()
        {return __cxx_atomic_fetch_sub(&amp;this-&gt;__a_, <span class="gs">__op, __</span>m);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* operator++(int) volatile throw() {return fetch_</span>add(1);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* operator++(int) throw() {return fetch_</span>add(1);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* operator--(int) volatile throw() {return fetch_</span>sub(1);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* operator--(int) throw() {return fetch_</span>sub(1);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* operator++() volatile throw() {return fetch_</span>add(1) + 1;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* operator++() throw() {return fetch_</span>add(1) + 1;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* operator--() volatile throw() {return fetch_</span>sub(1) - 1;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* operator--() throw() {return fetch_</span>sub(1) - 1;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* operator+=(ptrdiff_</span>t __op) volatile throw() {return fetch_add(__op) + __op;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* operator+=(ptrdiff_</span>t __op) throw() {return fetch_add(__op) + __op;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* operator-=(ptrdiff_</span>t __op) volatile throw() {return fetch_sub(__op) - __op;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* operator-=(ptrdiff_</span>t __op) throw() {return fetch_sub(__op) - __op;}
};



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_is_lock_free(const volatile atomic&lt;_Tp&gt;* __o) throw()
{
    return __o-&gt;is_lock_free();
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_is_lock_free(const atomic&lt;_Tp&gt;* __o) throw()
{
    return __o-&gt;is_lock_free();
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
atomic_init(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_d) throw()
{
    __cxx_atomic_init(&amp;__o-&gt;__a_, __d);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
atomic_init(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_d) throw()
{
    __cxx_atomic_init(&amp;__o-&gt;__a_, __d);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
atomic_store(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_d) throw()
{
    <span class="gs">__o-&gt;store(__</span>d);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
atomic_store(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_d) throw()
{
    <span class="gs">__o-&gt;store(__</span>d);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
atomic_store_explicit(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp __d, memory_</span>order __m) throw()
  <span class="gs">__attribute__</span>((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
{
    <span class="gs">__o-&gt;store(__</span>d, __m);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
atomic_store_explicit(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp __d, memory_</span>order __m) throw()
  <span class="gs">__attribute__</span>((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
{
    <span class="gs">__o-&gt;store(__</span>d, __m);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp
atomic_load(const volatile atomic&lt;_Tp&gt;* __o) throw()
{
    return __o-&gt;load();
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp
atomic_load(const atomic&lt;_Tp&gt;* __o) throw()
{
    return __o-&gt;load();
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp
atomic_load_explicit(const volatile atomic&lt;_Tp&gt;* __o, memory_order __m) throw()
  <span class="gs">__attribute__</span>((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
{
    return <span class="gs">__o-&gt;load(__</span>m);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp
atomic_load_explicit(const atomic&lt;_Tp&gt;* __o, memory_order __m) throw()
  <span class="gs">__attribute__</span>((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
{
    return <span class="gs">__o-&gt;load(__</span>m);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp
atomic_exchange(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_d) throw()
{
    return <span class="gs">__o-&gt;exchange(__</span>d);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp
atomic_exchange(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_d) throw()
{
    return <span class="gs">__o-&gt;exchange(__</span>d);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp
atomic_exchange_explicit(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp __d, memory_</span>order __m) throw()
{
    return <span class="gs">__o-&gt;exchange(__</span>d, __m);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp
atomic_exchange_explicit(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp __d, memory_</span>order __m) throw()
{
    return <span class="gs">__o-&gt;exchange(__</span>d, __m);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_compare_exchange_weak(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp* __e, _</span>Tp __d) throw()
{
    return __o-&gt;compare_exchange_weak(*__e, __d);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_compare_exchange_weak(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp* __e, _</span>Tp __d) throw()
{
    return __o-&gt;compare_exchange_weak(*__e, __d);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_compare_exchange_strong(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp* __e, _</span>Tp __d) throw()
{
    return __o-&gt;compare_exchange_strong(*__e, __d);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_compare_exchange_strong(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp* __e, _</span>Tp __d) throw()
{
    return __o-&gt;compare_exchange_strong(*__e, __d);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_compare_exchange_weak_explicit(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp* _</span>_e,
                                      <span class="ge">_Tp _</span>_d,
                                      memory_order __s, memory_order __f) throw()
  <span class="gs">__attribute__</span>((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
{
    return __o-&gt;compare_exchange_weak(*__e, <span class="gs">__d, __</span>s, __f);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_compare_exchange_weak_explicit(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp* __e, _</span>Tp __d,
                                      memory_order __s, memory_order __f) throw()
  <span class="gs">__attribute__</span>((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
{
    return __o-&gt;compare_exchange_weak(*__e, <span class="gs">__d, __</span>s, __f);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_compare_exchange_strong_explicit(volatile atomic&lt;_Tp&gt;* __o,
                                        <span class="ge">_Tp* __e, _</span>Tp __d,
                                        memory_order __s, memory_order __f) throw()
  <span class="gs">__attribute__</span>((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
{
    return __o-&gt;compare_exchange_strong(*__e, <span class="gs">__d, __</span>s, __f);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_compare_exchange_strong_explicit(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp* _</span>_e,
                                        <span class="ge">_Tp _</span>_d,
                                        memory_order __s, memory_order __f) throw()
  <span class="gs">__attribute__</span>((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, &quot;memory order argument to atomic operation is invalid&quot;, &quot;warning&quot;)))
{
    return __o-&gt;compare_exchange_strong(*__e, <span class="gs">__d, __</span>s, __f);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_add(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_op) throw()
{
    return __o-&gt;fetch_add(__op);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_add(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_op) throw()
{
    return __o-&gt;fetch_add(__op);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp*
atomic_fetch_add(volatile atomic&lt;_Tp*&gt;* __o, ptrdiff_t __op) throw()
{
    return __o-&gt;fetch_add(__op);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp*
atomic_fetch_add(atomic&lt;_Tp*&gt;* __o, ptrdiff_t __op) throw()
{
    return __o-&gt;fetch_add(__op);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_add_explicit(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp __op, memory_</span>order __m) throw()
{
    return __o-&gt;fetch_add(__op, __m);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_add_explicit(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp __op, memory_</span>order __m) throw()
{
    return __o-&gt;fetch_add(__op, __m);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp*
atomic_fetch_add_explicit(volatile atomic&lt;_Tp*&gt;* __o, ptrdiff_t __op,
                          memory_order __m) throw()
{
    return __o-&gt;fetch_add(__op, __m);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp*
atomic_fetch_add_explicit(atomic&lt;_Tp*&gt;* __o, ptrdiff_t __op, memory_order __m) throw()
{
    return __o-&gt;fetch_add(__op, __m);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_sub(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_op) throw()
{
    return __o-&gt;fetch_sub(__op);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_sub(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_op) throw()
{
    return __o-&gt;fetch_sub(__op);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp*
atomic_fetch_sub(volatile atomic&lt;_Tp*&gt;* __o, ptrdiff_t __op) throw()
{
    return __o-&gt;fetch_sub(__op);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp*
atomic_fetch_sub(atomic&lt;_Tp*&gt;* __o, ptrdiff_t __op) throw()
{
    return __o-&gt;fetch_sub(__op);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_sub_explicit(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp __op, memory_</span>order __m) throw()
{
    return __o-&gt;fetch_sub(__op, __m);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_sub_explicit(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp __op, memory_</span>order __m) throw()
{
    return __o-&gt;fetch_sub(__op, __m);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp*
atomic_fetch_sub_explicit(volatile atomic&lt;_Tp*&gt;* __o, ptrdiff_t __op,
                          memory_order __m) throw()
{
    return __o-&gt;fetch_sub(__op, __m);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp*
atomic_fetch_sub_explicit(atomic&lt;_Tp*&gt;* __o, ptrdiff_t __op, memory_order __m) throw()
{
    return __o-&gt;fetch_sub(__op, __m);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_and(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_op) throw()
{
    return __o-&gt;fetch_and(__op);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_and(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_op) throw()
{
    return __o-&gt;fetch_and(__op);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_and_explicit(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp __op, memory_</span>order __m) throw()
{
    return __o-&gt;fetch_and(__op, __m);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_and_explicit(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp __op, memory_</span>order __m) throw()
{
    return __o-&gt;fetch_and(__op, __m);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_or(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_op) throw()
{
    return __o-&gt;fetch_or(__op);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_or(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_op) throw()
{
    return __o-&gt;fetch_or(__op);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_or_explicit(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp __op, memory_</span>order __m) throw()
{
    return __o-&gt;fetch_or(__op, __m);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_or_explicit(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp __op, memory_</span>order __m) throw()
{
    return __o-&gt;fetch_or(__op, __m);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_xor(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_op) throw()
{
    return __o-&gt;fetch_xor(__op);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_xor(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp _</span>_op) throw()
{
    return __o-&gt;fetch_xor(__op);
}



template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_xor_explicit(volatile atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp __op, memory_</span>order __m) throw()
{
    return __o-&gt;fetch_xor(__op, __m);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Tp&gt;::value &amp;&amp; !is_same&lt;_Tp, bool&gt;::value,
    _Tp
&gt;::type
atomic_fetch_xor_explicit(atomic&lt;_Tp&gt;* __o, <span class="ge">_Tp __op, memory_</span>order __m) throw()
{
    return __o-&gt;fetch_xor(__op, __m);
}



typedef struct atomic_flag
{
    __cxx_atomic_impl&lt;bool&gt; __a_;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile throw()
        {return __cxx_atomic_exchange(&amp;__a_, bool(true), __m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool test_and_set(memory_order __m = memory_order_seq_cst) throw()
        {return __cxx_atomic_exchange(&amp;__a_, bool(true), __m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void clear(memory_order __m = memory_order_seq_cst) volatile throw()
        {__cxx_atomic_store(&amp;__a_, bool(false), __m);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void clear(memory_order __m = memory_order_seq_cst) throw()
        {__cxx_atomic_store(&amp;__a_, bool(false), __m);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    atomic_flag() throw() {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    atomic_flag(bool <span class="gs">__b) throw() : __</span>a<span class="ge">_(_</span>_b) {}






private:
    atomic_flag(const atomic_flag&amp;);
    atomic_flag&amp; operator=(const atomic_flag&amp;);
    atomic_flag&amp; operator=(const atomic_flag&amp;) volatile;

} atomic_flag;

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_flag_test_and_set(volatile atomic_flag* __o) throw()
{
    return __o-&gt;test_and_set();
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_flag_test_and_set(atomic_flag* __o) throw()
{
    return __o-&gt;test_and_set();
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) throw()
{
    return __o-&gt;test_and_set(__m);
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) throw()
{
    return __o-&gt;test_and_set(__m);
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
atomic_flag_clear(volatile atomic_flag* __o) throw()
{
    __o-&gt;clear();
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
atomic_flag_clear(atomic_flag* __o) throw()
{
    __o-&gt;clear();
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) throw()
{
    <span class="gs">__o-&gt;clear(__</span>m);
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) throw()
{
    <span class="gs">__o-&gt;clear(__</span>m);
}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
atomic_thread_fence(memory_order __m) throw()
{
    __cxx_atomic_thread_fence(__m);
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
atomic_signal_fence(memory_order __m) throw()
{
    __cxx_atomic_signal_fence(__m);
}



typedef atomic&lt;bool&gt; atomic_bool;
typedef atomic&lt;char&gt; atomic_char;
typedef atomic&lt;signed char&gt; atomic_schar;
typedef atomic&lt;unsigned char&gt; atomic_uchar;
typedef atomic&lt;short&gt; atomic_short;
typedef atomic&lt;unsigned short&gt; atomic_ushort;
typedef atomic&lt;int&gt; atomic_int;
typedef atomic&lt;unsigned int&gt; atomic_uint;
typedef atomic&lt;long&gt; atomic_long;
typedef atomic&lt;unsigned long&gt; atomic_ulong;
typedef atomic&lt;long long&gt; atomic_llong;
typedef atomic&lt;unsigned long long&gt; atomic_ullong;
typedef atomic&lt;char16_t&gt; atomic_char16_t;
typedef atomic&lt;char32_t&gt; atomic_char32_t;
typedef atomic&lt;wchar_t&gt; atomic_wchar_t;

typedef atomic&lt;int_least8_t&gt; atomic_int_least8_t;
typedef atomic&lt;uint_least8_t&gt; atomic_uint_least8_t;
typedef atomic&lt;int_least16_t&gt; atomic_int_least16_t;
typedef atomic&lt;uint_least16_t&gt; atomic_uint_least16_t;
typedef atomic&lt;int_least32_t&gt; atomic_int_least32_t;
typedef atomic&lt;uint_least32_t&gt; atomic_uint_least32_t;
typedef atomic&lt;int_least64_t&gt; atomic_int_least64_t;
typedef atomic&lt;uint_least64_t&gt; atomic_uint_least64_t;

typedef atomic&lt;int_fast8_t&gt; atomic_int_fast8_t;
typedef atomic&lt;uint_fast8_t&gt; atomic_uint_fast8_t;
typedef atomic&lt;int_fast16_t&gt; atomic_int_fast16_t;
typedef atomic&lt;uint_fast16_t&gt; atomic_uint_fast16_t;
typedef atomic&lt;int_fast32_t&gt; atomic_int_fast32_t;
typedef atomic&lt;uint_fast32_t&gt; atomic_uint_fast32_t;
typedef atomic&lt;int_fast64_t&gt; atomic_int_fast64_t;
typedef atomic&lt;uint_fast64_t&gt; atomic_uint_fast64_t;

typedef atomic&lt; int8_t&gt; atomic_int8_t;
typedef atomic&lt;uint8_t&gt; atomic_uint8_t;
typedef atomic&lt; int16_t&gt; atomic_int16_t;
typedef atomic&lt;uint16_t&gt; atomic_uint16_t;
typedef atomic&lt; int32_t&gt; atomic_int32_t;
typedef atomic&lt;uint32_t&gt; atomic_uint32_t;
typedef atomic&lt; int64_t&gt; atomic_int64_t;
typedef atomic&lt;uint64_t&gt; atomic_uint64_t;

typedef atomic&lt;intptr_t&gt; atomic_intptr_t;
typedef atomic&lt;uintptr_t&gt; atomic_uintptr_t;
typedef atomic&lt;size_t&gt; atomic_size_t;
typedef atomic&lt;ptrdiff_t&gt; atomic_ptrdiff_t;
typedef atomic&lt;intmax_t&gt; atomic_intmax_t;
typedef atomic&lt;uintmax_t&gt; atomic_uintmax_t;




} }






extern &quot;C&quot; {
void __assert_rtn(const char <span class="ge">*, const char *</span>, int, const char *) <span class="gs">__attribute__</span>((__noreturn__)) <span class="gs">__attribute__</span>((__cold__)) <span class="gs">__attribute__</span>((__disable_tail_calls__));



}





namespace std { inline namespace __1 {

template &lt;class _ValueType&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_ValueType __libcpp_</span>relaxed_load(_ValueType const* __value) {



    return __atomic_load_n(__value, 0);



}

template &lt;class _ValueType&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_ValueType __libcpp_</span>acquire_load(_ValueType const* __value) {



    return __atomic_load_n(__value, 2);



}



template &lt;class _Tp&gt; class allocator;

template &lt;&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) allocator&lt;void&gt;
{
public:
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;

    template &lt;class <span class="ge">_Up&gt; struct rebind {typedef allocator&lt;_</span>Up&gt; other;};
};

template &lt;&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) allocator&lt;const void&gt;
{
public:
    typedef const void* pointer;
    typedef const void* const_pointer;
    typedef const void value_type;

    template &lt;class <span class="ge">_Up&gt; struct rebind {typedef allocator&lt;_</span>Up&gt; other;};
};



template &lt;class _Tp, class = void&gt;
struct __has_element_type : false_type {};

template &lt;class _Tp&gt;
struct __has_element_type&lt;_Tp,
              typename __void_t&lt;typename <span class="ge">_Tp::element_</span>type&gt;::type&gt; : true_type {};

template &lt;class <span class="ge">_Ptr, bool = __has_</span>element_type&lt;_Ptr&gt;::value&gt;
struct __pointer_traits_element_type;

template &lt;class _Ptr&gt;
struct __pointer_traits_element_type&lt;_Ptr, true&gt;
{
    typedef typename <span class="ge">_Ptr::element_</span>type type;
};
template &lt;template &lt;class&gt; class <span class="ge">_Sp, class _</span>Tp&gt;
struct __pointer_traits_element_type&lt;_Sp&lt;_Tp&gt;, true&gt;
{
    typedef typename <span class="ge">_Sp&lt;_</span>Tp&gt;::element_type type;
};

template &lt;template &lt;class&gt; class <span class="ge">_Sp, class _</span>Tp&gt;
struct __pointer_traits_element_type&lt;_Sp&lt;_Tp&gt;, false&gt;
{
    typedef _Tp type;
};

template &lt;template &lt;class, class&gt; class <span class="ge">_Sp, class _</span>Tp, class _A0&gt;
struct __pointer_traits_element_type&lt;_Sp&lt;_Tp, _A0&gt;, true&gt;
{
    typedef typename <span class="ge">_Sp&lt;_</span>Tp, <span class="ge">_A0&gt;::element_</span>type type;
};

template &lt;template &lt;class, class&gt; class <span class="ge">_Sp, class _</span>Tp, class _A0&gt;
struct __pointer_traits_element_type&lt;_Sp&lt;_Tp, _A0&gt;, false&gt;
{
    typedef _Tp type;
};

template &lt;template &lt;class, class, class&gt; class <span class="ge">_Sp, class _</span>Tp, class <span class="ge">_A0, class _</span>A1&gt;
struct __pointer_traits_element_type&lt;_Sp&lt;_Tp, <span class="ge">_A0, _</span>A1&gt;, true&gt;
{
    typedef typename <span class="ge">_Sp&lt;_</span>Tp, <span class="ge">_A0, _</span>A1&gt;::element_type type;
};

template &lt;template &lt;class, class, class&gt; class <span class="ge">_Sp, class _</span>Tp, class <span class="ge">_A0, class _</span>A1&gt;
struct __pointer_traits_element_type&lt;_Sp&lt;_Tp, <span class="ge">_A0, _</span>A1&gt;, false&gt;
{
    typedef _Tp type;
};

template &lt;template &lt;class, class, class, class&gt; class <span class="ge">_Sp, class _</span>Tp, class _A0,
                                                           class <span class="ge">_A1, class _</span>A2&gt;
struct __pointer_traits_element_type&lt;_Sp&lt;_Tp, <span class="ge">_A0, _</span>A1, _A2&gt;, true&gt;
{
    typedef typename <span class="ge">_Sp&lt;_</span>Tp, <span class="ge">_A0, _</span>A1, <span class="ge">_A2&gt;::element_</span>type type;
};

template &lt;template &lt;class, class, class, class&gt; class <span class="ge">_Sp, class _</span>Tp, class _A0,
                                                           class <span class="ge">_A1, class _</span>A2&gt;
struct __pointer_traits_element_type&lt;_Sp&lt;_Tp, <span class="ge">_A0, _</span>A1, _A2&gt;, false&gt;
{
    typedef _Tp type;
};



template &lt;class _Tp, class = void&gt;
struct __has_difference_type : false_type {};

template &lt;class _Tp&gt;
struct __has_difference_type&lt;_Tp,
            typename __void_t&lt;typename <span class="ge">_Tp::difference_</span>type&gt;::type&gt; : true_type {};

template &lt;class <span class="ge">_Ptr, bool = __has_</span>difference_type&lt;_Ptr&gt;::value&gt;
struct __pointer_traits_difference_type
{
    typedef ptrdiff_t type;
};

template &lt;class _Ptr&gt;
struct __pointer_traits_difference_type&lt;_Ptr, true&gt;
{
    typedef typename <span class="ge">_Ptr::difference_</span>type type;
};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __has_rebind
{
private:
    struct <span class="gs">__two {char __</span>lx; char __lxx;};
    template &lt;class <span class="ge">_Xp&gt; static __two _</span>_test(...);
    template &lt;class <span class="ge">_Xp&gt; static char __test(typename _</span>Xp::template rebind&lt;_Up&gt;* = 0);
public:
    static const bool value = sizeof(__test&lt;_Tp&gt;(0)) == 1;
};

template &lt;class <span class="ge">_Tp, class _</span>Up, bool = __has_rebind&lt;_Tp, _Up&gt;::value&gt;
struct __pointer_traits_rebind
{



    typedef typename <span class="ge">_Tp::template rebind&lt;_</span>Up&gt;::other type;

};
template &lt;template &lt;class&gt; class <span class="ge">_Sp, class _</span>Tp, class _Up&gt;
struct __pointer_traits_rebind&lt;_Sp&lt;_Tp&gt;, _Up, true&gt;
{



    typedef typename <span class="ge">_Sp&lt;_</span>Tp&gt;::template rebind&lt;_Up&gt;::other type;

};

template &lt;template &lt;class&gt; class <span class="ge">_Sp, class _</span>Tp, class _Up&gt;
struct __pointer_traits_rebind&lt;_Sp&lt;_Tp&gt;, _Up, false&gt;
{
    typedef <span class="ge">_Sp&lt;_</span>Up&gt; type;
};

template &lt;template &lt;class, class&gt; class <span class="ge">_Sp, class _</span>Tp, class <span class="ge">_A0, class _</span>Up&gt;
struct __pointer_traits_rebind&lt;_Sp&lt;_Tp, <span class="ge">_A0&gt;, _</span>Up, true&gt;
{



    typedef typename <span class="ge">_Sp&lt;_</span>Tp, <span class="ge">_A0&gt;::template rebind&lt;_</span>Up&gt;::other type;

};

template &lt;template &lt;class, class&gt; class <span class="ge">_Sp, class _</span>Tp, class <span class="ge">_A0, class _</span>Up&gt;
struct __pointer_traits_rebind&lt;_Sp&lt;_Tp, <span class="ge">_A0&gt;, _</span>Up, false&gt;
{
    typedef <span class="ge">_Sp&lt;_</span>Up, _A0&gt; type;
};

template &lt;template &lt;class, class, class&gt; class <span class="ge">_Sp, class _</span>Tp, class _A0,
                                         class <span class="ge">_A1, class _</span>Up&gt;
struct __pointer_traits_rebind&lt;_Sp&lt;_Tp, <span class="ge">_A0, _</span>A1&gt;, _Up, true&gt;
{



    typedef typename <span class="ge">_Sp&lt;_</span>Tp, <span class="ge">_A0, _</span>A1&gt;::template rebind&lt;_Up&gt;::other type;

};

template &lt;template &lt;class, class, class&gt; class <span class="ge">_Sp, class _</span>Tp, class _A0,
                                         class <span class="ge">_A1, class _</span>Up&gt;
struct __pointer_traits_rebind&lt;_Sp&lt;_Tp, <span class="ge">_A0, _</span>A1&gt;, _Up, false&gt;
{
    typedef <span class="ge">_Sp&lt;_</span>Up, <span class="ge">_A0, _</span>A1&gt; type;
};

template &lt;template &lt;class, class, class, class&gt; class <span class="ge">_Sp, class _</span>Tp, class _A0,
                                                class <span class="ge">_A1, class _</span>A2, class _Up&gt;
struct __pointer_traits_rebind&lt;_Sp&lt;_Tp, <span class="ge">_A0, _</span>A1, <span class="ge">_A2&gt;, _</span>Up, true&gt;
{



    typedef typename <span class="ge">_Sp&lt;_</span>Tp, <span class="ge">_A0, _</span>A1, <span class="ge">_A2&gt;::template rebind&lt;_</span>Up&gt;::other type;

};

template &lt;template &lt;class, class, class, class&gt; class <span class="ge">_Sp, class _</span>Tp, class _A0,
                                                class <span class="ge">_A1, class _</span>A2, class _Up&gt;
struct __pointer_traits_rebind&lt;_Sp&lt;_Tp, <span class="ge">_A0, _</span>A1, <span class="ge">_A2&gt;, _</span>Up, false&gt;
{
    typedef <span class="ge">_Sp&lt;_</span>Up, <span class="ge">_A0, _</span>A1, _A2&gt; type;
};



template &lt;class _Ptr&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type&lt;pointer&gt;::type element_type;
    typedef typename __pointer_traits_difference_type&lt;pointer&gt;::type difference_type;




    template &lt;class _Up&gt; struct rebind
        {typedef typename __pointer_traits_rebind&lt;pointer, _Up&gt;::type other;};


private:
    struct __nat {};
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static pointer pointer_to(typename conditional&lt;is_void&lt;element_type&gt;::value,
                                           __nat, element_type&gt;::type&amp; __r)
        {return pointer::pointer_to(__r);}
};

template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) pointer_traits&lt;_Tp*&gt;
{
    typedef _Tp* pointer;
    typedef <span class="ge">_Tp element_</span>type;
    typedef ptrdiff_t difference_type;




    template &lt;class <span class="ge">_Up&gt; struct rebind {typedef _</span>Up* other;};


private:
    struct __nat {};
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static pointer pointer_to(typename conditional&lt;is_void&lt;element_type&gt;::value,
                                      __nat, element_type&gt;::type&amp; __r) throw()
        {return std::__1::addressof(__r);}
};

template &lt;class <span class="ge">_From, class _</span>To&gt;
struct __rebind_pointer {



    typedef typename pointer_traits&lt;_From&gt;::template rebind&lt;_To&gt;::other type;

};



template &lt;class _Tp, class = void&gt;
struct __has_pointer_type : false_type {};

template &lt;class _Tp&gt;
struct __has_pointer_type&lt;_Tp,
          typename __void_t&lt;typename <span class="ge">_Tp::pointer&gt;::type&gt; : true_</span>type {};

namespace __pointer_type_imp
{

template &lt;class <span class="ge">_Tp, class _</span>Dp, bool = __has_pointer_type&lt;_Dp&gt;::value&gt;
struct __pointer_type
{
    typedef typename _Dp::pointer type;
};

template &lt;class <span class="ge">_Tp, class _</span>Dp&gt;
struct __pointer_type&lt;_Tp, _Dp, false&gt;
{
    typedef _Tp* type;
};

}

template &lt;class <span class="ge">_Tp, class _</span>Dp&gt;
struct __pointer_type
{
    typedef typename __pointer_type_imp::__pointer_type&lt;_Tp, typename remove_reference&lt;_Dp&gt;::type&gt;::type type;
};

template &lt;class _Tp, class = void&gt;
struct __has_const_pointer : false_type {};

template &lt;class _Tp&gt;
struct __has_const_pointer&lt;_Tp,
            typename __void_t&lt;typename <span class="ge">_Tp::const_</span>pointer&gt;::type&gt; : true_type {};

template &lt;class <span class="ge">_Tp, class _</span>Ptr, class <span class="ge">_Alloc, bool = __has_</span>const_pointer&lt;_Alloc&gt;::value&gt;
struct __const_pointer
{
    typedef typename <span class="ge">_Alloc::const_</span>pointer type;
};

template &lt;class <span class="ge">_Tp, class _</span>Ptr, class _Alloc&gt;
struct __const_pointer&lt;_Tp, <span class="ge">_Ptr, _</span>Alloc, false&gt;
{



    typedef typename pointer_traits&lt;_Ptr&gt;::template rebind&lt;const _Tp&gt;::other type;

};

template &lt;class _Tp, class = void&gt;
struct __has_void_pointer : false_type {};

template &lt;class _Tp&gt;
struct __has_void_pointer&lt;_Tp,
               typename __void_t&lt;typename <span class="ge">_Tp::void_</span>pointer&gt;::type&gt; : true_type {};

template &lt;class <span class="ge">_Ptr, class _</span>Alloc, bool = __has_void_pointer&lt;_Alloc&gt;::value&gt;
struct __void_pointer
{
    typedef typename <span class="ge">_Alloc::void_</span>pointer type;
};

template &lt;class <span class="ge">_Ptr, class _</span>Alloc&gt;
struct __void_pointer&lt;_Ptr, _Alloc, false&gt;
{



    typedef typename pointer_traits&lt;_Ptr&gt;::template rebind&lt;void&gt;::other type;

};

template &lt;class _Tp, class = void&gt;
struct __has_const_void_pointer : false_type {};

template &lt;class _Tp&gt;
struct __has_const_void_pointer&lt;_Tp,
            typename __void_t&lt;typename <span class="ge">_Tp::const_</span>void_pointer&gt;::type&gt; : true_type {};

template &lt;class <span class="ge">_Ptr, class _</span>Alloc, bool = __has_const_void_pointer&lt;_Alloc&gt;::value&gt;
struct __const_void_pointer
{
    typedef typename <span class="ge">_Alloc::const_</span>void_pointer type;
};

template &lt;class <span class="ge">_Ptr, class _</span>Alloc&gt;
struct __const_void_pointer&lt;_Ptr, _Alloc, false&gt;
{



    typedef typename pointer_traits&lt;_Ptr&gt;::template rebind&lt;const void&gt;::other type;

};


template &lt;bool <span class="ge">_UsePointerTraits&gt; struct __to_</span>address_helper;

template &lt;&gt; struct __to_address_helper&lt;true&gt; {
    template &lt;class _Pointer&gt;
    using __return_type = __decltype(pointer_traits&lt;_Pointer&gt;::to_address(std::declval&lt;const _Pointer&amp;&gt;()));

    template &lt;class _Pointer&gt;

    static __return_type&lt;_Pointer&gt;
    __do_it(const <span class="ge">_Pointer &amp;__p) throw() { return pointer_</span>traits&lt;_Pointer&gt;::to_address(__p); }
};

template &lt;class <span class="ge">_Pointer, bool _</span>Dummy = true&gt;
using __choose_to_address = __to_address_helper&lt;_IsValidExpansion&lt;__to_address_helper&lt;_Dummy&gt;::template __return_type, _Pointer&gt;::value&gt;;


template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp*
__to_address(_Tp* __p) throw()
{
    <span class="ge">_Static_</span>assert(!is_function&lt;_Tp&gt;::value, &quot;_Tp is a function type&quot;);
    return __p;
}

template &lt;class _Pointer&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __choose_to_address&lt;_Pointer&gt;::template __return_type&lt;_Pointer&gt;
__to_address(const <span class="ge">_Pointer&amp; _</span>_p) throw() {
  return __choose_to_address&lt;_Pointer&gt;::__do_it(__p);
}

template &lt;&gt; struct __to_address_helper&lt;false&gt; {
    template &lt;class _Pointer&gt;
    using __return_type = typename pointer_traits&lt;_Pointer&gt;::element_type*;

    template &lt;class _Pointer&gt;

    static __return_type&lt;_Pointer&gt;
    __do_it(const <span class="ge">_Pointer &amp;__p) throw() { return std::__to_</span>address(__p.operator-&gt;()); }
};
template &lt;class _Tp, class = void&gt;
struct __has_size_type : false_type {};

template &lt;class _Tp&gt;
struct __has_size_type&lt;_Tp,
               typename __void_t&lt;typename <span class="ge">_Tp::size_</span>type&gt;::type&gt; : true_type {};

template &lt;class <span class="ge">_Alloc, class _</span>DiffType, bool = __has_size_type&lt;_Alloc&gt;::value&gt;
struct __size_type
{
    typedef typename make_unsigned&lt;_DiffType&gt;::type type;
};

template &lt;class <span class="ge">_Alloc, class _</span>DiffType&gt;
struct __size_type&lt;_Alloc, _DiffType, true&gt;
{
    typedef typename <span class="ge">_Alloc::size_</span>type type;
};

template &lt;class _Tp, class = void&gt;
struct __has_propagate_on_container_copy_assignment : false_type {};

template &lt;class _Tp&gt;
struct __has_propagate_on_container_copy_assignment&lt;_Tp,
    typename __void_t&lt;typename <span class="ge">_Tp::propagate_</span>on_container_copy_assignment&gt;::type&gt;
        : true_type {};

template &lt;class <span class="ge">_Alloc, bool = __has_</span>propagate_on_container_copy_assignment&lt;_Alloc&gt;::value&gt;
struct __propagate_on_container_copy_assignment
{
    typedef false_type type;
};

template &lt;class _Alloc&gt;
struct __propagate_on_container_copy_assignment&lt;_Alloc, true&gt;
{
    typedef typename <span class="ge">_Alloc::propagate_</span>on_container_copy_assignment type;
};

template &lt;class _Tp, class = void&gt;
struct __has_propagate_on_container_move_assignment : false_type {};

template &lt;class _Tp&gt;
struct __has_propagate_on_container_move_assignment&lt;_Tp,
           typename __void_t&lt;typename <span class="ge">_Tp::propagate_</span>on_container_move_assignment&gt;::type&gt;
               : true_type {};

template &lt;class <span class="ge">_Alloc, bool = __has_</span>propagate_on_container_move_assignment&lt;_Alloc&gt;::value&gt;
struct __propagate_on_container_move_assignment
{
    typedef false_type type;
};

template &lt;class _Alloc&gt;
struct __propagate_on_container_move_assignment&lt;_Alloc, true&gt;
{
    typedef typename <span class="ge">_Alloc::propagate_</span>on_container_move_assignment type;
};

template &lt;class _Tp, class = void&gt;
struct __has_propagate_on_container_swap : false_type {};

template &lt;class _Tp&gt;
struct __has_propagate_on_container_swap&lt;_Tp,
           typename __void_t&lt;typename <span class="ge">_Tp::propagate_</span>on_container_swap&gt;::type&gt;
               : true_type {};

template &lt;class <span class="ge">_Alloc, bool = __has_</span>propagate_on_container_swap&lt;_Alloc&gt;::value&gt;
struct __propagate_on_container_swap
{
    typedef false_type type;
};

template &lt;class _Alloc&gt;
struct __propagate_on_container_swap&lt;_Alloc, true&gt;
{
    typedef typename <span class="ge">_Alloc::propagate_</span>on_container_swap type;
};

template &lt;class _Tp, class = void&gt;
struct __has_is_always_equal : false_type {};

template &lt;class _Tp&gt;
struct __has_is_always_equal&lt;_Tp,
           typename __void_t&lt;typename <span class="ge">_Tp::is_</span>always_equal&gt;::type&gt;
               : true_type {};

template &lt;class <span class="ge">_Alloc, bool = __has_</span>is_always_equal&lt;_Alloc&gt;::value&gt;
struct __is_always_equal
{
    typedef typename std::__1::is_empty&lt;_Alloc&gt;::type type;
};

template &lt;class _Alloc&gt;
struct __is_always_equal&lt;_Alloc, true&gt;
{
    typedef typename <span class="ge">_Alloc::is_</span>always_equal type;
};

template &lt;class <span class="ge">_Tp, class _</span>Up, bool = __has_rebind&lt;_Tp, _Up&gt;::value&gt;
struct __has_rebind_other
{
private:
    struct <span class="gs">__two {char __</span>lx; char __lxx;};
    template &lt;class <span class="ge">_Xp&gt; static __two _</span>_test(...);
    template &lt;class <span class="ge">_Xp&gt; static char __test(typename _</span>Xp::template rebind&lt;_Up&gt;::other* = 0);
public:
    static const bool value = sizeof(__test&lt;_Tp&gt;(0)) == 1;
};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
struct __has_rebind_other&lt;_Tp, _Up, false&gt;
{
    static const bool value = false;
};

template &lt;class <span class="ge">_Tp, class _</span>Up, bool = __has_rebind_other&lt;_Tp, _Up&gt;::value&gt;
struct __allocator_traits_rebind
{
    typedef typename <span class="ge">_Tp::template rebind&lt;_</span>Up&gt;::other type;
};
template &lt;template &lt;class&gt; class <span class="ge">_Alloc, class _</span>Tp, class _Up&gt;
struct __allocator_traits_rebind&lt;_Alloc&lt;_Tp&gt;, _Up, true&gt;
{
    typedef typename <span class="ge">_Alloc&lt;_</span>Tp&gt;::template rebind&lt;_Up&gt;::other type;
};

template &lt;template &lt;class&gt; class <span class="ge">_Alloc, class _</span>Tp, class _Up&gt;
struct __allocator_traits_rebind&lt;_Alloc&lt;_Tp&gt;, _Up, false&gt;
{
    typedef <span class="ge">_Alloc&lt;_</span>Up&gt; type;
};

template &lt;template &lt;class, class&gt; class <span class="ge">_Alloc, class _</span>Tp, class <span class="ge">_A0, class _</span>Up&gt;
struct __allocator_traits_rebind&lt;_Alloc&lt;_Tp, <span class="ge">_A0&gt;, _</span>Up, true&gt;
{
    typedef typename <span class="ge">_Alloc&lt;_</span>Tp, <span class="ge">_A0&gt;::template rebind&lt;_</span>Up&gt;::other type;
};

template &lt;template &lt;class, class&gt; class <span class="ge">_Alloc, class _</span>Tp, class <span class="ge">_A0, class _</span>Up&gt;
struct __allocator_traits_rebind&lt;_Alloc&lt;_Tp, <span class="ge">_A0&gt;, _</span>Up, false&gt;
{
    typedef <span class="ge">_Alloc&lt;_</span>Up, _A0&gt; type;
};

template &lt;template &lt;class, class, class&gt; class <span class="ge">_Alloc, class _</span>Tp, class _A0,
                                         class <span class="ge">_A1, class _</span>Up&gt;
struct __allocator_traits_rebind&lt;_Alloc&lt;_Tp, <span class="ge">_A0, _</span>A1&gt;, _Up, true&gt;
{
    typedef typename <span class="ge">_Alloc&lt;_</span>Tp, <span class="ge">_A0, _</span>A1&gt;::template rebind&lt;_Up&gt;::other type;
};

template &lt;template &lt;class, class, class&gt; class <span class="ge">_Alloc, class _</span>Tp, class _A0,
                                         class <span class="ge">_A1, class _</span>Up&gt;
struct __allocator_traits_rebind&lt;_Alloc&lt;_Tp, <span class="ge">_A0, _</span>A1&gt;, _Up, false&gt;
{
    typedef <span class="ge">_Alloc&lt;_</span>Up, <span class="ge">_A0, _</span>A1&gt; type;
};

template &lt;template &lt;class, class, class, class&gt; class <span class="ge">_Alloc, class _</span>Tp, class _A0,
                                                class <span class="ge">_A1, class _</span>A2, class _Up&gt;
struct __allocator_traits_rebind&lt;_Alloc&lt;_Tp, <span class="ge">_A0, _</span>A1, <span class="ge">_A2&gt;, _</span>Up, true&gt;
{
    typedef typename <span class="ge">_Alloc&lt;_</span>Tp, <span class="ge">_A0, _</span>A1, <span class="ge">_A2&gt;::template rebind&lt;_</span>Up&gt;::other type;
};

template &lt;template &lt;class, class, class, class&gt; class <span class="ge">_Alloc, class _</span>Tp, class _A0,
                                                class <span class="ge">_A1, class _</span>A2, class _Up&gt;
struct __allocator_traits_rebind&lt;_Alloc&lt;_Tp, <span class="ge">_A0, _</span>A1, <span class="ge">_A2&gt;, _</span>Up, false&gt;
{
    typedef <span class="ge">_Alloc&lt;_</span>Up, <span class="ge">_A0, _</span>A1, _A2&gt; type;
};
template &lt;class <span class="ge">_Alloc, class _</span>SizeType, class _ConstVoidPtr&gt;
struct __has_allocate_hint
    : true_type
{
};
template &lt;class <span class="ge">_Alloc, class _</span>Pointer, class _Tp, class = void&gt;
struct __has_construct : std::false_type {};

template &lt;class <span class="ge">_Alloc, class _</span>Pointer, class _Tp&gt;
struct __has_construct&lt;_Alloc, <span class="ge">_Pointer, _</span>Tp, typename __void_t&lt;
    <span class="gs">__decltype(std::__</span>1::declval&lt;_Alloc&gt;().construct(std::__1::declval&lt;_Pointer&gt;(), std::__1::declval&lt;_Tp&gt;()))
&gt;::type&gt; : std::true_type {};

template &lt;class <span class="ge">_Alloc, class _</span>Pointer, class = void&gt;
struct __has_destroy : false_type {};

template &lt;class <span class="ge">_Alloc, class _</span>Pointer&gt;
struct __has_destroy&lt;_Alloc, <span class="ge">_Pointer, typename __void_</span>t&lt;
    <span class="gs">__decltype(std::__</span>1::declval&lt;_Alloc&gt;().destroy(std::__1::declval&lt;_Pointer&gt;()))
&gt;::type&gt; : std::true_type {};

template &lt;class _Alloc&gt;
struct __has_max_size
    : true_type
{
};

template &lt;class _Alloc&gt;
struct __has_select_on_container_copy_construction
    : false_type
{
};



template &lt;class <span class="ge">_Alloc, class _</span>Ptr, bool = __has_difference_type&lt;_Alloc&gt;::value&gt;
struct __alloc_traits_difference_type
{
    typedef typename pointer_traits&lt;_Ptr&gt;::difference_type type;
};

template &lt;class <span class="ge">_Alloc, class _</span>Ptr&gt;
struct __alloc_traits_difference_type&lt;_Alloc, _Ptr, true&gt;
{
    typedef typename <span class="ge">_Alloc::difference_</span>type type;
};

template &lt;class _Tp&gt;
struct __is_default_allocator : false_type {};

template &lt;class _Tp&gt;
struct __is_default_allocator&lt;std::__1::allocator&lt;_Tp&gt; &gt; : true_type {};



template &lt;class _Alloc,
    bool = __has_construct&lt;_Alloc, typename <span class="ge">_Alloc::value_</span>type*, typename <span class="ge">_Alloc::value_</span>type&amp;&amp;&gt;::value &amp;&amp; !__is_default_allocator&lt;_Alloc&gt;::value
<span class="k">    &gt;</span>
<span class="ge">struct __is_cpp17_move_insertable;</span>
template &lt;class _Alloc&gt;
struct __is_cpp17_move_insertable&lt;_Alloc, true&gt; : std::true_type {};
template &lt;class _Alloc&gt;
struct __is_cpp17_move_insertable&lt;_Alloc, false&gt; : std::is_move_constructible&lt;typename <span class="ge">_Alloc::value_</span>type&gt; {};

template &lt;class _Alloc,
    bool = __has_construct&lt;_Alloc, typename <span class="ge">_Alloc::value_</span>type*, const typename <span class="ge">_Alloc::value_</span>type&amp;&gt;::value &amp;&amp; !__is_default_allocator&lt;_Alloc&gt;::value
<span class="k">    &gt;</span>
<span class="ge">struct __is_cpp17_copy_insertable;</span>
template &lt;class _Alloc&gt;
struct __is_cpp17_copy_insertable&lt;_Alloc, true&gt; : __is_cpp17_move_insertable&lt;_Alloc&gt; {};
template &lt;class _Alloc&gt;
struct __is_cpp17_copy_insertable&lt;_Alloc, false&gt; : integral_constant&lt;bool,
    std::is_copy_constructible&lt;typename <span class="ge">_Alloc::value_</span>type&gt;::value &amp;&amp;
    __is_cpp17_move_insertable&lt;_Alloc&gt;::value&gt;
  {};



template &lt;class _Alloc&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) allocator_traits
{
    typedef <span class="ge">_Alloc allocator_</span>type;
    typedef typename allocator_type::value_type value_type;

    typedef typename __pointer_type&lt;value_type, allocator_type&gt;::type pointer;
    typedef typename __const_pointer&lt;value_type, pointer, allocator_type&gt;::type const_pointer;
    typedef typename __void_pointer&lt;pointer, allocator_type&gt;::type void_pointer;
    typedef typename __const_void_pointer&lt;pointer, allocator_type&gt;::type const_void_pointer;

    typedef typename __alloc_traits_difference_type&lt;allocator_type, pointer&gt;::type difference_type;
    typedef typename __size_type&lt;allocator_type, difference_type&gt;::type size_type;

    typedef typename __propagate_on_container_copy_assignment&lt;allocator_type&gt;::type
                     propagate_on_container_copy_assignment;
    typedef typename __propagate_on_container_move_assignment&lt;allocator_type&gt;::type
                     propagate_on_container_move_assignment;
    typedef typename __propagate_on_container_swap&lt;allocator_type&gt;::type
                     propagate_on_container_swap;
    typedef typename __is_always_equal&lt;allocator_type&gt;::type
                     is_always_equal;






    template &lt;class <span class="ge">_Tp&gt; struct rebind_</span>alloc
        {typedef typename __allocator_traits_rebind&lt;allocator_type, _Tp&gt;::type other;};
    template &lt;class <span class="ge">_Tp&gt; struct rebind_</span>traits
        {typedef allocator_traits&lt;typename rebind_alloc&lt;_Tp&gt;::other&gt; other;};


                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static pointer allocate(allocator_type&amp; __a, size_type __n)
        {return <span class="gs">__a.allocate(__</span>n);}
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static pointer allocate(allocator_type&amp; __a, size_type __n, const_void_pointer __hint)
        {return <span class="gs">__allocate(__</span>a, <span class="gs">__n, __</span>hint,
            __has_allocate_hint&lt;allocator_type, size_type, const_void_pointer&gt;());}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static void deallocate(allocator_type&amp; <span class="gs">__a, pointer __</span>p, size_type __n) throw()
        {<span class="gs">__a.deallocate(__</span>p, __n);}
    template &lt;class _Tp&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static void construct(allocator_type&amp;, <span class="ge">_Tp* _</span>_p)
            {
                ::new ((void*)__p) _Tp();
            }
    template &lt;class <span class="ge">_Tp, class _</span>A0&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static void construct(allocator_type&amp; __a, <span class="ge">_Tp* __p, const _</span>A0&amp; __a0)
            {
                <span class="gs">__construct(__</span>has_construct&lt;allocator_type, <span class="ge">_Tp*, const _</span>A0&amp;&gt;(),
                            <span class="gs">__a, __</span>p, __a0);
            }
    template &lt;class <span class="ge">_Tp, class _</span>A0, class _A1&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static void construct(allocator_type&amp;, <span class="ge">_Tp* __p, const _</span>A0&amp; __a0,
                              const <span class="ge">_A1&amp; _</span>_a1)
            {
                ::new ((void*)__p) <span class="ge">_Tp(__a0, _</span>_a1);
            }
    template &lt;class <span class="ge">_Tp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static void construct(allocator_type&amp;, <span class="ge">_Tp* __p, const _</span>A0&amp; __a0,
                              const <span class="ge">_A1&amp; __a1, const _</span>A2&amp; __a2)
            {
                ::new ((void*)__p) <span class="ge">_Tp(__a0, __a1, _</span>_a2);
            }


    template &lt;class _Tp&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static void destroy(allocator_type&amp; __a, <span class="ge">_Tp* _</span>_p)
            {<span class="gs">__destroy(__</span>has_destroy&lt;allocator_type, <span class="ge">_Tp*&gt;(), __a, _</span>_p);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static size_type max_size(const allocator_type&amp; __a) throw()
        {return __max_size(__has_max_size&lt;const allocator_type&gt;(), __a);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static allocator_type
        select_on_container_copy_construction(const allocator_type&amp; __a)
            {return __select_on_container_copy_construction(
                __has_select_on_container_copy_construction&lt;const allocator_type&gt;(),
                __a);}

    template &lt;class _Ptr&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static
        void
        __construct_forward_with_exception_guarantees(allocator_type&amp; __a, <span class="ge">_Ptr __begin1, _</span>Ptr __end1, <span class="ge">_Ptr&amp; _</span>_begin2)
        {
            <span class="ge">_Static_</span>assert(__is_cpp17_move_insertable&lt;allocator_type&gt;::value, &quot;The specified type does not meet the requirements of Cpp17MoveInsertible&quot;);

            for (; <span class="gs">__begin1 != __</span>end1; ++__begin1, (void) ++__begin2)
              construct(__a, std::__1::__to_address(__begin2),



                        std::__1::move_if_noexcept(*__begin1)

                        );
        }

    template &lt;class _Tp&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static
        typename enable_if
        &lt;
            (__is_default_allocator&lt;allocator_type&gt;::value
                || !__has_construct&lt;allocator_type, <span class="ge">_Tp*, _</span>Tp&gt;::value) &amp;&amp;
             is_trivially_move_constructible&lt;_Tp&gt;::value,
            void
        &gt;::type
        __construct_forward_with_exception_guarantees(allocator_type&amp;, <span class="ge">_Tp* __begin1, _</span>Tp* __end1, <span class="ge">_Tp*&amp; _</span>_begin2)
        {
            ptrdiff_t <span class="ge">_Np = __end1 - _</span>_begin1;
            if (_Np &gt; 0)
            {
                std::__1::memcpy(__begin2, __begin1, <span class="ge">_Np * sizeof(_</span>Tp));
                __begin2 += _Np;
            }
        }

    template &lt;class <span class="ge">_Iter, class _</span>Ptr&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static
        void
        __construct_range_forward(allocator_type&amp; __a, <span class="ge">_Iter __begin1, _</span>Iter __end1, <span class="ge">_Ptr&amp; _</span>_begin2)
        {
            for (; <span class="gs">__begin1 != __</span>end1; ++__begin1, (void) ++__begin2)
                construct(__a, std::__1::__to_address(__begin2), *__begin1);
        }

    template &lt;class <span class="ge">_SourceTp, class _</span>DestTp,
              class <span class="ge">_RawSourceTp = typename remove_</span>const&lt;_SourceTp&gt;::type,
              class <span class="ge">_RawDestTp = typename remove_</span>const&lt;_DestTp&gt;::type&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static
        typename enable_if
        &lt;
            is_trivially_copy_constructible&lt;_DestTp&gt;::value &amp;&amp;
            is_same&lt;_RawSourceTp, _RawDestTp&gt;::value &amp;&amp;
            (__is_default_allocator&lt;allocator_type&gt;::value ||
             !__has_construct&lt;allocator_type, <span class="ge">_DestTp*, _</span>SourceTp&amp;&gt;::value),
            void
        &gt;::type
        __construct_range_forward(allocator_type&amp;, <span class="ge">_SourceTp* __begin1, _</span>SourceTp* __end1, <span class="ge">_DestTp*&amp; _</span>_begin2)
        {
            ptrdiff_t <span class="ge">_Np = __end1 - _</span>_begin1;
            if (_Np &gt; 0)
            {
                std::__1::memcpy(const_cast&lt;_RawDestTp*&gt;(__begin2), __begin1, <span class="ge">_Np * sizeof(_</span>DestTp));
                __begin2 += _Np;
            }
        }

    template &lt;class _Ptr&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static
        void
        __construct_backward_with_exception_guarantees(allocator_type&amp; __a, <span class="ge">_Ptr __begin1, _</span>Ptr __end1, <span class="ge">_Ptr&amp; _</span>_end2)
        {
            <span class="ge">_Static_</span>assert(__is_cpp17_move_insertable&lt;allocator_type&gt;::value, &quot;The specified type does not meet the requirements of Cpp17MoveInsertable&quot;);

            while (<span class="gs">__end1 != __</span>begin1)
            {
              construct(__a, std::__1::__to_address(__end2 - 1),



                        std::__1::move_if_noexcept(*--__end1)

                        );
              --__end2;
            }
        }

    template &lt;class _Tp&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static
        typename enable_if
        &lt;
            (__is_default_allocator&lt;allocator_type&gt;::value
                || !__has_construct&lt;allocator_type, <span class="ge">_Tp*, _</span>Tp&gt;::value) &amp;&amp;
             is_trivially_move_constructible&lt;_Tp&gt;::value,
            void
        &gt;::type
        __construct_backward_with_exception_guarantees(allocator_type&amp;, <span class="ge">_Tp* __begin1, _</span>Tp* __end1, <span class="ge">_Tp*&amp; _</span>_end2)
        {
            ptrdiff_t <span class="ge">_Np = __end1 - _</span>_begin1;
            __end2 -= _Np;
            if (_Np &gt; 0)
                std::__1::memcpy(__end2, __begin1, <span class="ge">_Np * sizeof(_</span>Tp));
        }

private:

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static pointer __allocate(allocator_type&amp; __a, size_type __n,
        const_void_pointer __hint, true_type)
        {return <span class="gs">__a.allocate(__</span>n, __hint);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static pointer __allocate(allocator_type&amp; __a, size_type __n,
        const_void_pointer, false_type)
        {return <span class="gs">__a.allocate(__</span>n);}
    template &lt;class <span class="ge">_Tp, class _</span>A0&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static void __construct(true_type, allocator_type&amp; __a, <span class="ge">_Tp* _</span>_p,
                                const <span class="ge">_A0&amp; _</span>_a0)
            {<span class="gs">__a.construct(__</span>p, __a0);}
    template &lt;class <span class="ge">_Tp, class _</span>A0&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static void __construct(false_type, allocator_type&amp;, <span class="ge">_Tp* _</span>_p,
                                const <span class="ge">_A0&amp; _</span>_a0)
            {
                ::new ((void*)__p) <span class="ge">_Tp(_</span>_a0);
            }


    template &lt;class _Tp&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static void __destroy(true_type, allocator_type&amp; __a, <span class="ge">_Tp* _</span>_p)
            {<span class="gs">__a.destroy(__</span>p);}
    template &lt;class _Tp&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        static void __destroy(false_type, allocator_type&amp;, <span class="ge">_Tp* _</span>_p)
            {
                __p-&gt;~_Tp();
            }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static size_type __max_size(true_type, const allocator_type&amp; __a) throw()
            {return __a.max_size();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static size_type __max_size(false_type, const allocator_type&amp;) throw()
            {return numeric_limits&lt;size_type&gt;::max() / sizeof(value_type);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static allocator_type
        __select_on_container_copy_construction(true_type, const allocator_type&amp; __a)
            {return __a.select_on_container_copy_construction();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static allocator_type
        __select_on_container_copy_construction(false_type, const allocator_type&amp; __a)
            {return __a;}
};

template &lt;class <span class="ge">_Traits, class _</span>Tp&gt;
struct __rebind_alloc_helper
{



    typedef typename <span class="ge">_Traits::template rebind_</span>alloc&lt;_Tp&gt;::other type;

};



template &lt;class _Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) allocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp* pointer;
    typedef const <span class="ge">_Tp* const_</span>pointer;
    typedef _Tp&amp; reference;
    typedef const <span class="ge">_Tp&amp; const_</span>reference;
    typedef <span class="ge">_Tp value_</span>type;

    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    template &lt;class <span class="ge">_Up&gt; struct rebind {typedef allocator&lt;_</span>Up&gt; other;};

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    allocator() throw() {}

    template &lt;class _Up&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    allocator(const allocator&lt;_Up&gt;&amp;) throw() {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) pointer address(reference __x) const throw()
        {return std::__1::addressof(__x);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) const_pointer address(const_reference __x) const throw()
        {return std::__1::addressof(__x);}
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pointer allocate(size_type __n, allocator&lt;void&gt;::const_pointer = 0)
        {
        if (__n &gt; max_size())
            __throw_length_error(&quot;allocator&lt;T&gt;::allocate(size_t n)&quot;
                                 &quot; &#39;n&#39; exceeds maximum supported size&quot;);
        return static_cast&lt;pointer&gt;(std::__1::__libcpp_allocate(__n * sizeof(_Tp), <span class="ge">_Alignof(_</span>Tp)));
        }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void deallocate(pointer __p, size_type __n) throw()
        {std::__1::__libcpp_deallocate((void*)__p, __n * sizeof(_Tp), <span class="ge">_Alignof(_</span>Tp));}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) size_type max_size() const throw()
        {return size_type(~0) / sizeof(_Tp);}
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        void
        construct(pointer __p)
        {
            ::new((void*)__p) _Tp();
        }


    template &lt;class _A0&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        void
        construct(pointer __p, <span class="ge">_A0&amp; _</span>_a0)
        {
            ::new((void*)__p) <span class="ge">_Tp(_</span>_a0);
        }
    template &lt;class _A0&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        void
        construct(pointer __p, const <span class="ge">_A0&amp; _</span>_a0)
        {
            ::new((void*)__p) <span class="ge">_Tp(_</span>_a0);
        }

    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        void
        construct(pointer __p, <span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1)
        {
            ::new((void*)__p) <span class="ge">_Tp(__a0, _</span>_a1);
        }
    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        void
        construct(pointer __p, const <span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1)
        {
            ::new((void*)__p) <span class="ge">_Tp(__a0, _</span>_a1);
        }
    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        void
        construct(pointer __p, <span class="ge">_A0&amp; __a0, const _</span>A1&amp; __a1)
        {
            ::new((void*)__p) <span class="ge">_Tp(__a0, _</span>_a1);
        }
    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        void
        construct(pointer __p, const <span class="ge">_A0&amp; __a0, const _</span>A1&amp; __a1)
        {
            ::new((void*)__p) <span class="ge">_Tp(__a0, _</span>_a1);
        }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void destroy(pointer <span class="gs">__p) {__</span>p-&gt;~_Tp();}
};

template &lt;class _Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) allocator&lt;const _Tp&gt;
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp* pointer;
    typedef const <span class="ge">_Tp* const_</span>pointer;
    typedef const _Tp&amp; reference;
    typedef const <span class="ge">_Tp&amp; const_</span>reference;
    typedef const <span class="ge">_Tp value_</span>type;

    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    template &lt;class <span class="ge">_Up&gt; struct rebind {typedef allocator&lt;_</span>Up&gt; other;};

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    allocator() throw() {}

    template &lt;class _Up&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    allocator(const allocator&lt;_Up&gt;&amp;) throw() {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) const_pointer address(const_reference __x) const throw()
        {return std::__1::addressof(__x);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) pointer allocate(size_type __n, allocator&lt;void&gt;::const_pointer = 0)
    {
        if (__n &gt; max_size())
            __throw_length_error(&quot;allocator&lt;const T&gt;::allocate(size_t n)&quot;
                                 &quot; &#39;n&#39; exceeds maximum supported size&quot;);
        return static_cast&lt;pointer&gt;(std::__1::__libcpp_allocate(__n * sizeof(_Tp), <span class="ge">_Alignof(_</span>Tp)));
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void deallocate(pointer __p, size_type __n) throw()
        {std::__1::__libcpp_deallocate((void*) const_cast&lt;_Tp <span class="ge">*&gt;(__p), __n *</span> sizeof(_Tp), <span class="ge">_Alignof(_</span>Tp));}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) size_type max_size() const throw()
        {return size_type(~0) / sizeof(_Tp);}
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        void
        construct(pointer __p)
        {
            ::new((void*) const_cast&lt;_Tp *&gt;(__p)) _Tp();
        }


    template &lt;class _A0&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        void
        construct(pointer __p, <span class="ge">_A0&amp; _</span>_a0)
        {
            ::new((void*) const_cast&lt;_Tp *&gt;(__p)) <span class="ge">_Tp(_</span>_a0);
        }
    template &lt;class _A0&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        void
        construct(pointer __p, const <span class="ge">_A0&amp; _</span>_a0)
        {
            ::new((void*) const_cast&lt;_Tp *&gt;(__p)) <span class="ge">_Tp(_</span>_a0);
        }

    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        void
        construct(pointer __p, <span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1)
        {
            ::new((void*) const_cast&lt;_Tp *&gt;(__p)) <span class="ge">_Tp(__a0, _</span>_a1);
        }
    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        void
        construct(pointer __p, const <span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1)
        {
            ::new((void*) const_cast&lt;_Tp *&gt;(__p)) <span class="ge">_Tp(__a0, _</span>_a1);
        }
    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        void
        construct(pointer __p, <span class="ge">_A0&amp; __a0, const _</span>A1&amp; __a1)
        {
            ::new((void*) const_cast&lt;_Tp *&gt;(__p)) <span class="ge">_Tp(__a0, _</span>_a1);
        }
    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        void
        construct(pointer __p, const <span class="ge">_A0&amp; __a0, const _</span>A1&amp; __a1)
        {
            ::new((void*) const_cast&lt;_Tp *&gt;(__p)) <span class="ge">_Tp(__a0, _</span>_a1);
        }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void destroy(pointer <span class="gs">__p) {__</span>p-&gt;~_Tp();}
};

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator==(const allocator&lt;_Tp&gt;&amp;, const allocator&lt;_Up&gt;&amp;) throw() {return true;}

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator!=(const allocator&lt;_Tp&gt;&amp;, const allocator&lt;_Up&gt;&amp;) throw() {return false;}

template &lt;class <span class="ge">_OutputIterator, class _</span>Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) raw_storage_iterator
    : public iterator&lt;output_iterator_tag,
                      _Tp,
                      ptrdiff_t,
                      _Tp*,
                      raw_storage_iterator&lt;_OutputIterator, _Tp&gt;&amp;&gt;
{
private:
    <span class="ge">_OutputIterator __x_</span>;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit raw_storage_iterator(_OutputIterator <span class="gs">__x) : __</span>x<span class="ge">_(_</span>_x) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) raw_storage_iterator&amp; operator*() {return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) raw_storage_iterator&amp; operator=(const <span class="ge">_Tp&amp; _</span>_element)
        {::new(std::__1::addressof(*__x_)) <span class="ge">_Tp(_</span>_element); return *this;}




    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) raw_storage_iterator&amp; operator++() {++__x_; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) raw_storage_iterator operator++(int)
        {raw_storage_iterator <span class="gs">__t(*this); ++__</span>x<span class="ge">_; return _</span>_t;}



};

template &lt;class _Tp&gt;
                      <span class="gs">__attribute__</span>((__no_sanitize__(&quot;cfi&quot;)))
pair&lt;_Tp*, ptrdiff_t&gt;
get_temporary_buffer(ptrdiff_t __n) throw()
{
    pair&lt;_Tp*, ptrdiff_t&gt; __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) &lt;&lt; (sizeof(ptrdiff_t) * 8 - 1)))
                           / sizeof(_Tp);
    if (<span class="gs">__n &gt; __</span>m)
        <span class="gs">__n = __</span>m;
    while (__n &gt; 0)
    {
    if (__is_overaligned_for_new(_Alignof(_Tp)))
        {


            return __r;
        }

        __r.first = static_cast&lt;_Tp*&gt;(::operator new(__n * sizeof(_Tp), nothrow));


        if (__r.first)
        {
            <span class="gs">__r.second = __</span>n;
            break;
        }
        __n /= 2;
    }
    return __r;
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void return_temporary_buffer(_Tp* __p) throw()
{
  std::__1::__libcpp_deallocate_unsized((void*)__p, <span class="ge">_Alignof(_</span>Tp));
}


template &lt;class _Tp&gt;
struct auto_ptr_ref
{
    <span class="ge">_Tp* __ptr_</span>;
};

template&lt;class _Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) auto_ptr
{
private:
    <span class="ge">_Tp* __ptr_</span>;
public:
    typedef <span class="ge">_Tp element_</span>type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit auto_ptr(_Tp* <span class="gs">__p = 0) throw() : __</span>ptr_(__p) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) auto_ptr(auto_ptr&amp; <span class="gs">__p) throw() : __</span>ptr_(__p.release()) {}
    template&lt;class <span class="ge">_Up&gt; __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) auto_ptr(auto_ptr&lt;_Up&gt;&amp; __p) throw()
        : __ptr_(__p.release()) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) auto_ptr&amp; operator=(auto_ptr&amp; __p) throw()
        {reset(__p.release()); return *this;}
    template&lt;class <span class="ge">_Up&gt; __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) auto_ptr&amp; operator=(auto_ptr&lt;_Up&gt;&amp; __p) throw()
        {reset(__p.release()); return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) auto_ptr&amp; operator=(auto_ptr_ref&lt;_Tp&gt; __p) throw()
        {reset(__p.__ptr_); return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ~auto_ptr() throw() {delete __ptr_;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) _Tp&amp; operator*() const throw()
        {return *__ptr_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="ge">_Tp* operator-&gt;() const throw() {return __ptr_</span>;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="ge">_Tp* get() const throw() {return __ptr_</span>;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) _Tp* release() throw()
    {
        <span class="ge">_Tp* __t = __ptr_</span>;
        __ptr_ = 0;
        return __t;
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void reset(_Tp* __p = 0) throw()
    {
        if (__ptr_ != __p)
            delete __ptr_;
        __ptr_ = __p;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) auto_ptr(auto_ptr_ref&lt;_Tp&gt; <span class="gs">__p) throw() : __</span>ptr_(__p.__ptr_) {}
    template&lt;class <span class="ge">_Up&gt; __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) operator auto_ptr_ref&lt;_Up&gt;() throw()
        {auto_ptr_ref&lt;_Up&gt; <span class="gs">__t; __</span>t.__ptr_ = release(); return __t;}
    template&lt;class <span class="ge">_Up&gt; __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) operator auto_ptr&lt;_Up&gt;() throw()
        {return auto_ptr&lt;_Up&gt;(release());}
};

template &lt;&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) auto_ptr&lt;void&gt;
{
public:
    typedef void element_type;
};



struct __default_init_tag {};
struct __value_init_tag {};

template &lt;class <span class="ge">_Tp, int _</span>Idx,
          bool _CanBeEmptyBase =
              is_empty&lt;_Tp&gt;::value &amp;&amp; !__libcpp_is_final&lt;_Tp&gt;::value&gt;
struct __compressed_pair_elem {
  typedef <span class="ge">_Tp _</span>ParamT;
  typedef _Tp&amp; reference;
  typedef const <span class="ge">_Tp&amp; const_</span>reference;

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  __compressed_pair_elem(__default_init_tag) {}
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  __compressed_pair_elem(__value_init_tag) : __value_() {}

  template &lt;class <span class="ge">_Up, class = typename enable_</span>if&lt;
      !is_same&lt;__compressed_pair_elem, typename decay&lt;_Up&gt;::type&gt;::value
  &gt;::type&gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                    explicit
  __compressed_pair_elem(_Up&amp;&amp; __u)
      : __value_(std::__1::forward&lt;_Up&gt;(__u))
    {
    }
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) reference <span class="gs">__get() throw() { return __</span>value_; }
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  const_reference <span class="gs">__get() const throw() { return __</span>value_; }

private:
  <span class="ge">_Tp __value_</span>;
};

template &lt;class <span class="ge">_Tp, int _</span>Idx&gt;
struct __compressed_pair_elem&lt;_Tp, <span class="ge">_Idx, true&gt; : private _</span>Tp {
  typedef <span class="ge">_Tp _</span>ParamT;
  typedef _Tp&amp; reference;
  typedef const <span class="ge">_Tp&amp; const_</span>reference;
  typedef <span class="ge">_Tp __value_</span>type;

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __compressed_pair_elem() = default;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  __compressed_pair_elem(__default_init_tag) {}
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  __compressed_pair_elem(__value_init_tag) : __value_type() {}

  template &lt;class <span class="ge">_Up, class = typename enable_</span>if&lt;
        !is_same&lt;__compressed_pair_elem, typename decay&lt;_Up&gt;::type&gt;::value
  &gt;::type&gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                    explicit
  __compressed_pair_elem(_Up&amp;&amp; __u)
      : __value_type(std::__1::forward&lt;_Up&gt;(__u))
  {}
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) reference __get() throw() { return *this; }
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  const_reference __get() const throw() { return *this; }
};

template &lt;class <span class="ge">_T1, class _</span>T2&gt;
class __compressed_pair : private __compressed_pair_elem&lt;_T1, 0&gt;,
                          private __compressed_pair_elem&lt;_T2, 1&gt; {
  typedef __compressed_pair_elem&lt;_T1, 0&gt; _Base1;
  typedef __compressed_pair_elem&lt;_T2, 1&gt; _Base2;





  <span class="ge">_Static_</span>assert((!is_same&lt;_T1, <span class="ge">_T2&gt;::value), &quot;__compressed_</span>pair cannot be instantated when T1 and T2 are the same type; &quot; &quot;The current implementation is NOT ABI-compatible with the previous &quot; &quot;implementation for this configuration&quot;);




public:
    template &lt;bool _Dummy = true,
      class = typename enable_if&lt;
          __dependent_type&lt;is_default_constructible&lt;_T1&gt;, _Dummy&gt;::value &amp;&amp;
          __dependent_type&lt;is_default_constructible&lt;_T2&gt;, _Dummy&gt;::value
      &gt;::type
<span class="k">  &gt;</span>
<span class="ge">  __attribute__ ((__visibility__(&quot;hidden&quot;))) __attribute__ ((internal_linkage))</span>
                    __compressed_pair() : <span class="ge">_Base1(__value_</span>init_tag()), <span class="ge">_Base2(__value_</span>init_tag()) {}

  template &lt;class <span class="ge">_U1, class _</span>U2&gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  __compressed_pair(_U1&amp;&amp; __t1, <span class="ge">_U2&amp;&amp; _</span>_t2)
      : <span class="ge">_Base1(std::forward&lt;_</span>U1&gt;(__t1)), <span class="ge">_Base2(std::forward&lt;_</span>U2&gt;(__t2)) {}
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  typename _Base1::reference first() throw() {
    return static_cast&lt;_Base1&amp;&gt;(*this).__get();
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  typename <span class="ge">_Base1::const_</span>reference first() const throw() {
    return static_cast&lt;_Base1 const&amp;&gt;(*this).__get();
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  typename _Base2::reference second() throw() {
    return static_cast&lt;_Base2&amp;&gt;(*this).__get();
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  typename <span class="ge">_Base2::const_</span>reference second() const throw() {
    return static_cast&lt;_Base2 const&amp;&gt;(*this).__get();
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  void swap(__compressed_pair&amp; __x)


  {
    using std::swap;
    swap(first(), __x.first());
    swap(second(), __x.second());
  }
};

template &lt;class <span class="ge">_T1, class _</span>T2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void swap(__compressed_pair&lt;_T1, <span class="ge">_T2&gt;&amp; __x, __compressed_</span>pair&lt;_T1, <span class="ge">_T2&gt;&amp; _</span>_y)

                                                   {
  <span class="gs">__x.swap(__</span>y);
}



template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) default_delete {
    <span class="ge">_Static_</span>assert(!is_function&lt;_Tp&gt;::value, &quot;default_delete cannot be instantiated for function types&quot;);




  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) default_delete() {}

  template &lt;class _Up&gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  default_delete(const default_delete&lt;_Up&gt;&amp;,
                 typename enable_if&lt;is_convertible&lt;_Up*, _Tp*&gt;::value&gt;::type* =
                     0) throw() {}

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void operator()(_Tp* __ptr) const throw() {
    <span class="ge">_Static_</span>assert(sizeof(_Tp) &gt; 0, &quot;default_delete can not delete incomplete type&quot;);

    <span class="ge">_Static_</span>assert(!is_void&lt;_Tp&gt;::value, &quot;default_delete can not delete incomplete type&quot;);

    delete __ptr;
  }
};

template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) default_delete&lt;_Tp[]&gt; {
private:
  template &lt;class _Up&gt;
  struct _EnableIfConvertible
      : enable_if&lt;is_convertible&lt;_Up(*)[], _Tp(*)[]&gt;::value&gt; {};

public:



  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) default_delete() {}


  template &lt;class _Up&gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  default_delete(const default_delete&lt;_Up[]&gt;&amp;,
                 typename <span class="ge">_EnableIfConvertible&lt;_</span>Up&gt;::type* = 0) throw() {}

  template &lt;class _Up&gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  typename <span class="ge">_EnableIfConvertible&lt;_</span>Up&gt;::type
  operator()(_Up* __ptr) const throw() {
    <span class="ge">_Static_</span>assert(sizeof(_Tp) &gt; 0, &quot;default_delete can not delete incomplete type&quot;);

    <span class="ge">_Static_</span>assert(!is_void&lt;_Tp&gt;::value, &quot;default_delete can not delete void type&quot;);

    delete[] __ptr;
  }
};

template &lt;class _Deleter&gt;
struct __unique_ptr_deleter_sfinae {
  <span class="ge">_Static_</span>assert(!is_reference&lt;_Deleter&gt;::value, &quot;incorrect specialization&quot;);
  typedef const <span class="ge">_Deleter&amp; __lval_</span>ref_type;
  typedef <span class="ge">_Deleter&amp;&amp; __good_</span>rval_ref_type;
  typedef true_type __enable_rval_overload;
};

template &lt;class _Deleter&gt;
struct __unique_ptr_deleter_sfinae&lt;_Deleter const&amp;&gt; {
  typedef const <span class="ge">_Deleter&amp; __lval_</span>ref_type;
  typedef const <span class="ge">_Deleter&amp;&amp; __bad_</span>rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template &lt;class _Deleter&gt;
struct __unique_ptr_deleter_sfinae&lt;_Deleter&amp;&gt; {
  typedef <span class="ge">_Deleter&amp; __lval_</span>ref_type;
  typedef <span class="ge">_Deleter&amp;&amp; __bad_</span>rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template &lt;class <span class="ge">_Tp, class _</span>Dp = default_delete&lt;_Tp&gt; &gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) unique_ptr {
public:
  typedef <span class="ge">_Tp element_</span>type;
  typedef <span class="ge">_Dp deleter_</span>type;
  typedef typename __pointer_type&lt;_Tp, deleter_type&gt;::type pointer;

  <span class="ge">_Static_</span>assert(!is_rvalue_reference&lt;deleter_type&gt;::value, &quot;the specified deleter type cannot be an rvalue reference&quot;);


private:
  __compressed_pair&lt;pointer, deleter_type&gt; __ptr_;

  struct <span class="gs">__nat { int __</span>for_bool_; };

  typedef __unique_ptr_deleter_sfinae&lt;_Dp&gt; _DeleterSFINAE;

  template &lt;bool _Dummy&gt;
  using _LValRefType =
      typename __dependent_type&lt;_DeleterSFINAE, <span class="ge">_Dummy&gt;::__lval_</span>ref_type;

  template &lt;bool _Dummy&gt;
  using _GoodRValRefType =
      typename __dependent_type&lt;_DeleterSFINAE, <span class="ge">_Dummy&gt;::__good_</span>rval_ref_type;

  template &lt;bool _Dummy&gt;
  using _BadRValRefType =
      typename __dependent_type&lt;_DeleterSFINAE, <span class="ge">_Dummy&gt;::__bad_</span>rval_ref_type;

  template &lt;bool <span class="ge">_Dummy, class _</span>Deleter = typename __dependent_type&lt;
                             __identity&lt;deleter_type&gt;, _Dummy&gt;::type&gt;
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if&lt;is_default_constructible&lt;_Deleter&gt;::value &amp;&amp;
                         !is_pointer&lt;_Deleter&gt;::value&gt;::type;

  template &lt;class _ArgType&gt;
  using _EnableIfDeleterConstructible =
      typename enable_if&lt;is_constructible&lt;deleter_type, _ArgType&gt;::value&gt;::type;

  template &lt;class <span class="ge">_UPtr, class _</span>Up&gt;
  using <span class="ge">_EnableIfMoveConvertible = typename enable_</span>if&lt;
      is_convertible&lt;typename _UPtr::pointer, pointer&gt;::value &amp;&amp;
      !is_array&lt;_Up&gt;::value
  &gt;::type;

  template &lt;class _UDel&gt;
  using <span class="ge">_EnableIfDeleterConvertible = typename enable_</span>if&lt;
      (is_reference&lt;_Dp&gt;::value &amp;&amp; is_same&lt;_Dp, _UDel&gt;::value) ||
      (!is_reference&lt;_Dp&gt;::value &amp;&amp; is_convertible&lt;_UDel, _Dp&gt;::value)
    &gt;::type;

  template &lt;class _UDel&gt;
  using <span class="ge">_EnableIfDeleterAssignable = typename enable_</span>if&lt;
      is_assignable&lt;_Dp&amp;, _UDel&amp;&amp;&gt;::value
    &gt;::type;

public:
  template &lt;bool _Dummy = true,
            class = <span class="ge">_EnableIfDeleterDefaultConstructible&lt;_</span>Dummy&gt; &gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                    unique_ptr() throw() : __ptr_(pointer(), __default_init_tag()) {}

  template &lt;bool _Dummy = true,
            class = <span class="ge">_EnableIfDeleterDefaultConstructible&lt;_</span>Dummy&gt; &gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                    unique_ptr(nullptr_t) throw() : __ptr_(pointer(), __default_init_tag()) {}

  template &lt;bool _Dummy = true,
            class = <span class="ge">_EnableIfDeleterDefaultConstructible&lt;_</span>Dummy&gt; &gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  explicit unique_ptr(pointer <span class="gs">__p) throw() : __</span>ptr_(__p, __default_init_tag()) {}

  template &lt;bool _Dummy = true,
            class = <span class="ge">_EnableIfDeleterConstructible&lt;_</span>LValRefType&lt;_Dummy&gt; &gt; &gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr(pointer __p, <span class="ge">_LValRefType&lt;_</span>Dummy&gt; __d) throw()
      : __ptr_(__p, __d) {}

  template &lt;bool _Dummy = true,
            class = <span class="ge">_EnableIfDeleterConstructible&lt;_</span>GoodRValRefType&lt;_Dummy&gt; &gt; &gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr(pointer __p, <span class="ge">_GoodRValRefType&lt;_</span>Dummy&gt; __d) throw()
      : __ptr_(__p, std::__1::move(__d)) {
    <span class="ge">_Static_</span>assert(!is_reference&lt;deleter_type&gt;::value, &quot;rvalue deleter bound to reference&quot;);

  }

  template &lt;bool _Dummy = true,
            class = <span class="ge">_EnableIfDeleterConstructible&lt;_</span>BadRValRefType&lt;_Dummy&gt; &gt; &gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr(pointer __p, <span class="ge">_BadRValRefType&lt;_</span>Dummy&gt; __d) = delete;

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr(unique_ptr&amp;&amp; __u) throw()
      : __ptr_(__u.release(), std::__1::forward&lt;deleter_type&gt;(__u.get_deleter())) {
  }

  template &lt;class <span class="ge">_Up, class _</span>Ep,
      class = <span class="ge">_EnableIfMoveConvertible&lt;unique_</span>ptr&lt;_Up, <span class="ge">_Ep&gt;, _</span>Up&gt;,
      class = <span class="ge">_EnableIfDeleterConvertible&lt;_</span>Ep&gt;
<span class="k">  &gt;</span>
<span class="ge">  __attribute__ ((__visibility__(&quot;hidden&quot;))) __attribute__ ((internal_linkage))</span>
  unique_ptr(unique_ptr&lt;_Up, <span class="ge">_Ep&gt;&amp;&amp; _</span>_u) throw()
      : __ptr_(__u.release(), std::__1::forward&lt;_Ep&gt;(__u.get_deleter())) {}


  template &lt;class _Up&gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr(auto_ptr&lt;_Up&gt;&amp;&amp; __p,
             typename enable_if&lt;is_convertible&lt;_Up*, _Tp*&gt;::value &amp;&amp;
                                    is_same&lt;_Dp, default_delete&lt;_Tp&gt; &gt;::value,
                                <span class="gs">__nat&gt;::type = __</span>nat()) throw()
      : __ptr_(__p.release(), __default_init_tag()) {}


  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr&amp; operator=(unique_ptr&amp;&amp; __u) throw() {
    reset(__u.release());
    __ptr_.second() = std::__1::forward&lt;deleter_type&gt;(__u.get_deleter());
    return *this;
  }

  template &lt;class <span class="ge">_Up, class _</span>Ep,
      class = <span class="ge">_EnableIfMoveConvertible&lt;unique_</span>ptr&lt;_Up, <span class="ge">_Ep&gt;, _</span>Up&gt;,
      class = <span class="ge">_EnableIfDeleterAssignable&lt;_</span>Ep&gt;
<span class="k">  &gt;</span>
<span class="ge">  __attribute__ ((__visibility__(&quot;hidden&quot;))) __attribute__ ((internal_linkage))</span>
  unique_ptr&amp; operator=(unique_ptr&lt;_Up, <span class="ge">_Ep&gt;&amp;&amp; _</span>_u) throw() {
    reset(__u.release());
    __ptr_.second() = std::__1::forward&lt;_Ep&gt;(__u.get_deleter());
    return *this;
  }


  template &lt;class _Up&gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
      typename enable_if&lt;is_convertible&lt;_Up*, _Tp*&gt;::value &amp;&amp;
                             is_same&lt;_Dp, default_delete&lt;_Tp&gt; &gt;::value,
                         unique_ptr&amp;&gt;::type
      operator=(auto_ptr&lt;_Up&gt; __p) {
    reset(__p.release());
    return *this;
  }



  unique_ptr(unique_ptr const&amp;) = delete;
  unique_ptr&amp; operator=(unique_ptr const&amp;) = delete;



  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  ~unique_ptr() { reset(); }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr&amp; operator=(nullptr_t) throw() {
    reset();
    return *this;
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  typename add_lvalue_reference&lt;_Tp&gt;::type
  operator*() const {
    return *__ptr_.first();
  }
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  pointer operator-&gt;() const throw() {
    return __ptr_.first();
  }
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  pointer get() const throw() {
    return __ptr_.first();
  }
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  deleter_type&amp; get_deleter() throw() {
    return __ptr_.second();
  }
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  const deleter_type&amp; get_deleter() const throw() {
    return __ptr_.second();
  }
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                   operator bool() const throw() {
    return __ptr_.first() != std::__1::__get_nullptr_t();
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  pointer release() throw() {
    pointer <span class="gs">__t = __</span>ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  void reset(pointer __p = pointer()) throw() {
    pointer <span class="gs">__tmp = __</span>ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  void swap(unique_ptr&amp; __u) throw() {
    __ptr_.swap(__u.__ptr_);
  }
};


template &lt;class <span class="ge">_Tp, class _</span>Dp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) unique_ptr&lt;_Tp[], _Dp&gt; {
public:
  typedef <span class="ge">_Tp element_</span>type;
  typedef <span class="ge">_Dp deleter_</span>type;
  typedef typename __pointer_type&lt;_Tp, deleter_type&gt;::type pointer;

private:
  __compressed_pair&lt;pointer, deleter_type&gt; __ptr_;

  template &lt;class _From&gt;
  struct <span class="ge">_CheckArrayPointerConversion : is_</span>same&lt;_From, pointer&gt; {};

  template &lt;class _FromElem&gt;
  struct <span class="ge">_CheckArrayPointerConversion&lt;_</span>FromElem*&gt;
      : integral_constant&lt;bool,
          is_same&lt;_FromElem*, pointer&gt;::value ||
            (is_same&lt;pointer, element_type*&gt;::value &amp;&amp;
             is_convertible&lt;_FromElem(*)[], element_type(*)[]&gt;::value)
<span class="k">      &gt;</span>
<span class="ge">  {};</span>

  typedef __unique_ptr_deleter_sfinae&lt;_Dp&gt; _DeleterSFINAE;

  template &lt;bool _Dummy&gt;
  using _LValRefType =
      typename __dependent_type&lt;_DeleterSFINAE, <span class="ge">_Dummy&gt;::__lval_</span>ref_type;

  template &lt;bool _Dummy&gt;
  using _GoodRValRefType =
      typename __dependent_type&lt;_DeleterSFINAE, <span class="ge">_Dummy&gt;::__good_</span>rval_ref_type;

  template &lt;bool _Dummy&gt;
  using _BadRValRefType =
      typename __dependent_type&lt;_DeleterSFINAE, <span class="ge">_Dummy&gt;::__bad_</span>rval_ref_type;

  template &lt;bool <span class="ge">_Dummy, class _</span>Deleter = typename __dependent_type&lt;
                             __identity&lt;deleter_type&gt;, _Dummy&gt;::type&gt;
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if&lt;is_default_constructible&lt;_Deleter&gt;::value &amp;&amp;
                         !is_pointer&lt;_Deleter&gt;::value&gt;::type;

  template &lt;class _ArgType&gt;
  using _EnableIfDeleterConstructible =
      typename enable_if&lt;is_constructible&lt;deleter_type, _ArgType&gt;::value&gt;::type;

  template &lt;class _Pp&gt;
  using <span class="ge">_EnableIfPointerConvertible = typename enable_</span>if&lt;
      <span class="ge">_CheckArrayPointerConversion&lt;_</span>Pp&gt;::value
  &gt;::type;

  template &lt;class <span class="ge">_UPtr, class _</span>Up,
        class <span class="ge">_ElemT = typename _</span>UPtr::element_type&gt;
  using <span class="ge">_EnableIfMoveConvertible = typename enable_</span>if&lt;
      is_array&lt;_Up&gt;::value &amp;&amp;
      is_same&lt;pointer, element_type*&gt;::value &amp;&amp;
      is_same&lt;typename <span class="ge">_UPtr::pointer, _</span>ElemT*&gt;::value &amp;&amp;
      is_convertible&lt;_ElemT(*)[], element_type(*)[]&gt;::value
    &gt;::type;

  template &lt;class _UDel&gt;
  using <span class="ge">_EnableIfDeleterConvertible = typename enable_</span>if&lt;
      (is_reference&lt;_Dp&gt;::value &amp;&amp; is_same&lt;_Dp, _UDel&gt;::value) ||
      (!is_reference&lt;_Dp&gt;::value &amp;&amp; is_convertible&lt;_UDel, _Dp&gt;::value)
    &gt;::type;

  template &lt;class _UDel&gt;
  using <span class="ge">_EnableIfDeleterAssignable = typename enable_</span>if&lt;
      is_assignable&lt;_Dp&amp;, _UDel&amp;&amp;&gt;::value
    &gt;::type;

public:
  template &lt;bool _Dummy = true,
            class = <span class="ge">_EnableIfDeleterDefaultConstructible&lt;_</span>Dummy&gt; &gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                    unique_ptr() throw() : __ptr_(pointer(), __default_init_tag()) {}

  template &lt;bool _Dummy = true,
            class = <span class="ge">_EnableIfDeleterDefaultConstructible&lt;_</span>Dummy&gt; &gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                    unique_ptr(nullptr_t) throw() : __ptr_(pointer(), __default_init_tag()) {}

  template &lt;class <span class="ge">_Pp, bool _</span>Dummy = true,
            class = <span class="ge">_EnableIfDeleterDefaultConstructible&lt;_</span>Dummy&gt;,
            class = <span class="ge">_EnableIfPointerConvertible&lt;_</span>Pp&gt; &gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  explicit unique_ptr(_Pp __p) throw()
      : __ptr_(__p, __default_init_tag()) {}

  template &lt;class <span class="ge">_Pp, bool _</span>Dummy = true,
            class = <span class="ge">_EnableIfDeleterConstructible&lt;_</span>LValRefType&lt;_Dummy&gt; &gt;,
            class = <span class="ge">_EnableIfPointerConvertible&lt;_</span>Pp&gt; &gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr(_Pp __p, <span class="ge">_LValRefType&lt;_</span>Dummy&gt; __d) throw()
      : __ptr_(__p, __d) {}

  template &lt;bool _Dummy = true,
            class = <span class="ge">_EnableIfDeleterConstructible&lt;_</span>LValRefType&lt;_Dummy&gt; &gt; &gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr(nullptr_t, <span class="ge">_LValRefType&lt;_</span>Dummy&gt; __d) throw()
      : __ptr_(std::__1::__get_nullptr_t(), __d) {}

  template &lt;class <span class="ge">_Pp, bool _</span>Dummy = true,
            class = <span class="ge">_EnableIfDeleterConstructible&lt;_</span>GoodRValRefType&lt;_Dummy&gt; &gt;,
            class = <span class="ge">_EnableIfPointerConvertible&lt;_</span>Pp&gt; &gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr(_Pp __p, <span class="ge">_GoodRValRefType&lt;_</span>Dummy&gt; __d) throw()
      : __ptr_(__p, std::__1::move(__d)) {
    <span class="ge">_Static_</span>assert(!is_reference&lt;deleter_type&gt;::value, &quot;rvalue deleter bound to reference&quot;);

  }

  template &lt;bool _Dummy = true,
            class = <span class="ge">_EnableIfDeleterConstructible&lt;_</span>GoodRValRefType&lt;_Dummy&gt; &gt; &gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr(nullptr_t, <span class="ge">_GoodRValRefType&lt;_</span>Dummy&gt; __d) throw()
      : __ptr_(std::__1::__get_nullptr_t(), std::__1::move(__d)) {
    <span class="ge">_Static_</span>assert(!is_reference&lt;deleter_type&gt;::value, &quot;rvalue deleter bound to reference&quot;);

  }

  template &lt;class <span class="ge">_Pp, bool _</span>Dummy = true,
            class = <span class="ge">_EnableIfDeleterConstructible&lt;_</span>BadRValRefType&lt;_Dummy&gt; &gt;,
            class = <span class="ge">_EnableIfPointerConvertible&lt;_</span>Pp&gt; &gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr(_Pp __p, <span class="ge">_BadRValRefType&lt;_</span>Dummy&gt; __d) = delete;

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr(unique_ptr&amp;&amp; __u) throw()
      : __ptr_(__u.release(), std::__1::forward&lt;deleter_type&gt;(__u.get_deleter())) {
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr&amp; operator=(unique_ptr&amp;&amp; __u) throw() {
    reset(__u.release());
    __ptr_.second() = std::__1::forward&lt;deleter_type&gt;(__u.get_deleter());
    return *this;
  }

  template &lt;class <span class="ge">_Up, class _</span>Ep,
      class = <span class="ge">_EnableIfMoveConvertible&lt;unique_</span>ptr&lt;_Up, <span class="ge">_Ep&gt;, _</span>Up&gt;,
      class = <span class="ge">_EnableIfDeleterConvertible&lt;_</span>Ep&gt;
<span class="k">  &gt;</span>
<span class="ge">  __attribute__ ((__visibility__(&quot;hidden&quot;))) __attribute__ ((internal_linkage))</span>
  unique_ptr(unique_ptr&lt;_Up, <span class="ge">_Ep&gt;&amp;&amp; _</span>_u) throw()
      : __ptr_(__u.release(), std::__1::forward&lt;_Ep&gt;(__u.get_deleter())) {
  }

  template &lt;class <span class="ge">_Up, class _</span>Ep,
      class = <span class="ge">_EnableIfMoveConvertible&lt;unique_</span>ptr&lt;_Up, <span class="ge">_Ep&gt;, _</span>Up&gt;,
      class = <span class="ge">_EnableIfDeleterAssignable&lt;_</span>Ep&gt;
<span class="k">  &gt;</span>
<span class="ge">  __attribute__ ((__visibility__(&quot;hidden&quot;))) __attribute__ ((internal_linkage))</span>
  unique_ptr&amp;
  operator=(unique_ptr&lt;_Up, <span class="ge">_Ep&gt;&amp;&amp; _</span>_u) throw() {
    reset(__u.release());
    __ptr_.second() = std::__1::forward&lt;_Ep&gt;(__u.get_deleter());
    return *this;
  }


  unique_ptr(unique_ptr const&amp;) = delete;
  unique_ptr&amp; operator=(unique_ptr const&amp;) = delete;


public:
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  ~unique_ptr() { reset(); }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  unique_ptr&amp; operator=(nullptr_t) throw() {
    reset();
    return *this;
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  typename add_lvalue_reference&lt;_Tp&gt;::type
  operator[](size_t __i) const {
    return __ptr_.first()[__i];
  }
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  pointer get() const throw() {
    return __ptr_.first();
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  deleter_type&amp; get_deleter() throw() {
    return __ptr_.second();
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  const deleter_type&amp; get_deleter() const throw() {
    return __ptr_.second();
  }
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                   operator bool() const throw() {
    return __ptr_.first() != std::__1::__get_nullptr_t();
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  pointer release() throw() {
    pointer <span class="gs">__t = __</span>ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  template &lt;class _Pp&gt;
  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  typename enable_if&lt;
      <span class="ge">_CheckArrayPointerConversion&lt;_</span>Pp&gt;::value
  &gt;::type
  reset(_Pp __p) throw() {
    pointer <span class="gs">__tmp = __</span>ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  void reset(nullptr_t = std::__1::__get_nullptr_t()) throw() {
    pointer <span class="gs">__tmp = __</span>ptr_.first();
    __ptr_.first() = std::__1::__get_nullptr_t();
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
  void swap(unique_ptr&amp; __u) throw() {
    __ptr_.swap(__u.__ptr_);
  }

};

template &lt;class <span class="ge">_Tp, class _</span>Dp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if&lt;
    __is_swappable&lt;_Dp&gt;::value,
    void
&gt;::type
swap(unique_ptr&lt;_Tp, <span class="ge">_Dp&gt;&amp; __x, unique_</span>ptr&lt;_Tp, <span class="ge">_Dp&gt;&amp; __y) throw() {__x.swap(_</span>_y);}

template &lt;class <span class="ge">_T1, class _</span>D1, class <span class="ge">_T2, class _</span>D2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; __x, const unique_</span>ptr&lt;_T2, <span class="ge">_D2&gt;&amp; __y) {return __x.get() == _</span>_y.get();}

template &lt;class <span class="ge">_T1, class _</span>D1, class <span class="ge">_T2, class _</span>D2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; __x, const unique_</span>ptr&lt;_T2, <span class="ge">_D2&gt;&amp; __y) {return !(__x == _</span>_y);}

template &lt;class <span class="ge">_T1, class _</span>D1, class <span class="ge">_T2, class _</span>D2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt; (const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; __x, const unique_</span>ptr&lt;_T2, <span class="ge">_D2&gt;&amp; _</span>_y)
{
    typedef typename unique_ptr&lt;_T1, <span class="ge">_D1&gt;::pointer _</span>P1;
    typedef typename unique_ptr&lt;_T2, <span class="ge">_D2&gt;::pointer _</span>P2;
    typedef typename common_type&lt;_P1, <span class="ge">_P2&gt;::type _</span>Vp;
    return less&lt;_Vp&gt;()(__x.get(), __y.get());
}

template &lt;class <span class="ge">_T1, class _</span>D1, class <span class="ge">_T2, class _</span>D2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt; (const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; __x, const unique_</span>ptr&lt;_T2, <span class="ge">_D2&gt;&amp; __y) {return __y &lt; _</span>_x;}

template &lt;class <span class="ge">_T1, class _</span>D1, class <span class="ge">_T2, class _</span>D2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; __x, const unique_</span>ptr&lt;_T2, <span class="ge">_D2&gt;&amp; __y) {return !(__y &lt; _</span>_x);}

template &lt;class <span class="ge">_T1, class _</span>D1, class <span class="ge">_T2, class _</span>D2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; __x, const unique_</span>ptr&lt;_T2, <span class="ge">_D2&gt;&amp; __y) {return !(__x &lt; _</span>_y);}

template &lt;class <span class="ge">_T1, class _</span>D1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; __x, nullptr_</span>t) throw()
{
    return !__x;
}

template &lt;class <span class="ge">_T1, class _</span>D1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(nullptr_t, const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; _</span>_x) throw()
{
    return !__x;
}

template &lt;class <span class="ge">_T1, class _</span>D1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; __x, nullptr_</span>t) throw()
{
    return static_cast&lt;bool&gt;(__x);
}

template &lt;class <span class="ge">_T1, class _</span>D1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(nullptr_t, const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; _</span>_x) throw()
{
    return static_cast&lt;bool&gt;(__x);
}

template &lt;class <span class="ge">_T1, class _</span>D1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;(const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; __x, nullptr_</span>t)
{
    typedef typename unique_ptr&lt;_T1, <span class="ge">_D1&gt;::pointer _</span>P1;
    return less&lt;_P1&gt;()(__x.get(), std::__1::__get_nullptr_t());
}

template &lt;class <span class="ge">_T1, class _</span>D1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;(nullptr_t, const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; _</span>_x)
{
    typedef typename unique_ptr&lt;_T1, <span class="ge">_D1&gt;::pointer _</span>P1;
    return less&lt;_P1&gt;()(std::__1::__get_nullptr_t(), __x.get());
}

template &lt;class <span class="ge">_T1, class _</span>D1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;(const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; __x, nullptr_</span>t)
{
    return std::__1::__get_nullptr_t() &lt; __x;
}

template &lt;class <span class="ge">_T1, class _</span>D1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;(nullptr_t, const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; _</span>_x)
{
    return <span class="gs">__x &lt; std::__</span>1::__get_nullptr_t();
}

template &lt;class <span class="ge">_T1, class _</span>D1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; __x, nullptr_</span>t)
{
    return !(std::__1::__get_nullptr_t() &lt; __x);
}

template &lt;class <span class="ge">_T1, class _</span>D1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(nullptr_t, const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; _</span>_x)
{
    return !(__x &lt; std::__1::__get_nullptr_t());
}

template &lt;class <span class="ge">_T1, class _</span>D1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; __x, nullptr_</span>t)
{
    return !(__x &lt; std::__1::__get_nullptr_t());
}

template &lt;class <span class="ge">_T1, class _</span>D1&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(nullptr_t, const unique_ptr&lt;_T1, <span class="ge">_D1&gt;&amp; _</span>_x)
{
    return !(std::__1::__get_nullptr_t() &lt; __x);
}
template &lt;class <span class="ge">_Tp, class _</span>Dp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;unique_ptr&lt;_Tp, _Dp&gt; &gt;




{
    typedef unique_ptr&lt;_Tp, <span class="ge">_Dp&gt; argument_</span>type;
    typedef size_t result_type;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    result_type operator()(const argument_type&amp; __ptr) const
    {
        typedef typename argument_type::pointer pointer;
        return hash&lt;pointer&gt;()(__ptr.get());
    }
};

struct __destruct_n
{
private:
    size_t __size_;

    template &lt;class _Tp&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __process(_Tp* __p, false_type) throw()
        {for (size_t <span class="gs">__i = 0; __</span>i &lt; __size_; ++__i, ++__p) __p-&gt;~_Tp();}

    template &lt;class _Tp&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __process(_Tp*, true_type) throw()
        {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __incr(false_type) throw()
        {++__size_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __incr(true_type) throw()
        {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __set(size_t __s, false_type) throw()
        {__size_ = __s;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __set(size_t, true_type) throw()
        {}
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit __destruct_n(size_t __s) throw()
        : __size_(__s) {}

    template &lt;class _Tp&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __incr(_Tp*) throw()
        {__incr(integral_constant&lt;bool, is_trivially_destructible&lt;_Tp&gt;::value&gt;());}

    template &lt;class _Tp&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __set(size_t __s, _Tp*) throw()
        {<span class="gs">__set(__</span>s, integral_constant&lt;bool, is_trivially_destructible&lt;_Tp&gt;::value&gt;());}

    template &lt;class _Tp&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void operator()(_Tp* __p) throw()
        {<span class="gs">__process(__</span>p, integral_constant&lt;bool, is_trivially_destructible&lt;_Tp&gt;::value&gt;());}
};

template &lt;class _Alloc&gt;
class __allocator_destructor
{
    typedef allocator_traits&lt;_Alloc&gt; __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::size_type size_type;
private:
    <span class="ge">_Alloc&amp; __alloc_</span>;
    size_type __s_;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __allocator_destructor(_Alloc&amp; __a, size_type __s)
             throw()
        : __alloc_(__a), __s_(__s) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void operator()(pointer __p) throw()
        {__alloc_traits::deallocate(__alloc_, <span class="gs">__p, __</span>s_);}
};

template &lt;class <span class="ge">_InputIterator, class _</span>ForwardIterator&gt;
_ForwardIterator
uninitialized_copy(_InputIterator __f, <span class="ge">_InputIterator __l, _</span>ForwardIterator __r)
{
    typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type value_type;

    <span class="ge">_ForwardIterator __s = _</span>_r;
    try
    {

        for (; <span class="gs">__f != __</span>l; ++__f, (void) ++__r)
            ::new (static_cast&lt;void*&gt;(std::__1::addressof(*__r))) value_type(*__f);

    }
    catch (...)
    {
        for (; <span class="gs">__s != __</span>r; ++__s)
            __s-&gt;~value_type();
        throw;
    }

    return __r;
}

template &lt;class <span class="ge">_InputIterator, class _</span>Size, class _ForwardIterator&gt;
_ForwardIterator
uninitialized_copy_n(_InputIterator __f, <span class="ge">_Size __n, _</span>ForwardIterator __r)
{
    typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type value_type;

    <span class="ge">_ForwardIterator __s = _</span>_r;
    try
    {

        for (; <span class="gs">__n &gt; 0; ++__</span>f, (void) ++__r, (void) --__n)
            ::new (static_cast&lt;void*&gt;(std::__1::addressof(*__r))) value_type(*__f);

    }
    catch (...)
    {
        for (; <span class="gs">__s != __</span>r; ++__s)
            __s-&gt;~value_type();
        throw;
    }

    return __r;
}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Tp&gt;
void
uninitialized_fill(_ForwardIterator __f, <span class="ge">_ForwardIterator __l, const _</span>Tp&amp; __x)
{
    typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type value_type;

    <span class="ge">_ForwardIterator __s = _</span>_f;
    try
    {

        for (; <span class="gs">__f != __</span>l; ++__f)
            ::new (static_cast&lt;void*&gt;(std::__1::addressof(*__f))) value_type(__x);

    }
    catch (...)
    {
        for (; <span class="gs">__s != __</span>f; ++__s)
            __s-&gt;~value_type();
        throw;
    }

}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Size, class _Tp&gt;
_ForwardIterator
uninitialized_fill_n(_ForwardIterator __f, <span class="ge">_Size __n, const _</span>Tp&amp; __x)
{
    typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type value_type;

    <span class="ge">_ForwardIterator __s = _</span>_f;
    try
    {

        for (; <span class="gs">__n &gt; 0; ++__</span>f, (void) --__n)
            ::new (static_cast&lt;void*&gt;(std::__1::addressof(*__f))) value_type(__x);

    }
    catch (...)
    {
        for (; <span class="gs">__s != __</span>f; ++__s)
            __s-&gt;~value_type();
        throw;
    }

    return __f;
}
template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) _Tp
__libcpp_atomic_refcount_increment(_Tp&amp; __t) throw()
{

    return __atomic_add_fetch(&amp;__t, 1, 0);



}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) _Tp
__libcpp_atomic_refcount_decrement(_Tp&amp; __t) throw()
{

    return __atomic_add_fetch(&amp;__t, -1, 4);



}

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bad_weak_ptr
    : public std::exception
{
public:
    virtual ~bad_weak_ptr() throw();
    virtual const char* what() const throw();
};

<span class="gs">__attribute__</span> ((noreturn)) inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __throw_bad_weak_ptr()
{

    throw bad_weak_ptr();



}

template&lt;class <span class="ge">_Tp&gt; class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) weak_ptr;

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __shared_count
{
    __shared_count(const __shared_count&amp;);
    __shared_count&amp; operator=(const __shared_count&amp;);

protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() throw() = 0;

public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit __shared_count(long __refs = 0) throw()
        : __shared_owners_(__refs) {}






    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __add_shared() throw() {
      __libcpp_atomic_refcount_increment(__shared_owners_);
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool __release_shared() throw() {
      if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {
        __on_zero_shared();
        return true;
      }
      return false;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    long use_count() const throw() {
        return __libcpp_relaxed_load(&amp;__shared_owners_) + 1;
    }
};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit __shared_weak_count(long __refs = 0) throw()
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    virtual ~__shared_weak_count();

public:






    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __add_shared() throw() {
      __shared_count::__add_shared();
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __add_weak() throw() {
      __libcpp_atomic_refcount_increment(__shared_weak_owners_);
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __release_shared() throw() {
      if (__shared_count::__release_shared())
        __release_weak();
    }

    void __release_weak() throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    long use_count() const throw() {return __shared_count::use_count();}
    __shared_weak_count* lock() throw();






    virtual const void* __get_deleter(const type_info&amp;) const throw();

private:
    virtual void __on_zero_shared_weak() throw() = 0;
};

template &lt;class <span class="ge">_Tp, class _</span>Dp, class _Alloc&gt;
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair&lt;__compressed_pair&lt;_Tp, <span class="ge">_Dp&gt;, _</span>Alloc&gt; __data_;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __shared_ptr_pointer(_Tp __p, <span class="ge">_Dp __d, _</span>Alloc __a)
        : __data_(__compressed_pair&lt;_Tp, <span class="ge">_Dp&gt;(__p, std::__1::move(__d)), std::__1::move(_</span>_a)) {}


    virtual const void* __get_deleter(const type_info&amp;) const throw();


private:
    virtual void __on_zero_shared() throw();
    virtual void __on_zero_shared_weak() throw();
};



template &lt;class <span class="ge">_Tp, class _</span>Dp, class _Alloc&gt;
const void*
__shared_ptr_pointer&lt;_Tp, <span class="ge">_Dp, _</span>Alloc&gt;::__get_deleter(const type_info&amp; __t) const throw()
{
    return __t == typeid(_Dp) ? std::__1::addressof(__data_.first().second()) : std::__1::__get_nullptr_t();
}



template &lt;class <span class="ge">_Tp, class _</span>Dp, class _Alloc&gt;
void
__shared_ptr_pointer&lt;_Tp, <span class="ge">_Dp, _</span>Alloc&gt;::__on_zero_shared() throw()
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}

template &lt;class <span class="ge">_Tp, class _</span>Dp, class _Alloc&gt;
void
__shared_ptr_pointer&lt;_Tp, <span class="ge">_Dp, _</span>Alloc&gt;::__on_zero_shared_weak() throw()
{
    typedef typename __allocator_traits_rebind&lt;_Alloc, __shared_ptr_pointer&gt;::type _Al;
    typedef allocator_traits&lt;_Al&gt; _ATraits;
    typedef pointer_traits&lt;typename <span class="ge">_ATraits::pointer&gt; _</span>PTraits;

    <span class="ge">_Al __a(__data_</span>.second());
    __data_.second().~_Alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template &lt;class <span class="ge">_Tp, class _</span>Alloc&gt;
class __shared_ptr_emplace
    : public __shared_weak_count
{
    __compressed_pair&lt;_Alloc, <span class="ge">_Tp&gt; __data_</span>;
public:

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __shared_ptr_emplace(_Alloc __a)
        : __data_(std::__1::move(__a), __value_init_tag()) {}
    template &lt;class _A0&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        __shared_ptr_emplace(_Alloc __a, <span class="ge">_A0&amp; _</span>_a0)
            : __data_(__a, <span class="ge">_Tp(_</span>_a0)) {}

    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        __shared_ptr_emplace(_Alloc __a, <span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1)
            : __data_(__a, <span class="ge">_Tp(__a0, _</span>_a1)) {}

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        __shared_ptr_emplace(_Alloc __a, <span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1, <span class="ge">_A2&amp; _</span>_a2)
            : __data_(__a, <span class="ge">_Tp(__a0, __a1, _</span>_a2)) {}



private:
    virtual void __on_zero_shared() throw();
    virtual void __on_zero_shared_weak() throw();
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp* get() throw() {return std::__1::addressof(__data_</span>.second());}
};

template &lt;class <span class="ge">_Tp, class _</span>Alloc&gt;
void
__shared_ptr_emplace&lt;_Tp, <span class="ge">_Alloc&gt;::__on_</span>zero_shared() throw()
{
    __data_.second().~_Tp();
}

template &lt;class <span class="ge">_Tp, class _</span>Alloc&gt;
void
__shared_ptr_emplace&lt;_Tp, <span class="ge">_Alloc&gt;::__on_</span>zero_shared_weak() throw()
{
    typedef typename __allocator_traits_rebind&lt;_Alloc, __shared_ptr_emplace&gt;::type _Al;
    typedef allocator_traits&lt;_Al&gt; _ATraits;
    typedef pointer_traits&lt;typename <span class="ge">_ATraits::pointer&gt; _</span>PTraits;
    <span class="ge">_Al __a(__data_</span>.first());
    __data_.first().~_Alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

struct __shared_ptr_dummy_rebind_allocator_type;
template &lt;&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) allocator&lt;__shared_ptr_dummy_rebind_allocator_type&gt;
{
public:
    template &lt;class _Other&gt;
    struct rebind
    {
        typedef allocator&lt;_Other&gt; other;
    };
};

template&lt;class <span class="ge">_Tp&gt; class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) enable_shared_from_this;

template&lt;class _Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) shared_ptr
{
public:
    typedef <span class="ge">_Tp element_</span>type;




private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

    struct <span class="gs">__nat {int __</span>for_bool_;};
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                      shared_ptr() throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                      shared_ptr(nullptr_t) throw();
    template&lt;class _Yp&gt;
        explicit shared_ptr(_Yp* __p,
                            typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, <span class="gs">__nat&gt;::type = __</span>nat());
    template&lt;class <span class="ge">_Yp, class _</span>Dp&gt;
        shared_ptr(_Yp* __p, <span class="ge">_Dp _</span>_d,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, <span class="gs">__nat&gt;::type = __</span>nat());
    template&lt;class <span class="ge">_Yp, class _</span>Dp, class _Alloc&gt;
        shared_ptr(_Yp* __p, <span class="ge">_Dp __d, _</span>Alloc __a,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, <span class="gs">__nat&gt;::type = __</span>nat());
    template &lt;class <span class="ge">_Dp&gt; shared_</span>ptr(nullptr_t __p, <span class="ge">_Dp _</span>_d);
    template &lt;class <span class="ge">_Dp, class _</span>Alloc&gt; shared_ptr(nullptr_t __p, <span class="ge">_Dp __d, _</span>Alloc __a);
    template&lt;class <span class="ge">_Yp&gt; __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) shared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r, element_type* __p) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    shared_ptr(const shared_ptr&amp; __r) throw();
    template&lt;class _Yp&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        shared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, <span class="gs">__nat&gt;::type = __</span>nat())
                       throw();







    template&lt;class <span class="ge">_Yp&gt; explicit shared_</span>ptr(const weak_ptr&lt;_Yp&gt;&amp; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, <span class="gs">__nat&gt;::type= __</span>nat());






    template&lt;class _Yp&gt;
        shared_ptr(auto_ptr&lt;_Yp&gt; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, <span class="gs">__nat&gt;::type = __</span>nat());
    template &lt;class <span class="ge">_Yp, class _</span>Dp&gt;
        shared_ptr(unique_ptr&lt;_Yp, _Dp&gt;,
                   typename enable_if
                   &lt;
                       !is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;
                       !is_array&lt;_Yp&gt;::value &amp;&amp;
                       is_convertible&lt;typename unique_ptr&lt;_Yp, <span class="ge">_Dp&gt;::pointer, element_</span>type*&gt;::value,
                       __nat
                   &gt;::type = __nat());
    template &lt;class <span class="ge">_Yp, class _</span>Dp&gt;
        shared_ptr(unique_ptr&lt;_Yp, _Dp&gt;,
                   typename enable_if
                   &lt;
                       is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;
                       !is_array&lt;_Yp&gt;::value &amp;&amp;
                       is_convertible&lt;typename unique_ptr&lt;_Yp, <span class="ge">_Dp&gt;::pointer, element_</span>type*&gt;::value,
                       __nat
                   &gt;::type = __nat());


    ~shared_ptr();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    shared_ptr&amp; operator=(const shared_ptr&amp; __r) throw();
    template&lt;class _Yp&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            shared_ptr&amp;
        &gt;::type
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        operator=(const shared_ptr&lt;_Yp&gt;&amp; __r) throw();
    template&lt;class _Yp&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        typename enable_if
        &lt;
            !is_array&lt;_Yp&gt;::value &amp;&amp;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            shared_ptr&amp;
        &gt;::type
        operator=(auto_ptr&lt;_Yp&gt; __r);


    template &lt;class <span class="ge">_Yp, class _</span>Dp&gt;
        typename enable_if
        &lt;
            !is_array&lt;_Yp&gt;::value &amp;&amp;
            is_convertible&lt;typename unique_ptr&lt;_Yp, <span class="ge">_Dp&gt;::pointer, element_</span>type*&gt;::value,
            shared_ptr&amp;
        &gt;::type




        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        operator=(unique_ptr&lt;_Yp, <span class="ge">_Dp&gt; _</span>_r);


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void swap(shared_ptr&amp; __r) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void reset() throw();
    template&lt;class _Yp&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            void
        &gt;::type
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        reset(_Yp* __p);
    template&lt;class <span class="ge">_Yp, class _</span>Dp&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            void
        &gt;::type
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        reset(_Yp* __p, <span class="ge">_Dp _</span>_d);
    template&lt;class <span class="ge">_Yp, class _</span>Dp, class _Alloc&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            void
        &gt;::type
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        reset(_Yp* __p, <span class="ge">_Dp __d, _</span>Alloc __a);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    element_type* get() const throw() {return __ptr_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename add_lvalue_reference&lt;element_type&gt;::type operator*() const throw()
        {return *__ptr_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    element_type* operator-&gt;() const throw() {return __ptr_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    long use_count() const throw() {return __cntrl_ ? __cntrl_-&gt;use_count() : 0;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool unique() const throw() {return use_count() == 1;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                     operator bool() const throw() {return get() != 0;}
    template &lt;class _Up&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        bool owner_before(shared_ptr&lt;_Up&gt; const&amp; __p) const throw()
        {return __cntrl_ &lt; <span class="gs">__p.__</span>cntrl_;}
    template &lt;class _Up&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        bool owner_before(weak_ptr&lt;_Up&gt; const&amp; __p) const throw()
        {return __cntrl_ &lt; <span class="gs">__p.__</span>cntrl_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool
    __owner_equivalent(const shared_ptr&amp; __p) const
        {return __cntrl_ == <span class="gs">__p.__</span>cntrl_;}


    template &lt;class _Dp&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        <span class="ge">_Dp* __get_</span>deleter() const throw()
            {return static_cast&lt;_Dp*&gt;(__cntrl_
                    ? const_cast&lt;void *&gt;(__cntrl_-&gt;__get_deleter(typeid(_Dp)))
                      : std::__1::__get_nullptr_t());}


    template&lt;class <span class="ge">_Yp, class _</span>CntrlBlk&gt;
    static shared_ptr&lt;_Tp&gt;
    __create_with_control_block(_Yp* __p, <span class="ge">_CntrlBlk* _</span>_cntrl)
    {
        shared_ptr&lt;_Tp&gt; __r;
        <span class="gs">__r.__</span>ptr_ = __p;
        <span class="gs">__r.__</span>cntrl_ = __cntrl;
        <span class="gs">__r.__</span>enable_weak_this(__r.__ptr_, <span class="gs">__r.__</span>ptr_);
        return __r;
    }

    template&lt;class <span class="ge">_Alloc, class ..._</span>Args&gt;
        static
        shared_ptr&lt;_Tp&gt;
        allocate_shared(const <span class="ge">_Alloc&amp; __a, _</span>Args&amp;&amp; ...__args);

private:
    template &lt;class <span class="ge">_Yp, bool = is_</span>function&lt;_Yp&gt;::value&gt;
        struct __shared_ptr_default_allocator
        {
            typedef allocator&lt;_Yp&gt; type;
        };

    template &lt;class _Yp&gt;
        struct __shared_ptr_default_allocator&lt;_Yp, true&gt;
        {
            typedef allocator&lt;__shared_ptr_dummy_rebind_allocator_type&gt; type;
        };

    template &lt;class <span class="ge">_Yp, class _</span>OrigPtr&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        typename enable_if&lt;is_convertible&lt;_OrigPtr*,
                                          const enable_shared_from_this&lt;_Yp&gt;*
        &gt;::value,
            void&gt;::type
        __enable_weak_this(const enable_shared_from_this&lt;_Yp&gt;* __e,
                           <span class="ge">_OrigPtr* _</span>_ptr) throw()
        {
            typedef typename remove_cv&lt;_Yp&gt;::type _RawYp;
            if (<span class="gs">__e &amp;&amp; __</span>e-&gt;__weak_this_.expired())
            {
                <span class="gs">__e-&gt;__</span>weak_this_ = shared_ptr&lt;_RawYp&gt;(*this,
                    const_cast&lt;_RawYp*&gt;(static_cast&lt;const <span class="ge">_Yp*&gt;(_</span>_ptr)));
            }
        }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __enable_weak_this(...) throw() {}

    template &lt;class <span class="ge">_Up&gt; friend class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) shared_ptr;
    template &lt;class <span class="ge">_Up&gt; friend class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) weak_ptr;
};


template&lt;class _Tp&gt;
inline

shared_ptr&lt;_Tp&gt;::shared_ptr() throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template&lt;class _Tp&gt;
inline

shared_ptr&lt;_Tp&gt;::shared_ptr(nullptr_t) throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template&lt;class _Tp&gt;
template&lt;class _Yp&gt;
shared_ptr&lt;_Tp&gt;::shared_ptr(_Yp* __p,
                            typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)
    : __ptr_(__p)
{
    unique_ptr&lt;_Yp&gt; <span class="gs">__hold(__</span>p);
    typedef typename __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;
    typedef __shared_ptr_pointer&lt;_Yp*, default_delete&lt;_Yp&gt;, <span class="ge">_AllocT &gt; _</span>CntrlBlk;
    __cntrl_ = new <span class="ge">_CntrlBlk(__p, default_</span>delete&lt;_Yp&gt;(), _AllocT());
    __hold.release();
    __enable_weak_this(__p, __p);
}

template&lt;class _Tp&gt;
template&lt;class <span class="ge">_Yp, class _</span>Dp&gt;
shared_ptr&lt;_Tp&gt;::shared_ptr(_Yp* __p, <span class="ge">_Dp _</span>_d,
                            typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)
    : __ptr_(__p)
{

    try
    {

        typedef typename __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;
        typedef __shared_ptr_pointer&lt;_Yp*, <span class="ge">_Dp, _</span>AllocT &gt; _CntrlBlk;
        __cntrl_ = new <span class="ge">_CntrlBlk(__p, __d, _</span>AllocT());
        __enable_weak_this(__p, __p);

    }
    catch (...)
    {
        <span class="gs">__d(__</span>p);
        throw;
    }

}

template&lt;class _Tp&gt;
template&lt;class _Dp&gt;
shared_ptr&lt;_Tp&gt;::shared_ptr(nullptr_t __p, <span class="ge">_Dp _</span>_d)
    : __ptr_(0)
{

    try
    {

        typedef typename __shared_ptr_default_allocator&lt;_Tp&gt;::type _AllocT;
        typedef __shared_ptr_pointer&lt;nullptr_t, <span class="ge">_Dp, _</span>AllocT &gt; _CntrlBlk;
        __cntrl_ = new <span class="ge">_CntrlBlk(__p, __d, _</span>AllocT());

    }
    catch (...)
    {
        <span class="gs">__d(__</span>p);
        throw;
    }

}

template&lt;class _Tp&gt;
template&lt;class <span class="ge">_Yp, class _</span>Dp, class _Alloc&gt;
shared_ptr&lt;_Tp&gt;::shared_ptr(_Yp* __p, <span class="ge">_Dp __d, _</span>Alloc __a,
                            typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)
    : __ptr_(__p)
{

    try
    {

        typedef __shared_ptr_pointer&lt;_Yp*, <span class="ge">_Dp, _</span>Alloc&gt; _CntrlBlk;
        typedef typename __allocator_traits_rebind&lt;_Alloc, <span class="ge">_CntrlBlk&gt;::type _</span>A2;
        typedef __allocator_destructor&lt;_A2&gt; _D2;
        <span class="ge">_A2 __a2(_</span>_a);
        unique_ptr&lt;_CntrlBlk, <span class="ge">_D2&gt; __hold2(__a2.allocate(1), _</span>D2(__a2, 1));
        ::new(static_cast&lt;void*&gt;(std::__1::addressof(*__hold2.get())))
            <span class="ge">_CntrlBlk(__p, __d, _</span>_a);
        __cntrl_ = std::__1::addressof(*__hold2.release());
        __enable_weak_this(__p, __p);

    }
    catch (...)
    {
        <span class="gs">__d(__</span>p);
        throw;
    }

}

template&lt;class _Tp&gt;
template&lt;class <span class="ge">_Dp, class _</span>Alloc&gt;
shared_ptr&lt;_Tp&gt;::shared_ptr(nullptr_t __p, <span class="ge">_Dp __d, _</span>Alloc __a)
    : __ptr_(0)
{

    try
    {

        typedef __shared_ptr_pointer&lt;nullptr_t, <span class="ge">_Dp, _</span>Alloc&gt; _CntrlBlk;
        typedef typename __allocator_traits_rebind&lt;_Alloc, <span class="ge">_CntrlBlk&gt;::type _</span>A2;
        typedef __allocator_destructor&lt;_A2&gt; _D2;
        <span class="ge">_A2 __a2(_</span>_a);
        unique_ptr&lt;_CntrlBlk, <span class="ge">_D2&gt; __hold2(__a2.allocate(1), _</span>D2(__a2, 1));
        ::new(static_cast&lt;void*&gt;(std::__1::addressof(*__hold2.get())))
            <span class="ge">_CntrlBlk(__p, __d, _</span>_a);
        __cntrl_ = std::__1::addressof(*__hold2.release());

    }
    catch (...)
    {
        <span class="gs">__d(__</span>p);
        throw;
    }

}

template&lt;class _Tp&gt;
template&lt;class _Yp&gt;
inline
shared_ptr&lt;_Tp&gt;::shared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r, element_type *__p) throw()
    : __ptr_(__p),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_-&gt;__add_shared();
}

template&lt;class _Tp&gt;
inline
shared_ptr&lt;_Tp&gt;::shared_ptr(const shared_ptr&amp; __r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_-&gt;__add_shared();
}

template&lt;class _Tp&gt;
template&lt;class _Yp&gt;
inline
shared_ptr&lt;_Tp&gt;::shared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r,
                            typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)
         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_-&gt;__add_shared();
}
template&lt;class _Tp&gt;
template&lt;class _Yp&gt;



shared_ptr&lt;_Tp&gt;::shared_ptr(auto_ptr&lt;_Yp&gt; __r,

                            typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer&lt;_Yp*, default_delete&lt;_Yp&gt;, allocator&lt;_Yp&gt; &gt; _CntrlBlk;
    __cntrl_ = new <span class="ge">_CntrlBlk(__r.get(), default_</span>delete&lt;_Yp&gt;(), allocator&lt;_Yp&gt;());
    __enable_weak_this(__r.get(), __r.get());
    __r.release();
}


template&lt;class _Tp&gt;
template &lt;class <span class="ge">_Yp, class _</span>Dp&gt;



shared_ptr&lt;_Tp&gt;::shared_ptr(unique_ptr&lt;_Yp, <span class="ge">_Dp&gt; _</span>_r,

                            typename enable_if
                            &lt;
                                !is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;
                                !is_array&lt;_Yp&gt;::value &amp;&amp;
                                is_convertible&lt;typename unique_ptr&lt;_Yp, <span class="ge">_Dp&gt;::pointer, element_</span>type*&gt;::value,
                                __nat
                            &gt;::type)
    : __ptr_(__r.get())
{





    {
        typedef typename __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;
        typedef __shared_ptr_pointer&lt;_Yp*, <span class="ge">_Dp, _</span>AllocT &gt; _CntrlBlk;
        __cntrl_ = new <span class="ge">_CntrlBlk(__r.get(), __r.get_</span>deleter(), _AllocT());
        __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
}

template&lt;class _Tp&gt;
template &lt;class <span class="ge">_Yp, class _</span>Dp&gt;



shared_ptr&lt;_Tp&gt;::shared_ptr(unique_ptr&lt;_Yp, <span class="ge">_Dp&gt; _</span>_r,

                            typename enable_if
                            &lt;
                                is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;
                                !is_array&lt;_Yp&gt;::value &amp;&amp;
                                is_convertible&lt;typename unique_ptr&lt;_Yp, <span class="ge">_Dp&gt;::pointer, element_</span>type*&gt;::value,
                                __nat
                            &gt;::type)
    : __ptr_(__r.get())
{





    {
        typedef typename __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;
        typedef __shared_ptr_pointer&lt;_Yp*,
                                     reference_wrapper&lt;typename remove_reference&lt;_Dp&gt;::type&gt;,
                                     <span class="ge">_AllocT &gt; _</span>CntrlBlk;
        __cntrl_ = new <span class="ge">_CntrlBlk(__r.get(), ref(__r.get_</span>deleter()), _AllocT());
        __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
}

template&lt;class _Tp&gt;
template&lt;class <span class="ge">_Alloc, class ..._</span>Args&gt;
shared_ptr&lt;_Tp&gt;
shared_ptr&lt;_Tp&gt;::allocate_shared(const <span class="ge">_Alloc&amp; __a, _</span>Args&amp;&amp; ...__args)
{
    <span class="ge">_Static_</span>assert(is_constructible&lt;_Tp, <span class="ge">_Args...&gt;::value, &quot;Can&#39;t construct object in allocate_</span>shared&quot;);
    typedef __shared_ptr_emplace&lt;_Tp, <span class="ge">_Alloc&gt; _</span>CntrlBlk;
    typedef typename __allocator_traits_rebind&lt;_Alloc, <span class="ge">_CntrlBlk&gt;::type _</span>A2;
    typedef __allocator_destructor&lt;_A2&gt; _D2;
    <span class="ge">_A2 __a2(_</span>_a);
    unique_ptr&lt;_CntrlBlk, <span class="ge">_D2&gt; __hold2(__a2.allocate(1), _</span>D2(__a2, 1));
    ::new(static_cast&lt;void*&gt;(std::__1::addressof(*__hold2.get())))
        <span class="ge">_CntrlBlk(__a, std::__1::forward&lt;_</span>Args&gt;(__args)...);
    shared_ptr&lt;_Tp&gt; __r;
    <span class="gs">__r.__</span>ptr_ = __hold2.get()-&gt;get();
    <span class="gs">__r.__</span>cntrl_ = std::__1::addressof(*__hold2.release());
    <span class="gs">__r.__</span>enable_weak_this(__r.__ptr_, <span class="gs">__r.__</span>ptr_);
    return __r;
}

template&lt;class _Tp&gt;
shared_ptr&lt;_Tp&gt;::~shared_ptr()
{
    if (__cntrl_)
        __cntrl_-&gt;__release_shared();
}

template&lt;class _Tp&gt;
inline
shared_ptr&lt;_Tp&gt;&amp;
shared_ptr&lt;_Tp&gt;::operator=(const shared_ptr&amp; __r) throw()
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template&lt;class _Tp&gt;
template&lt;class _Yp&gt;
inline
typename enable_if
&lt;
    is_convertible&lt;_Yp*, typename shared_ptr&lt;_Tp&gt;::element_type*&gt;::value,
    shared_ptr&lt;_Tp&gt;&amp;
&gt;::type
shared_ptr&lt;_Tp&gt;::operator=(const shared_ptr&lt;_Yp&gt;&amp; __r) throw()
{
    shared_ptr(__r).swap(*this);
    return *this;
}
template&lt;class _Tp&gt;
template&lt;class _Yp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    !is_array&lt;_Yp&gt;::value &amp;&amp;
    is_convertible&lt;_Yp*, typename shared_ptr&lt;_Tp&gt;::element_type*&gt;::value,
    shared_ptr&lt;_Tp&gt;&amp;
&gt;::type
shared_ptr&lt;_Tp&gt;::operator=(auto_ptr&lt;_Yp&gt; __r)
{
    shared_ptr(__r).swap(*this);
    return *this;
}


template&lt;class _Tp&gt;
template &lt;class <span class="ge">_Yp, class _</span>Dp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    !is_array&lt;_Yp&gt;::value &amp;&amp;
    is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer,
                   typename shared_ptr&lt;_Tp&gt;::element_type*&gt;::value,
    shared_ptr&lt;_Tp&gt;&amp;
&gt;::type
shared_ptr&lt;_Tp&gt;::operator=(unique_ptr&lt;_Yp, <span class="ge">_Dp&gt; _</span>_r)
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}



template&lt;class _Tp&gt;
inline
void
shared_ptr&lt;_Tp&gt;::swap(shared_ptr&amp; __r) throw()
{
    std::__1::swap(__ptr_, <span class="gs">__r.__</span>ptr_);
    std::__1::swap(__cntrl_, <span class="gs">__r.__</span>cntrl_);
}

template&lt;class _Tp&gt;
inline
void
shared_ptr&lt;_Tp&gt;::reset() throw()
{
    shared_ptr().swap(*this);
}

template&lt;class _Tp&gt;
template&lt;class _Yp&gt;
inline
typename enable_if
&lt;
    is_convertible&lt;_Yp*, typename shared_ptr&lt;_Tp&gt;::element_type*&gt;::value,
    void
&gt;::type
shared_ptr&lt;_Tp&gt;::reset(_Yp* __p)
{
    shared_ptr(__p).swap(*this);
}

template&lt;class _Tp&gt;
template&lt;class <span class="ge">_Yp, class _</span>Dp&gt;
inline
typename enable_if
&lt;
    is_convertible&lt;_Yp*, typename shared_ptr&lt;_Tp&gt;::element_type*&gt;::value,
    void
&gt;::type
shared_ptr&lt;_Tp&gt;::reset(_Yp* __p, <span class="ge">_Dp _</span>_d)
{
    shared_ptr(__p, __d).swap(*this);
}

template&lt;class _Tp&gt;
template&lt;class <span class="ge">_Yp, class _</span>Dp, class _Alloc&gt;
inline
typename enable_if
&lt;
    is_convertible&lt;_Yp*, typename shared_ptr&lt;_Tp&gt;::element_type*&gt;::value,
    void
&gt;::type
shared_ptr&lt;_Tp&gt;::reset(_Yp* __p, <span class="ge">_Dp __d, _</span>Alloc __a)
{
    shared_ptr(__p, <span class="gs">__d, __</span>a).swap(*this);
}

template&lt;class <span class="ge">_Tp, class ..._</span>Args&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    !is_array&lt;_Tp&gt;::value,
    shared_ptr&lt;_Tp&gt;
&gt;::type
make_shared(_Args&amp;&amp; ...__args)
{
    <span class="ge">_Static_</span>assert(is_constructible&lt;_Tp, <span class="ge">_Args...&gt;::value, &quot;Can&#39;t construct object in make_</span>shared&quot;);
    typedef __shared_ptr_emplace&lt;_Tp, allocator&lt;_Tp&gt; &gt; _CntrlBlk;
    typedef allocator&lt;_CntrlBlk&gt; _A2;
    typedef __allocator_destructor&lt;_A2&gt; _D2;

    <span class="ge">_A2 _</span>_a2;
    unique_ptr&lt;_CntrlBlk, <span class="ge">_D2&gt; __hold2(__a2.allocate(1), _</span>D2(__a2, 1));
    ::new(__hold2.get()) <span class="ge">_CntrlBlk(__a2, std::__1::forward&lt;_</span>Args&gt;(__args)...);

    <span class="ge">_Tp *__ptr = _</span>_hold2.get()-&gt;get();
    return shared_ptr&lt;_Tp&gt;::__create_with_control_block(__ptr, __hold2.release());
}

template&lt;class <span class="ge">_Tp, class _</span>Alloc, class ..._Args&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    !is_array&lt;_Tp&gt;::value,
    shared_ptr&lt;_Tp&gt;
&gt;::type
allocate_shared(const <span class="ge">_Alloc&amp; __a, _</span>Args&amp;&amp; ...__args)
{
    return shared_ptr&lt;_Tp&gt;::allocate_shared(__a, std::__1::forward&lt;_Args&gt;(__args)...);
}

template&lt;class <span class="ge">_Tp, class _</span>Up&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const shared_ptr&lt;_Tp&gt;&amp; __x, const shared_ptr&lt;_Up&gt;&amp; __y) throw()
{
    return <span class="gs">__x.get() == __</span>y.get();
}

template&lt;class <span class="ge">_Tp, class _</span>Up&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const shared_ptr&lt;_Tp&gt;&amp; __x, const shared_ptr&lt;_Up&gt;&amp; __y) throw()
{
    return !(__x == __y);
}

template&lt;class <span class="ge">_Tp, class _</span>Up&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;(const shared_ptr&lt;_Tp&gt;&amp; __x, const shared_ptr&lt;_Up&gt;&amp; __y) throw()
{

    typedef typename common_type&lt;_Tp*, <span class="ge">_Up*&gt;::type _</span>Vp;
    return less&lt;_Vp&gt;()(__x.get(), __y.get());




}

template&lt;class <span class="ge">_Tp, class _</span>Up&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;(const shared_ptr&lt;_Tp&gt;&amp; __x, const shared_ptr&lt;_Up&gt;&amp; __y) throw()
{
    return <span class="gs">__y &lt; __</span>x;
}

template&lt;class <span class="ge">_Tp, class _</span>Up&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const shared_ptr&lt;_Tp&gt;&amp; __x, const shared_ptr&lt;_Up&gt;&amp; __y) throw()
{
    return !(__y &lt; __x);
}

template&lt;class <span class="ge">_Tp, class _</span>Up&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const shared_ptr&lt;_Tp&gt;&amp; __x, const shared_ptr&lt;_Up&gt;&amp; __y) throw()
{
    return !(__x &lt; __y);
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const shared_ptr&lt;_Tp&gt;&amp; __x, nullptr_t) throw()
{
    return !__x;
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __x) throw()
{
    return !__x;
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const shared_ptr&lt;_Tp&gt;&amp; __x, nullptr_t) throw()
{
    return static_cast&lt;bool&gt;(__x);
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __x) throw()
{
    return static_cast&lt;bool&gt;(__x);
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;(const shared_ptr&lt;_Tp&gt;&amp; __x, nullptr_t) throw()
{
    return less&lt;_Tp*&gt;()(__x.get(), std::__1::__get_nullptr_t());
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __x) throw()
{
    return less&lt;_Tp*&gt;()(std::__1::__get_nullptr_t(), __x.get());
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;(const shared_ptr&lt;_Tp&gt;&amp; __x, nullptr_t) throw()
{
    return std::__1::__get_nullptr_t() &lt; __x;
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __x) throw()
{
    return <span class="gs">__x &lt; std::__</span>1::__get_nullptr_t();
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const shared_ptr&lt;_Tp&gt;&amp; __x, nullptr_t) throw()
{
    return !(std::__1::__get_nullptr_t() &lt; __x);
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __x) throw()
{
    return !(__x &lt; std::__1::__get_nullptr_t());
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const shared_ptr&lt;_Tp&gt;&amp; __x, nullptr_t) throw()
{
    return !(__x &lt; std::__1::__get_nullptr_t());
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __x) throw()
{
    return !(std::__1::__get_nullptr_t() &lt; __x);
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
swap(shared_ptr&lt;_Tp&gt;&amp; __x, shared_ptr&lt;_Tp&gt;&amp; __y) throw()
{
    <span class="gs">__x.swap(__</span>y);
}

template&lt;class <span class="ge">_Tp, class _</span>Up&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    !is_array&lt;_Tp&gt;::value &amp;&amp; !is_array&lt;_Up&gt;::value,
    shared_ptr&lt;_Tp&gt;
&gt;::type
static_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) throw()
{
    return shared_ptr&lt;_Tp&gt;(__r, static_cast&lt;_Tp*&gt;(__r.get()));
}

template&lt;class <span class="ge">_Tp, class _</span>Up&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    !is_array&lt;_Tp&gt;::value &amp;&amp; !is_array&lt;_Up&gt;::value,
    shared_ptr&lt;_Tp&gt;
&gt;::type
dynamic_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) throw()
{
    <span class="ge">_Tp* __p = dynamic_</span>cast&lt;_Tp*&gt;(__r.get());
    return __p ? shared_ptr&lt;_Tp&gt;(__r, __p) : shared_ptr&lt;_Tp&gt;();
}

template&lt;class <span class="ge">_Tp, class _</span>Up&gt;
typename enable_if
&lt;
    is_array&lt;_Tp&gt;::value == is_array&lt;_Up&gt;::value,
    shared_ptr&lt;_Tp&gt;
&gt;::type
const_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) throw()
{
    typedef typename remove_extent&lt;_Tp&gt;::type _RTp;
    return shared_ptr&lt;_Tp&gt;(__r, const_cast&lt;_RTp*&gt;(__r.get()));
}



template&lt;class <span class="ge">_Dp, class _</span>Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Dp*
get_deleter(const shared_ptr&lt;_Tp&gt;&amp; __p) throw()
{
    return <span class="gs">__p.template __</span>get_deleter&lt;_Dp&gt;();
}



template&lt;class _Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) weak_ptr
{
public:
    typedef <span class="ge">_Tp element_</span>type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                      weak_ptr() throw();
    template&lt;class <span class="ge">_Yp&gt; __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) weak_ptr(shared_ptr&lt;_Yp&gt; const&amp; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, <span class="ge">_Tp*&gt;::value, _</span>_nat*&gt;::type = 0)
                        throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    weak_ptr(weak_ptr const&amp; __r) throw();
    template&lt;class <span class="ge">_Yp&gt; __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) weak_ptr(weak_ptr&lt;_Yp&gt; const&amp; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, <span class="ge">_Tp*&gt;::value, _</span>_nat*&gt;::type = 0)
                         throw();
    ~weak_ptr();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    weak_ptr&amp; operator=(weak_ptr const&amp; __r) throw();
    template&lt;class _Yp&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            weak_ptr&amp;
        &gt;::type
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        operator=(weak_ptr&lt;_Yp&gt; const&amp; __r) throw();
    template&lt;class _Yp&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            weak_ptr&amp;
        &gt;::type
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        operator=(shared_ptr&lt;_Yp&gt; const&amp; __r) throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void swap(weak_ptr&amp; __r) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void reset() throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    long use_count() const throw()
        {return __cntrl_ ? __cntrl_-&gt;use_count() : 0;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool expired() const throw()
        {return __cntrl_ == 0 || __cntrl_-&gt;use_count() == 0;}
    shared_ptr&lt;_Tp&gt; lock() const throw();
    template&lt;class _Up&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        bool owner_before(const shared_ptr&lt;_Up&gt;&amp; __r) const throw()
        {return __cntrl_ &lt; <span class="gs">__r.__</span>cntrl_;}
    template&lt;class _Up&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        bool owner_before(const weak_ptr&lt;_Up&gt;&amp; __r) const throw()
        {return __cntrl_ &lt; <span class="gs">__r.__</span>cntrl_;}

    template &lt;class <span class="ge">_Up&gt; friend class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) weak_ptr;
    template &lt;class <span class="ge">_Up&gt; friend class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) shared_ptr;
};

template&lt;class _Tp&gt;
inline

weak_ptr&lt;_Tp&gt;::weak_ptr() throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template&lt;class _Tp&gt;
inline
weak_ptr&lt;_Tp&gt;::weak_ptr(weak_ptr const&amp; __r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_-&gt;__add_weak();
}

template&lt;class _Tp&gt;
template&lt;class _Yp&gt;
inline
weak_ptr&lt;_Tp&gt;::weak_ptr(shared_ptr&lt;_Yp&gt; const&amp; __r,
                        typename enable_if&lt;is_convertible&lt;_Yp*, <span class="ge">_Tp*&gt;::value, _</span>_nat*&gt;::type)
                         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_-&gt;__add_weak();
}

template&lt;class _Tp&gt;
template&lt;class _Yp&gt;
inline
weak_ptr&lt;_Tp&gt;::weak_ptr(weak_ptr&lt;_Yp&gt; const&amp; __r,
                        typename enable_if&lt;is_convertible&lt;_Yp*, <span class="ge">_Tp*&gt;::value, _</span>_nat*&gt;::type)
         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_-&gt;__add_weak();
}
template&lt;class _Tp&gt;
weak_ptr&lt;_Tp&gt;::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_-&gt;__release_weak();
}

template&lt;class _Tp&gt;
inline
weak_ptr&lt;_Tp&gt;&amp;
weak_ptr&lt;_Tp&gt;::operator=(weak_ptr const&amp; __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template&lt;class _Tp&gt;
template&lt;class _Yp&gt;
inline
typename enable_if
&lt;
    is_convertible&lt;_Yp*, _Tp*&gt;::value,
    weak_ptr&lt;_Tp&gt;&amp;
&gt;::type
weak_ptr&lt;_Tp&gt;::operator=(weak_ptr&lt;_Yp&gt; const&amp; __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}
template&lt;class _Tp&gt;
template&lt;class _Yp&gt;
inline
typename enable_if
&lt;
    is_convertible&lt;_Yp*, _Tp*&gt;::value,
    weak_ptr&lt;_Tp&gt;&amp;
&gt;::type
weak_ptr&lt;_Tp&gt;::operator=(shared_ptr&lt;_Yp&gt; const&amp; __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template&lt;class _Tp&gt;
inline
void
weak_ptr&lt;_Tp&gt;::swap(weak_ptr&amp; __r) throw()
{
    std::__1::swap(__ptr_, <span class="gs">__r.__</span>ptr_);
    std::__1::swap(__cntrl_, <span class="gs">__r.__</span>cntrl_);
}

template&lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
swap(weak_ptr&lt;_Tp&gt;&amp; __x, weak_ptr&lt;_Tp&gt;&amp; __y) throw()
{
    <span class="gs">__x.swap(__</span>y);
}

template&lt;class _Tp&gt;
inline
void
weak_ptr&lt;_Tp&gt;::reset() throw()
{
    weak_ptr().swap(*this);
}

template&lt;class _Tp&gt;
template&lt;class _Yp&gt;
shared_ptr&lt;_Tp&gt;::shared_ptr(const weak_ptr&lt;_Yp&gt;&amp; __r,
                            typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? <span class="gs">__r.__</span>cntrl_-&gt;lock() : <span class="gs">__r.__</span>cntrl_)
{
    if (__cntrl_ == 0)
        __throw_bad_weak_ptr();
}

template&lt;class _Tp&gt;
shared_ptr&lt;_Tp&gt;
weak_ptr&lt;_Tp&gt;::lock() const throw()
{
    shared_ptr&lt;_Tp&gt; __r;
    <span class="gs">__r.__</span>cntrl_ = __cntrl_ ? __cntrl_-&gt;lock() : __cntrl_;
    if (<span class="gs">__r.__</span>cntrl_)
        <span class="gs">__r.__</span>ptr_ = __ptr_;
    return __r;
}




template &lt;class <span class="ge">_Tp&gt; struct owner_</span>less;


template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) owner_less&lt;shared_ptr&lt;_Tp&gt; &gt;
    : binary_function&lt;shared_ptr&lt;_Tp&gt;, shared_ptr&lt;_Tp&gt;, bool&gt;
{
    typedef bool result_type;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(shared_ptr&lt;_Tp&gt; const&amp; __x, shared_ptr&lt;_Tp&gt; const&amp; __y) const throw()
        {return __x.owner_before(__y);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(shared_ptr&lt;_Tp&gt; const&amp; __x, weak_ptr&lt;_Tp&gt; const&amp; __y) const throw()
        {return __x.owner_before(__y);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()( weak_ptr&lt;_Tp&gt; const&amp; __x, shared_ptr&lt;_Tp&gt; const&amp; __y) const throw()
        {return __x.owner_before(__y);}
};

template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) owner_less&lt;weak_ptr&lt;_Tp&gt; &gt;
    : binary_function&lt;weak_ptr&lt;_Tp&gt;, weak_ptr&lt;_Tp&gt;, bool&gt;
{
    typedef bool result_type;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()( weak_ptr&lt;_Tp&gt; const&amp; __x, weak_ptr&lt;_Tp&gt; const&amp; __y) const throw()
        {return __x.owner_before(__y);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(shared_ptr&lt;_Tp&gt; const&amp; __x, weak_ptr&lt;_Tp&gt; const&amp; __y) const throw()
        {return __x.owner_before(__y);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()( weak_ptr&lt;_Tp&gt; const&amp; __x, shared_ptr&lt;_Tp&gt; const&amp; __y) const throw()
        {return __x.owner_before(__y);}
};
template&lt;class _Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) enable_shared_from_this
{
    mutable weak_ptr&lt;_Tp&gt; __weak_this_;
protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    enable_shared_from_this() throw() {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    enable_shared_from_this(enable_shared_from_this const&amp;) throw() {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    enable_shared_from_this&amp; operator=(enable_shared_from_this const&amp;) throw()
        {return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~enable_shared_from_this() {}
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    shared_ptr&lt;_Tp&gt; shared_from_this()
        {return shared_ptr&lt;_Tp&gt;(__weak_this_);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    shared_ptr&lt;_Tp const&gt; shared_from_this() const
        {return shared_ptr&lt;const <span class="ge">_Tp&gt;(__weak_</span>this_);}
    template &lt;class <span class="ge">_Up&gt; friend class shared_</span>ptr;
};

template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;shared_ptr&lt;_Tp&gt; &gt;
{
    typedef shared_ptr&lt;_Tp&gt; argument_type;
    typedef size_t result_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    result_type operator()(const argument_type&amp; __ptr) const throw()
    {
        return hash&lt;_Tp*&gt;()(__ptr.get());
    }
};

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Yp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_ostream&lt;_CharT, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __os, shared_</span>ptr&lt;_Yp&gt; const&amp; __p);




class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __sp_mut
{
    void* __lx;
public:
    void lock() throw();
    void unlock() throw();

private:
                      __sp_mut(void*) throw();
    __sp_mut(const __sp_mut&amp;);
    __sp_mut&amp; operator=(const __sp_mut&amp;);

    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __sp_mut&amp; __get_sp_mut(const void*);
};

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) <span class="gs">__attribute__</span>((availability(macosx,strict,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,strict,introduced=7.0)))
__sp_mut&amp; __get_sp_mut(const void*);

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
atomic_is_lock_free(const shared_ptr&lt;_Tp&gt;*)
{
    return false;
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span>((availability(macosx,strict,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,strict,introduced=7.0)))
shared_ptr&lt;_Tp&gt;
atomic_load(const shared_ptr&lt;_Tp&gt;* __p)
{
    __sp_mut&amp; <span class="gs">__m = __</span>get_sp_mut(__p);
    __m.lock();
    shared_ptr&lt;_Tp&gt; <span class="gs">__q = *__</span>p;
    __m.unlock();
    return __q;
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="gs">__attribute__</span>((availability(macosx,strict,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,strict,introduced=7.0)))
shared_ptr&lt;_Tp&gt;
atomic_load_explicit(const shared_ptr&lt;_Tp&gt;* __p, memory_order)
{
    return atomic_load(__p);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span>((availability(macosx,strict,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,strict,introduced=7.0)))
void
atomic_store(shared_ptr&lt;_Tp&gt;* __p, shared_ptr&lt;_Tp&gt; __r)
{
    __sp_mut&amp; <span class="gs">__m = __</span>get_sp_mut(__p);
    __m.lock();
    <span class="gs">__p-&gt;swap(__</span>r);
    __m.unlock();
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="gs">__attribute__</span>((availability(macosx,strict,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,strict,introduced=7.0)))
void
atomic_store_explicit(shared_ptr&lt;_Tp&gt;* __p, shared_ptr&lt;_Tp&gt; __r, memory_order)
{
    atomic_store(__p, __r);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span>((availability(macosx,strict,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,strict,introduced=7.0)))
shared_ptr&lt;_Tp&gt;
atomic_exchange(shared_ptr&lt;_Tp&gt;* __p, shared_ptr&lt;_Tp&gt; __r)
{
    __sp_mut&amp; <span class="gs">__m = __</span>get_sp_mut(__p);
    __m.lock();
    <span class="gs">__p-&gt;swap(__</span>r);
    __m.unlock();
    return __r;
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="gs">__attribute__</span>((availability(macosx,strict,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,strict,introduced=7.0)))
shared_ptr&lt;_Tp&gt;
atomic_exchange_explicit(shared_ptr&lt;_Tp&gt;* __p, shared_ptr&lt;_Tp&gt; __r, memory_order)
{
    return atomic_exchange(__p, __r);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span>((availability(macosx,strict,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_strong(shared_ptr&lt;_Tp&gt;* __p, shared_ptr&lt;_Tp&gt;* __v, shared_ptr&lt;_Tp&gt; __w)
{
    shared_ptr&lt;_Tp&gt; __temp;
    __sp_mut&amp; <span class="gs">__m = __</span>get_sp_mut(__p);
    __m.lock();
    if (<span class="gs">__p-&gt;__</span>owner_equivalent(*__v))
    {
        std::__1::swap(__temp, *__p);
        *<span class="gs">__p = __</span>w;
        __m.unlock();
        return true;
    }
    std::__1::swap(__temp, *__v);
    <span class="ge">*__v = *</span>__p;
    __m.unlock();
    return false;
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="gs">__attribute__</span>((availability(macosx,strict,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_weak(shared_ptr&lt;_Tp&gt;* __p, shared_ptr&lt;_Tp&gt;* __v, shared_ptr&lt;_Tp&gt; __w)
{
    return atomic_compare_exchange_strong(__p, <span class="gs">__v, __</span>w);
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="gs">__attribute__</span>((availability(macosx,strict,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_strong_explicit(shared_ptr&lt;_Tp&gt;* __p, shared_ptr&lt;_Tp&gt;* __v,
                                        shared_ptr&lt;_Tp&gt; __w, memory_order, memory_order)
{
    return atomic_compare_exchange_strong(__p, <span class="gs">__v, __</span>w);
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="gs">__attribute__</span>((availability(macosx,strict,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_weak_explicit(shared_ptr&lt;_Tp&gt;* __p, shared_ptr&lt;_Tp&gt;* __v,
                                      shared_ptr&lt;_Tp&gt; __w, memory_order, memory_order)
{
    return atomic_compare_exchange_weak(__p, <span class="gs">__v, __</span>w);
}
struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) pointer_safety
{
    enum __lx
    {
        relaxed,
        preferred,
        strict
    };

    <span class="gs">__lx __</span>v_;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pointer_safety() : __v_() {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pointer_safety(__lx <span class="gs">__v) : __</span>v<span class="ge">_(_</span>_v) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    operator int() const {return __v_;}
};
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
pointer_safety get_pointer_safety() throw() {
  return pointer_safety::relaxed;
}




<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void declare_reachable(void* __p);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void declare_no_pointers(char* __p, size_t __n);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void undeclare_no_pointers(char* __p, size_t __n);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void* __undeclare_reachable(void* __p);

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Tp*
undeclare_reachable(_Tp* __p)
{
    return static_cast&lt;_Tp*&gt;(__undeclare_reachable(__p));
}

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void* align(size_t __align, size_t <span class="gs">__sz, void*&amp; __</span>ptr, size_t&amp; __space);


template &lt;typename _Alloc&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __swap_allocator(_Alloc &amp; __a1, <span class="ge">_Alloc &amp; _</span>_a2)





{
    __swap_allocator(__a1, __a2,
      integral_constant&lt;bool, std::__1::allocator_traits&lt;_Alloc&gt;::propagate_on_container_swap::value&gt;());
}

template &lt;typename _Alloc&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __swap_allocator(_Alloc &amp; __a1, <span class="ge">_Alloc &amp; __a2, true_</span>type)





{
    using std::__1::swap;
    swap(__a1, __a2);
}

template &lt;typename _Alloc&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __swap_allocator(_Alloc &amp;, <span class="ge">_Alloc &amp;, false_</span>type) throw() {}

template &lt;typename <span class="ge">_Alloc, typename _</span>Traits=allocator_traits&lt;_Alloc&gt; &gt;
struct __noexcept_move_assign_container : public integral_constant&lt;bool,
    <span class="ge">_Traits::propagate_</span>on_container_move_assignment::value



        &amp;&amp; is_nothrow_move_assignable&lt;_Alloc&gt;::value

<span class="k">    &gt; </span><span class="ge">{};</span>
template&lt;typename _Alloc, typename = void, typename = void&gt;
struct __is_allocator : false_type {};

template&lt;typename _Alloc&gt;
struct __is_allocator&lt;_Alloc,
       typename __void_t&lt;typename <span class="ge">_Alloc::value_</span>type&gt;::type,
       typename __void_t&lt;__decltype(std::__1::declval&lt;_Alloc&amp;&gt;().allocate(size_t(0)))&gt;::type
<span class="k">     &gt;</span>
<span class="ge">   : true_type {};</span>





struct __builtin_new_allocator {
  struct __builtin_new_deleter {
    typedef void* pointer_type;

                      explicit __builtin_new_deleter(size_t __size, size_t __align)
        : __size_(__size), __align_(__align) {}

    void operator()(void* p) const throw() {
        std::__libcpp_deallocate(p, __size_, __align_);
    }

   private:
    size_t __size_;
    size_t __align_;
  };

  typedef unique_ptr&lt;void, __builtin_new_deleter&gt; __holder_t;

  static __holder_t __allocate_bytes(size_t __s, size_t __align) {
      return __holder_t(std::__libcpp_allocate(__s, __align),
                     __builtin_new_deleter(__s, __align));
  }

  static void __deallocate_bytes(void* __p, size_t __s,
                                 size_t __align) throw() {
      std::__libcpp_deallocate(__p, <span class="gs">__s, __</span>align);
  }

  template &lt;class _Tp&gt;
  <span class="gs">__attribute__</span>((__nodebug__)) <span class="gs">__attribute__</span> ((__always_inline__))
  static __holder_t __allocate_type(size_t __n) {
      return __allocate_bytes(__n * sizeof(_Tp), <span class="ge">_Alignof(_</span>Tp));
  }

  template &lt;class _Tp&gt;
  <span class="gs">__attribute__</span>((__nodebug__)) <span class="gs">__attribute__</span> ((__always_inline__))
  static void __deallocate_type(void* __p, size_t __n) throw() {
      __deallocate_bytes(__p, __n * sizeof(_Tp), <span class="ge">_Alignof(_</span>Tp));
  }
};


} }


namespace std { inline namespace __1 {




template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) plus : binary_function&lt;_Tp, <span class="ge">_Tp, _</span>Tp&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator()(const _</span>Tp&amp; __x, const <span class="ge">_Tp&amp; _</span>_y) const
        {return <span class="gs">__x + __</span>y;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) minus : binary_function&lt;_Tp, <span class="ge">_Tp, _</span>Tp&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator()(const _</span>Tp&amp; __x, const <span class="ge">_Tp&amp; _</span>_y) const
        {return <span class="gs">__x - __</span>y;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) multiplies : binary_function&lt;_Tp, <span class="ge">_Tp, _</span>Tp&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator()(const _</span>Tp&amp; __x, const <span class="ge">_Tp&amp; _</span>_y) const
        {return <span class="gs">__x * __</span>y;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) divides : binary_function&lt;_Tp, <span class="ge">_Tp, _</span>Tp&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator()(const _</span>Tp&amp; __x, const <span class="ge">_Tp&amp; _</span>_y) const
        {return <span class="gs">__x / __</span>y;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) modulus : binary_function&lt;_Tp, <span class="ge">_Tp, _</span>Tp&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator()(const _</span>Tp&amp; __x, const <span class="ge">_Tp&amp; _</span>_y) const
        {return <span class="gs">__x % __</span>y;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) negate : unary_function&lt;_Tp, _Tp&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator()(const _</span>Tp&amp; __x) const
        {return -__x;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) equal_to : binary_function&lt;_Tp, _Tp, bool&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_Tp&amp; __x, const _</span>Tp&amp; __y) const
        {return <span class="gs">__x == __</span>y;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) not_equal_to : binary_function&lt;_Tp, _Tp, bool&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_Tp&amp; __x, const _</span>Tp&amp; __y) const
        {return <span class="gs">__x != __</span>y;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) greater : binary_function&lt;_Tp, _Tp, bool&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_Tp&amp; __x, const _</span>Tp&amp; __y) const
        {return <span class="gs">__x &gt; __</span>y;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) greater_equal : binary_function&lt;_Tp, _Tp, bool&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_Tp&amp; __x, const _</span>Tp&amp; __y) const
        {return <span class="gs">__x &gt;= __</span>y;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) less_equal : binary_function&lt;_Tp, _Tp, bool&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_Tp&amp; __x, const _</span>Tp&amp; __y) const
        {return <span class="gs">__x &lt;= __</span>y;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) logical_and : binary_function&lt;_Tp, _Tp, bool&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_Tp&amp; __x, const _</span>Tp&amp; __y) const
        {return <span class="gs">__x &amp;&amp; __</span>y;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) logical_or : binary_function&lt;_Tp, _Tp, bool&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_Tp&amp; __x, const _</span>Tp&amp; __y) const
        {return <span class="gs">__x || __</span>y;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) logical_not : unary_function&lt;_Tp, bool&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_Tp&amp; _</span>_x) const
        {return !__x;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) bit_and : binary_function&lt;_Tp, <span class="ge">_Tp, _</span>Tp&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator()(const _</span>Tp&amp; __x, const <span class="ge">_Tp&amp; _</span>_y) const
        {return <span class="gs">__x &amp; __</span>y;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) bit_or : binary_function&lt;_Tp, <span class="ge">_Tp, _</span>Tp&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator()(const _</span>Tp&amp; __x, const <span class="ge">_Tp&amp; _</span>_y) const
        {return <span class="gs">__x | __</span>y;}
};
template &lt;class _Tp&gt;

struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) bit_xor : binary_function&lt;_Tp, <span class="ge">_Tp, _</span>Tp&gt;
{
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_Tp operator()(const _</span>Tp&amp; __x, const <span class="ge">_Tp&amp; _</span>_y) const
        {return <span class="gs">__x ^ __</span>y;}
};
template &lt;class _Predicate&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) unary_negate
    : public unary_function&lt;typename <span class="ge">_Predicate::argument_</span>type, bool&gt;
{
    <span class="ge">_Predicate __pred_</span>;
public:
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit unary_negate(const <span class="ge">_Predicate&amp; _</span>_pred)
        : __pred_(__pred) {}
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const typename <span class="ge">_Predicate::argument_</span>type&amp; __x) const
        {return !__pred_(__x);}
};

template &lt;class _Predicate&gt;
                            inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
unary_negate&lt;_Predicate&gt;
not1(const <span class="ge">_Predicate&amp; __pred) {return unary_</span>negate&lt;_Predicate&gt;(__pred);}

template &lt;class _Predicate&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) binary_negate
    : public binary_function&lt;typename <span class="ge">_Predicate::first_</span>argument_type,
                             typename <span class="ge">_Predicate::second_</span>argument_type,
                             bool&gt;
{
    <span class="ge">_Predicate __pred_</span>;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit
    binary_negate(const <span class="ge">_Predicate&amp; __pred) : __pred_</span>(__pred) {}

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const typename <span class="ge">_Predicate::first_</span>argument_type&amp; __x,
                    const typename <span class="ge">_Predicate::second_</span>argument_type&amp; __y) const
        {return !__pred_(__x, __y);}
};

template &lt;class _Predicate&gt;
                            inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
binary_negate&lt;_Predicate&gt;
not2(const <span class="ge">_Predicate&amp; __pred) {return binary_</span>negate&lt;_Predicate&gt;(__pred);}


template &lt;class __Operation&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) binder1st
    : public unary_function&lt;typename __Operation::second_argument_type,
                            typename __Operation::result_type&gt;
{
protected:
    __Operation op;
    typename __Operation::first_argument_type value;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) binder1st(const <span class="gs">__Operation&amp; __</span>x,
                               const typename __Operation::first_argument_type __y)
        : op(__x), value(__y) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) typename __Operation::result_type operator()
        (typename __Operation::second_argument_type&amp; __x) const
            {return op(value, __x);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) typename __Operation::result_type operator()
        (const typename __Operation::second_argument_type&amp; __x) const
            {return op(value, __x);}
};

template &lt;class __Operation, class _Tp&gt;
                            inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
binder1st&lt;__Operation&gt;
bind1st(const <span class="gs">__Operation&amp; __</span>op, const <span class="ge">_Tp&amp; _</span>_x)
    {return binder1st&lt;__Operation&gt;(__op, __x);}

template &lt;class __Operation&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) binder2nd
    : public unary_function&lt;typename __Operation::first_argument_type,
                            typename __Operation::result_type&gt;
{
protected:
    __Operation op;
    typename __Operation::second_argument_type value;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    binder2nd(const <span class="gs">__Operation&amp; __</span>x, const typename __Operation::second_argument_type __y)
        : op(__x), value(__y) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) typename __Operation::result_type operator()
        ( typename __Operation::first_argument_type&amp; __x) const
            {return op(__x, value);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) typename __Operation::result_type operator()
        (const typename __Operation::first_argument_type&amp; __x) const
            {return op(__x, value);}
};

template &lt;class __Operation, class _Tp&gt;
                            inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
binder2nd&lt;__Operation&gt;
bind2nd(const <span class="gs">__Operation&amp; __</span>op, const <span class="ge">_Tp&amp; _</span>_x)
    {return binder2nd&lt;__Operation&gt;(__op, __x);}

template &lt;class <span class="ge">_Arg, class _</span>Result&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) pointer_to_unary_function
    : public unary_function&lt;_Arg, _Result&gt;
{
    <span class="ge">_Result (*__f_</span>)(_Arg);
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit pointer_to_unary_function(_Result (*__f)(_Arg))
        : __f_(__f) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="ge">_Result operator()(_</span>Arg __x) const
        {return __f_(__x);}
};

template &lt;class <span class="ge">_Arg, class _</span>Result&gt;
                            inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
pointer_to_unary_function&lt;_Arg,_Result&gt;
ptr_fun(_Result (*__f)(_Arg))
    {return pointer_to_unary_function&lt;_Arg,_Result&gt;(__f);}

template &lt;class <span class="ge">_Arg1, class _</span>Arg2, class _Result&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) pointer_to_binary_function
    : public binary_function&lt;_Arg1, <span class="ge">_Arg2, _</span>Result&gt;
{
    <span class="ge">_Result (*__f_</span>)(_Arg1, _Arg2);
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))
        : __f_(__f) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="ge">_Result operator()(_</span>Arg1 __x, <span class="ge">_Arg2 _</span>_y) const
        {return __f_(__x, __y);}
};

template &lt;class <span class="ge">_Arg1, class _</span>Arg2, class _Result&gt;
                            inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
pointer_to_binary_function&lt;_Arg1,_Arg2,_Result&gt;
ptr_fun(_Result (*__f)(_Arg1,_Arg2))
    {return pointer_to_binary_function&lt;_Arg1,_Arg2,_Result&gt;(__f);}

template&lt;class <span class="ge">_Sp, class _</span>Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) mem_fun_t
    : public unary_function&lt;_Tp*, _Sp&gt;
{
    <span class="ge">_Sp (_</span>Tp::*__p_)();
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit mem_fun_t(_Sp (<span class="ge">_Tp::*_</span>_p)())
        : __p_(__p) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="ge">_Sp operator()(_</span>Tp* __p) const
        {return (<span class="gs">__p-&gt;*__</span>p_)();}
};

template&lt;class <span class="ge">_Sp, class _</span>Tp, class _Ap&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) mem_fun1_t
    : public binary_function&lt;_Tp*, <span class="ge">_Ap, _</span>Sp&gt;
{
    <span class="ge">_Sp (_</span>Tp::*__p_)(_Ap);
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit mem_fun1_t(_Sp (<span class="ge">_Tp::*__p)(_</span>Ap))
        : __p_(__p) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="ge">_Sp operator()(_</span>Tp* __p, <span class="ge">_Ap _</span>_x) const
        {return (<span class="gs">__p-&gt;*__</span>p<span class="ge">_)(_</span>_x);}
};

template&lt;class <span class="ge">_Sp, class _</span>Tp&gt;
                            inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
mem_fun_t&lt;_Sp,_Tp&gt;
mem_fun(_Sp (<span class="ge">_Tp::*_</span>_f)())
    {return mem_fun_t&lt;_Sp,_Tp&gt;(__f);}

template&lt;class <span class="ge">_Sp, class _</span>Tp, class _Ap&gt;
                            inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
mem_fun1_t&lt;_Sp,_Tp,_Ap&gt;
mem_fun(_Sp (<span class="ge">_Tp::*__f)(_</span>Ap))
    {return mem_fun1_t&lt;_Sp,_Tp,_Ap&gt;(__f);}

template&lt;class <span class="ge">_Sp, class _</span>Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) mem_fun_ref_t
    : public unary_function&lt;_Tp, _Sp&gt;
{
    <span class="ge">_Sp (_</span>Tp::*__p_)();
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit mem_fun_ref_t(_Sp (<span class="ge">_Tp::*_</span>_p)())
        : __p_(__p) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="ge">_Sp operator()(_</span>Tp&amp; __p) const
        {return (<span class="gs">__p.*__</span>p_)();}
};

template&lt;class <span class="ge">_Sp, class _</span>Tp, class _Ap&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) mem_fun1_ref_t
    : public binary_function&lt;_Tp, <span class="ge">_Ap, _</span>Sp&gt;
{
    <span class="ge">_Sp (_</span>Tp::*__p_)(_Ap);
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit mem_fun1_ref_t(_Sp (<span class="ge">_Tp::*__p)(_</span>Ap))
        : __p_(__p) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="ge">_Sp operator()(_</span>Tp&amp; __p, <span class="ge">_Ap _</span>_x) const
        {return (<span class="gs">__p.*__</span>p<span class="ge">_)(_</span>_x);}
};

template&lt;class <span class="ge">_Sp, class _</span>Tp&gt;
                            inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
mem_fun_ref_t&lt;_Sp,_Tp&gt;
mem_fun_ref(_Sp (<span class="ge">_Tp::*_</span>_f)())
    {return mem_fun_ref_t&lt;_Sp,_Tp&gt;(__f);}

template&lt;class <span class="ge">_Sp, class _</span>Tp, class _Ap&gt;
                            inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
mem_fun1_ref_t&lt;_Sp,_Tp,_Ap&gt;
mem_fun_ref(_Sp (<span class="ge">_Tp::*__f)(_</span>Ap))
    {return mem_fun1_ref_t&lt;_Sp,_Tp,_Ap&gt;(__f);}

template &lt;class <span class="ge">_Sp, class _</span>Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) const_mem_fun_t
    : public unary_function&lt;const <span class="ge">_Tp*, _</span>Sp&gt;
{
    <span class="ge">_Sp (_</span>Tp::*__p_)() const;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit const_mem_fun_t(_Sp (<span class="ge">_Tp::*_</span>_p)() const)
        : __p_(__p) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="ge">_Sp operator()(const _</span>Tp* __p) const
        {return (<span class="gs">__p-&gt;*__</span>p_)();}
};

template &lt;class <span class="ge">_Sp, class _</span>Tp, class _Ap&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) const_mem_fun1_t
    : public binary_function&lt;const <span class="ge">_Tp*, _</span>Ap, _Sp&gt;
{
    <span class="ge">_Sp (_</span>Tp::*__p_)(_Ap) const;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit const_mem_fun1_t(_Sp (<span class="ge">_Tp::*__p)(_</span>Ap) const)
        : __p_(__p) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="ge">_Sp operator()(const _</span>Tp* __p, <span class="ge">_Ap _</span>_x) const
        {return (<span class="gs">__p-&gt;*__</span>p<span class="ge">_)(_</span>_x);}
};

template &lt;class <span class="ge">_Sp, class _</span>Tp&gt;
                            inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
const_mem_fun_t&lt;_Sp,_Tp&gt;
mem_fun(_Sp (<span class="ge">_Tp::*_</span>_f)() const)
    {return const_mem_fun_t&lt;_Sp,_Tp&gt;(__f);}

template &lt;class <span class="ge">_Sp, class _</span>Tp, class _Ap&gt;
                            inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
const_mem_fun1_t&lt;_Sp,_Tp,_Ap&gt;
mem_fun(_Sp (<span class="ge">_Tp::*__f)(_</span>Ap) const)
    {return const_mem_fun1_t&lt;_Sp,_Tp,_Ap&gt;(__f);}

template &lt;class <span class="ge">_Sp, class _</span>Tp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) const_mem_fun_ref_t
    : public unary_function&lt;_Tp, _Sp&gt;
{
    <span class="ge">_Sp (_</span>Tp::*__p_)() const;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit const_mem_fun_ref_t(_Sp (<span class="ge">_Tp::*_</span>_p)() const)
        : __p_(__p) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="ge">_Sp operator()(const _</span>Tp&amp; __p) const
        {return (<span class="gs">__p.*__</span>p_)();}
};

template &lt;class <span class="ge">_Sp, class _</span>Tp, class _Ap&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) const_mem_fun1_ref_t
    : public binary_function&lt;_Tp, <span class="ge">_Ap, _</span>Sp&gt;
{
    <span class="ge">_Sp (_</span>Tp::*__p_)(_Ap) const;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit const_mem_fun1_ref_t(_Sp (<span class="ge">_Tp::*__p)(_</span>Ap) const)
        : __p_(__p) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="ge">_Sp operator()(const _</span>Tp&amp; __p, <span class="ge">_Ap _</span>_x) const
        {return (<span class="gs">__p.*__</span>p<span class="ge">_)(_</span>_x);}
};

template &lt;class <span class="ge">_Sp, class _</span>Tp&gt;
                            inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
const_mem_fun_ref_t&lt;_Sp,_Tp&gt;
mem_fun_ref(_Sp (<span class="ge">_Tp::*_</span>_f)() const)
    {return const_mem_fun_ref_t&lt;_Sp,_Tp&gt;(__f);}

template &lt;class <span class="ge">_Sp, class _</span>Tp, class _Ap&gt;
                            inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
const_mem_fun1_ref_t&lt;_Sp,_Tp,_Ap&gt;
mem_fun_ref(_Sp (<span class="ge">_Tp::*__f)(_</span>Ap) const)
    {return const_mem_fun1_ref_t&lt;_Sp,_Tp,_Ap&gt;(__f);}






template &lt;class _Tp&gt;
class __mem_fn
    : public __weak_result_type&lt;_Tp&gt;
{
public:

    typedef _Tp type;
private:
    type __f_;

public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __mem_fn(type <span class="gs">__f) throw() : __</span>f<span class="ge">_(_</span>_f) {}
    template &lt;class _A0&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return0&lt;type, _A0&gt;::type
    operator() (<span class="ge">_A0&amp; _</span>_a0) const {
        return <span class="gs">__invoke(__</span>f<span class="ge">_, _</span>_a0);
    }

    template &lt;class _A0&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return0&lt;type, _A0 const&gt;::type
    operator() (<span class="ge">_A0 const&amp; _</span>_a0) const {
        return <span class="gs">__invoke(__</span>f<span class="ge">_, _</span>_a0);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return1&lt;type, <span class="ge">_A0, _</span>A1&gt;::type
    operator() (<span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1) const {
        return <span class="gs">__invoke(__</span>f<span class="ge">_, __a0, _</span>_a1);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return1&lt;type, <span class="ge">_A0 const, _</span>A1&gt;::type
    operator() (<span class="ge">_A0 const&amp; __a0, _</span>A1&amp; __a1) const {
        return <span class="gs">__invoke(__</span>f<span class="ge">_, __a0, _</span>_a1);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return1&lt;type, <span class="ge">_A0, _</span>A1 const&gt;::type
    operator() (<span class="ge">_A0&amp; __a0, _</span>A1 const&amp; __a1) const {
        return <span class="gs">__invoke(__</span>f<span class="ge">_, __a0, _</span>_a1);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return1&lt;type, <span class="ge">_A0 const, _</span>A1 const&gt;::type
    operator() (<span class="ge">_A0 const&amp; __a0, _</span>A1 const&amp; __a1) const {
        return <span class="gs">__invoke(__</span>f<span class="ge">_, __a0, _</span>_a1);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0, _</span>A1, _A2&gt;::type
    operator() (<span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1, <span class="ge">_A2&amp; _</span>_a2) const {
        return <span class="gs">__invoke(__</span>f<span class="ge">_, __a0, __a1, _</span>_a2);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0 const, _</span>A1, _A2&gt;::type
    operator() (<span class="ge">_A0 const&amp; __a0, _</span>A1&amp; __a1, <span class="ge">_A2&amp; _</span>_a2) const {
        return <span class="gs">__invoke(__</span>f<span class="ge">_, __a0, __a1, _</span>_a2);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0, _</span>A1 const, _A2&gt;::type
    operator() (<span class="ge">_A0&amp; __a0, _</span>A1 const&amp; __a1, <span class="ge">_A2&amp; _</span>_a2) const {
        return <span class="gs">__invoke(__</span>f<span class="ge">_, __a0, __a1, _</span>_a2);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0, _</span>A1, _A2 const&gt;::type
    operator() (<span class="ge">_A0&amp; __a0, _</span>A1&amp; __a1, <span class="ge">_A2 const&amp; _</span>_a2) const {
        return <span class="gs">__invoke(__</span>f<span class="ge">_, __a0, __a1, _</span>_a2);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0 const, _</span>A1 const, _A2&gt;::type
    operator() (<span class="ge">_A0 const&amp; __a0, _</span>A1 const&amp; __a1, <span class="ge">_A2&amp; _</span>_a2) const {
        return <span class="gs">__invoke(__</span>f<span class="ge">_, __a0, __a1, _</span>_a2);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0 const, _</span>A1, _A2 const&gt;::type
    operator() (<span class="ge">_A0 const&amp; __a0, _</span>A1&amp; __a1, <span class="ge">_A2 const&amp; _</span>_a2) const {
        return <span class="gs">__invoke(__</span>f<span class="ge">_, __a0, __a1, _</span>_a2);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0, _</span>A1 const, _A2 const&gt;::type
    operator() (<span class="ge">_A0&amp; __a0, _</span>A1 const&amp; __a1, <span class="ge">_A2 const&amp; _</span>_a2) const {
        return <span class="gs">__invoke(__</span>f<span class="ge">_, __a0, __a1, _</span>_a2);
    }

    template &lt;class <span class="ge">_A0, class _</span>A1, class _A2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    typename __invoke_return2&lt;type, <span class="ge">_A0 const, _</span>A1 const, _A2 const&gt;::type
    operator() (<span class="ge">_A0 const&amp; __a0, _</span>A1 const&amp; __a1, <span class="ge">_A2 const&amp; _</span>_a2) const {
        return <span class="gs">__invoke(__</span>f<span class="ge">_, __a0, __a1, _</span>_a2);
    }

};

template&lt;class <span class="ge">_Rp, class _</span>Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__mem_fn&lt;_Rp _Tp::*&gt;
mem_fn(_Rp <span class="ge">_Tp::* _</span>_pm) throw()
{
    return __mem_fn&lt;_Rp <span class="ge">_Tp::*&gt;(_</span>_pm);
}







class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bad_function_call
    : public exception
{






};

<span class="gs">__attribute__</span> ((noreturn)) inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __throw_bad_function_call()
{

    throw bad_function_call();



}

template&lt;class <span class="ge">_Fp&gt; class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) function;

namespace __function
{

template&lt;class _Rp&gt;
struct __maybe_derive_from_unary_function
{
};

template&lt;class <span class="ge">_Rp, class _</span>A1&gt;
struct __maybe_derive_from_unary_function&lt;_Rp(_A1)&gt;
    : public unary_function&lt;_A1, _Rp&gt;
{
};

template&lt;class _Rp&gt;
struct __maybe_derive_from_binary_function
{
};

template&lt;class <span class="ge">_Rp, class _</span>A1, class _A2&gt;
struct __maybe_derive_from_binary_function&lt;_Rp(_A1, _A2)&gt;
    : public binary_function&lt;_A1, <span class="ge">_A2, _</span>Rp&gt;
{
};

template &lt;class _Fp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __not_null(_Fp const&amp;) { return true; }

template &lt;class _Fp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __not_null(_Fp* <span class="gs">__ptr) { return __</span>ptr; }

template &lt;class <span class="ge">_Ret, class _</span>Class&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __not_null(_Ret <span class="ge">_Class::*__ptr) { return _</span>_ptr; }

template &lt;class _Fp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __not_null(function&lt;_Fp&gt; const&amp; <span class="gs">__f) { return !!__</span>f; }


template &lt;class <span class="ge">_Rp, class ..._</span>Args&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __not_null(_Rp (^__p)(_Args...)) { return __p; }


}


namespace __function {

template&lt;class <span class="ge">_Fp&gt; class _</span>_base;

template&lt;class _Rp&gt;
class __base&lt;_Rp()&gt;
{
    <span class="gs">__base(const __</span>base&amp;);
    <span class="gs">__base&amp; operator=(const __</span>base&amp;);
public:
    __base() {}
    virtual ~__base() {}
    virtual <span class="gs">__base* __</span>clone() const = 0;
    virtual void <span class="gs">__clone(__</span>base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()() = 0;

    virtual const void* target(const type_info&amp;) const = 0;
    virtual const std::type_info&amp; target_type() const = 0;

};

template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
class __base&lt;_Rp(_A0)&gt;
{
    <span class="gs">__base(const __</span>base&amp;);
    <span class="gs">__base&amp; operator=(const __</span>base&amp;);
public:
    __base() {}
    virtual ~__base() {}
    virtual <span class="gs">__base* __</span>clone() const = 0;
    virtual void <span class="gs">__clone(__</span>base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual <span class="ge">_Rp operator()(_</span>A0) = 0;

    virtual const void* target(const type_info&amp;) const = 0;
    virtual const std::type_info&amp; target_type() const = 0;

};

template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
class __base&lt;_Rp(_A0, _A1)&gt;
{
    <span class="gs">__base(const __</span>base&amp;);
    <span class="gs">__base&amp; operator=(const __</span>base&amp;);
public:
    __base() {}
    virtual ~__base() {}
    virtual <span class="gs">__base* __</span>clone() const = 0;
    virtual void <span class="gs">__clone(__</span>base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual <span class="ge">_Rp operator()(_</span>A0, _A1) = 0;

    virtual const void* target(const type_info&amp;) const = 0;
    virtual const std::type_info&amp; target_type() const = 0;

};

template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
class __base&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;
{
    <span class="gs">__base(const __</span>base&amp;);
    <span class="gs">__base&amp; operator=(const __</span>base&amp;);
public:
    __base() {}
    virtual ~__base() {}
    virtual <span class="gs">__base* __</span>clone() const = 0;
    virtual void <span class="gs">__clone(__</span>base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual <span class="ge">_Rp operator()(_</span>A0, <span class="ge">_A1, _</span>A2) = 0;

    virtual const void* target(const type_info&amp;) const = 0;
    virtual const std::type_info&amp; target_type() const = 0;

};

template&lt;class <span class="ge">_FD, class _</span>Alloc, class <span class="ge">_FB&gt; class _</span>_func;

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class _Rp&gt;
class __func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp()&gt;
    : public __base&lt;_Rp()&gt;
{
    __compressed_pair&lt;_Fp, <span class="ge">_Alloc&gt; __f_</span>;
public:
    explicit __func(_Fp <span class="gs">__f) : __</span>f<span class="ge">_(std::__1::move(__f), __default_</span>init_tag()) {}
    explicit __func(_Fp __f, <span class="ge">_Alloc __a) : __f_</span>(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base&lt;_Rp()&gt;* __clone() const;
    virtual void <span class="gs">__clone(__</span>base&lt;_Rp()&gt;*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()();

    virtual const void* target(const type_info&amp;) const;
    virtual const std::type_info&amp; target_type() const;

};

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class _Rp&gt;
__base&lt;_Rp()&gt;*
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp()&gt;::__clone() const
{
    typedef allocator_traits&lt;_Alloc&gt; __alloc_traits;
    typedef typename __rebind_alloc_helper&lt;__alloc_traits, __func&gt;::type _Ap;
    <span class="ge">_Ap __a(__f_</span>.second());
    typedef __allocator_destructor&lt;_Ap&gt; _Dp;
    unique_ptr&lt;__func, <span class="ge">_Dp&gt; __hold(__a.allocate(1), _</span>Dp(__a, 1));
    ::new (<span class="gs">__hold.get()) __</span>func(__f_.first(), <span class="ge">_Alloc(_</span>_a));
    return __hold.release();
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class _Rp&gt;
void
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp()&gt;::__clone(__base&lt;_Rp()&gt;* __p) const
{
    ::new (<span class="gs">__p) __</span>func(__f_.first(), __f_.second());
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class _Rp&gt;
void
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp()&gt;::destroy()
{
    __f_.~__compressed_pair&lt;_Fp, _Alloc&gt;();
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class _Rp&gt;
void
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp()&gt;::destroy_deallocate()
{
    typedef allocator_traits&lt;_Alloc&gt; __alloc_traits;
    typedef typename __rebind_alloc_helper&lt;__alloc_traits, __func&gt;::type _Ap;
    <span class="ge">_Ap __a(__f_</span>.second());
    __f_.~__compressed_pair&lt;_Fp, _Alloc&gt;();
    __a.deallocate(this, 1);
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class _Rp&gt;
_Rp
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp()&gt;::operator()()
{
    typedef __invoke_void_return_wrapper&lt;_Rp&gt; _Invoker;
    return <span class="ge">_Invoker::__call(__f_</span>.first());
}



template&lt;class <span class="ge">_Fp, class _</span>Alloc, class _Rp&gt;
const void*
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp()&gt;::target(const type_info&amp; __ti) const
{
    if (__ti == typeid(_Fp))
        return &amp;__f_.first();
    return (const void*)0;
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class _Rp&gt;
const std::type_info&amp;
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp()&gt;::target_type() const
{
    return typeid(_Fp);
}



template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0&gt;
class __func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0)&gt;
    : public __base&lt;_Rp(_A0)&gt;
{
    __compressed_pair&lt;_Fp, <span class="ge">_Alloc&gt; __f_</span>;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit __func(_Fp <span class="gs">__f) : __</span>f<span class="ge">_(std::__1::move(__f), __default_</span>init_tag()) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit __func(_Fp __f, <span class="ge">_Alloc _</span>_a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base&lt;_Rp(_A0)&gt;* __clone() const;
    virtual void <span class="gs">__clone(__</span>base&lt;_Rp(_A0)&gt;*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual <span class="ge">_Rp operator()(_</span>A0);

    virtual const void* target(const type_info&amp;) const;
    virtual const std::type_info&amp; target_type() const;

};

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0&gt;
__base&lt;_Rp(_A0)&gt;*
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0)&gt;::__clone() const
{
    typedef allocator_traits&lt;_Alloc&gt; __alloc_traits;
    typedef typename __rebind_alloc_helper&lt;__alloc_traits, __func&gt;::type _Ap;
    <span class="ge">_Ap __a(__f_</span>.second());
    typedef __allocator_destructor&lt;_Ap&gt; _Dp;
    unique_ptr&lt;__func, <span class="ge">_Dp&gt; __hold(__a.allocate(1), _</span>Dp(__a, 1));
    ::new (<span class="gs">__hold.get()) __</span>func(__f_.first(), <span class="ge">_Alloc(_</span>_a));
    return __hold.release();
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0&gt;
void
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0)&gt;::__clone(__base&lt;_Rp(_A0)&gt;* __p) const
{
    ::new (<span class="gs">__p) __</span>func(__f_.first(), __f_.second());
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0&gt;
void
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0)&gt;::destroy()
{
    __f_.~__compressed_pair&lt;_Fp, _Alloc&gt;();
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0&gt;
void
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0)&gt;::destroy_deallocate()
{
    typedef allocator_traits&lt;_Alloc&gt; __alloc_traits;
    typedef typename __rebind_alloc_helper&lt;__alloc_traits, __func&gt;::type _Ap;
    <span class="ge">_Ap __a(__f_</span>.second());
    __f_.~__compressed_pair&lt;_Fp, _Alloc&gt;();
    __a.deallocate(this, 1);
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0&gt;
_Rp
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0)&gt;::operator()(_A0 __a0)
{
    typedef __invoke_void_return_wrapper&lt;_Rp&gt; _Invoker;
    return <span class="ge">_Invoker::__call(__f_</span>.first(), __a0);
}



template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0&gt;
const void*
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0)&gt;::target(const type_info&amp; __ti) const
{
    if (__ti == typeid(_Fp))
        return &amp;__f_.first();
    return (const void*)0;
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0&gt;
const std::type_info&amp;
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0)&gt;::target_type() const
{
    return typeid(_Fp);
}



template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
class __func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, _A1)&gt;
    : public __base&lt;_Rp(_A0, _A1)&gt;
{
    __compressed_pair&lt;_Fp, <span class="ge">_Alloc&gt; __f_</span>;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit __func(_Fp <span class="gs">__f) : __</span>f<span class="ge">_(std::__1::move(__f), __default_</span>init_tag()) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit __func(_Fp __f, <span class="ge">_Alloc _</span>_a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base&lt;_Rp(_A0, <span class="ge">_A1)&gt;* _</span>_clone() const;
    virtual void <span class="gs">__clone(__</span>base&lt;_Rp(_A0, _A1)&gt;*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual <span class="ge">_Rp operator()(_</span>A0, _A1);

    virtual const void* target(const type_info&amp;) const;
    virtual const std::type_info&amp; target_type() const;

};

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
__base&lt;_Rp(_A0, _A1)&gt;*
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1)&gt;::_</span>_clone() const
{
    typedef allocator_traits&lt;_Alloc&gt; __alloc_traits;
    typedef typename __rebind_alloc_helper&lt;__alloc_traits, __func&gt;::type _Ap;
    <span class="ge">_Ap __a(__f_</span>.second());
    typedef __allocator_destructor&lt;_Ap&gt; _Dp;
    unique_ptr&lt;__func, <span class="ge">_Dp&gt; __hold(__a.allocate(1), _</span>Dp(__a, 1));
    ::new (<span class="gs">__hold.get()) __</span>func(__f_.first(), <span class="ge">_Alloc(_</span>_a));
    return __hold.release();
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
void
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1)&gt;::__clone(__base&lt;_</span>Rp(_A0, <span class="ge">_A1)&gt;* _</span>_p) const
{
    ::new (<span class="gs">__p) __</span>func(__f_.first(), __f_.second());
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
void
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, _A1)&gt;::destroy()
{
    __f_.~__compressed_pair&lt;_Fp, _Alloc&gt;();
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
void
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1)&gt;::destroy_</span>deallocate()
{
    typedef allocator_traits&lt;_Alloc&gt; __alloc_traits;
    typedef typename __rebind_alloc_helper&lt;__alloc_traits, __func&gt;::type _Ap;
    <span class="ge">_Ap __a(__f_</span>.second());
    __f_.~__compressed_pair&lt;_Fp, _Alloc&gt;();
    __a.deallocate(this, 1);
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
_Rp
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1)&gt;::operator()(_</span>A0 __a0, <span class="ge">_A1 _</span>_a1)
{
    typedef __invoke_void_return_wrapper&lt;_Rp&gt; _Invoker;
    return <span class="ge">_Invoker::__call(__f_</span>.first(), <span class="gs">__a0, __</span>a1);
}



template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
const void*
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1)&gt;::target(const type_</span>info&amp; __ti) const
{
    if (__ti == typeid(_Fp))
        return &amp;__f_.first();
    return (const void*)0;
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
const std::type_info&amp;
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1)&gt;::target_</span>type() const
{
    return typeid(_Fp);
}



template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
class __func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;
    : public __base&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;
{
    __compressed_pair&lt;_Fp, <span class="ge">_Alloc&gt; __f_</span>;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit __func(_Fp <span class="gs">__f) : __</span>f<span class="ge">_(std::__1::move(__f), __default_</span>init_tag()) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit __func(_Fp __f, <span class="ge">_Alloc _</span>_a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;* __clone() const;
    virtual void <span class="gs">__clone(__</span>base&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual <span class="ge">_Rp operator()(_</span>A0, <span class="ge">_A1, _</span>A2);

    virtual const void* target(const type_info&amp;) const;
    virtual const std::type_info&amp; target_type() const;

};

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
__base&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;*
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::__clone() const
{
    typedef allocator_traits&lt;_Alloc&gt; __alloc_traits;
    typedef typename __rebind_alloc_helper&lt;__alloc_traits, __func&gt;::type _Ap;
    <span class="ge">_Ap __a(__f_</span>.second());
    typedef __allocator_destructor&lt;_Ap&gt; _Dp;
    unique_ptr&lt;__func, <span class="ge">_Dp&gt; __hold(__a.allocate(1), _</span>Dp(__a, 1));
    ::new (<span class="gs">__hold.get()) __</span>func(__f_.first(), <span class="ge">_Alloc(_</span>_a));
    return __hold.release();
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
void
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::__clone(__base&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;* __p) const
{
    ::new (<span class="gs">__p) __</span>func(__f_.first(), __f_.second());
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
void
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::destroy()
{
    __f_.~__compressed_pair&lt;_Fp, _Alloc&gt;();
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
void
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::destroy_deallocate()
{
    typedef allocator_traits&lt;_Alloc&gt; __alloc_traits;
    typedef typename __rebind_alloc_helper&lt;__alloc_traits, __func&gt;::type _Ap;
    <span class="ge">_Ap __a(__f_</span>.second());
    __f_.~__compressed_pair&lt;_Fp, _Alloc&gt;();
    __a.deallocate(this, 1);
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
_Rp
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::operator()(_A0 __a0, <span class="ge">_A1 __a1, _</span>A2 __a2)
{
    typedef __invoke_void_return_wrapper&lt;_Rp&gt; _Invoker;
    return <span class="ge">_Invoker::__call(__f_</span>.first(), <span class="gs">__a0, __</span>a1, __a2);
}



template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
const void*
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::target(const type_info&amp; __ti) const
{
    if (__ti == typeid(_Fp))
        return &amp;__f_.first();
    return (const void*)0;
}

template&lt;class <span class="ge">_Fp, class _</span>Alloc, class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
const std::type_info&amp;
__func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::target_type() const
{
    return typeid(_Fp);
}



}

template&lt;class _Rp&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) function&lt;_Rp()&gt;
{
    typedef <span class="gs">__function::__</span>base&lt;_Rp()&gt; __base;
    aligned_storage&lt;3*sizeof(void*)&gt;::type __buf_;
    <span class="gs">__base* __</span>f_;

public:
    typedef <span class="ge">_Rp result_</span>type;


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit function() : __f_(0) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) function(nullptr_t) : __f_(0) {}
    function(const function&amp;);
    template&lt;class _Fp&gt;
      function(_Fp,
               typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type* = 0);

    template&lt;class _Alloc&gt;
      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
      function(allocator_arg_t, const <span class="ge">_Alloc&amp;) : __f_</span>(0) {}
    template&lt;class _Alloc&gt;
      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
      function(allocator_arg_t, const <span class="ge">_Alloc&amp;, nullptr_</span>t) : __f_(0) {}
    template&lt;class _Alloc&gt;
      function(allocator_arg_t, const _Alloc&amp;, const function&amp;);
    template&lt;class <span class="ge">_Fp, class _</span>Alloc&gt;
      function(allocator_arg_t, const <span class="ge">_Alloc&amp; __a, _</span>Fp __f,
               typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type* = 0);

    function&amp; operator=(const function&amp;);
    function&amp; operator=(nullptr_t);
    template&lt;class _Fp&gt;
      typename enable_if
      &lt;
        !is_integral&lt;_Fp&gt;::value,
        function&amp;
      &gt;::type
      operator=(_Fp);

    ~function();


    void swap(function&amp;);
    template&lt;class <span class="ge">_Fp, class _</span>Alloc&gt;
      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
      void assign(_Fp __f, const <span class="ge">_Alloc&amp; _</span>_a)
        {function(allocator_arg, <span class="gs">__a, __</span>f).swap(*this);}


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) operator bool() const {return __f_;}

private:

    template&lt;class _R2&gt;
      bool operator==(const function&lt;_R2()&gt;&amp;) const;
    template&lt;class _R2&gt;
      bool operator!=(const function&lt;_R2()&gt;&amp;) const;
public:

    _Rp operator()() const;



    const std::type_info&amp; target_type() const;
    template &lt;typename <span class="ge">_Tp&gt; _</span>Tp* target();
    template &lt;typename <span class="ge">_Tp&gt; const _</span>Tp* target() const;

};

template&lt;class _Rp&gt;
function&lt;_Rp()&gt;::function(const function&amp; __f)
{
    if (<span class="gs">__f.__</span>f_ == 0)
        __f_ = 0;
    else if (<span class="gs">__f.__</span>f_ == (const <span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone(__f_</span>);
    }
    else
        __f_ = <span class="gs">__f.__</span>f<span class="ge">_-&gt;_</span>_clone();
}

template&lt;class _Rp&gt;
template&lt;class _Alloc&gt;
function&lt;_Rp()&gt;::function(allocator_arg_t, const <span class="ge">_Alloc&amp;, const function&amp; _</span>_f)
{
    if (<span class="gs">__f.__</span>f_ == 0)
        __f_ = 0;
    else if (<span class="gs">__f.__</span>f_ == (const <span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone(__f_</span>);
    }
    else
        __f_ = <span class="gs">__f.__</span>f<span class="ge">_-&gt;_</span>_clone();
}

template&lt;class _Rp&gt;
template &lt;class _Fp&gt;
function&lt;_Rp()&gt;::function(_Fp __f,
                                     typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type*)
    : __f_(0)
{
    if (<span class="gs">__function::__</span>not_null(__f))
    {
        typedef <span class="gs">__function::__</span>func&lt;_Fp, allocator&lt;_Fp&gt;, <span class="ge">_Rp()&gt; _</span>FF;
        if (sizeof(_FF) &lt;= sizeof(__buf_))
        {
            __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
            ::new (__f_) <span class="ge">_FF(_</span>_f);
        }
        else
        {
            typedef allocator&lt;_FF&gt; _Ap;
            <span class="ge">_Ap _</span>_a;
            typedef __allocator_destructor&lt;_Ap&gt; _Dp;
            unique_ptr&lt;__base, <span class="ge">_Dp&gt; __hold(__a.allocate(1), _</span>Dp(__a, 1));
            ::new (__hold.get()) <span class="ge">_FF(__f, allocator&lt;_</span>Fp&gt;(__a));
            __f_ = __hold.release();
        }
    }
}

template&lt;class _Rp&gt;
template &lt;class <span class="ge">_Fp, class _</span>Alloc&gt;
function&lt;_Rp()&gt;::function(allocator_arg_t, const <span class="ge">_Alloc&amp; __a0, _</span>Fp __f,
                                     typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type*)
    : __f_(0)
{
    typedef allocator_traits&lt;_Alloc&gt; __alloc_traits;
    if (<span class="gs">__function::__</span>not_null(__f))
    {
        typedef <span class="gs">__function::__</span>func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp()&gt; _FF;
        if (sizeof(_FF) &lt;= sizeof(__buf_))
        {
            __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
            ::new (__f_) <span class="ge">_FF(__f, _</span>_a0);
        }
        else
        {
            typedef typename __rebind_alloc_helper&lt;__alloc_traits, <span class="ge">_FF&gt;::type _</span>Ap;
            <span class="ge">_Ap __a(_</span>_a0);
            typedef __allocator_destructor&lt;_Ap&gt; _Dp;
            unique_ptr&lt;__base, <span class="ge">_Dp&gt; __hold(__a.allocate(1), _</span>Dp(__a, 1));
            ::new (__hold.get()) <span class="ge">_FF(__f, _</span>Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template&lt;class _Rp&gt;
function&lt;_Rp()&gt;&amp;
function&lt;_Rp()&gt;::operator=(const function&amp; __f)
{
    if (__f)
        function(__f).swap(*this);
    else
        *this = std::__1::__get_nullptr_t();
    return *this;
}

template&lt;class _Rp&gt;
function&lt;_Rp()&gt;&amp;
function&lt;_Rp()&gt;::operator=(nullptr_t)
{
    <span class="gs">__base* __</span>t = __f_;
    __f_ = 0;
    if (<span class="gs">__t == (__</span>base*)&amp;__buf_)
        __t-&gt;destroy();
    else if (__t)
        __t-&gt;destroy_deallocate();
    return *this;
}

template&lt;class _Rp&gt;
template &lt;class _Fp&gt;
typename enable_if
&lt;
    !is_integral&lt;_Fp&gt;::value,
    function&lt;_Rp()&gt;&amp;
&gt;::type
function&lt;_Rp()&gt;::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template&lt;class _Rp&gt;
function&lt;_Rp()&gt;::~function()
{
    if (__f_ == (<span class="gs">__base*)&amp;__</span>buf_)
        __f_-&gt;destroy();
    else if (__f_)
        __f_-&gt;destroy_deallocate();
}

template&lt;class _Rp&gt;
void
function&lt;_Rp()&gt;::swap(function&amp; __f)
{
    if (std::__1::addressof(__f) == this)
      return;
    if (__f_ == (<span class="gs">__base*)&amp;__</span>buf_ &amp;&amp; <span class="gs">__f.__</span>f_ == (<span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        typename aligned_storage&lt;sizeof(__buf_)&gt;::type __tempbuf;
        <span class="gs">__base* __</span>t = (<span class="gs">__base*)&amp;__</span>tempbuf;
        __f_-&gt;__clone(__t);
        __f_-&gt;destroy();
        __f_ = 0;
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone((__base*)&amp;__buf_</span>);
        <span class="gs">__f.__</span>f_-&gt;destroy();
        <span class="gs">__f.__</span>f_ = 0;
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
        <span class="gs">__t-&gt;__</span>clone((__base*)&amp;__f.__buf_);
        __t-&gt;destroy();
        <span class="gs">__f.__</span>f_ = (<span class="gs">__base*)&amp;__</span>f.__buf_;
    }
    else if (__f_ == (<span class="gs">__base*)&amp;__</span>buf_)
    {
        __f_-&gt;__clone((__base*)&amp;__f.__buf_);
        __f_-&gt;destroy();
        __f_ = <span class="gs">__f.__</span>f_;
        <span class="gs">__f.__</span>f_ = (<span class="gs">__base*)&amp;__</span>f.__buf_;
    }
    else if (<span class="gs">__f.__</span>f_ == (<span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone((__base*)&amp;__buf_</span>);
        <span class="gs">__f.__</span>f_-&gt;destroy();
        <span class="gs">__f.__</span>f_ = __f_;
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
    }
    else
        std::__1::swap(__f_, <span class="gs">__f.__</span>f_);
}

template&lt;class _Rp&gt;
_Rp
function&lt;_Rp()&gt;::operator()() const
{
    if (__f_ == 0)
        __throw_bad_function_call();
    return (*__f_)();
}



template&lt;class _Rp&gt;
const std::type_info&amp;
function&lt;_Rp()&gt;::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_-&gt;target_type();
}

template&lt;class _Rp&gt;
template &lt;typename _Tp&gt;
_Tp*
function&lt;_Rp()&gt;::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (<span class="ge">_Tp*) const_</span>cast&lt;void *&gt;(__f_-&gt;target(typeid(_Tp)));
}

template&lt;class _Rp&gt;
template &lt;typename _Tp&gt;
const _Tp*
function&lt;_Rp()&gt;::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const <span class="ge">_Tp*)__f_</span>-&gt;target(typeid(_Tp));
}



template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) function&lt;_Rp(_A0)&gt;
    : public unary_function&lt;_A0, _Rp&gt;
{
    typedef <span class="gs">__function::__</span>base&lt;_Rp(_A0)&gt; __base;
    aligned_storage&lt;3*sizeof(void*)&gt;::type __buf_;
    <span class="gs">__base* __</span>f_;

public:
    typedef <span class="ge">_Rp result_</span>type;


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit function() : __f_(0) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) function(nullptr_t) : __f_(0) {}
    function(const function&amp;);
    template&lt;class _Fp&gt;
      function(_Fp,
               typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type* = 0);

    template&lt;class _Alloc&gt;
      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
      function(allocator_arg_t, const <span class="ge">_Alloc&amp;) : __f_</span>(0) {}
    template&lt;class _Alloc&gt;
      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
      function(allocator_arg_t, const <span class="ge">_Alloc&amp;, nullptr_</span>t) : __f_(0) {}
    template&lt;class _Alloc&gt;
      function(allocator_arg_t, const _Alloc&amp;, const function&amp;);
    template&lt;class <span class="ge">_Fp, class _</span>Alloc&gt;
      function(allocator_arg_t, const <span class="ge">_Alloc&amp; __a, _</span>Fp __f,
               typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type* = 0);

    function&amp; operator=(const function&amp;);
    function&amp; operator=(nullptr_t);
    template&lt;class _Fp&gt;
      typename enable_if
      &lt;
        !is_integral&lt;_Fp&gt;::value,
        function&amp;
      &gt;::type
      operator=(_Fp);

    ~function();


    void swap(function&amp;);
    template&lt;class <span class="ge">_Fp, class _</span>Alloc&gt;
      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
      void assign(_Fp __f, const <span class="ge">_Alloc&amp; _</span>_a)
        {function(allocator_arg, <span class="gs">__a, __</span>f).swap(*this);}


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) operator bool() const {return __f_;}

private:

    template&lt;class <span class="ge">_R2, class _</span>B0&gt;
      bool operator==(const function&lt;_R2(_B0)&gt;&amp;) const;
    template&lt;class <span class="ge">_R2, class _</span>B0&gt;
      bool operator!=(const function&lt;_R2(_B0)&gt;&amp;) const;
public:

    <span class="ge">_Rp operator()(_</span>A0) const;



    const std::type_info&amp; target_type() const;
    template &lt;typename <span class="ge">_Tp&gt; _</span>Tp* target();
    template &lt;typename <span class="ge">_Tp&gt; const _</span>Tp* target() const;

};

template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
function&lt;_Rp(_A0)&gt;::function(const function&amp; __f)
{
    if (<span class="gs">__f.__</span>f_ == 0)
        __f_ = 0;
    else if (<span class="gs">__f.__</span>f_ == (const <span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone(__f_</span>);
    }
    else
        __f_ = <span class="gs">__f.__</span>f<span class="ge">_-&gt;_</span>_clone();
}

template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
template&lt;class _Alloc&gt;
function&lt;_Rp(_A0)&gt;::function(allocator_arg_t, const <span class="ge">_Alloc&amp;, const function&amp; _</span>_f)
{
    if (<span class="gs">__f.__</span>f_ == 0)
        __f_ = 0;
    else if (<span class="gs">__f.__</span>f_ == (const <span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone(__f_</span>);
    }
    else
        __f_ = <span class="gs">__f.__</span>f<span class="ge">_-&gt;_</span>_clone();
}

template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
template &lt;class _Fp&gt;
function&lt;_Rp(_A0)&gt;::function(_Fp __f,
                                     typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type*)
    : __f_(0)
{
    if (<span class="gs">__function::__</span>not_null(__f))
    {
        typedef <span class="gs">__function::__</span>func&lt;_Fp, allocator&lt;_Fp&gt;, <span class="ge">_Rp(_</span>A0)&gt; _FF;
        if (sizeof(_FF) &lt;= sizeof(__buf_))
        {
            __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
            ::new (__f_) <span class="ge">_FF(_</span>_f);
        }
        else
        {
            typedef allocator&lt;_FF&gt; _Ap;
            <span class="ge">_Ap _</span>_a;
            typedef __allocator_destructor&lt;_Ap&gt; _Dp;
            unique_ptr&lt;__base, <span class="ge">_Dp&gt; __hold(__a.allocate(1), _</span>Dp(__a, 1));
            ::new (__hold.get()) <span class="ge">_FF(__f, allocator&lt;_</span>Fp&gt;(__a));
            __f_ = __hold.release();
        }
    }
}

template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
template &lt;class <span class="ge">_Fp, class _</span>Alloc&gt;
function&lt;_Rp(_A0)&gt;::function(allocator_arg_t, const <span class="ge">_Alloc&amp; __a0, _</span>Fp __f,
                                     typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type*)
    : __f_(0)
{
    typedef allocator_traits&lt;_Alloc&gt; __alloc_traits;
    if (<span class="gs">__function::__</span>not_null(__f))
    {
        typedef <span class="gs">__function::__</span>func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0)&gt; _FF;
        if (sizeof(_FF) &lt;= sizeof(__buf_))
        {
            __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
            ::new (__f_) <span class="ge">_FF(__f, _</span>_a0);
        }
        else
        {
            typedef typename __rebind_alloc_helper&lt;__alloc_traits, <span class="ge">_FF&gt;::type _</span>Ap;
            <span class="ge">_Ap __a(_</span>_a0);
            typedef __allocator_destructor&lt;_Ap&gt; _Dp;
            unique_ptr&lt;__base, <span class="ge">_Dp&gt; __hold(__a.allocate(1), _</span>Dp(__a, 1));
            ::new (__hold.get()) <span class="ge">_FF(__f, _</span>Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
function&lt;_Rp(_A0)&gt;&amp;
function&lt;_Rp(_A0)&gt;::operator=(const function&amp; __f)
{
    if (__f)
        function(__f).swap(*this);
    else
        *this = std::__1::__get_nullptr_t();
    return *this;
}

template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
function&lt;_Rp(_A0)&gt;&amp;
function&lt;_Rp(_A0)&gt;::operator=(nullptr_t)
{
    <span class="gs">__base* __</span>t = __f_;
    __f_ = 0;
    if (<span class="gs">__t == (__</span>base*)&amp;__buf_)
        __t-&gt;destroy();
    else if (__t)
        __t-&gt;destroy_deallocate();
    return *this;
}

template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
template &lt;class _Fp&gt;
typename enable_if
&lt;
    !is_integral&lt;_Fp&gt;::value,
    function&lt;_Rp(_A0)&gt;&amp;
&gt;::type
function&lt;_Rp(_A0)&gt;::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
function&lt;_Rp(_A0)&gt;::~function()
{
    if (__f_ == (<span class="gs">__base*)&amp;__</span>buf_)
        __f_-&gt;destroy();
    else if (__f_)
        __f_-&gt;destroy_deallocate();
}

template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
void
function&lt;_Rp(_A0)&gt;::swap(function&amp; __f)
{
    if (std::__1::addressof(__f) == this)
      return;
    if (__f_ == (<span class="gs">__base*)&amp;__</span>buf_ &amp;&amp; <span class="gs">__f.__</span>f_ == (<span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        typename aligned_storage&lt;sizeof(__buf_)&gt;::type __tempbuf;
        <span class="gs">__base* __</span>t = (<span class="gs">__base*)&amp;__</span>tempbuf;
        __f_-&gt;__clone(__t);
        __f_-&gt;destroy();
        __f_ = 0;
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone((__base*)&amp;__buf_</span>);
        <span class="gs">__f.__</span>f_-&gt;destroy();
        <span class="gs">__f.__</span>f_ = 0;
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
        <span class="gs">__t-&gt;__</span>clone((__base*)&amp;__f.__buf_);
        __t-&gt;destroy();
        <span class="gs">__f.__</span>f_ = (<span class="gs">__base*)&amp;__</span>f.__buf_;
    }
    else if (__f_ == (<span class="gs">__base*)&amp;__</span>buf_)
    {
        __f_-&gt;__clone((__base*)&amp;__f.__buf_);
        __f_-&gt;destroy();
        __f_ = <span class="gs">__f.__</span>f_;
        <span class="gs">__f.__</span>f_ = (<span class="gs">__base*)&amp;__</span>f.__buf_;
    }
    else if (<span class="gs">__f.__</span>f_ == (<span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone((__base*)&amp;__buf_</span>);
        <span class="gs">__f.__</span>f_-&gt;destroy();
        <span class="gs">__f.__</span>f_ = __f_;
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
    }
    else
        std::__1::swap(__f_, <span class="gs">__f.__</span>f_);
}

template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
_Rp
function&lt;_Rp(_A0)&gt;::operator()(_A0 __a0) const
{
    if (__f_ == 0)
        __throw_bad_function_call();
    return (*__f_)(__a0);
}



template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
const std::type_info&amp;
function&lt;_Rp(_A0)&gt;::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_-&gt;target_type();
}

template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
template &lt;typename _Tp&gt;
_Tp*
function&lt;_Rp(_A0)&gt;::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (<span class="ge">_Tp*) const_</span>cast&lt;void *&gt;(__f_-&gt;target(typeid(_Tp)));
}

template&lt;class <span class="ge">_Rp, class _</span>A0&gt;
template &lt;typename _Tp&gt;
const _Tp*
function&lt;_Rp(_A0)&gt;::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const <span class="ge">_Tp*)__f_</span>-&gt;target(typeid(_Tp));
}



template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) function&lt;_Rp(_A0, _A1)&gt;
    : public binary_function&lt;_A0, <span class="ge">_A1, _</span>Rp&gt;
{
    typedef <span class="gs">__function::__</span>base&lt;_Rp(_A0, <span class="ge">_A1)&gt; _</span>_base;
    aligned_storage&lt;3*sizeof(void*)&gt;::type __buf_;
    <span class="gs">__base* __</span>f_;

public:
    typedef <span class="ge">_Rp result_</span>type;


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit function() : __f_(0) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) function(nullptr_t) : __f_(0) {}
    function(const function&amp;);
    template&lt;class _Fp&gt;
      function(_Fp,
               typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type* = 0);

    template&lt;class _Alloc&gt;
      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
      function(allocator_arg_t, const <span class="ge">_Alloc&amp;) : __f_</span>(0) {}
    template&lt;class _Alloc&gt;
      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
      function(allocator_arg_t, const <span class="ge">_Alloc&amp;, nullptr_</span>t) : __f_(0) {}
    template&lt;class _Alloc&gt;
      function(allocator_arg_t, const _Alloc&amp;, const function&amp;);
    template&lt;class <span class="ge">_Fp, class _</span>Alloc&gt;
      function(allocator_arg_t, const <span class="ge">_Alloc&amp; __a, _</span>Fp __f,
               typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type* = 0);

    function&amp; operator=(const function&amp;);
    function&amp; operator=(nullptr_t);
    template&lt;class _Fp&gt;
      typename enable_if
      &lt;
        !is_integral&lt;_Fp&gt;::value,
        function&amp;
      &gt;::type
      operator=(_Fp);

    ~function();


    void swap(function&amp;);
    template&lt;class <span class="ge">_Fp, class _</span>Alloc&gt;
      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
      void assign(_Fp __f, const <span class="ge">_Alloc&amp; _</span>_a)
        {function(allocator_arg, <span class="gs">__a, __</span>f).swap(*this);}


    operator bool() const {return __f_;}

private:

    template&lt;class <span class="ge">_R2, class _</span>B0, class _B1&gt;
      bool operator==(const function&lt;_R2(_B0, _B1)&gt;&amp;) const;
    template&lt;class <span class="ge">_R2, class _</span>B0, class _B1&gt;
      bool operator!=(const function&lt;_R2(_B0, _B1)&gt;&amp;) const;
public:

    <span class="ge">_Rp operator()(_</span>A0, _A1) const;



    const std::type_info&amp; target_type() const;
    template &lt;typename <span class="ge">_Tp&gt; _</span>Tp* target();
    template &lt;typename <span class="ge">_Tp&gt; const _</span>Tp* target() const;

};

template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
function&lt;_Rp(_A0, <span class="ge">_A1)&gt;::function(const function&amp; _</span>_f)
{
    if (<span class="gs">__f.__</span>f_ == 0)
        __f_ = 0;
    else if (<span class="gs">__f.__</span>f_ == (const <span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone(__f_</span>);
    }
    else
        __f_ = <span class="gs">__f.__</span>f<span class="ge">_-&gt;_</span>_clone();
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
template&lt;class _Alloc&gt;
function&lt;_Rp(_A0, <span class="ge">_A1)&gt;::function(allocator_</span>arg_t, const <span class="ge">_Alloc&amp;, const function&amp; _</span>_f)
{
    if (<span class="gs">__f.__</span>f_ == 0)
        __f_ = 0;
    else if (<span class="gs">__f.__</span>f_ == (const <span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone(__f_</span>);
    }
    else
        __f_ = <span class="gs">__f.__</span>f<span class="ge">_-&gt;_</span>_clone();
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
template &lt;class _Fp&gt;
function&lt;_Rp(_A0, <span class="ge">_A1)&gt;::function(_</span>Fp __f,
                                 typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type*)
    : __f_(0)
{
    if (<span class="gs">__function::__</span>not_null(__f))
    {
        typedef <span class="gs">__function::__</span>func&lt;_Fp, allocator&lt;_Fp&gt;, <span class="ge">_Rp(_</span>A0, <span class="ge">_A1)&gt; _</span>FF;
        if (sizeof(_FF) &lt;= sizeof(__buf_))
        {
            __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
            ::new (__f_) <span class="ge">_FF(_</span>_f);
        }
        else
        {
            typedef allocator&lt;_FF&gt; _Ap;
            <span class="ge">_Ap _</span>_a;
            typedef __allocator_destructor&lt;_Ap&gt; _Dp;
            unique_ptr&lt;__base, <span class="ge">_Dp&gt; __hold(__a.allocate(1), _</span>Dp(__a, 1));
            ::new (__hold.get()) <span class="ge">_FF(__f, allocator&lt;_</span>Fp&gt;(__a));
            __f_ = __hold.release();
        }
    }
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
template &lt;class <span class="ge">_Fp, class _</span>Alloc&gt;
function&lt;_Rp(_A0, <span class="ge">_A1)&gt;::function(allocator_</span>arg_t, const <span class="ge">_Alloc&amp; __a0, _</span>Fp __f,
                                 typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type*)
    : __f_(0)
{
    typedef allocator_traits&lt;_Alloc&gt; __alloc_traits;
    if (<span class="gs">__function::__</span>not_null(__f))
    {
        typedef <span class="gs">__function::__</span>func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1)&gt; _</span>FF;
        if (sizeof(_FF) &lt;= sizeof(__buf_))
        {
            __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
            ::new (__f_) <span class="ge">_FF(__f, _</span>_a0);
        }
        else
        {
            typedef typename __rebind_alloc_helper&lt;__alloc_traits, <span class="ge">_FF&gt;::type _</span>Ap;
            <span class="ge">_Ap __a(_</span>_a0);
            typedef __allocator_destructor&lt;_Ap&gt; _Dp;
            unique_ptr&lt;__base, <span class="ge">_Dp&gt; __hold(__a.allocate(1), _</span>Dp(__a, 1));
            ::new (__hold.get()) <span class="ge">_FF(__f, _</span>Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
function&lt;_Rp(_A0, _A1)&gt;&amp;
function&lt;_Rp(_A0, <span class="ge">_A1)&gt;::operator=(const function&amp; _</span>_f)
{
    if (__f)
        function(__f).swap(*this);
    else
        *this = std::__1::__get_nullptr_t();
    return *this;
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
function&lt;_Rp(_A0, _A1)&gt;&amp;
function&lt;_Rp(_A0, <span class="ge">_A1)&gt;::operator=(nullptr_</span>t)
{
    <span class="gs">__base* __</span>t = __f_;
    __f_ = 0;
    if (<span class="gs">__t == (__</span>base*)&amp;__buf_)
        __t-&gt;destroy();
    else if (__t)
        __t-&gt;destroy_deallocate();
    return *this;
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
template &lt;class _Fp&gt;
typename enable_if
&lt;
    !is_integral&lt;_Fp&gt;::value,
    function&lt;_Rp(_A0, _A1)&gt;&amp;
&gt;::type
function&lt;_Rp(_A0, <span class="ge">_A1)&gt;::operator=(_</span>Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
function&lt;_Rp(_A0, _A1)&gt;::~function()
{
    if (__f_ == (<span class="gs">__base*)&amp;__</span>buf_)
        __f_-&gt;destroy();
    else if (__f_)
        __f_-&gt;destroy_deallocate();
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
void
function&lt;_Rp(_A0, <span class="ge">_A1)&gt;::swap(function&amp; _</span>_f)
{
    if (std::__1::addressof(__f) == this)
      return;
    if (__f_ == (<span class="gs">__base*)&amp;__</span>buf_ &amp;&amp; <span class="gs">__f.__</span>f_ == (<span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        typename aligned_storage&lt;sizeof(__buf_)&gt;::type __tempbuf;
        <span class="gs">__base* __</span>t = (<span class="gs">__base*)&amp;__</span>tempbuf;
        __f_-&gt;__clone(__t);
        __f_-&gt;destroy();
        __f_ = 0;
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone((__base*)&amp;__buf_</span>);
        <span class="gs">__f.__</span>f_-&gt;destroy();
        <span class="gs">__f.__</span>f_ = 0;
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
        <span class="gs">__t-&gt;__</span>clone((__base*)&amp;__f.__buf_);
        __t-&gt;destroy();
        <span class="gs">__f.__</span>f_ = (<span class="gs">__base*)&amp;__</span>f.__buf_;
    }
    else if (__f_ == (<span class="gs">__base*)&amp;__</span>buf_)
    {
        __f_-&gt;__clone((__base*)&amp;__f.__buf_);
        __f_-&gt;destroy();
        __f_ = <span class="gs">__f.__</span>f_;
        <span class="gs">__f.__</span>f_ = (<span class="gs">__base*)&amp;__</span>f.__buf_;
    }
    else if (<span class="gs">__f.__</span>f_ == (<span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone((__base*)&amp;__buf_</span>);
        <span class="gs">__f.__</span>f_-&gt;destroy();
        <span class="gs">__f.__</span>f_ = __f_;
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
    }
    else
        std::__1::swap(__f_, <span class="gs">__f.__</span>f_);
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
_Rp
function&lt;_Rp(_A0, <span class="ge">_A1)&gt;::operator()(_</span>A0 __a0, <span class="ge">_A1 _</span>_a1) const
{
    if (__f_ == 0)
        __throw_bad_function_call();
    return (*__f_)(__a0, __a1);
}



template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
const std::type_info&amp;
function&lt;_Rp(_A0, <span class="ge">_A1)&gt;::target_</span>type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_-&gt;target_type();
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
template &lt;typename _Tp&gt;
_Tp*
function&lt;_Rp(_A0, _A1)&gt;::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (<span class="ge">_Tp*) const_</span>cast&lt;void *&gt;(__f_-&gt;target(typeid(_Tp)));
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class _A1&gt;
template &lt;typename _Tp&gt;
const _Tp*
function&lt;_Rp(_A0, _A1)&gt;::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const <span class="ge">_Tp*)__f_</span>-&gt;target(typeid(_Tp));
}



template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;
{
    typedef <span class="gs">__function::__</span>base&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt; __base;
    aligned_storage&lt;3*sizeof(void*)&gt;::type __buf_;
    <span class="gs">__base* __</span>f_;

public:
    typedef <span class="ge">_Rp result_</span>type;


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit function() : __f_(0) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) function(nullptr_t) : __f_(0) {}
    function(const function&amp;);
    template&lt;class _Fp&gt;
      function(_Fp,
               typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type* = 0);

    template&lt;class _Alloc&gt;
      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
      function(allocator_arg_t, const <span class="ge">_Alloc&amp;) : __f_</span>(0) {}
    template&lt;class _Alloc&gt;
      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
      function(allocator_arg_t, const <span class="ge">_Alloc&amp;, nullptr_</span>t) : __f_(0) {}
    template&lt;class _Alloc&gt;
      function(allocator_arg_t, const _Alloc&amp;, const function&amp;);
    template&lt;class <span class="ge">_Fp, class _</span>Alloc&gt;
      function(allocator_arg_t, const <span class="ge">_Alloc&amp; __a, _</span>Fp __f,
               typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type* = 0);

    function&amp; operator=(const function&amp;);
    function&amp; operator=(nullptr_t);
    template&lt;class _Fp&gt;
      typename enable_if
      &lt;
        !is_integral&lt;_Fp&gt;::value,
        function&amp;
      &gt;::type
      operator=(_Fp);

    ~function();


    void swap(function&amp;);
    template&lt;class <span class="ge">_Fp, class _</span>Alloc&gt;
      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
      void assign(_Fp __f, const <span class="ge">_Alloc&amp; _</span>_a)
        {function(allocator_arg, <span class="gs">__a, __</span>f).swap(*this);}


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) operator bool() const {return __f_;}

private:

    template&lt;class <span class="ge">_R2, class _</span>B0, class <span class="ge">_B1, class _</span>B2&gt;
      bool operator==(const function&lt;_R2(_B0, <span class="ge">_B1, _</span>B2)&gt;&amp;) const;
    template&lt;class <span class="ge">_R2, class _</span>B0, class <span class="ge">_B1, class _</span>B2&gt;
      bool operator!=(const function&lt;_R2(_B0, <span class="ge">_B1, _</span>B2)&gt;&amp;) const;
public:

    <span class="ge">_Rp operator()(_</span>A0, <span class="ge">_A1, _</span>A2) const;



    const std::type_info&amp; target_type() const;
    template &lt;typename <span class="ge">_Tp&gt; _</span>Tp* target();
    template &lt;typename <span class="ge">_Tp&gt; const _</span>Tp* target() const;

};

template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::function(const function&amp; __f)
{
    if (<span class="gs">__f.__</span>f_ == 0)
        __f_ = 0;
    else if (<span class="gs">__f.__</span>f_ == (const <span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone(__f_</span>);
    }
    else
        __f_ = <span class="gs">__f.__</span>f<span class="ge">_-&gt;_</span>_clone();
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
template&lt;class _Alloc&gt;
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::function(allocator_arg_t, const _Alloc&amp;,
                                      const function&amp; __f)
{
    if (<span class="gs">__f.__</span>f_ == 0)
        __f_ = 0;
    else if (<span class="gs">__f.__</span>f_ == (const <span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone(__f_</span>);
    }
    else
        __f_ = <span class="gs">__f.__</span>f<span class="ge">_-&gt;_</span>_clone();
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
template &lt;class _Fp&gt;
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::function(_Fp __f,
                                     typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type*)
    : __f_(0)
{
    if (<span class="gs">__function::__</span>not_null(__f))
    {
        typedef <span class="gs">__function::__</span>func&lt;_Fp, allocator&lt;_Fp&gt;, <span class="ge">_Rp(_</span>A0, <span class="ge">_A1, _</span>A2)&gt; _FF;
        if (sizeof(_FF) &lt;= sizeof(__buf_))
        {
            __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
            ::new (__f_) <span class="ge">_FF(_</span>_f);
        }
        else
        {
            typedef allocator&lt;_FF&gt; _Ap;
            <span class="ge">_Ap _</span>_a;
            typedef __allocator_destructor&lt;_Ap&gt; _Dp;
            unique_ptr&lt;__base, <span class="ge">_Dp&gt; __hold(__a.allocate(1), _</span>Dp(__a, 1));
            ::new (__hold.get()) <span class="ge">_FF(__f, allocator&lt;_</span>Fp&gt;(__a));
            __f_ = __hold.release();
        }
    }
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
template &lt;class <span class="ge">_Fp, class _</span>Alloc&gt;
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::function(allocator_arg_t, const <span class="ge">_Alloc&amp; __a0, _</span>Fp __f,
                                     typename enable_if&lt;!is_integral&lt;_Fp&gt;::value&gt;::type*)
    : __f_(0)
{
    typedef allocator_traits&lt;_Alloc&gt; __alloc_traits;
    if (<span class="gs">__function::__</span>not_null(__f))
    {
        typedef <span class="gs">__function::__</span>func&lt;_Fp, <span class="ge">_Alloc, _</span>Rp(_A0, <span class="ge">_A1, _</span>A2)&gt; _FF;
        if (sizeof(_FF) &lt;= sizeof(__buf_))
        {
            __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
            ::new (__f_) <span class="ge">_FF(__f, _</span>_a0);
        }
        else
        {
            typedef typename __rebind_alloc_helper&lt;__alloc_traits, <span class="ge">_FF&gt;::type _</span>Ap;
            <span class="ge">_Ap __a(_</span>_a0);
            typedef __allocator_destructor&lt;_Ap&gt; _Dp;
            unique_ptr&lt;__base, <span class="ge">_Dp&gt; __hold(__a.allocate(1), _</span>Dp(__a, 1));
            ::new (__hold.get()) <span class="ge">_FF(__f, _</span>Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;&amp;
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::operator=(const function&amp; __f)
{
    if (__f)
        function(__f).swap(*this);
    else
        *this = std::__1::__get_nullptr_t();
    return *this;
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;&amp;
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::operator=(nullptr_t)
{
    <span class="gs">__base* __</span>t = __f_;
    __f_ = 0;
    if (<span class="gs">__t == (__</span>base*)&amp;__buf_)
        __t-&gt;destroy();
    else if (__t)
        __t-&gt;destroy_deallocate();
    return *this;
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
template &lt;class _Fp&gt;
typename enable_if
&lt;
    !is_integral&lt;_Fp&gt;::value,
    function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;&amp;
&gt;::type
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::~function()
{
    if (__f_ == (<span class="gs">__base*)&amp;__</span>buf_)
        __f_-&gt;destroy();
    else if (__f_)
        __f_-&gt;destroy_deallocate();
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
void
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::swap(function&amp; __f)
{
    if (std::__1::addressof(__f) == this)
      return;
    if (__f_ == (<span class="gs">__base*)&amp;__</span>buf_ &amp;&amp; <span class="gs">__f.__</span>f_ == (<span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        typename aligned_storage&lt;sizeof(__buf_)&gt;::type __tempbuf;
        <span class="gs">__base* __</span>t = (<span class="gs">__base*)&amp;__</span>tempbuf;
        __f_-&gt;__clone(__t);
        __f_-&gt;destroy();
        __f_ = 0;
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone((__base*)&amp;__buf_</span>);
        <span class="gs">__f.__</span>f_-&gt;destroy();
        <span class="gs">__f.__</span>f_ = 0;
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
        <span class="gs">__t-&gt;__</span>clone((__base*)&amp;__f.__buf_);
        __t-&gt;destroy();
        <span class="gs">__f.__</span>f_ = (<span class="gs">__base*)&amp;__</span>f.__buf_;
    }
    else if (__f_ == (<span class="gs">__base*)&amp;__</span>buf_)
    {
        __f_-&gt;__clone((__base*)&amp;__f.__buf_);
        __f_-&gt;destroy();
        __f_ = <span class="gs">__f.__</span>f_;
        <span class="gs">__f.__</span>f_ = (<span class="gs">__base*)&amp;__</span>f.__buf_;
    }
    else if (<span class="gs">__f.__</span>f_ == (<span class="gs">__base*)&amp;__</span>f.__buf_)
    {
        <span class="gs">__f.__</span>f<span class="ge">_-&gt;__clone((__base*)&amp;__buf_</span>);
        <span class="gs">__f.__</span>f_-&gt;destroy();
        <span class="gs">__f.__</span>f_ = __f_;
        __f_ = (<span class="gs">__base*)&amp;__</span>buf_;
    }
    else
        std::__1::swap(__f_, <span class="gs">__f.__</span>f_);
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
_Rp
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::operator()(_A0 __a0, <span class="ge">_A1 __a1, _</span>A2 __a2) const
{
    if (__f_ == 0)
        __throw_bad_function_call();
    return (*__f_)(__a0, <span class="gs">__a1, __</span>a2);
}



template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
const std::type_info&amp;
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_-&gt;target_type();
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
template &lt;typename _Tp&gt;
_Tp*
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (<span class="ge">_Tp*) const_</span>cast&lt;void *&gt;(__f_-&gt;target(typeid(_Tp)));
}

template&lt;class <span class="ge">_Rp, class _</span>A0, class <span class="ge">_A1, class _</span>A2&gt;
template &lt;typename _Tp&gt;
const _Tp*
function&lt;_Rp(_A0, <span class="ge">_A1, _</span>A2)&gt;::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const <span class="ge">_Tp*)__f_</span>-&gt;target(typeid(_Tp));
}



template &lt;class _Fp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const function&lt;_Fp&gt;&amp; __f, nullptr_t) {return !__f;}

template &lt;class _Fp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(nullptr_t, const function&lt;_Fp&gt;&amp; <span class="gs">__f) {return !__</span>f;}

template &lt;class _Fp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const function&lt;_Fp&gt;&amp; __f, nullptr_t) {return (bool)__f;}

template &lt;class _Fp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(nullptr_t, const function&lt;_Fp&gt;&amp; <span class="gs">__f) {return (bool)__</span>f;}

template &lt;class _Fp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
swap(function&lt;_Fp&gt;&amp; __x, function&lt;_Fp&gt;&amp; __y)
{return <span class="gs">__x.swap(__</span>y);}







template&lt;class <span class="ge">_Tp&gt; struct __is_</span>bind_expression : public false_type {};
template&lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_bind_expression
    : public __is_bind_expression&lt;typename remove_cv&lt;_Tp&gt;::type&gt; {};






template&lt;class <span class="ge">_Tp&gt; struct __is_</span>placeholder : public integral_constant&lt;int, 0&gt; {};
template&lt;class <span class="ge">_Tp&gt; struct __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) is_placeholder
    : public __is_placeholder&lt;typename remove_cv&lt;_Tp&gt;::type&gt; {};






namespace placeholders
{

template &lt;int <span class="ge">_Np&gt; struct _</span>_ph {};


<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) extern const __ph&lt;1&gt; _1;
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) extern const __ph&lt;2&gt; _2;
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) extern const __ph&lt;3&gt; _3;
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) extern const __ph&lt;4&gt; _4;
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) extern const __ph&lt;5&gt; _5;
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) extern const __ph&lt;6&gt; _6;
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) extern const __ph&lt;7&gt; _7;
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) extern const __ph&lt;8&gt; _8;
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) extern const __ph&lt;9&gt; _9;
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) extern const __ph&lt;10&gt; _10;
}

template&lt;int _Np&gt;
struct __is_placeholder&lt;placeholders::__ph&lt;_Np&gt; &gt;
    : public integral_constant&lt;int, _Np&gt; {};
template &lt;class <span class="ge">_BinaryPredicate, class _</span>ForwardIterator1, class _ForwardIterator2&gt;
pair&lt;_ForwardIterator1, _ForwardIterator1&gt;
__search(_ForwardIterator1 __first1, <span class="ge">_ForwardIterator1 _</span>_last1,
         <span class="ge">_ForwardIterator2 __first2, _</span>ForwardIterator2 __last2, <span class="ge">_BinaryPredicate _</span>_pred,
         forward_iterator_tag, forward_iterator_tag)
{
    if (<span class="gs">__first2 == __</span>last2)
        return make_pair(__first1, __first1);
    while (true)
    {

        while (true)
        {
            if (<span class="gs">__first1 == __</span>last1)
                return make_pair(__last1, __last1);
            if (<span class="gs">__pred(*__</span>first1, *__first2))
                break;
            ++__first1;
        }

        <span class="ge">_ForwardIterator1 __m1 = _</span>_first1;
        <span class="ge">_ForwardIterator2 __m2 = _</span>_first2;
        while (true)
        {
            if (++__m2 == __last2)
                return make_pair(__first1, __m1);
            if (++__m1 == __last1)
                return make_pair(__last1, __last1);
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template &lt;class <span class="ge">_BinaryPredicate, class _</span>RandomAccessIterator1, class _RandomAccessIterator2&gt;

pair&lt;_RandomAccessIterator1, _RandomAccessIterator1&gt;
__search(_RandomAccessIterator1 __first1, <span class="ge">_RandomAccessIterator1 _</span>_last1,
         <span class="ge">_RandomAccessIterator2 __first2, _</span>RandomAccessIterator2 __last2, <span class="ge">_BinaryPredicate _</span>_pred,
           random_access_iterator_tag, random_access_iterator_tag)
{
    typedef typename iterator_traits&lt;_RandomAccessIterator1&gt;::difference_type _D1;
    typedef typename iterator_traits&lt;_RandomAccessIterator2&gt;::difference_type _D2;

    const <span class="ge">_D2 __len2 = __last2 - _</span>_first2;
    if (__len2 == 0)
        return make_pair(__first1, __first1);
    const <span class="ge">_D1 __len1 = __last1 - _</span>_first1;
    if (<span class="gs">__len1 &lt; __</span>len2)
        return make_pair(__last1, __last1);
    const <span class="ge">_RandomAccessIterator1 __s = __last1 - (_</span>_len2 - 1);

    while (true)
    {
        while (true)
        {
            if (<span class="gs">__first1 == __</span>s)
                return make_pair(__last1, __last1);
            if (<span class="gs">__pred(*__</span>first1, *__first2))
                break;
            ++__first1;
        }

        <span class="ge">_RandomAccessIterator1 __m1 = _</span>_first1;
        <span class="ge">_RandomAccessIterator2 __m2 = _</span>_first2;
         while (true)
         {
             if (++__m2 == __last2)
                 return make_pair(__first1, <span class="gs">__first1 + __</span>len2);
             ++__m1;
             if (!__pred(*__m1, *__m2))
             {
                 ++__first1;
                 break;
             }
         }
    }
}
template &lt;class <span class="ge">_Container, class _</span>Predicate&gt;
inline void __libcpp_erase_if_container( <span class="ge">_Container&amp; __c, _</span>Predicate __pred)
{
 for (typename <span class="ge">_Container::iterator __iter = __c.begin(), __last = __c.end(); __iter != _</span>_last;)
 {
  if (<span class="gs">__pred(*__</span>iter))
   <span class="gs">__iter = __</span>c.erase(__iter);
  else
   ++__iter;
 }
}

} }






namespace std { inline namespace __1 {



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_ctz(unsigned <span class="gs">__x) throw() { return __</span>builtin_ctz(__x); }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_ctz(unsigned long <span class="gs">__x) throw() { return __</span>builtin_ctzl(__x); }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_ctz(unsigned long long <span class="gs">__x) throw() { return __</span>builtin_ctzll(__x); }


inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_clz(unsigned <span class="gs">__x) throw() { return __</span>builtin_clz(__x); }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_clz(unsigned long <span class="gs">__x) throw() { return __</span>builtin_clzl(__x); }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_clz(unsigned long long <span class="gs">__x) throw() { return __</span>builtin_clzll(__x); }


inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_popcount(unsigned <span class="gs">__x) throw() { return __</span>builtin_popcount(__x); }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_popcount(unsigned long <span class="gs">__x) throw() { return __</span>builtin_popcountl(__x); }

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_popcount(unsigned long long <span class="gs">__x) throw() { return __</span>builtin_popcountll(__x); }
template &lt;class _Tp&gt;
using __bitop_unsigned_integer = integral_constant&lt;bool,
         is_integral&lt;_Tp&gt;::value &amp;&amp;
         is_unsigned&lt;_Tp&gt;::value &amp;&amp;
        <span class="ge">_IsNotSame&lt;typename remove_</span>cv&lt;_Tp&gt;::type, bool&gt;::value &amp;&amp;
        <span class="ge">_IsNotSame&lt;typename remove_</span>cv&lt;_Tp&gt;::type, signed char&gt;::value &amp;&amp;
        <span class="ge">_IsNotSame&lt;typename remove_</span>cv&lt;_Tp&gt;::type, wchar_t&gt;::value &amp;&amp;
        <span class="ge">_IsNotSame&lt;typename remove_</span>cv&lt;_Tp&gt;::type, char16_t&gt;::value &amp;&amp;
        <span class="ge">_IsNotSame&lt;typename remove_</span>cv&lt;_Tp&gt;::type, char32_t&gt;::value
    &gt;;


template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __rotl(_</span>Tp <span class="gs">__t, unsigned int __</span>cnt) throw()
{
    <span class="ge">_Static_</span>assert(__bitop_unsigned_integer&lt;_Tp&gt;::value, &quot;__rotl requires unsigned&quot;);
    const unsigned int __dig = numeric_limits&lt;_Tp&gt;::digits;
    if ((__cnt % __dig) == 0)
        return __t;
    return (<span class="gs">__t &lt;&lt; (__</span>cnt % <span class="gs">__dig)) | (__</span>t &gt;&gt; (<span class="gs">__dig - (__</span>cnt % __dig)));
}


template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __rotr(_</span>Tp <span class="gs">__t, unsigned int __</span>cnt) throw()
{
    <span class="ge">_Static_</span>assert(__bitop_unsigned_integer&lt;_Tp&gt;::value, &quot;__rotr requires unsigned&quot;);
    const unsigned int __dig = numeric_limits&lt;_Tp&gt;::digits;
    if ((__cnt % __dig) == 0)
        return __t;
    return (<span class="gs">__t &gt;&gt; (__</span>cnt % <span class="gs">__dig)) | (__</span>t &lt;&lt; (<span class="gs">__dig - (__</span>cnt % __dig)));
}



template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __countr_zero(_Tp __t) throw()
{
    <span class="ge">_Static_</span>assert(__bitop_unsigned_integer&lt;_Tp&gt;::value, &quot;__countr_zero requires unsigned&quot;);
    if (__t == 0)
        return numeric_limits&lt;_Tp&gt;::digits;

    if (sizeof(_Tp) &lt;= sizeof(unsigned int))
        return __libcpp_ctz(static_cast&lt;unsigned int&gt;(__t));
    else if (sizeof(_Tp) &lt;= sizeof(unsigned long))
        return __libcpp_ctz(static_cast&lt;unsigned long&gt;(__t));
    else if (sizeof(_Tp) &lt;= sizeof(unsigned long long))
        return __libcpp_ctz(static_cast&lt;unsigned long long&gt;(__t));
    else
    {
        int __ret = 0;
        int __iter = 0;
        const unsigned int __ulldigits = numeric_limits&lt;unsigned long long&gt;::digits;
        while ((__iter = __libcpp_ctz(static_cast&lt;unsigned long long&gt;(__t))) == __ulldigits)
        {
            <span class="gs">__ret += __</span>iter;
            <span class="gs">__t &gt;&gt;= __</span>ulldigits;
        }
        return <span class="gs">__ret + __</span>iter;
    }
}

template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __countl_zero(_Tp __t) throw()
{
    <span class="ge">_Static_</span>assert(__bitop_unsigned_integer&lt;_Tp&gt;::value, &quot;__countl_zero requires unsigned&quot;);
    if (__t == 0)
        return numeric_limits&lt;_Tp&gt;::digits;

    if (sizeof(_Tp) &lt;= sizeof(unsigned int))
        return __libcpp_clz(static_cast&lt;unsigned int&gt;(__t))
              <span class="k">-</span> (numeric_limits&lt;unsigned int&gt;::digits - numeric_limits&lt;_Tp&gt;::digits);
    else if (sizeof(_Tp) &lt;= sizeof(unsigned long))
        return __libcpp_clz(static_cast&lt;unsigned long&gt;(__t))
              <span class="k">-</span> (numeric_limits&lt;unsigned long&gt;::digits - numeric_limits&lt;_Tp&gt;::digits);
    else if (sizeof(_Tp) &lt;= sizeof(unsigned long long))
        return __libcpp_clz(static_cast&lt;unsigned long long&gt;(__t))
              <span class="k">-</span> (numeric_limits&lt;unsigned long long&gt;::digits - numeric_limits&lt;_Tp&gt;::digits);
    else
    {
        int __ret = 0;
        int __iter = 0;
        const unsigned int __ulldigits = numeric_limits&lt;unsigned long long&gt;::digits;
        while (true) {
            <span class="gs">__t = __</span>rotr(__t, __ulldigits);
            if ((__iter = __countl_zero(static_cast&lt;unsigned long long&gt;(__t))) != __ulldigits)
                break;
            <span class="gs">__ret += __</span>iter;
            }
        return <span class="gs">__ret + __</span>iter;
    }
}

template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __countl_one(_Tp __t) throw()
{
    <span class="ge">_Static_</span>assert(__bitop_unsigned_integer&lt;_Tp&gt;::value, &quot;__countl_one requires unsigned&quot;);
    return __t != numeric_limits&lt;_Tp&gt;::max()
        ? __countl_zero(static_cast&lt;_Tp&gt;(~__t))
        : numeric_limits&lt;_Tp&gt;::digits;
}


template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __countr_one(_Tp __t) throw()
{
    <span class="ge">_Static_</span>assert(__bitop_unsigned_integer&lt;_Tp&gt;::value, &quot;__countr_one requires unsigned&quot;);
    return __t != numeric_limits&lt;_Tp&gt;::max()
        ? __countr_zero(static_cast&lt;_Tp&gt;(~__t))
        : numeric_limits&lt;_Tp&gt;::digits;
}


template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int
__popcount(_Tp __t) throw()
{
    <span class="ge">_Static_</span>assert(__bitop_unsigned_integer&lt;_Tp&gt;::value, &quot;__libcpp_popcount requires unsigned&quot;);
    if (sizeof(_Tp) &lt;= sizeof(unsigned int))
        return __libcpp_popcount(static_cast&lt;unsigned int&gt;(__t));
    else if (sizeof(_Tp) &lt;= sizeof(unsigned long))
        return __libcpp_popcount(static_cast&lt;unsigned long&gt;(__t));
    else if (sizeof(_Tp) &lt;= sizeof(unsigned long long))
        return __libcpp_popcount(static_cast&lt;unsigned long long&gt;(__t));
    else
    {
        int __ret = 0;
        while (__t != 0)
        {
            <span class="gs">__ret += __</span>libcpp_popcount(static_cast&lt;unsigned long long&gt;(__t));
            __t &gt;&gt;= numeric_limits&lt;unsigned long long&gt;::digits;
        }
        return __ret;
    }
}



template&lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
unsigned __bit_log2(_Tp __t) throw()
{
    <span class="ge">_Static_</span>assert(__bitop_unsigned_integer&lt;_Tp&gt;::value, &quot;__bit_log2 requires unsigned&quot;);
    return std::numeric_limits&lt;_Tp&gt;::digits - 1 - __countl_zero(__t);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __ispow2(_Tp __t) throw()
{
    <span class="ge">_Static_</span>assert(__bitop_unsigned_integer&lt;_Tp&gt;::value, &quot;__ispow2 requires unsigned&quot;);
 return <span class="gs">__t != 0 &amp;&amp; (((__</span>t &amp; (__t - 1)) == 0));
}
} }





namespace std { inline namespace __1 {




template &lt;class <span class="ge">_T1, class _</span>T2 = _T1&gt;
struct __equal_to
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool operator()(const <span class="ge">_T1&amp; __x, const _</span>T1&amp; <span class="gs">__y) const {return __</span>x == __y;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool operator()(const <span class="ge">_T1&amp; __x, const _</span>T2&amp; <span class="gs">__y) const {return __</span>x == __y;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool operator()(const <span class="ge">_T2&amp; __x, const _</span>T1&amp; <span class="gs">__y) const {return __</span>x == __y;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool operator()(const <span class="ge">_T2&amp; __x, const _</span>T2&amp; <span class="gs">__y) const {return __</span>x == __y;}
};

template &lt;class _T1&gt;
struct __equal_to&lt;_T1, _T1&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_T1&amp; __x, const _</span>T1&amp; <span class="gs">__y) const {return __</span>x == __y;}
};

template &lt;class _T1&gt;
struct __equal_to&lt;const <span class="ge">_T1, _</span>T1&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_T1&amp; __x, const _</span>T1&amp; <span class="gs">__y) const {return __</span>x == __y;}
};

template &lt;class _T1&gt;
struct __equal_to&lt;_T1, const _T1&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_T1&amp; __x, const _</span>T1&amp; <span class="gs">__y) const {return __</span>x == __y;}
};

template &lt;class <span class="ge">_T1, class _</span>T2 = _T1&gt;
struct __less
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_T1&amp; __x, const _</span>T1&amp; <span class="gs">__y) const {return __</span>x &lt; __y;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_T1&amp; __x, const _</span>T2&amp; <span class="gs">__y) const {return __</span>x &lt; __y;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_T2&amp; __x, const _</span>T1&amp; <span class="gs">__y) const {return __</span>x &lt; __y;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_T2&amp; __x, const _</span>T2&amp; <span class="gs">__y) const {return __</span>x &lt; __y;}
};

template &lt;class _T1&gt;
struct __less&lt;_T1, _T1&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_T1&amp; __x, const _</span>T1&amp; <span class="gs">__y) const {return __</span>x &lt; __y;}
};

template &lt;class _T1&gt;
struct __less&lt;const <span class="ge">_T1, _</span>T1&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_T1&amp; __x, const _</span>T1&amp; <span class="gs">__y) const {return __</span>x &lt; __y;}
};

template &lt;class _T1&gt;
struct __less&lt;_T1, const _T1&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_T1&amp; __x, const _</span>T1&amp; <span class="gs">__y) const {return __</span>x &lt; __y;}
};

template &lt;class _Predicate&gt;
class __invert
{
private:
    <span class="ge">_Predicate __p_</span>;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __invert() {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit __invert(_Predicate <span class="gs">__p) : __</span>p<span class="ge">_(_</span>_p) {}

    template &lt;class _T1&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_T1&amp; __x) {return !__p_</span>(__x);}

    template &lt;class <span class="ge">_T1, class _</span>T2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_T1&amp; __x, const _</span>T2&amp; <span class="gs">__y) {return __</span>p<span class="ge">_(__y, _</span>_x);}
};



template &lt;typename _Integral&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_integral&lt;_Integral&gt;::value,
    _Integral
&gt;::type
__half_positive(_Integral __value)
{
    return static_cast&lt;_Integral&gt;(static_cast&lt;typename make_unsigned&lt;_Integral&gt;::type&gt;(__value) / 2);
}

template &lt;typename _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    !is_integral&lt;_Tp&gt;::value,
    _Tp
&gt;::type
__half_positive(_Tp __value)
{
    return __value / 2;
}
template &lt;class _Comp&gt;
struct __comp_ref_type {



  typedef typename add_lvalue_reference&lt;_Comp&gt;::type type;



};



template &lt;class <span class="ge">_InputIterator, class _</span>Predicate&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
all_of(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>Predicate __pred)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
        if (!__pred(*__first))
            return false;
    return true;
}



template &lt;class <span class="ge">_InputIterator, class _</span>Predicate&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
any_of(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>Predicate __pred)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
        if (<span class="gs">__pred(*__</span>first))
            return true;
    return false;
}



template &lt;class <span class="ge">_InputIterator, class _</span>Predicate&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
none_of(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>Predicate __pred)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
        if (<span class="gs">__pred(*__</span>first))
            return false;
    return true;
}



template &lt;class <span class="ge">_InputIterator, class _</span>Function&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Function
for_each(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>Function __f)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
        <span class="gs">__f(*__</span>first);
    return __f;
}
template &lt;class <span class="ge">_InputIterator, class _</span>Tp&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_InputIterator
find(_InputIterator __first, <span class="ge">_InputIterator __last, const _</span>Tp&amp; __value_)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
        if (*__first == __value_)
            break;
    return __first;
}



template &lt;class <span class="ge">_InputIterator, class _</span>Predicate&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_InputIterator
find_if(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>Predicate __pred)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
        if (<span class="gs">__pred(*__</span>first))
            break;
    return __first;
}



template&lt;class <span class="ge">_InputIterator, class _</span>Predicate&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_InputIterator
find_if_not(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>Predicate __pred)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
        if (!__pred(*__first))
            break;
    return __first;
}



template &lt;class <span class="ge">_BinaryPredicate, class _</span>ForwardIterator1, class _ForwardIterator2&gt;
                              _ForwardIterator1
__find_end(_ForwardIterator1 __first1, <span class="ge">_ForwardIterator1 _</span>_last1,
           <span class="ge">_ForwardIterator2 __first2, _</span>ForwardIterator2 __last2, <span class="ge">_BinaryPredicate _</span>_pred,
           forward_iterator_tag, forward_iterator_tag)
{

    <span class="ge">_ForwardIterator1 __r = _</span>_last1;
    if (<span class="gs">__first2 == __</span>last2)
        return __r;
    while (true)
    {
        while (true)
        {
            if (<span class="gs">__first1 == __</span>last1)
                return __r;
            if (<span class="gs">__pred(*__</span>first1, *__first2))
                break;
            ++__first1;
        }

        <span class="ge">_ForwardIterator1 __m1 = _</span>_first1;
        <span class="ge">_ForwardIterator2 __m2 = _</span>_first2;
        while (true)
        {
            if (++__m2 == __last2)
            {
                <span class="gs">__r = __</span>first1;
                ++__first1;
                break;
            }
            if (++__m1 == __last1)
                return __r;
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template &lt;class <span class="ge">_BinaryPredicate, class _</span>BidirectionalIterator1, class _BidirectionalIterator2&gt;
                              _BidirectionalIterator1
__find_end(_BidirectionalIterator1 __first1, <span class="ge">_BidirectionalIterator1 _</span>_last1,
           <span class="ge">_BidirectionalIterator2 __first2, _</span>BidirectionalIterator2 __last2, <span class="ge">_BinaryPredicate _</span>_pred,
           bidirectional_iterator_tag, bidirectional_iterator_tag)
{

    if (<span class="gs">__first2 == __</span>last2)
        return __last1;
    <span class="ge">_BidirectionalIterator1 __l1 = _</span>_last1;
    <span class="ge">_BidirectionalIterator2 __l2 = _</span>_last2;
    --__l2;
    while (true)
    {

        while (true)
        {
            if (<span class="gs">__first1 == __</span>l1)
                return __last1;
            if (<span class="gs">__pred(*--__</span>l1, *__l2))
                break;
        }

        <span class="ge">_BidirectionalIterator1 __m1 = _</span>_l1;
        <span class="ge">_BidirectionalIterator2 __m2 = _</span>_l2;
        while (true)
        {
            if (<span class="gs">__m2 == __</span>first2)
                return __m1;
            if (<span class="gs">__m1 == __</span>first1)
                return __last1;
            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template &lt;class <span class="ge">_BinaryPredicate, class _</span>RandomAccessIterator1, class _RandomAccessIterator2&gt;
                              _RandomAccessIterator1
__find_end(_RandomAccessIterator1 __first1, <span class="ge">_RandomAccessIterator1 _</span>_last1,
           <span class="ge">_RandomAccessIterator2 __first2, _</span>RandomAccessIterator2 __last2, <span class="ge">_BinaryPredicate _</span>_pred,
           random_access_iterator_tag, random_access_iterator_tag)
{

    typename iterator_traits&lt;_RandomAccessIterator2&gt;::difference_type <span class="gs">__len2 = __</span>last2 - __first2;
    if (__len2 == 0)
        return __last1;
    typename iterator_traits&lt;_RandomAccessIterator1&gt;::difference_type <span class="gs">__len1 = __</span>last1 - __first1;
    if (<span class="gs">__len1 &lt; __</span>len2)
        return __last1;
    const <span class="ge">_RandomAccessIterator1 __s = __first1 + (_</span>_len2 - 1);
    <span class="ge">_RandomAccessIterator1 __l1 = _</span>_last1;
    <span class="ge">_RandomAccessIterator2 __l2 = _</span>_last2;
    --__l2;
    while (true)
    {
        while (true)
        {
            if (<span class="gs">__s == __</span>l1)
                return __last1;
            if (<span class="gs">__pred(*--__</span>l1, *__l2))
                break;
        }
        <span class="ge">_RandomAccessIterator1 __m1 = _</span>_l1;
        <span class="ge">_RandomAccessIterator2 __m2 = _</span>_l2;
        while (true)
        {
            if (<span class="gs">__m2 == __</span>first2)
                return __m1;

            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template &lt;class <span class="ge">_ForwardIterator1, class _</span>ForwardIterator2, class _BinaryPredicate&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, <span class="ge">_ForwardIterator1 _</span>_last1,
         <span class="ge">_ForwardIterator2 __first2, _</span>ForwardIterator2 __last2, <span class="ge">_BinaryPredicate _</span>_pred)
{
    return std::__1::__find_end&lt;typename add_lvalue_reference&lt;_BinaryPredicate&gt;::type&gt;
                         (<span class="gs">__first1, __</span>last1, <span class="gs">__first2, __</span>last2, __pred,
                          typename iterator_traits&lt;_ForwardIterator1&gt;::iterator_category(),
                          typename iterator_traits&lt;_ForwardIterator2&gt;::iterator_category());
}

template &lt;class <span class="ge">_ForwardIterator1, class _</span>ForwardIterator2&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, <span class="ge">_ForwardIterator1 _</span>_last1,
         <span class="ge">_ForwardIterator2 __first2, _</span>ForwardIterator2 __last2)
{
    typedef typename iterator_traits&lt;_ForwardIterator1&gt;::value_type __v1;
    typedef typename iterator_traits&lt;_ForwardIterator2&gt;::value_type __v2;
    return std::__1::find_end(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>equal_to&lt;__v1, __v2&gt;());
}



template &lt;class <span class="ge">_ForwardIterator1, class _</span>ForwardIterator2, class _BinaryPredicate&gt;
                              _ForwardIterator1
__find_first_of_ce(_ForwardIterator1 __first1, <span class="ge">_ForwardIterator1 _</span>_last1,
              <span class="ge">_ForwardIterator2 __first2, _</span>ForwardIterator2 __last2, <span class="ge">_BinaryPredicate _</span>_pred)
{
    for (; <span class="gs">__first1 != __</span>last1; ++__first1)
        for (<span class="ge">_ForwardIterator2 __j = __first2; __j != __last2; ++_</span>_j)
            if (<span class="gs">__pred(*__</span>first1, *__j))
                return __first1;
    return __last1;
}


template &lt;class <span class="ge">_ForwardIterator1, class _</span>ForwardIterator2, class _BinaryPredicate&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, <span class="ge">_ForwardIterator1 _</span>_last1,
              <span class="ge">_ForwardIterator2 __first2, _</span>ForwardIterator2 __last2, <span class="ge">_BinaryPredicate _</span>_pred)
{
    return std::__1::__find_first_of_ce(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>pred);
}

template &lt;class <span class="ge">_ForwardIterator1, class _</span>ForwardIterator2&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, <span class="ge">_ForwardIterator1 _</span>_last1,
              <span class="ge">_ForwardIterator2 __first2, _</span>ForwardIterator2 __last2)
{
    typedef typename iterator_traits&lt;_ForwardIterator1&gt;::value_type __v1;
    typedef typename iterator_traits&lt;_ForwardIterator2&gt;::value_type __v2;
    return std::__1::__find_first_of_ce(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>equal_to&lt;__v1, __v2&gt;());
}



template &lt;class <span class="ge">_ForwardIterator, class _</span>BinaryPredicate&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
adjacent_find(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>BinaryPredicate __pred)
{
    if (<span class="gs">__first != __</span>last)
    {
        <span class="ge">_ForwardIterator __i = _</span>_first;
        while (++__i != __last)
        {
            if (<span class="gs">__pred(*__</span>first, *__i))
                return __first;
            <span class="gs">__first = __</span>i;
        }
    }
    return __last;
}

template &lt;class _ForwardIterator&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
adjacent_find(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last)
{
    typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type __v;
    return std::__1::adjacent_find(__first, <span class="gs">__last, __</span>equal_to&lt;__v&gt;());
}



template &lt;class <span class="ge">_InputIterator, class _</span>Tp&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename iterator_traits&lt;_InputIterator&gt;::difference_type
count(_InputIterator __first, <span class="ge">_InputIterator __last, const _</span>Tp&amp; __value_)
{
    typename iterator_traits&lt;_InputIterator&gt;::difference_type __r(0);
    for (; <span class="gs">__first != __</span>last; ++__first)
        if (*__first == __value_)
            ++__r;
    return __r;
}



template &lt;class <span class="ge">_InputIterator, class _</span>Predicate&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename iterator_traits&lt;_InputIterator&gt;::difference_type
count_if(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>Predicate __pred)
{
    typename iterator_traits&lt;_InputIterator&gt;::difference_type __r(0);
    for (; <span class="gs">__first != __</span>last; ++__first)
        if (<span class="gs">__pred(*__</span>first))
            ++__r;
    return __r;
}



template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class _BinaryPredicate&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
pair&lt;_InputIterator1, _InputIterator2&gt;
mismatch(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
         <span class="ge">_InputIterator2 __first2, _</span>BinaryPredicate __pred)
{
    for (; <span class="gs">__first1 != __</span>last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair&lt;_InputIterator1, <span class="ge">_InputIterator2&gt;(__first1, _</span>_first2);
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
pair&lt;_InputIterator1, _InputIterator2&gt;
mismatch(_InputIterator1 __first1, <span class="ge">_InputIterator1 __last1, _</span>InputIterator2 __first2)
{
    typedef typename iterator_traits&lt;_InputIterator1&gt;::value_type __v1;
    typedef typename iterator_traits&lt;_InputIterator2&gt;::value_type __v2;
    return std::__1::mismatch(__first1, <span class="gs">__last1, __</span>first2, __equal_to&lt;__v1, __v2&gt;());
}
template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class _BinaryPredicate&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
equal(_InputIterator1 __first1, <span class="ge">_InputIterator1 __last1, _</span>InputIterator2 __first2, <span class="ge">_BinaryPredicate _</span>_pred)
{
    for (; <span class="gs">__first1 != __</span>last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            return false;
    return true;
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
equal(_InputIterator1 __first1, <span class="ge">_InputIterator1 __last1, _</span>InputIterator2 __first2)
{
    typedef typename iterator_traits&lt;_InputIterator1&gt;::value_type __v1;
    typedef typename iterator_traits&lt;_InputIterator2&gt;::value_type __v2;
    return std::__1::equal(__first1, <span class="gs">__last1, __</span>first2, __equal_to&lt;__v1, __v2&gt;());
}
template&lt;class <span class="ge">_ForwardIterator1, class _</span>ForwardIterator2, class _BinaryPredicate&gt;
                                                    bool
is_permutation(_ForwardIterator1 __first1, <span class="ge">_ForwardIterator1 _</span>_last1,
               <span class="ge">_ForwardIterator2 __first2, _</span>BinaryPredicate __pred)
{

    for (; <span class="gs">__first1 != __</span>last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    if (<span class="gs">__first1 == __</span>last1)
        return true;


    typedef typename iterator_traits&lt;_ForwardIterator1&gt;::difference_type _D1;
    <span class="ge">_D1 __l1 = std::__1::distance(__first1, _</span>_last1);
    if (__l1 == _D1(1))
        return false;
    <span class="ge">_ForwardIterator2 __last2 = std::__1::next(__first2, _</span>_l1);


    for (<span class="ge">_ForwardIterator1 __i = __first1; __i != __last1; ++_</span>_i)
    {

        <span class="ge">_ForwardIterator1 __match = _</span>_first1;
        for (; <span class="gs">__match != __</span>i; ++__match)
            if (<span class="gs">__pred(*__</span>match, *__i))
                break;
        if (<span class="gs">__match == __</span>i) {

            <span class="ge">_D1 _</span>_c2 = 0;
            for (<span class="ge">_ForwardIterator2 __j = __first2; __j != __last2; ++_</span>_j)
                if (<span class="gs">__pred(*__</span>i, *__j))
                    ++__c2;
            if (__c2 == 0)
                return false;

            <span class="ge">_D1 _</span>_c1 = 1;
            for (<span class="ge">_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++_</span>_j)
                if (<span class="gs">__pred(*__</span>i, *__j))
                    ++__c1;
            if (<span class="gs">__c1 != __</span>c2)
                return false;
        }
    }
    return true;
}

template&lt;class <span class="ge">_ForwardIterator1, class _</span>ForwardIterator2&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
is_permutation(_ForwardIterator1 __first1, <span class="ge">_ForwardIterator1 _</span>_last1,
               <span class="ge">_ForwardIterator2 _</span>_first2)
{
    typedef typename iterator_traits&lt;_ForwardIterator1&gt;::value_type __v1;
    typedef typename iterator_traits&lt;_ForwardIterator2&gt;::value_type __v2;
    return std::__1::is_permutation(__first1, <span class="gs">__last1, __</span>first2, __equal_to&lt;__v1, __v2&gt;());
}
template &lt;class <span class="ge">_ForwardIterator1, class _</span>ForwardIterator2, class _BinaryPredicate&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator1
search(_ForwardIterator1 __first1, <span class="ge">_ForwardIterator1 _</span>_last1,
       <span class="ge">_ForwardIterator2 __first2, _</span>ForwardIterator2 __last2, <span class="ge">_BinaryPredicate _</span>_pred)
{
    return std::__1::__search&lt;typename add_lvalue_reference&lt;_BinaryPredicate&gt;::type&gt;
                         (<span class="gs">__first1, __</span>last1, <span class="gs">__first2, __</span>last2, __pred,
                          typename iterator_traits&lt;_ForwardIterator1&gt;::iterator_category(),
                          typename iterator_traits&lt;_ForwardIterator2&gt;::iterator_category())
            .first;
}

template &lt;class <span class="ge">_ForwardIterator1, class _</span>ForwardIterator2&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator1
search(_ForwardIterator1 __first1, <span class="ge">_ForwardIterator1 _</span>_last1,
       <span class="ge">_ForwardIterator2 __first2, _</span>ForwardIterator2 __last2)
{
    typedef typename iterator_traits&lt;_ForwardIterator1&gt;::value_type __v1;
    typedef typename iterator_traits&lt;_ForwardIterator2&gt;::value_type __v2;
    return std::__1::search(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>equal_to&lt;__v1, __v2&gt;());
}
template &lt;class <span class="ge">_BinaryPredicate, class _</span>ForwardIterator, class <span class="ge">_Size, class _</span>Tp&gt;
                              _ForwardIterator
__search_n(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last,
           <span class="ge">_Size __count, const _</span>Tp&amp; __value_, <span class="ge">_BinaryPredicate __pred, forward_</span>iterator_tag)
{
    if (__count &lt;= 0)
        return __first;
    while (true)
    {

        while (true)
        {
            if (<span class="gs">__first == __</span>last)
                return __last;
            if (<span class="gs">__pred(*__</span>first, __value_))
                break;
            ++__first;
        }

        <span class="ge">_ForwardIterator __m = _</span>_first;
        <span class="ge">_Size _</span>_c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
            if (++__m == __last)
                return __last;
            if (!__pred(*__m, __value_))
            {
                <span class="gs">__first = __</span>m;
                ++__first;
                break;
            }
        }
    }
}

template &lt;class <span class="ge">_BinaryPredicate, class _</span>RandomAccessIterator, class <span class="ge">_Size, class _</span>Tp&gt;
                              _RandomAccessIterator
__search_n(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator _</span>_last,
           <span class="ge">_Size __count, const _</span>Tp&amp; __value_, <span class="ge">_BinaryPredicate __pred, random_</span>access_iterator_tag)
{
    if (__count &lt;= 0)
        return __first;
    <span class="ge">_Size __len = static_</span>cast&lt;_Size&gt;(__last - __first);
    if (<span class="gs">__len &lt; __</span>count)
        return __last;
    const <span class="ge">_RandomAccessIterator __s = __last - (_</span>_count - 1);
    while (true)
    {

        while (true)
        {
            if (<span class="gs">__first &gt;= __</span>s)
                return __last;
            if (<span class="gs">__pred(*__</span>first, __value_))
                break;
            ++__first;
        }

        <span class="ge">_RandomAccessIterator __m = _</span>_first;
        <span class="ge">_Size _</span>_c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
             ++__m;
            if (!__pred(*__m, __value_))
            {
                <span class="gs">__first = __</span>m;
                ++__first;
                break;
            }
        }
    }
}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Size, class <span class="ge">_Tp, class _</span>BinaryPredicate&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
search_n(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last,
         <span class="ge">_Size __count, const _</span>Tp&amp; __value_, <span class="ge">_BinaryPredicate _</span>_pred)
{
    return std::__1::__search_n&lt;typename add_lvalue_reference&lt;_BinaryPredicate&gt;::type&gt;
           (<span class="gs">__first, __</span>last, __convert_to_integral(__count), __value_, __pred,
           typename iterator_traits&lt;_ForwardIterator&gt;::iterator_category());
}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Size, class _Tp&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
search_n(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Size __count, const <span class="ge">_Tp&amp; __value_</span>)
{
    typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type __v;
    return std::__1::search_n(__first, <span class="gs">__last, __</span>convert_to_integral(__count),
                           __value_, __equal_to&lt;__v, _Tp&gt;());
}


template &lt;class _Iter&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Iter
__unwrap_iter(_Iter __i)
{
    return __i;
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_trivially_copy_assignable&lt;_Tp&gt;::value,
    _Tp*
&gt;::type
__unwrap_iter(move_iterator&lt;_Tp*&gt; __i)
{
    return __i.base();
}



template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_trivially_copy_assignable&lt;_Tp&gt;::value,
    _Tp*
&gt;::type
__unwrap_iter(__wrap_iter&lt;_Tp*&gt; __i)
{
    return __i.base();
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_trivially_copy_assignable&lt;_Tp&gt;::value,
    const _Tp*
&gt;::type
__unwrap_iter(__wrap_iter&lt;const <span class="ge">_Tp*&gt; _</span>_i)
{
    return __i.base();
}
template &lt;class <span class="ge">_InputIterator, class _</span>OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
__copy_constexpr(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>OutputIterator __result)
{
    for (; <span class="gs">__first != __</span>last; ++__first, (void) ++__result)
        <span class="ge">*__result = *</span>__first;
    return __result;
}

template &lt;class <span class="ge">_InputIterator, class _</span>OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
__copy(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>OutputIterator __result)
{
    return __copy_constexpr(__first, <span class="gs">__last, __</span>result);
}

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_same&lt;typename remove_const&lt;_Tp&gt;::type, _Up&gt;::value &amp;&amp;
    is_trivially_copy_assignable&lt;_Up&gt;::value,
    _Up*
&gt;::type
__copy(_Tp* __first, <span class="ge">_Tp* __last, _</span>Up* __result)
{
    const size_t __n = static_cast&lt;size_t&gt;(__last - __first);
    if (__n &gt; 0)
        std::__1::memmove(__result, <span class="gs">__first, __</span>n * sizeof(_Up));
    return <span class="gs">__result + __</span>n;
}

template &lt;class <span class="ge">_InputIterator, class _</span>OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
copy(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>OutputIterator __result)
{
    if (__libcpp_is_constant_evaluated()) {
        return std::__1::__copy_constexpr(
            __unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
    } else {
        return std::__1::__copy(
            __unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
    }
}



template &lt;class <span class="ge">_BidirectionalIterator, class _</span>OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
__copy_backward_constexpr(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __last, _</span>OutputIterator __result)
{
    while (<span class="gs">__first != __</span>last)
        <span class="ge">*--__result = *</span>--__last;
    return __result;
}

template &lt;class <span class="ge">_BidirectionalIterator, class _</span>OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
__copy_backward(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __last, _</span>OutputIterator __result)
{
    return __copy_backward_constexpr(__first, <span class="gs">__last, __</span>result);
}

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_same&lt;typename remove_const&lt;_Tp&gt;::type, _Up&gt;::value &amp;&amp;
    is_trivially_copy_assignable&lt;_Up&gt;::value,
    _Up*
&gt;::type
__copy_backward(_Tp* __first, <span class="ge">_Tp* __last, _</span>Up* __result)
{
    const size_t __n = static_cast&lt;size_t&gt;(__last - __first);
    if (__n &gt; 0)
    {
        <span class="gs">__result -= __</span>n;
        std::__1::memmove(__result, <span class="gs">__first, __</span>n * sizeof(_Up));
    }
    return __result;
}

template &lt;class <span class="ge">_BidirectionalIterator1, class _</span>BidirectionalIterator2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, <span class="ge">_BidirectionalIterator1 _</span>_last,
              <span class="ge">_BidirectionalIterator2 _</span>_result)
{
    if (__libcpp_is_constant_evaluated()) {
        return std::__1::__copy_backward_constexpr(__unwrap_iter(__first),
                                                __unwrap_iter(__last),
                                                __unwrap_iter(__result));
    } else {
        return std::__1::__copy_backward(__unwrap_iter(__first),
                                      __unwrap_iter(__last),
                                      __unwrap_iter(__result));
    }
}



template&lt;class <span class="ge">_InputIterator, class _</span>OutputIterator, class _Predicate&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
copy_if(_InputIterator __first, <span class="ge">_InputIterator _</span>_last,
        <span class="ge">_OutputIterator __result, _</span>Predicate __pred)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
    {
        if (<span class="gs">__pred(*__</span>first))
        {
            <span class="ge">*__result = *</span>__first;
            ++__result;
        }
    }
    return __result;
}



template&lt;class <span class="ge">_InputIterator, class _</span>Size, class _OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    __is_cpp17_input_iterator&lt;_InputIterator&gt;::value &amp;&amp;
   !__is_cpp17_random_access_iterator&lt;_InputIterator&gt;::value,
    _OutputIterator
&gt;::type
copy_n(_InputIterator __first, <span class="ge">_Size __orig_</span>n, <span class="ge">_OutputIterator _</span>_result)
{
    typedef <span class="gs">__decltype(__</span>convert_to_integral(__orig_n)) _IntegralSize;
    <span class="ge">_IntegralSize __n = __orig_</span>n;
    if (__n &gt; 0)
    {
        <span class="ge">*__result = *</span>__first;
        ++__result;
        for (--__n; <span class="gs">__n &gt; 0; --__</span>n)
        {
            ++__first;
            <span class="ge">*__result = *</span>__first;
            ++__result;
        }
    }
    return __result;
}

template&lt;class <span class="ge">_InputIterator, class _</span>Size, class _OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    __is_cpp17_random_access_iterator&lt;_InputIterator&gt;::value,
    _OutputIterator
&gt;::type
copy_n(_InputIterator __first, <span class="ge">_Size __orig_</span>n, <span class="ge">_OutputIterator _</span>_result)
{
    typedef <span class="gs">__decltype(__</span>convert_to_integral(__orig_n)) _IntegralSize;
    <span class="ge">_IntegralSize __n = __orig_</span>n;
    return std::__1::copy(__first, <span class="gs">__first + __</span>n, __result);
}



template &lt;class <span class="ge">_InputIterator, class _</span>OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
__move(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>OutputIterator __result)
{
    for (; <span class="gs">__first != __</span>last; ++__first, (void) ++__result)
        <span class="ge">*__result = std::__1::move(*</span>__first);
    return __result;
}

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_same&lt;typename remove_const&lt;_Tp&gt;::type, _Up&gt;::value &amp;&amp;
    is_trivially_copy_assignable&lt;_Up&gt;::value,
    _Up*
&gt;::type
__move(_Tp* __first, <span class="ge">_Tp* __last, _</span>Up* __result)
{
    const size_t __n = static_cast&lt;size_t&gt;(__last - __first);
    if (__n &gt; 0)
        std::__1::memmove(__result, <span class="gs">__first, __</span>n * sizeof(_Up));
    return <span class="gs">__result + __</span>n;
}

template &lt;class <span class="ge">_InputIterator, class _</span>OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
move(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>OutputIterator __result)
{
    return std::__1::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template &lt;class <span class="ge">_InputIterator, class _</span>OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
__move_backward(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>OutputIterator __result)
{
    while (<span class="gs">__first != __</span>last)
        <span class="ge">*--__result = std::__1::move(*</span>--__last);
    return __result;
}

template &lt;class <span class="ge">_Tp, class _</span>Up&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_same&lt;typename remove_const&lt;_Tp&gt;::type, _Up&gt;::value &amp;&amp;
    is_trivially_copy_assignable&lt;_Up&gt;::value,
    _Up*
&gt;::type
__move_backward(_Tp* __first, <span class="ge">_Tp* __last, _</span>Up* __result)
{
    const size_t __n = static_cast&lt;size_t&gt;(__last - __first);
    if (__n &gt; 0)
    {
        <span class="gs">__result -= __</span>n;
        std::__1::memmove(__result, <span class="gs">__first, __</span>n * sizeof(_Up));
    }
    return __result;
}

template &lt;class <span class="ge">_BidirectionalIterator1, class _</span>BidirectionalIterator2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, <span class="ge">_BidirectionalIterator1 _</span>_last,
              <span class="ge">_BidirectionalIterator2 _</span>_result)
{
    return std::__1::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}







template &lt;class <span class="ge">_InputIterator, class _</span>OutputIterator, class _UnaryOperation&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
transform(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>OutputIterator __result, <span class="ge">_UnaryOperation _</span>_op)
{
    for (; <span class="gs">__first != __</span>last; ++__first, (void) ++__result)
        <span class="ge">*__result = __op(*</span>__first);
    return __result;
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class <span class="ge">_OutputIterator, class _</span>BinaryOperation&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
transform(_InputIterator1 __first1, <span class="ge">_InputIterator1 __last1, _</span>InputIterator2 __first2,
          <span class="ge">_OutputIterator __result, _</span>BinaryOperation __binary_op)
{
    for (; <span class="gs">__first1 != __</span>last1; ++__first1, (void) ++__first2, ++__result)
        <span class="ge">*__result = __binary_op(*</span><span class="gs">__first1, *__</span>first2);
    return __result;
}



template &lt;class <span class="ge">_ForwardIterator, class _</span>Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
replace(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __old_value, const <span class="ge">_Tp&amp; __new_</span>value)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
        if (*__first == __old_value)
            *<span class="gs">__first = __</span>new_value;
}



template &lt;class <span class="ge">_ForwardIterator, class _</span>Predicate, class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
replace_if(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Predicate __pred, const <span class="ge">_Tp&amp; __new_</span>value)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
        if (<span class="gs">__pred(*__</span>first))
            *<span class="gs">__first = __</span>new_value;
}



template &lt;class <span class="ge">_InputIterator, class _</span>OutputIterator, class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
replace_copy(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>OutputIterator __result,
             const <span class="ge">_Tp&amp; __old_</span>value, const <span class="ge">_Tp&amp; __new_</span>value)
{
    for (; <span class="gs">__first != __</span>last; ++__first, (void) ++__result)
        if (*__first == __old_value)
            *<span class="gs">__result = __</span>new_value;
        else
            <span class="ge">*__result = *</span>__first;
    return __result;
}



template &lt;class <span class="ge">_InputIterator, class _</span>OutputIterator, class <span class="ge">_Predicate, class _</span>Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
replace_copy_if(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>OutputIterator __result,
                <span class="ge">_Predicate __pred, const _</span>Tp&amp; __new_value)
{
    for (; <span class="gs">__first != __</span>last; ++__first, (void) ++__result)
        if (<span class="gs">__pred(*__</span>first))
            *<span class="gs">__result = __</span>new_value;
        else
            <span class="ge">*__result = *</span>__first;
    return __result;
}



template &lt;class <span class="ge">_OutputIterator, class _</span>Size, class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
__fill_n(_OutputIterator __first, <span class="ge">_Size __n, const _</span>Tp&amp; __value_)
{
    for (; <span class="gs">__n &gt; 0; ++__</span>first, (void) --__n)
        *<span class="gs">__first = __</span>value_;
    return __first;
}

template &lt;class <span class="ge">_OutputIterator, class _</span>Size, class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
fill_n(_OutputIterator __first, <span class="ge">_Size __n, const _</span>Tp&amp; __value_)
{
   return std::__1::__fill_n(__first, __convert_to_integral(__n), __value_);
}



template &lt;class <span class="ge">_ForwardIterator, class _</span>Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
__fill(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_, forward_iterator_tag)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
        *<span class="gs">__first = __</span>value_;
}

template &lt;class <span class="ge">_RandomAccessIterator, class _</span>Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
__fill(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, const _</span>Tp&amp; __value_, random_access_iterator_tag)
{
    std::__1::fill_n(__first, <span class="gs">__last - __</span>first, __value_);
}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
fill(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_)
{
    std::__1::__fill(__first, <span class="gs">__last, __</span>value_, typename iterator_traits&lt;_ForwardIterator&gt;::iterator_category());
}



template &lt;class <span class="ge">_ForwardIterator, class _</span>Generator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
generate(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Generator __gen)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
        *<span class="gs">__first = __</span>gen();
}



template &lt;class <span class="ge">_OutputIterator, class _</span>Size, class _Generator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
generate_n(_OutputIterator __first, <span class="ge">_Size __orig_</span>n, <span class="ge">_Generator _</span>_gen)
{
    typedef <span class="gs">__decltype(__</span>convert_to_integral(__orig_n)) _IntegralSize;
    <span class="ge">_IntegralSize __n = __orig_</span>n;
    for (; <span class="gs">__n &gt; 0; ++__</span>first, (void) --__n)
        *<span class="gs">__first = __</span>gen();
    return __first;
}



template &lt;class <span class="ge">_ForwardIterator, class _</span>Tp&gt;
                                                    _ForwardIterator
remove(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_)
{
    <span class="gs">__first = std::__</span>1::find(__first, <span class="gs">__last, __</span>value_);
    if (<span class="gs">__first != __</span>last)
    {
        <span class="ge">_ForwardIterator __i = _</span>_first;
        while (++__i != __last)
        {
            if (!(*__i == __value_))
            {
                <span class="ge">*__first = std::__1::move(*</span>__i);
                ++__first;
            }
        }
    }
    return __first;
}



template &lt;class <span class="ge">_ForwardIterator, class _</span>Predicate&gt;
                                                    _ForwardIterator
remove_if(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Predicate __pred)
{
    <span class="gs">__first = std::__</span>1::find_if&lt;_ForwardIterator, typename add_lvalue_reference&lt;_Predicate&gt;::type&gt;
                           (<span class="gs">__first, __</span>last, __pred);
    if (<span class="gs">__first != __</span>last)
    {
        <span class="ge">_ForwardIterator __i = _</span>_first;
        while (++__i != __last)
        {
            if (!__pred(*__i))
            {
                <span class="ge">*__first = std::__1::move(*</span>__i);
                ++__first;
            }
        }
    }
    return __first;
}



template &lt;class <span class="ge">_InputIterator, class _</span>OutputIterator, class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
remove_copy(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>OutputIterator __result, const <span class="ge">_Tp&amp; __value_</span>)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
    {
        if (!(*__first == __value_))
        {
            <span class="ge">*__result = *</span>__first;
            ++__result;
        }
    }
    return __result;
}



template &lt;class <span class="ge">_InputIterator, class _</span>OutputIterator, class _Predicate&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
remove_copy_if(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>OutputIterator __result, <span class="ge">_Predicate _</span>_pred)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
    {
        if (!__pred(*__first))
        {
            <span class="ge">*__result = *</span>__first;
            ++__result;
        }
    }
    return __result;
}



template &lt;class <span class="ge">_ForwardIterator, class _</span>BinaryPredicate&gt;
                                                    _ForwardIterator
unique(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>BinaryPredicate __pred)
{
    <span class="gs">__first = std::__</span>1::adjacent_find&lt;_ForwardIterator, typename add_lvalue_reference&lt;_BinaryPredicate&gt;::type&gt;
                                 (<span class="gs">__first, __</span>last, __pred);
    if (<span class="gs">__first != __</span>last)
    {


        <span class="ge">_ForwardIterator __i = _</span>_first;
        for (++__i; ++__i != __last;)
            if (!__pred(*__first, *__i))
                <span class="ge">*++__first = std::__1::move(*</span>__i);
        ++__first;
    }
    return __first;
}

template &lt;class _ForwardIterator&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
unique(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last)
{
    typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type __v;
    return std::__1::unique(__first, <span class="gs">__last, __</span>equal_to&lt;__v&gt;());
}



template &lt;class <span class="ge">_BinaryPredicate, class _</span>InputIterator, class _OutputIterator&gt;
                              _OutputIterator
__unique_copy(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>OutputIterator __result, <span class="ge">_BinaryPredicate _</span>_pred,
              input_iterator_tag, output_iterator_tag)
{
    if (<span class="gs">__first != __</span>last)
    {
        typename iterator_traits&lt;_InputIterator&gt;::value_type <span class="gs">__t(*__</span>first);
        *<span class="gs">__result = __</span>t;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(__t, *__first))
            {
                <span class="gs">__t = *__</span>first;
                *<span class="gs">__result = __</span>t;
                ++__result;
            }
        }
    }
    return __result;
}

template &lt;class <span class="ge">_BinaryPredicate, class _</span>ForwardIterator, class _OutputIterator&gt;
                              _OutputIterator
__unique_copy(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>OutputIterator __result, <span class="ge">_BinaryPredicate _</span>_pred,
              forward_iterator_tag, output_iterator_tag)
{
    if (<span class="gs">__first != __</span>last)
    {
        <span class="ge">_ForwardIterator __i = _</span>_first;
        <span class="ge">*__result = *</span>__i;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(*__i, *__first))
            {
                <span class="ge">*__result = *</span>__first;
                ++__result;
                <span class="gs">__i = __</span>first;
            }
        }
    }
    return __result;
}

template &lt;class <span class="ge">_BinaryPredicate, class _</span>InputIterator, class _ForwardIterator&gt;
                              _ForwardIterator
__unique_copy(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>ForwardIterator __result, <span class="ge">_BinaryPredicate _</span>_pred,
              input_iterator_tag, forward_iterator_tag)
{
    if (<span class="gs">__first != __</span>last)
    {
        <span class="ge">*__result = *</span>__first;
        while (++__first != __last)
            if (!__pred(*__result, *__first))
                <span class="ge">*++__result = *</span>__first;
        ++__result;
    }
    return __result;
}

template &lt;class <span class="ge">_InputIterator, class _</span>OutputIterator, class _BinaryPredicate&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
unique_copy(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>OutputIterator __result, <span class="ge">_BinaryPredicate _</span>_pred)
{
    return std::__1::__unique_copy&lt;typename add_lvalue_reference&lt;_BinaryPredicate&gt;::type&gt;
                              (<span class="gs">__first, __</span>last, <span class="gs">__result, __</span>pred,
                               typename iterator_traits&lt;_InputIterator&gt;::iterator_category(),
                               typename iterator_traits&lt;_OutputIterator&gt;::iterator_category());
}

template &lt;class <span class="ge">_InputIterator, class _</span>OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
unique_copy(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>OutputIterator __result)
{
    typedef typename iterator_traits&lt;_InputIterator&gt;::value_type __v;
    return std::__1::unique_copy(__first, <span class="gs">__last, __</span>result, __equal_to&lt;__v&gt;());
}



template &lt;class _BidirectionalIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
__reverse(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __last, bidirectional_</span>iterator_tag)
{
    while (<span class="gs">__first != __</span>last)
    {
        if (<span class="gs">__first == --__</span>last)
            break;
        std::__1::iter_swap(__first, __last);
        ++__first;
    }
}

template &lt;class _RandomAccessIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
__reverse(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, random_</span>access_iterator_tag)
{
    if (<span class="gs">__first != __</span>last)
        for (; <span class="gs">__first &lt; --__</span>last; ++__first)
            std::__1::iter_swap(__first, __last);
}

template &lt;class _BidirectionalIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
reverse(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator _</span>_last)
{
    std::__1::__reverse(__first, __last, typename iterator_traits&lt;_BidirectionalIterator&gt;::iterator_category());
}



template &lt;class <span class="ge">_BidirectionalIterator, class _</span>OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
reverse_copy(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __last, _</span>OutputIterator __result)
{
    for (; <span class="gs">__first != __</span>last; ++__result)
        <span class="ge">*__result = *</span>--__last;
    return __result;
}



template &lt;class _ForwardIterator&gt;
_ForwardIterator
__rotate_left(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last)
{
    typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type value_type;
    value_type <span class="gs">__tmp = std::__</span>1::move(*__first);
    <span class="ge">_ForwardIterator __lm1 = std::__1::move(std::__1::next(__first), __last, _</span>_first);
    *<span class="gs">__lm1 = std::__</span>1::move(__tmp);
    return __lm1;
}

template &lt;class _BidirectionalIterator&gt;
_BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator _</span>_last)
{
    typedef typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type value_type;
    <span class="ge">_BidirectionalIterator __lm1 = std::__1::prev(_</span>_last);
    value_type <span class="gs">__tmp = std::__</span>1::move(*__lm1);
    <span class="ge">_BidirectionalIterator __fp1 = std::__1::move_</span>backward(__first, <span class="gs">__lm1, __</span>last);
    *<span class="gs">__first = std::__</span>1::move(__tmp);
    return __fp1;
}

template &lt;class _ForwardIterator&gt;
_ForwardIterator
__rotate_forward(_ForwardIterator __first, <span class="ge">_ForwardIterator __middle, _</span>ForwardIterator __last)
{
    <span class="ge">_ForwardIterator __i = _</span>_middle;
    while (true)
    {
        swap(*__first, *__i);
        ++__first;
        if (++__i == __last)
            break;
        if (<span class="gs">__first == __</span>middle)
            <span class="gs">__middle = __</span>i;
    }
    <span class="ge">_ForwardIterator __r = _</span>_first;
    if (<span class="gs">__first != __</span>middle)
    {
        <span class="gs">__i = __</span>middle;
        while (true)
        {
            swap(*__first, *__i);
            ++__first;
            if (++__i == __last)
            {
                if (<span class="gs">__first == __</span>middle)
                    break;
                <span class="gs">__i = __</span>middle;
            }
            else if (<span class="gs">__first == __</span>middle)
                <span class="gs">__middle = __</span>i;
        }
    }
    return __r;
}

template&lt;typename _Integral&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_Integral
__algo_gcd(_Integral __x, <span class="ge">_Integral _</span>_y)
{
    do
    {
        <span class="ge">_Integral __t = __x % _</span>_y;
        <span class="gs">__x = __</span>y;
        <span class="gs">__y = __</span>t;
    } while (__y);
    return __x;
}

template&lt;typename _RandomAccessIterator&gt;
_RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __middle, _</span>RandomAccessIterator __last)
{
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type difference_type;
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type value_type;

    const difference_type <span class="gs">__m1 = __</span>middle - __first;
    const difference_type <span class="gs">__m2 = __</span>last - __middle;
    if (<span class="gs">__m1 == __</span>m2)
    {
        std::__1::swap_ranges(__first, <span class="gs">__middle, __</span>middle);
        return __middle;
    }
    const difference_type <span class="gs">__g = std::__</span>1::__algo_gcd(__m1, __m2);
    for (<span class="ge">_RandomAccessIterator __p = __first + __g; __p != _</span>_first;)
    {
        value_type <span class="gs">__t(std::__</span>1::move(*--__p));
        <span class="ge">_RandomAccessIterator __p1 = _</span>_p;
        <span class="ge">_RandomAccessIterator __p2 = __p1 + _</span>_m1;
        do
        {
            <span class="ge">*__p1 = std::__1::move(*</span>__p2);
            <span class="gs">__p1 = __</span>p2;
            const difference_type <span class="gs">__d = __</span>last - __p2;
            if (<span class="gs">__m1 &lt; __</span>d)
                <span class="gs">__p2 += __</span>m1;
            else
                <span class="gs">__p2 = __</span>first + (<span class="gs">__m1 - __</span>d);
        } while (<span class="gs">__p2 != __</span>p);
        *<span class="gs">__p1 = std::__</span>1::move(__t);
    }
    return <span class="gs">__first + __</span>m2;
}

template &lt;class _ForwardIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
__rotate(_ForwardIterator __first, <span class="ge">_ForwardIterator __middle, _</span>ForwardIterator __last,
         std::__1::forward_iterator_tag)
{
    typedef typename std::__1::iterator_traits&lt;_ForwardIterator&gt;::value_type value_type;
    if (std::__1::is_trivially_move_assignable&lt;value_type&gt;::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
    }
    return std::__1::__rotate_forward(__first, <span class="gs">__middle, __</span>last);
}

template &lt;class _BidirectionalIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_BidirectionalIterator
__rotate(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __middle, _</span>BidirectionalIterator __last,
         std::__1::bidirectional_iterator_tag)
{
    typedef typename std::__1::iterator_traits&lt;_BidirectionalIterator&gt;::value_type value_type;
    if (std::__1::is_trivially_move_assignable&lt;value_type&gt;::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
    }
    return std::__1::__rotate_forward(__first, <span class="gs">__middle, __</span>last);
}

template &lt;class _RandomAccessIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_RandomAccessIterator
__rotate(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __middle, _</span>RandomAccessIterator __last,
         std::__1::random_access_iterator_tag)
{
    typedef typename std::__1::iterator_traits&lt;_RandomAccessIterator&gt;::value_type value_type;
    if (std::__1::is_trivially_move_assignable&lt;value_type&gt;::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
        return std::__1::__rotate_gcd(__first, <span class="gs">__middle, __</span>last);
    }
    return std::__1::__rotate_forward(__first, <span class="gs">__middle, __</span>last);
}

template &lt;class _ForwardIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
rotate(_ForwardIterator __first, <span class="ge">_ForwardIterator __middle, _</span>ForwardIterator __last)
{
    if (<span class="gs">__first == __</span>middle)
        return __last;
    if (<span class="gs">__middle == __</span>last)
        return __first;
    return std::__1::__rotate(__first, <span class="gs">__middle, __</span>last,
                           typename std::__1::iterator_traits&lt;_ForwardIterator&gt;::iterator_category());
}



template &lt;class <span class="ge">_ForwardIterator, class _</span>OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
rotate_copy(_ForwardIterator __first, <span class="ge">_ForwardIterator __middle, _</span>ForwardIterator __last, <span class="ge">_OutputIterator _</span>_result)
{
    return std::__1::copy(__first, <span class="gs">__middle, std::__</span>1::copy(__middle, <span class="gs">__last, __</span>result));
}



template &lt;class <span class="ge">_ForwardIterator, class _</span>Compare&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
min_element(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Compare __comp)
{
    <span class="ge">_Static_</span>assert(__is_cpp17_forward_iterator&lt;_ForwardIterator&gt;::value, &quot;std::min_element requires a ForwardIterator&quot;);

    if (<span class="gs">__first != __</span>last)
    {
        <span class="ge">_ForwardIterator __i = _</span>_first;
        while (++__i != __last)
            if (<span class="gs">__comp(*__</span>i, *__first))
                <span class="gs">__first = __</span>i;
    }
    return __first;
}

template &lt;class _ForwardIterator&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
min_element(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last)
{
    return std::__1::min_element(__first, __last,
              __less&lt;typename iterator_traits&lt;_ForwardIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Tp, class _</span>Compare&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
const _Tp&amp;
min(const <span class="ge">_Tp&amp; __a, const _</span>Tp&amp; __b, <span class="ge">_Compare _</span>_comp)
{
    return <span class="gs">__comp(__</span>b, <span class="gs">__a) ? __</span>b : __a;
}

template &lt;class _Tp&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
const _Tp&amp;
min(const <span class="ge">_Tp&amp; __a, const _</span>Tp&amp; __b)
{
    return std::__1::min(__a, <span class="gs">__b, __</span>less&lt;_Tp&gt;());
}
template &lt;class <span class="ge">_ForwardIterator, class _</span>Compare&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
max_element(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Compare __comp)
{
    <span class="ge">_Static_</span>assert(__is_cpp17_forward_iterator&lt;_ForwardIterator&gt;::value, &quot;std::max_element requires a ForwardIterator&quot;);

    if (<span class="gs">__first != __</span>last)
    {
        <span class="ge">_ForwardIterator __i = _</span>_first;
        while (++__i != __last)
            if (<span class="gs">__comp(*__</span>first, *__i))
                <span class="gs">__first = __</span>i;
    }
    return __first;
}


template &lt;class _ForwardIterator&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
max_element(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last)
{
    return std::__1::max_element(__first, __last,
              __less&lt;typename iterator_traits&lt;_ForwardIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Tp, class _</span>Compare&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
const _Tp&amp;
max(const <span class="ge">_Tp&amp; __a, const _</span>Tp&amp; __b, <span class="ge">_Compare _</span>_comp)
{
    return <span class="gs">__comp(__</span>a, <span class="gs">__b) ? __</span>b : __a;
}

template &lt;class _Tp&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
const _Tp&amp;
max(const <span class="ge">_Tp&amp; __a, const _</span>Tp&amp; __b)
{
    return std::__1::max(__a, <span class="gs">__b, __</span>less&lt;_Tp&gt;());
}
template &lt;class <span class="ge">_ForwardIterator, class _</span>Compare&gt;

std::pair&lt;_ForwardIterator, _ForwardIterator&gt;
minmax_element(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Compare __comp)
{
  <span class="ge">_Static_</span>assert(__is_cpp17_forward_iterator&lt;_ForwardIterator&gt;::value, &quot;std::minmax_element requires a ForwardIterator&quot;);

  std::pair&lt;_ForwardIterator, <span class="ge">_ForwardIterator&gt; __result(__first, _</span>_first);
  if (<span class="gs">__first != __</span>last)
  {
      if (++__first != __last)
      {
          if (<span class="gs">__comp(*__</span>first, *__result.first))
              <span class="gs">__result.first = __</span>first;
          else
              <span class="gs">__result.second = __</span>first;
          while (++__first != __last)
          {
              <span class="ge">_ForwardIterator __i = _</span>_first;
              if (++__first == __last)
              {
                  if (<span class="gs">__comp(*__</span>i, *__result.first))
                      <span class="gs">__result.first = __</span>i;
                  else if (!__comp(*__i, *__result.second))
                      <span class="gs">__result.second = __</span>i;
                  break;
              }
              else
              {
                  if (<span class="gs">__comp(*__</span>first, *__i))
                  {
                      if (<span class="gs">__comp(*__</span>first, *__result.first))
                          <span class="gs">__result.first = __</span>first;
                      if (!__comp(*__i, *__result.second))
                          <span class="gs">__result.second = __</span>i;
                  }
                  else
                  {
                      if (<span class="gs">__comp(*__</span>i, *__result.first))
                          <span class="gs">__result.first = __</span>i;
                      if (!__comp(*__first, *__result.second))
                          <span class="gs">__result.second = __</span>first;
                  }
              }
          }
      }
  }
  return __result;
}

template &lt;class _ForwardIterator&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
std::pair&lt;_ForwardIterator, _ForwardIterator&gt;
minmax_element(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last)
{
    return std::__1::minmax_element(__first, __last,
              __less&lt;typename iterator_traits&lt;_ForwardIterator&gt;::value_type&gt;());
}



template&lt;class <span class="ge">_Tp, class _</span>Compare&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
pair&lt;const <span class="ge">_Tp&amp;, const _</span>Tp&amp;&gt;
minmax(const <span class="ge">_Tp&amp; __a, const _</span>Tp&amp; __b, <span class="ge">_Compare _</span>_comp)
{
    return <span class="gs">__comp(__</span>b, __a) ? pair&lt;const <span class="ge">_Tp&amp;, const _</span>Tp&amp;&gt;(__b, __a) :
                              pair&lt;const <span class="ge">_Tp&amp;, const _</span>Tp&amp;&gt;(__a, __b);
}

template&lt;class _Tp&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
pair&lt;const <span class="ge">_Tp&amp;, const _</span>Tp&amp;&gt;
minmax(const <span class="ge">_Tp&amp; __a, const _</span>Tp&amp; __b)
{
    return std::__1::minmax(__a, <span class="gs">__b, __</span>less&lt;_Tp&gt;());
}
template &lt;unsigned long long <span class="ge">_Xp, size_</span>t _Rp&gt;
struct __log2_imp
{
    static const size_t value = <span class="ge">_Xp &amp; ((unsigned long long)(1) &lt;&lt; _</span>Rp) ? _Rp
                                           : __log2_imp&lt;_Xp, _Rp - 1&gt;::value;
};

template &lt;unsigned long long _Xp&gt;
struct __log2_imp&lt;_Xp, 0&gt;
{
    static const size_t value = 0;
};

template &lt;size_t _Rp&gt;
struct __log2_imp&lt;0, _Rp&gt;
{
    static const size_t value = _Rp + 1;
};

template &lt;class <span class="ge">_UIntType, _</span>UIntType _Xp&gt;
struct __log2
{
    static const size_t value = __log2_imp&lt;_Xp,
                                         sizeof(_UIntType) * 8 - 1&gt;::value;
};

template&lt;class <span class="ge">_Engine, class _</span>UIntType&gt;
class __independent_bits_engine
{
public:

    typedef <span class="ge">_UIntType result_</span>type;

private:
    typedef typename <span class="ge">_Engine::result_</span>type <span class="ge">_Engine_</span>result_type;
    typedef typename conditional
        &lt;
            sizeof(_Engine_result_type) &lt;= sizeof(result_type),
                result_type,
                <span class="ge">_Engine_</span>result_type
        &gt;::type <span class="ge">_Working_</span>result_type;

    <span class="ge">_Engine&amp; __e_</span>;
    size_t __w_;
    size_t __w0_;
    size_t __n_;
    size_t __n0_;
    <span class="ge">_Working_</span>result_type __y0_;
    <span class="ge">_Working_</span>result_type __y1_;
    <span class="ge">_Engine_</span>result_type __mask0_;
    <span class="ge">_Engine_</span>result_type __mask1_;


    static const <span class="ge">_Working_</span>result_type <span class="ge">_Rp = _</span>Engine::_Max - <span class="ge">_Engine::_</span>Min
                                          + <span class="ge">_Working_</span>result_type(1);




    static const size_t <span class="gs">__m = __</span>log2&lt;_Working_result_type, _Rp&gt;::value;
    static const size_t <span class="ge">_WDt = numeric_</span>limits&lt;_Working_result_type&gt;::digits;
    static const size_t <span class="ge">_EDt = numeric_</span>limits&lt;_Engine_result_type&gt;::digits;

public:

    __independent_bits_engine(_Engine&amp; __e, size_t __w);


    result_type operator()() {return __eval(integral_constant&lt;bool, _Rp != 0&gt;());}

private:
    result_type __eval(false_type);
    result_type __eval(true_type);
};

template&lt;class <span class="ge">_Engine, class _</span>UIntType&gt;
__independent_bits_engine&lt;_Engine, _UIntType&gt;
    ::__independent_bits_engine(_Engine&amp; __e, size_t __w)
        : __e_(__e),
          __w_(__w)
{
    __n_ = __w_ / <span class="gs">__m + (__</span>w_ % __m != 0);
    __w0_ = __w_ / __n_;
    if (_Rp == 0)
        __y0_ = _Rp;
    else if (__w0_ &lt; _WDt)
        __y0_ = (<span class="ge">_Rp &gt;&gt; __w0_</span>) &lt;&lt; __w0_;
    else
        __y0_ = 0;
    if (<span class="ge">_Rp - __y0_</span> &gt; __y0_ / __n_)
    {
        ++__n_;
        __w0_ = __w_ / __n_;
        if (__w0_ &lt; _WDt)
            __y0_ = (<span class="ge">_Rp &gt;&gt; __w0_</span>) &lt;&lt; __w0_;
        else
            __y0_ = 0;
    }
    __n0_ = __n_ - __w_ % __n_;
    if (__w0_ &lt; _WDt - 1)
        __y1_ = (<span class="ge">_Rp &gt;&gt; (__w0_</span> + 1)) &lt;&lt; (__w0_ + 1);
    else
        __y1_ = 0;
    __mask0_ = __w0_ &gt; 0 ? <span class="ge">_Engine_</span>result_type(~0) &gt;&gt; (<span class="ge">_EDt - __w0_</span>) :
                          <span class="ge">_Engine_</span>result_type(0);
    __mask1_ = __w0_ &lt; _EDt - 1 ?
                               <span class="ge">_Engine_</span>result_type(~0) &gt;&gt; (<span class="ge">_EDt - (__w0_</span> + 1)) :
                               <span class="ge">_Engine_</span>result_type(~0);
}

template&lt;class <span class="ge">_Engine, class _</span>UIntType&gt;
inline
_UIntType
__independent_bits_engine&lt;_Engine, <span class="ge">_UIntType&gt;::__eval(false_</span>type)
{
    return static_cast&lt;result_type&gt;(__e_() &amp; __mask0_);
}

template&lt;class <span class="ge">_Engine, class _</span>UIntType&gt;
_UIntType
__independent_bits_engine&lt;_Engine, <span class="ge">_UIntType&gt;::__eval(true_</span>type)
{
    const size_t <span class="ge">_WRt = numeric_</span>limits&lt;result_type&gt;::digits;
    result_type _Sp = 0;
    for (size_t <span class="gs">__k = 0; __</span>k &lt; __n0_; ++__k)
    {
        <span class="ge">_Engine_</span>result_type __u;
        do
        {
            <span class="gs">__u = __</span>e<span class="ge">_() - _</span>Engine::min();
        } while (<span class="gs">__u &gt;= __</span>y0_);
        if (__w0_ &lt; _WRt)
            <span class="ge">_Sp &lt;&lt;= __w0_</span>;
        else
            _Sp = 0;
        <span class="ge">_Sp += __u &amp; __mask0_</span>;
    }
    for (size_t <span class="gs">__k = __</span>n0_; <span class="gs">__k &lt; __</span>n<span class="ge">_; ++_</span>_k)
    {
        <span class="ge">_Engine_</span>result_type __u;
        do
        {
            <span class="gs">__u = __</span>e<span class="ge">_() - _</span>Engine::min();
        } while (<span class="gs">__u &gt;= __</span>y1_);
        if (__w0_ &lt; _WRt - 1)
            <span class="ge">_Sp &lt;&lt;= __w0_</span> + 1;
        else
            _Sp = 0;
        <span class="ge">_Sp += __u &amp; __mask1_</span>;
    }
    return _Sp;
}



template&lt;class _IntType = int&gt;
class uniform_int_distribution
{
public:

    typedef <span class="ge">_IntType result_</span>type;

    class param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_int_distribution distribution_type;

        explicit param_type(result_type __a = 0,
                            result_type __b = numeric_limits&lt;result_type&gt;::max())
            : __a_(__a), __b_(__b) {}

        result_type a() const {return __a_;}
        result_type b() const {return __b_;}

        friend bool operator==(const param_type&amp; __x, const param_type&amp; __y)
            {return <span class="gs">__x.__</span>a_ == <span class="gs">__y.__</span>a_ &amp;&amp; <span class="gs">__x.__</span>b_ == <span class="gs">__y.__</span>b_;}
        friend bool operator!=(const param_type&amp; __x, const param_type&amp; __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:

    explicit uniform_int_distribution(result_type __a = 0,
                                      result_type __b = numeric_limits&lt;result_type&gt;::max())
        : __p_(param_type(__a, __b)) {}
    explicit uniform_int_distribution(const param_type&amp; <span class="gs">__p) : __</span>p<span class="ge">_(_</span>_p) {}
    void reset() {}


    template&lt;class <span class="ge">_URNG&gt; result_</span>type operator()(_URNG&amp; __g)
        {return (*this)(__g, __p_);}
    template&lt;class <span class="ge">_URNG&gt; result_</span>type operator()(_URNG&amp; __g, const param_type&amp; __p);


    result_type a() const {return __p_.a();}
    result_type b() const {return __p_.b();}

    param_type param() const {return __p_;}
    void param(const param_type&amp; <span class="gs">__p) {__</span>p_ = __p;}

    result_type min() const {return a();}
    result_type max() const {return b();}

    friend bool operator==(const uniform_int_distribution&amp; __x,
                           const uniform_int_distribution&amp; __y)
        {return <span class="gs">__x.__</span>p_ == <span class="gs">__y.__</span>p_;}
    friend bool operator!=(const uniform_int_distribution&amp; __x,
                           const uniform_int_distribution&amp; __y)
            {return !(__x == __y);}
};

template&lt;class _IntType&gt;
template&lt;class _URNG&gt;
typename uniform_int_distribution&lt;_IntType&gt;::result_type
uniform_int_distribution&lt;_IntType&gt;::operator()(_URNG&amp; __g, const param_type&amp; __p)
<span class="gs">__attribute__</span>((__no_sanitize__(&quot;unsigned-integer-overflow&quot;)))
{
    typedef typename conditional&lt;sizeof(result_type) &lt;= sizeof(uint32_t),
                                            uint32_t, uint64_t&gt;::type _UIntType;
    const <span class="ge">_UIntType _</span>Rp = <span class="ge">_UIntType(__p.b()) - _</span>UIntType(__p.a()) + _UIntType(1);
    if (_Rp == 1)
        return __p.a();
    const size_t <span class="ge">_Dt = numeric_</span>limits&lt;_UIntType&gt;::digits;
    typedef __independent_bits_engine&lt;_URNG, <span class="ge">_UIntType&gt; _</span>Eng;
    if (_Rp == 0)
        return static_cast&lt;result_type&gt;(_Eng(__g, _Dt)());
    size_t __w = <span class="ge">_Dt - __libcpp_</span>clz(_Rp) - 1;
    if ((_Rp &amp; (std::numeric_limits&lt;_UIntType&gt;::max() &gt;&gt; (<span class="ge">_Dt - _</span>_w))) != 0)
        ++__w;
    <span class="ge">_Eng __e(__g, _</span>_w);
    <span class="ge">_UIntType _</span>_u;
    do
    {
        <span class="gs">__u = __</span>e();
    } while (__u &gt;= _Rp);
    return static_cast&lt;result_type&gt;(__u + __p.a());
}



class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __rs_default;

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __rs_default __rs_get();

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __rs_default
{
    static unsigned __c_;

    __rs_default();
public:
    typedef uint_fast32_t result_type;

    static const result_type _Min = 0;
    static const result_type _Max = 0xFFFFFFFF;

    __rs_default(const __rs_default&amp;);
    ~__rs_default();

    result_type operator()();

    static result_type min() {return _Min;}
    static result_type max() {return _Max;}

    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __rs_default __rs_get();
};

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __rs_default __rs_get();

template &lt;class _RandomAccessIterator&gt;
                            void
random_shuffle(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator _</span>_last)
{
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type difference_type;
    typedef uniform_int_distribution&lt;ptrdiff_t&gt; _Dp;
    typedef typename <span class="ge">_Dp::param_</span>type _Pp;
    difference_type <span class="gs">__d = __</span>last - __first;
    if (__d &gt; 1)
    {
        <span class="ge">_Dp _</span>_uid;
        __rs_default <span class="gs">__g = __</span>rs_get();
        for (--__last, (void) --__d; <span class="gs">__first &lt; __</span>last; ++__first, (void) --__d)
        {
            difference_type <span class="gs">__i = __</span>uid(__g, <span class="ge">_Pp(0, _</span>_d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template &lt;class <span class="ge">_RandomAccessIterator, class _</span>RandomNumberGenerator&gt;
                            void
random_shuffle(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator _</span>_last,



               <span class="ge">_RandomNumberGenerator&amp; _</span>_rand)

{
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type difference_type;
    difference_type <span class="gs">__d = __</span>last - __first;
    if (__d &gt; 1)
    {
        for (--__last; <span class="gs">__first &lt; __</span>last; ++__first, (void) --__d)
        {
            difference_type <span class="gs">__i = __</span>rand(__d);
            if (__i != difference_type(0))
              swap(*__first, *(__first + __i));
        }
    }
}


template &lt;class <span class="ge">_PopulationIterator, class _</span>SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_SampleIterator __sample(_</span>PopulationIterator __first,
                         <span class="ge">_PopulationIterator __last, _</span>SampleIterator __output_iter,
                         <span class="ge">_Distance _</span>_n,
                         <span class="ge">_UniformRandomNumberGenerator &amp; _</span>_g,
                         input_iterator_tag) {

  <span class="ge">_Distance _</span>_k = 0;
  for (; <span class="gs">__first != __</span>last &amp;&amp; <span class="gs">__k &lt; __</span>n; ++__first, (void) ++__k)
    __output_iter[__k] = *__first;
  <span class="ge">_Distance __sz = _</span>_k;
  for (; <span class="gs">__first != __</span>last; ++__first, (void) ++__k) {
    <span class="ge">_Distance __r = std::__1::uniform_</span>int_distribution&lt;_Distance&gt;(0, <span class="gs">__k)(__</span>g);
    if (<span class="gs">__r &lt; __</span>sz)
      __output_iter[__r] = *__first;
  }
  return __output_iter + std::__1::min(__n, __k);
}

template &lt;class <span class="ge">_PopulationIterator, class _</span>SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_SampleIterator __sample(_</span>PopulationIterator __first,
                         <span class="ge">_PopulationIterator __last, _</span>SampleIterator __output_iter,
                         <span class="ge">_Distance _</span>_n,
                         <span class="ge">_UniformRandomNumberGenerator&amp; _</span>_g,
                         forward_iterator_tag) {
  <span class="ge">_Distance __unsampled_</span>sz = std::__1::distance(__first, __last);
  for (<span class="gs">__n = std::__</span>1::min(__n, __unsampled_sz); <span class="gs">__n != 0; ++__</span>first) {
    <span class="ge">_Distance _</span>_r =
        std::__1::uniform_int_distribution&lt;_Distance&gt;(0, --__unsampled_sz)(__g);
    if (<span class="gs">__r &lt; __</span>n) {
      <span class="ge">*__output_iter++ = *</span>__first;
      --__n;
    }
  }
  return __output_iter;
}

template &lt;class <span class="ge">_PopulationIterator, class _</span>SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_SampleIterator __sample(_</span>PopulationIterator __first,
                         <span class="ge">_PopulationIterator __last, _</span>SampleIterator __output_iter,
                         <span class="ge">_Distance __n, _</span>UniformRandomNumberGenerator&amp; __g) {
  typedef typename iterator_traits&lt;_PopulationIterator&gt;::iterator_category
        _PopCategory;
  typedef typename iterator_traits&lt;_PopulationIterator&gt;::difference_type
        _Difference;
  <span class="ge">_Static_</span>assert(__is_cpp17_forward_iterator&lt;_PopulationIterator&gt;::value || __is_cpp17_random_access_iterator&lt;_SampleIterator&gt;::value, &quot;SampleIterator must meet the requirements of RandomAccessIterator&quot;);


  typedef typename common_type&lt;_Distance, <span class="ge">_Difference&gt;::type _</span>CommonType;
  ((void)0);
  return std::__1::__sample(
      <span class="gs">__first, __</span>last, __output_iter, <span class="ge">_CommonType(_</span>_n),
      __g, _PopCategory());
}
template&lt;class <span class="ge">_RandomAccessIterator, class _</span>UniformRandomNumberGenerator&gt;
    void shuffle(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator _</span>_last,
                 <span class="ge">_UniformRandomNumberGenerator&amp;&amp; _</span>_g)
{
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type difference_type;
    typedef uniform_int_distribution&lt;ptrdiff_t&gt; _Dp;
    typedef typename <span class="ge">_Dp::param_</span>type _Pp;
    difference_type <span class="gs">__d = __</span>last - __first;
    if (__d &gt; 1)
    {
        <span class="ge">_Dp _</span>_uid;
        for (--__last, (void) --__d; <span class="gs">__first &lt; __</span>last; ++__first, (void) --__d)
        {
            difference_type <span class="gs">__i = __</span>uid(__g, <span class="ge">_Pp(0, _</span>_d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template &lt;class <span class="ge">_InputIterator, class _</span>Predicate&gt;
                                                    bool
is_partitioned(_InputIterator __first, <span class="ge">_InputIterator __last, _</span>Predicate __pred)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
        if (!__pred(*__first))
            break;
    if ( <span class="gs">__first == __</span>last )
        return true;
    ++__first;
    for (; <span class="gs">__first != __</span>last; ++__first)
        if (<span class="gs">__pred(*__</span>first))
            return false;
    return true;
}



template &lt;class <span class="ge">_Predicate, class _</span>ForwardIterator&gt;
_ForwardIterator
__partition(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Predicate __pred, forward_iterator_tag)
{
    while (true)
    {
        if (<span class="gs">__first == __</span>last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    for (<span class="ge">_ForwardIterator __p = __first; ++__p != _</span>_last;)
    {
        if (<span class="gs">__pred(*__</span>p))
        {
            swap(*__first, *__p);
            ++__first;
        }
    }
    return __first;
}

template &lt;class <span class="ge">_Predicate, class _</span>BidirectionalIterator&gt;
_BidirectionalIterator
__partition(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __last, _</span>Predicate __pred,
            bidirectional_iterator_tag)
{
    while (true)
    {
        while (true)
        {
            if (<span class="gs">__first == __</span>last)
                return __first;
            if (!__pred(*__first))
                break;
            ++__first;
        }
        do
        {
            if (<span class="gs">__first == --__</span>last)
                return __first;
        } while (!__pred(*__last));
        swap(*__first, *__last);
        ++__first;
    }
}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Predicate&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
partition(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Predicate __pred)
{
    return std::__1::__partition&lt;typename add_lvalue_reference&lt;_Predicate&gt;::type&gt;
                            (<span class="gs">__first, __</span>last, __pred, typename iterator_traits&lt;_ForwardIterator&gt;::iterator_category());
}



template &lt;class <span class="ge">_InputIterator, class _</span>OutputIterator1,
          class <span class="ge">_OutputIterator2, class _</span>Predicate&gt;
                              pair&lt;_OutputIterator1, _OutputIterator2&gt;
partition_copy(_InputIterator __first, <span class="ge">_InputIterator _</span>_last,
               <span class="ge">_OutputIterator1 __out_</span>true, <span class="ge">_OutputIterator2 __out_</span>false,
               <span class="ge">_Predicate _</span>_pred)
{
    for (; <span class="gs">__first != __</span>last; ++__first)
    {
        if (<span class="gs">__pred(*__</span>first))
        {
            <span class="ge">*__out_true = *</span>__first;
            ++__out_true;
        }
        else
        {
            <span class="ge">*__out_false = *</span>__first;
            ++__out_false;
        }
    }
    return pair&lt;_OutputIterator1, <span class="ge">_OutputIterator2&gt;(__out_</span>true, __out_false);
}



template&lt;class <span class="ge">_ForwardIterator, class _</span>Predicate&gt;
                              _ForwardIterator
partition_point(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Predicate __pred)
{
    typedef typename iterator_traits&lt;_ForwardIterator&gt;::difference_type difference_type;
    difference_type <span class="gs">__len = std::__</span>1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type <span class="gs">__l2 = std::__</span>1::__half_positive(__len);
        <span class="ge">_ForwardIterator __m = _</span>_first;
        std::__1::advance(__m, __l2);
        if (<span class="gs">__pred(*__</span>m))
        {
            <span class="gs">__first = ++__</span>m;
            <span class="gs">__len -= __</span>l2 + 1;
        }
        else
            <span class="gs">__len = __</span>l2;
    }
    return __first;
}



template &lt;class <span class="ge">_Predicate, class _</span>ForwardIterator, class <span class="ge">_Distance, class _</span>Pair&gt;
_ForwardIterator
__stable_partition(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Predicate __pred,
                   <span class="ge">_Distance __len, _</span>Pair __p, forward_iterator_tag __fit)
{


    if (__len == 1)
        return __first;
    if (__len == 2)
    {
        <span class="ge">_ForwardIterator __m = _</span>_first;
        if (<span class="gs">__pred(*++__</span>m))
        {
            swap(*__first, *__m);
            return __m;
        }
        return __first;
    }
    if (<span class="gs">__len &lt;= __</span>p.second)
    {
        typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type value_type;
        __destruct_n __d(0);
        unique_ptr&lt;value_type, __destruct_n&amp;&gt; <span class="gs">__h(__</span>p.first, __d);


        value_type* <span class="gs">__t = __</span>p.first;
        ::new(__t) value_type(std::__1::move(*__first));
        <span class="gs">__d.__</span>incr((value_type*)0);
        ++__t;
        <span class="ge">_ForwardIterator __i = _</span>_first;
        while (++__i != __last)
        {
            if (<span class="gs">__pred(*__</span>i))
            {
                <span class="ge">*__first = std::__1::move(*</span>__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__1::move(*__i));
                <span class="gs">__d.__</span>incr((value_type*)0);
                ++__t;
            }
        }


        <span class="gs">__i = __</span>first;
        for (value_type* <span class="gs">__t2 = __</span>p.first; <span class="gs">__t2 &lt; __</span>t; ++__t2, (void) ++__i)
            <span class="ge">*__i = std::__1::move(*</span>__t2);

        return __first;
    }


    <span class="ge">_ForwardIterator __m = _</span>_first;
    <span class="ge">_Distance __len2 = _</span>_len / 2;
    std::__1::advance(__m, __len2);



    typedef typename add_lvalue_reference&lt;_Predicate&gt;::type _PredRef;
    <span class="ge">_ForwardIterator __first_</span>false = __stable_partition&lt;_PredRef&gt;(__first, <span class="gs">__m, __</span>pred, <span class="gs">__len2, __</span>p, __fit);



    <span class="ge">_ForwardIterator __m1 = _</span>_m;
    <span class="ge">_ForwardIterator __second_</span>false = __last;
    <span class="ge">_Distance __len_</span>half = <span class="gs">__len - __</span>len2;
    while (<span class="gs">__pred(*__</span>m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = __stable_partition&lt;_PredRef&gt;(__m1, <span class="gs">__last, __</span>pred, __len_half, <span class="gs">__p, __</span>fit);
__second_half_done:


    return std::__1::rotate(__first_false, <span class="gs">__m, __</span>second_false);


}

struct __return_temporary_buffer
{
    template &lt;class _Tp&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void operator()(_Tp* <span class="gs">__p) const {std::__</span>1::return_temporary_buffer(__p);}
};

template &lt;class <span class="ge">_Predicate, class _</span>ForwardIterator&gt;
_ForwardIterator
__stable_partition(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Predicate __pred,
                   forward_iterator_tag)
{
    const unsigned __alloc_limit = 3;

    while (true)
    {
        if (<span class="gs">__first == __</span>last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    typedef typename iterator_traits&lt;_ForwardIterator&gt;::difference_type difference_type;
    typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type value_type;
    difference_type <span class="gs">__len = std::__</span>1::distance(__first, __last);
    pair&lt;value_type*, ptrdiff_t&gt; __p(0, 0);
    unique_ptr&lt;value_type, __return_temporary_buffer&gt; __h;
    if (<span class="gs">__len &gt;= __</span>alloc_limit)
    {
        <span class="gs">__p = std::__</span>1::get_temporary_buffer&lt;value_type&gt;(__len);
        <span class="gs">__h.reset(__</span>p.first);
    }
    return __stable_partition&lt;typename add_lvalue_reference&lt;_Predicate&gt;::type&gt;
                             (<span class="gs">__first, __</span>last, <span class="gs">__pred, __</span>len, __p, forward_iterator_tag());
}

template &lt;class <span class="ge">_Predicate, class _</span>BidirectionalIterator, class <span class="ge">_Distance, class _</span>Pair&gt;
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __last, _</span>Predicate __pred,
                   <span class="ge">_Distance __len, _</span>Pair __p, bidirectional_iterator_tag __bit)
{



    if (__len == 2)
    {
        swap(*__first, *__last);
        return __last;
    }
    if (__len == 3)
    {
        <span class="ge">_BidirectionalIterator __m = _</span>_first;
        if (<span class="gs">__pred(*++__</span>m))
        {
            swap(*__first, *__m);
            swap(*__m, *__last);
            return __last;
        }
        swap(*__m, *__last);
        swap(*__first, *__m);
        return __m;
    }
    if (<span class="gs">__len &lt;= __</span>p.second)
    {
        typedef typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type value_type;
        __destruct_n __d(0);
        unique_ptr&lt;value_type, __destruct_n&amp;&gt; <span class="gs">__h(__</span>p.first, __d);


        value_type* <span class="gs">__t = __</span>p.first;
        ::new(__t) value_type(std::__1::move(*__first));
        <span class="gs">__d.__</span>incr((value_type*)0);
        ++__t;
        <span class="ge">_BidirectionalIterator __i = _</span>_first;
        while (++__i != __last)
        {
            if (<span class="gs">__pred(*__</span>i))
            {
                <span class="ge">*__first = std::__1::move(*</span>__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__1::move(*__i));
                <span class="gs">__d.__</span>incr((value_type*)0);
                ++__t;
            }
        }

        <span class="ge">*__first = std::__1::move(*</span>__i);
        <span class="gs">__i = ++__</span>first;


        for (value_type* <span class="gs">__t2 = __</span>p.first; <span class="gs">__t2 &lt; __</span>t; ++__t2, (void) ++__i)
            <span class="ge">*__i = std::__1::move(*</span>__t2);

        return __first;
    }


    <span class="ge">_BidirectionalIterator __m = _</span>_first;
    <span class="ge">_Distance __len2 = _</span>_len / 2;
    std::__1::advance(__m, __len2);



    <span class="ge">_BidirectionalIterator __m1 = _</span>_m;
    <span class="ge">_BidirectionalIterator __first_</span>false = __first;
    <span class="ge">_Distance __len_</span>half = __len2;
    while (!__pred(*--__m1))
    {
        if (<span class="gs">__m1 == __</span>first)
            goto __first_half_done;
        --__len_half;
    }


    typedef typename add_lvalue_reference&lt;_Predicate&gt;::type _PredRef;
    __first_false = __stable_partition&lt;_PredRef&gt;(__first, <span class="gs">__m1, __</span>pred, __len_half, <span class="gs">__p, __</span>bit);
__first_half_done:



    <span class="gs">__m1 = __</span>m;
    <span class="ge">_BidirectionalIterator __second_</span>false = __last;
    ++__second_false;
    __len_half = <span class="gs">__len - __</span>len2;
    while (<span class="gs">__pred(*__</span>m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = __stable_partition&lt;_PredRef&gt;(__m1, <span class="gs">__last, __</span>pred, __len_half, <span class="gs">__p, __</span>bit);
__second_half_done:


    return std::__1::rotate(__first_false, <span class="gs">__m, __</span>second_false);


}

template &lt;class <span class="ge">_Predicate, class _</span>BidirectionalIterator&gt;
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __last, _</span>Predicate __pred,
                   bidirectional_iterator_tag)
{
    typedef typename iterator_traits&lt;_BidirectionalIterator&gt;::difference_type difference_type;
    typedef typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type value_type;
    const difference_type __alloc_limit = 4;

    while (true)
    {
        if (<span class="gs">__first == __</span>last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    do
    {
        if (<span class="gs">__first == --__</span>last)
            return __first;
    } while (!__pred(*__last));




    difference_type <span class="gs">__len = std::__</span>1::distance(__first, __last) + 1;
    pair&lt;value_type*, ptrdiff_t&gt; __p(0, 0);
    unique_ptr&lt;value_type, __return_temporary_buffer&gt; __h;
    if (<span class="gs">__len &gt;= __</span>alloc_limit)
    {
        <span class="gs">__p = std::__</span>1::get_temporary_buffer&lt;value_type&gt;(__len);
        <span class="gs">__h.reset(__</span>p.first);
    }
    return __stable_partition&lt;typename add_lvalue_reference&lt;_Predicate&gt;::type&gt;
                             (<span class="gs">__first, __</span>last, <span class="gs">__pred, __</span>len, __p, bidirectional_iterator_tag());
}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Predicate&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
stable_partition(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Predicate __pred)
{
    return __stable_partition&lt;typename add_lvalue_reference&lt;_Predicate&gt;::type&gt;
                             (<span class="gs">__first, __</span>last, __pred, typename iterator_traits&lt;_ForwardIterator&gt;::iterator_category());
}



template &lt;class <span class="ge">_ForwardIterator, class _</span>Compare&gt;
                                                    _ForwardIterator
is_sorted_until(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Compare __comp)
{
    if (<span class="gs">__first != __</span>last)
    {
        <span class="ge">_ForwardIterator __i = _</span>_first;
        while (++__i != __last)
        {
            if (<span class="gs">__comp(*__</span>i, *__first))
                return __i;
            <span class="gs">__first = __</span>i;
        }
    }
    return __last;
}

template&lt;class _ForwardIterator&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
is_sorted_until(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last)
{
    return std::__1::is_sorted_until(__first, <span class="gs">__last, __</span>less&lt;typename iterator_traits&lt;_ForwardIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_ForwardIterator, class _</span>Compare&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
is_sorted(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, _</span>Compare __comp)
{
    return std::__1::is_sorted_until(__first, <span class="gs">__last, __</span>comp) == __last;
}

template&lt;class _ForwardIterator&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
is_sorted(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last)
{
    return std::__1::is_sorted(__first, <span class="gs">__last, __</span>less&lt;typename iterator_traits&lt;_ForwardIterator&gt;::value_type&gt;());
}





template &lt;class <span class="ge">_Compare, class _</span>ForwardIterator&gt;
unsigned
__sort3(_ForwardIterator __x, <span class="ge">_ForwardIterator __y, _</span>ForwardIterator __z, <span class="ge">_Compare _</span>_c)
{
    unsigned __r = 0;
    if (!__c(*__y, *__x))
    {
        if (!__c(*__z, *__y))
            return __r;

        swap(*__y, *__z);
        __r = 1;
        if (<span class="gs">__c(*__</span>y, *__x))
        {
            swap(*__x, *__y);
            __r = 2;
        }
        return __r;
    }
    if (<span class="gs">__c(*__</span>z, *__y))
    {
        swap(*__x, *__z);
        __r = 1;
        return __r;
    }
    swap(*__x, *__y);
    __r = 1;
    if (<span class="gs">__c(*__</span>z, *__y))
    {
        swap(*__y, *__z);
        __r = 2;
    }
    return __r;
}



template &lt;class <span class="ge">_Compare, class _</span>ForwardIterator&gt;
unsigned
__sort4(_ForwardIterator __x1, <span class="ge">_ForwardIterator __x2, _</span>ForwardIterator __x3,
            <span class="ge">_ForwardIterator __x4, _</span>Compare __c)
{
    unsigned <span class="gs">__r = __</span>sort3&lt;_Compare&gt;(__x1, <span class="gs">__x2, __</span>x3, __c);
    if (<span class="gs">__c(*__</span>x4, *__x3))
    {
        swap(*__x3, *__x4);
        ++__r;
        if (<span class="gs">__c(*__</span>x3, *__x2))
        {
            swap(*__x2, *__x3);
            ++__r;
            if (<span class="gs">__c(*__</span>x2, *__x1))
            {
                swap(*__x1, *__x2);
                ++__r;
            }
        }
    }
    return __r;
}



template &lt;class <span class="ge">_Compare, class _</span>ForwardIterator&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
unsigned
__sort5(_ForwardIterator __x1, <span class="ge">_ForwardIterator __x2, _</span>ForwardIterator __x3,
            <span class="ge">_ForwardIterator __x4, _</span>ForwardIterator __x5, <span class="ge">_Compare _</span>_c)
{
    unsigned <span class="gs">__r = __</span>sort4&lt;_Compare&gt;(__x1, <span class="gs">__x2, __</span>x3, <span class="gs">__x4, __</span>c);
    if (<span class="gs">__c(*__</span>x5, *__x4))
    {
        swap(*__x4, *__x5);
        ++__r;
        if (<span class="gs">__c(*__</span>x4, *__x3))
        {
            swap(*__x3, *__x4);
            ++__r;
            if (<span class="gs">__c(*__</span>x3, *__x2))
            {
                swap(*__x2, *__x3);
                ++__r;
                if (<span class="gs">__c(*__</span>x2, *__x1))
                {
                    swap(*__x1, *__x2);
                    ++__r;
                }
            }
        }
    }
    return __r;
}


template &lt;class <span class="ge">_Compare, class _</span>BirdirectionalIterator&gt;
void
__selection_sort(_BirdirectionalIterator __first, <span class="ge">_BirdirectionalIterator __last, _</span>Compare __comp)
{
    <span class="ge">_BirdirectionalIterator __lm1 = _</span>_last;
    for (--__lm1; <span class="gs">__first != __</span>lm1; ++__first)
    {
        <span class="ge">_BirdirectionalIterator __i = std::__1::min_</span>element&lt;_BirdirectionalIterator,
                                                        typename add_lvalue_reference&lt;_Compare&gt;::type&gt;
                                                       (<span class="gs">__first, __</span>last, __comp);
        if (<span class="gs">__i != __</span>first)
            swap(*__first, *__i);
    }
}

template &lt;class <span class="ge">_Compare, class _</span>BirdirectionalIterator&gt;
void
__insertion_sort(_BirdirectionalIterator __first, <span class="ge">_BirdirectionalIterator __last, _</span>Compare __comp)
{
    typedef typename iterator_traits&lt;_BirdirectionalIterator&gt;::value_type value_type;
    if (<span class="gs">__first != __</span>last)
    {
        <span class="ge">_BirdirectionalIterator __i = _</span>_first;
        for (++__i; <span class="gs">__i != __</span>last; ++__i)
        {
            <span class="ge">_BirdirectionalIterator __j = _</span>_i;
            value_type <span class="gs">__t(std::__</span>1::move(*__j));
            for (<span class="ge">_BirdirectionalIterator __k = __i; __k != __first &amp;&amp; __comp(__t, *--__k); --_</span>_j)
                <span class="ge">*__j = std::__1::move(*</span>__k);
            *<span class="gs">__j = std::__</span>1::move(__t);
        }
    }
}

template &lt;class <span class="ge">_Compare, class _</span>RandomAccessIterator&gt;
void
__insertion_sort_3(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp)
{
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type value_type;
    <span class="ge">_RandomAccessIterator __j = _</span>_first+2;
    __sort3&lt;_Compare&gt;(__first, <span class="gs">__first+1, __</span>j, __comp);
    for (<span class="ge">_RandomAccessIterator __i = __j+1; __i != __last; ++_</span>_i)
    {
        if (<span class="gs">__comp(*__</span>i, *__j))
        {
            value_type <span class="gs">__t(std::__</span>1::move(*__i));
            <span class="ge">_RandomAccessIterator __k = _</span>_j;
            <span class="gs">__j = __</span>i;
            do
            {
                <span class="ge">*__j = std::__1::move(*</span>__k);
                <span class="gs">__j = __</span>k;
            } while (<span class="gs">__j != __</span>first &amp;&amp; <span class="gs">__comp(__</span>t, *--__k));
            *<span class="gs">__j = std::__</span>1::move(__t);
        }
        <span class="gs">__j = __</span>i;
    }
}

template &lt;class <span class="ge">_Compare, class _</span>RandomAccessIterator&gt;
bool
__insertion_sort_incomplete(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp)
{
    switch (<span class="gs">__last - __</span>first)
    {
    case 0:
    case 1:
        return true;
    case 2:
        if (<span class="gs">__comp(*--__</span>last, *__first))
            swap(*__first, *__last);
        return true;
    case 3:
        std::__1::__sort3&lt;_Compare&gt;(__first, <span class="gs">__first+1, --__</span>last, __comp);
        return true;
    case 4:
        std::__1::__sort4&lt;_Compare&gt;(__first, <span class="gs">__first+1, __</span>first+2, --__last, __comp);
        return true;
    case 5:
        std::__1::__sort5&lt;_Compare&gt;(__first, <span class="gs">__first+1, __</span>first+2, <span class="gs">__first+3, --__</span>last, __comp);
        return true;
    }
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type value_type;
    <span class="ge">_RandomAccessIterator __j = _</span>_first+2;
    __sort3&lt;_Compare&gt;(__first, <span class="gs">__first+1, __</span>j, __comp);
    const unsigned __limit = 8;
    unsigned __count = 0;
    for (<span class="ge">_RandomAccessIterator __i = __j+1; __i != __last; ++_</span>_i)
    {
        if (<span class="gs">__comp(*__</span>i, *__j))
        {
            value_type <span class="gs">__t(std::__</span>1::move(*__i));
            <span class="ge">_RandomAccessIterator __k = _</span>_j;
            <span class="gs">__j = __</span>i;
            do
            {
                <span class="ge">*__j = std::__1::move(*</span>__k);
                <span class="gs">__j = __</span>k;
            } while (<span class="gs">__j != __</span>first &amp;&amp; <span class="gs">__comp(__</span>t, *--__k));
            *<span class="gs">__j = std::__</span>1::move(__t);
            if (++__count == __limit)
                return ++__i == __last;
        }
        <span class="gs">__j = __</span>i;
    }
    return true;
}

template &lt;class <span class="ge">_Compare, class _</span>BirdirectionalIterator&gt;
void
__insertion_sort_move(_BirdirectionalIterator __first1, <span class="ge">_BirdirectionalIterator _</span>_last1,
                      typename iterator_traits&lt;_BirdirectionalIterator&gt;::value_type* __first2, <span class="ge">_Compare _</span>_comp)
{
    typedef typename iterator_traits&lt;_BirdirectionalIterator&gt;::value_type value_type;
    if (<span class="gs">__first1 != __</span>last1)
    {
        __destruct_n __d(0);
        unique_ptr&lt;value_type, __destruct_n&amp;&gt; <span class="gs">__h(__</span>first2, __d);
        value_type* <span class="gs">__last2 = __</span>first2;
        ::new(__last2) value_type(std::__1::move(*__first1));
        <span class="gs">__d.__</span>incr((value_type*)0);
        for (++__last2; ++__first1 != <span class="gs">__last1; ++__</span>last2)
        {
            value_type* <span class="gs">__j2 = __</span>last2;
            value_type* <span class="gs">__i2 = __</span>j2;
            if (<span class="gs">__comp(*__</span>first1, *--__i2))
            {
                ::new(__j2) value_type(std::__1::move(*__i2));
                <span class="gs">__d.__</span>incr((value_type*)0);
                for (--__j2; <span class="gs">__i2 != __</span>first2 &amp;&amp; <span class="gs">__comp(*__</span>first1, *--__i2); --__j2)
                    <span class="ge">*__j2 = std::__1::move(*</span>__i2);
                <span class="ge">*__j2 = std::__1::move(*</span>__first1);
            }
            else
            {
                ::new(__j2) value_type(std::__1::move(*__first1));
                <span class="gs">__d.__</span>incr((value_type*)0);
            }
        }
        __h.release();
    }
}

template &lt;class <span class="ge">_Compare, class _</span>RandomAccessIterator&gt;
void
__sort(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp)
{

    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type difference_type;
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type value_type;
    const difference_type __limit = is_trivially_copy_constructible&lt;value_type&gt;::value &amp;&amp;
                                    is_trivially_copy_assignable&lt;value_type&gt;::value ? 30 : 6;
    while (true)
    {
    __restart:
        difference_type <span class="gs">__len = __</span>last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (<span class="gs">__comp(*--__</span>last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            std::__1::__sort3&lt;_Compare&gt;(__first, <span class="gs">__first+1, --__</span>last, __comp);
            return;
        case 4:
            std::__1::__sort4&lt;_Compare&gt;(__first, <span class="gs">__first+1, __</span>first+2, --__last, __comp);
            return;
        case 5:
            std::__1::__sort5&lt;_Compare&gt;(__first, <span class="gs">__first+1, __</span>first+2, <span class="gs">__first+3, --__</span>last, __comp);
            return;
        }
        if (<span class="gs">__len &lt;= __</span>limit)
        {
            std::__1::__insertion_sort_3&lt;_Compare&gt;(__first, <span class="gs">__last, __</span>comp);
            return;
        }

        <span class="ge">_RandomAccessIterator __m = _</span>_first;
        <span class="ge">_RandomAccessIterator __lm1 = _</span>_last;
        --__lm1;
        unsigned __n_swaps;
        {
        difference_type __delta;
        if (__len &gt;= 1000)
        {
            <span class="gs">__delta = __</span>len/2;
            <span class="gs">__m += __</span>delta;
            __delta /= 2;
            __n_swaps = std::__1::__sort5&lt;_Compare&gt;(__first, <span class="gs">__first + __</span>delta, <span class="gs">__m, __</span>m+__delta, <span class="gs">__lm1, __</span>comp);
        }
        else
        {
            <span class="gs">__delta = __</span>len/2;
            <span class="gs">__m += __</span>delta;
            __n_swaps = std::__1::__sort3&lt;_Compare&gt;(__first, <span class="gs">__m, __</span>lm1, __comp);
        }
        }



        <span class="ge">_RandomAccessIterator __i = _</span>_first;
        <span class="ge">_RandomAccessIterator __j = _</span>_lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (<span class="gs">__i == --__</span>j)
                {


                    ++__i;
                    <span class="gs">__j = __</span>last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (<span class="gs">__i == __</span>j)
                                return;
                            if (<span class="gs">__comp(*__</span>first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (<span class="gs">__i == __</span>j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (<span class="gs">__comp(*__</span>first, *--__j))
                            ;
                        if (<span class="gs">__i &gt;= __</span>j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }



                    <span class="gs">__first = __</span>i;
                    goto __restart;
                }
                if (<span class="gs">__comp(*__</span>j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }

        ++__i;


        if (<span class="gs">__i &lt; __</span>j)
        {


            while (true)
            {

                while (<span class="gs">__comp(*__</span>i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (<span class="gs">__i &gt; __</span>j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (<span class="gs">__m == __</span>i)
                    <span class="gs">__m = __</span>j;
                ++__i;
            }
        }

        if (<span class="gs">__i != __</span>m &amp;&amp; <span class="gs">__comp(*__</span>m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }


        if (__n_swaps == 0)
        {
            bool <span class="gs">__fs = std::__</span>1::__insertion_sort_incomplete&lt;_Compare&gt;(__first, <span class="gs">__i, __</span>comp);
            if (std::__1::__insertion_sort_incomplete&lt;_Compare&gt;(__i+1, <span class="gs">__last, __</span>comp))
            {
                if (__fs)
                    return;
                <span class="gs">__last = __</span>i;
                continue;
            }
            else
            {
                if (__fs)
                {
                    <span class="gs">__first = ++__</span>i;
                    continue;
                }
            }
        }

        if (<span class="gs">__i - __</span>first &lt; <span class="gs">__last - __</span>i)
        {
            std::__1::__sort&lt;_Compare&gt;(__first, <span class="gs">__i, __</span>comp);

            <span class="gs">__first = ++__</span>i;
        }
        else
        {
            std::__1::__sort&lt;_Compare&gt;(__i+1, <span class="gs">__last, __</span>comp);

            <span class="gs">__last = __</span>i;
        }
    }
}


template &lt;class <span class="ge">_RandomAccessIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
sort(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    std::__1::__sort&lt;_Comp_ref&gt;(__first, __last, <span class="ge">_Comp_</span>ref(__comp));
}

template &lt;class _RandomAccessIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
sort(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator _</span>_last)
{
    std::__1::sort(__first, <span class="gs">__last, __</span>less&lt;typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type&gt;());
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
sort(_Tp** __first, <span class="ge">_Tp** _</span>_last)
{
    std::__1::sort((size_t*)__first, (size_t*)__last, __less&lt;size_t&gt;());
}

template &lt;class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
sort(__wrap_iter&lt;_Tp*&gt; <span class="gs">__first, __</span>wrap_iter&lt;_Tp*&gt; __last)
{
    std::__1::sort(__first.base(), __last.base());
}

template &lt;class <span class="ge">_Tp, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
sort(__wrap_iter&lt;_Tp*&gt; <span class="gs">__first, __</span>wrap_iter&lt;_Tp*&gt; __last, <span class="ge">_Compare _</span>_comp)
{
    typedef typename add_lvalue_reference&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    std::__1::sort&lt;_Tp*, <span class="ge">_Comp_</span>ref&gt;(__first.base(), <span class="gs">__last.base(), __</span>comp);
}

extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;char&gt;&amp;, char*&gt;(char*, char*, __less&lt;char&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;wchar_t&gt;&amp;, wchar_t*&gt;(wchar_t*, wchar_t*, __less&lt;wchar_t&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;signed char&gt;&amp;, signed char*&gt;(signed char*, signed char*, __less&lt;signed char&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;unsigned char&gt;&amp;, unsigned char*&gt;(unsigned char*, unsigned char*, __less&lt;unsigned char&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;short&gt;&amp;, short*&gt;(short*, short*, __less&lt;short&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;unsigned short&gt;&amp;, unsigned short*&gt;(unsigned short*, unsigned short*, __less&lt;unsigned short&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;int&gt;&amp;, int*&gt;(int*, int*, __less&lt;int&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;unsigned&gt;&amp;, unsigned*&gt;(unsigned*, unsigned*, __less&lt;unsigned&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;long&gt;&amp;, long*&gt;(long*, long*, __less&lt;long&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;unsigned long&gt;&amp;, unsigned long*&gt;(unsigned long*, unsigned long*, __less&lt;unsigned long&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;long long&gt;&amp;, long long*&gt;(long long*, long long*, __less&lt;long long&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;unsigned long long&gt;&amp;, unsigned long long*&gt;(unsigned long long*, unsigned long long*, __less&lt;unsigned long long&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;float&gt;&amp;, float*&gt;(float*, float*, __less&lt;float&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;double&gt;&amp;, double*&gt;(double*, double*, __less&lt;double&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void <span class="gs">__sort&lt;__</span>less&lt;long double&gt;&amp;, long double*&gt;(long double*, long double*, __less&lt;long double&gt;&amp;);

extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;char&gt;&amp;, char*&gt;(char*, char*, __less&lt;char&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;wchar_t&gt;&amp;, wchar_t*&gt;(wchar_t*, wchar_t*, __less&lt;wchar_t&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;signed char&gt;&amp;, signed char*&gt;(signed char*, signed char*, __less&lt;signed char&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;unsigned char&gt;&amp;, unsigned char*&gt;(unsigned char*, unsigned char*, __less&lt;unsigned char&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;short&gt;&amp;, short*&gt;(short*, short*, __less&lt;short&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;unsigned short&gt;&amp;, unsigned short*&gt;(unsigned short*, unsigned short*, __less&lt;unsigned short&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;int&gt;&amp;, int*&gt;(int*, int*, __less&lt;int&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;unsigned&gt;&amp;, unsigned*&gt;(unsigned*, unsigned*, __less&lt;unsigned&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;long&gt;&amp;, long*&gt;(long*, long*, __less&lt;long&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;unsigned long&gt;&amp;, unsigned long*&gt;(unsigned long*, unsigned long*, __less&lt;unsigned long&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;long long&gt;&amp;, long long*&gt;(long long*, long long*, __less&lt;long long&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;unsigned long long&gt;&amp;, unsigned long long*&gt;(unsigned long long*, unsigned long long*, __less&lt;unsigned long long&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;float&gt;&amp;, float*&gt;(float*, float*, __less&lt;float&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;double&gt;&amp;, double*&gt;(double*, double*, __less&lt;double&gt;&amp;);
extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) bool __insertion_sort_incomplete&lt;__less&lt;long double&gt;&amp;, long double*&gt;(long double*, long double*, __less&lt;long double&gt;&amp;);

extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) unsigned <span class="gs">__sort5&lt;__</span>less&lt;long double&gt;&amp;, long double*&gt;(long double*, long double*, long double*, long double*, long double*, __less&lt;long double&gt;&amp;);



template &lt;class <span class="ge">_Compare, class _</span>ForwardIterator, class _Tp&gt;
                              _ForwardIterator
__lower_bound(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_, <span class="ge">_Compare _</span>_comp)
{
    typedef typename iterator_traits&lt;_ForwardIterator&gt;::difference_type difference_type;
    difference_type <span class="gs">__len = std::__</span>1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type <span class="gs">__l2 = std::__</span>1::__half_positive(__len);
        <span class="ge">_ForwardIterator __m = _</span>_first;
        std::__1::advance(__m, __l2);
        if (<span class="gs">__comp(*__</span>m, __value_))
        {
            <span class="gs">__first = ++__</span>m;
            <span class="gs">__len -= __</span>l2 + 1;
        }
        else
            <span class="gs">__len = __</span>l2;
    }
    return __first;
}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Tp, class _Compare&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
lower_bound(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_, <span class="ge">_Compare _</span>_comp)
{
    typedef typename add_lvalue_reference&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return __lower_bound&lt;_Comp_ref&gt;(__first, <span class="gs">__last, __</span>value_, __comp);
}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Tp&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
lower_bound(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_)
{
    return std::__1::lower_bound(__first, <span class="gs">__last, __</span>value_,
                             __less&lt;typename iterator_traits&lt;_ForwardIterator&gt;::value_type, _Tp&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>ForwardIterator, class _Tp&gt;
                              _ForwardIterator
__upper_bound(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_, <span class="ge">_Compare _</span>_comp)
{
    typedef typename iterator_traits&lt;_ForwardIterator&gt;::difference_type difference_type;
    difference_type <span class="gs">__len = std::__</span>1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type <span class="gs">__l2 = std::__</span>1::__half_positive(__len);
        <span class="ge">_ForwardIterator __m = _</span>_first;
        std::__1::advance(__m, __l2);
        if (<span class="gs">__comp(__</span>value_, *__m))
            <span class="gs">__len = __</span>l2;
        else
        {
            <span class="gs">__first = ++__</span>m;
            <span class="gs">__len -= __</span>l2 + 1;
        }
    }
    return __first;
}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Tp, class _Compare&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
upper_bound(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_, <span class="ge">_Compare _</span>_comp)
{
    typedef typename add_lvalue_reference&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return __upper_bound&lt;_Comp_ref&gt;(__first, <span class="gs">__last, __</span>value_, __comp);
}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Tp&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_ForwardIterator
upper_bound(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_)
{
    return std::__1::upper_bound(__first, <span class="gs">__last, __</span>value_,
                             __less&lt;_Tp, typename iterator_traits&lt;_ForwardIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>ForwardIterator, class _Tp&gt;
                              pair&lt;_ForwardIterator, _ForwardIterator&gt;
__equal_range(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_, <span class="ge">_Compare _</span>_comp)
{
    typedef typename iterator_traits&lt;_ForwardIterator&gt;::difference_type difference_type;
    difference_type <span class="gs">__len = std::__</span>1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type <span class="gs">__l2 = std::__</span>1::__half_positive(__len);
        <span class="ge">_ForwardIterator __m = _</span>_first;
        std::__1::advance(__m, __l2);
        if (<span class="gs">__comp(*__</span>m, __value_))
        {
            <span class="gs">__first = ++__</span>m;
            <span class="gs">__len -= __</span>l2 + 1;
        }
        else if (<span class="gs">__comp(__</span>value_, *__m))
        {
            <span class="gs">__last = __</span>m;
            <span class="gs">__len = __</span>l2;
        }
        else
        {
            <span class="ge">_ForwardIterator __mp1 = _</span>_m;
            return pair&lt;_ForwardIterator, _ForwardIterator&gt;
                   (
                      __lower_bound&lt;_Compare&gt;(__first, <span class="gs">__m, __</span>value_, __comp),
                      __upper_bound&lt;_Compare&gt;(++__mp1, <span class="gs">__last, __</span>value_, __comp)
                   );
        }
    }
    return pair&lt;_ForwardIterator, <span class="ge">_ForwardIterator&gt;(__first, _</span>_first);
}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Tp, class _Compare&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
pair&lt;_ForwardIterator, _ForwardIterator&gt;
equal_range(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_, <span class="ge">_Compare _</span>_comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return __equal_range&lt;_Comp_ref&gt;(__first, <span class="gs">__last, __</span>value_, __comp);
}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Tp&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
pair&lt;_ForwardIterator, _ForwardIterator&gt;
equal_range(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_)
{
    return std::__1::equal_range(__first, <span class="gs">__last, __</span>value_,
                             __less&lt;typename iterator_traits&lt;_ForwardIterator&gt;::value_type, _Tp&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>ForwardIterator, class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
__binary_search(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_, <span class="ge">_Compare _</span>_comp)
{
    <span class="gs">__first = __</span>lower_bound&lt;_Compare&gt;(__first, <span class="gs">__last, __</span>value_, __comp);
    return <span class="gs">__first != __</span>last &amp;&amp; !<span class="gs">__comp(__</span>value_, *__first);
}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Tp, class _Compare&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
binary_search(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_, <span class="ge">_Compare _</span>_comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return __binary_search&lt;_Comp_ref&gt;(__first, <span class="gs">__last, __</span>value_, __comp);
}

template &lt;class <span class="ge">_ForwardIterator, class _</span>Tp&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
binary_search(_ForwardIterator __first, <span class="ge">_ForwardIterator __last, const _</span>Tp&amp; __value_)
{
    return std::__1::binary_search(__first, <span class="gs">__last, __</span>value_,
                             __less&lt;typename iterator_traits&lt;_ForwardIterator&gt;::value_type, _Tp&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>InputIterator1, class <span class="ge">_InputIterator2, class _</span>OutputIterator&gt;
_OutputIterator
__merge(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
        <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator __result, _</span>Compare __comp)
{
    for (; <span class="gs">__first1 != __</span>last1; ++__result)
    {
        if (<span class="gs">__first2 == __</span>last2)
            return std::__1::copy(__first1, <span class="gs">__last1, __</span>result);
        if (<span class="gs">__comp(*__</span>first2, *__first1))
        {
            <span class="ge">*__result = *</span>__first2;
            ++__first2;
        }
        else
        {
            <span class="ge">*__result = *</span>__first1;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, <span class="gs">__last2, __</span>result);
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class <span class="ge">_OutputIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
merge(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
      <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator __result, _</span>Compare __comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return std::__1::__merge&lt;_Comp_ref&gt;(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>result, __comp);
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class _OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
merge(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
      <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator _</span>_result)
{
    typedef typename iterator_traits&lt;_InputIterator1&gt;::value_type __v1;
    typedef typename iterator_traits&lt;_InputIterator2&gt;::value_type __v2;
    return std::__1::merge(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>result, <span class="gs">__less&lt;__</span>v1, __v2&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>InputIterator1, class _InputIterator2,
          class _OutputIterator&gt;
void __half_inplace_merge(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
                          <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2,
                          <span class="ge">_OutputIterator __result, _</span>Compare __comp)
{
    for (; <span class="gs">__first1 != __</span>last1; ++__result)
    {
        if (<span class="gs">__first2 == __</span>last2)
        {
            std::__1::move(__first1, <span class="gs">__last1, __</span>result);
            return;
        }

        if (<span class="gs">__comp(*__</span>first2, *__first1))
        {
            <span class="ge">*__result = std::__1::move(*</span>__first2);
            ++__first2;
        }
        else
        {
            <span class="ge">*__result = std::__1::move(*</span>__first1);
            ++__first1;
        }
    }

}

template &lt;class <span class="ge">_Compare, class _</span>BidirectionalIterator&gt;
void
__buffered_inplace_merge(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __middle, _</span>BidirectionalIterator __last,
                <span class="ge">_Compare __comp, typename iterator_</span>traits&lt;_BidirectionalIterator&gt;::difference_type __len1,
                                 typename iterator_traits&lt;_BidirectionalIterator&gt;::difference_type __len2,
                typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type* __buff)
{
    typedef typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type value_type;
    __destruct_n __d(0);
    unique_ptr&lt;value_type, __destruct_n&amp;&gt; <span class="gs">__h2(__</span>buff, __d);
    if (<span class="gs">__len1 &lt;= __</span>len2)
    {
        value_type* <span class="gs">__p = __</span>buff;
        for (<span class="ge">_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_</span>type*)0), (void) ++__i, (void) ++__p)
            ::new(__p) value_type(std::__1::move(*__i));
        __half_inplace_merge(__buff, <span class="gs">__p, __</span>middle, <span class="gs">__last, __</span>first, __comp);
    }
    else
    {
        value_type* <span class="gs">__p = __</span>buff;
        for (<span class="ge">_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_</span>type*)0), (void) ++__i, (void) ++__p)
            ::new(__p) value_type(std::__1::move(*__i));
        typedef reverse_iterator&lt;_BidirectionalIterator&gt; _RBi;
        typedef reverse_iterator&lt;value_type*&gt; _Rv;
        __half_inplace_merge(_Rv(__p), <span class="ge">_Rv(_</span>_buff),
                             <span class="ge">_RBi(__middle), _</span>RBi(__first),
                             <span class="ge">_RBi(__last), __invert&lt;_</span>Compare&gt;(__comp));
    }
}

template &lt;class <span class="ge">_Compare, class _</span>BidirectionalIterator&gt;
void
__inplace_merge(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __middle, _</span>BidirectionalIterator __last,
                <span class="ge">_Compare __comp, typename iterator_</span>traits&lt;_BidirectionalIterator&gt;::difference_type __len1,
                                 typename iterator_traits&lt;_BidirectionalIterator&gt;::difference_type __len2,
                typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits&lt;_BidirectionalIterator&gt;::difference_type difference_type;
    while (true)
    {

        if (__len2 == 0)
            return;
        if (<span class="gs">__len1 &lt;= __</span>buff_size || <span class="gs">__len2 &lt;= __</span>buff_size)
            return __buffered_inplace_merge&lt;_Compare&gt;
                   (<span class="gs">__first, __</span>middle, <span class="gs">__last, __</span>comp, <span class="gs">__len1, __</span>len2, __buff);

        for (; true; ++__first, (void) --__len1)
        {
            if (__len1 == 0)
                return;
            if (<span class="gs">__comp(*__</span>middle, *__first))
                break;
        }
        <span class="ge">_BidirectionalIterator _</span>_m1;
        <span class="ge">_BidirectionalIterator _</span>_m2;
        difference_type __len11;
        difference_type __len21;

        if (<span class="gs">__len1 &lt; __</span>len2)
        {
            <span class="gs">__len21 = __</span>len2 / 2;
            <span class="gs">__m2 = __</span>middle;
            std::__1::advance(__m2, __len21);
            <span class="gs">__m1 = __</span>upper_bound&lt;_Compare&gt;(__first, <span class="gs">__middle, *__</span>m2, __comp);
            <span class="gs">__len11 = std::__</span>1::distance(__first, __m1);
        }
        else
        {
            if (__len1 == 1)
            {

                swap(*__first, *__middle);
                return;
            }

            <span class="gs">__len11 = __</span>len1 / 2;
            <span class="gs">__m1 = __</span>first;
            std::__1::advance(__m1, __len11);
            <span class="gs">__m2 = __</span>lower_bound&lt;_Compare&gt;(__middle, <span class="gs">__last, *__</span>m1, __comp);
            <span class="gs">__len21 = std::__</span>1::distance(__middle, __m2);
        }
        difference_type <span class="gs">__len12 = __</span>len1 - __len11;
        difference_type <span class="gs">__len22 = __</span>len2 - __len21;


        <span class="gs">__middle = std::__</span>1::rotate(__m1, <span class="gs">__middle, __</span>m2);


        if (<span class="gs">__len11 + __</span>len21 &lt; <span class="gs">__len12 + __</span>len22)
        {
            __inplace_merge&lt;_Compare&gt;(__first, <span class="gs">__m1, __</span>middle, <span class="gs">__comp, __</span>len11, <span class="gs">__len21, __</span>buff, __buff_size);

            <span class="gs">__first = __</span>middle;
            <span class="gs">__middle = __</span>m2;
            <span class="gs">__len1 = __</span>len12;
            <span class="gs">__len2 = __</span>len22;
        }
        else
        {
            __inplace_merge&lt;_Compare&gt;(__middle, <span class="gs">__m2, __</span>last, <span class="gs">__comp, __</span>len12, <span class="gs">__len22, __</span>buff, __buff_size);

            <span class="gs">__last = __</span>middle;
            <span class="gs">__middle = __</span>m1;
            <span class="gs">__len1 = __</span>len11;
            <span class="gs">__len2 = __</span>len21;
        }
    }
}

template &lt;class <span class="ge">_BidirectionalIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
inplace_merge(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __middle, _</span>BidirectionalIterator __last,
              <span class="ge">_Compare _</span>_comp)
{
    typedef typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type value_type;
    typedef typename iterator_traits&lt;_BidirectionalIterator&gt;::difference_type difference_type;
    difference_type <span class="gs">__len1 = std::__</span>1::distance(__first, __middle);
    difference_type <span class="gs">__len2 = std::__</span>1::distance(__middle, __last);
    difference_type __buf_size = std::__1::min(__len1, __len2);
    pair&lt;value_type*, ptrdiff_t&gt; <span class="gs">__buf = std::__</span>1::get_temporary_buffer&lt;value_type&gt;(__buf_size);
    unique_ptr&lt;value_type, __return_temporary_buffer&gt; <span class="gs">__h(__</span>buf.first);
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return std::__1::__inplace_merge&lt;_Comp_ref&gt;(__first, <span class="gs">__middle, __</span>last, <span class="gs">__comp, __</span>len1, __len2,
                                            <span class="gs">__buf.first, __</span>buf.second);
}

template &lt;class _BidirectionalIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
inplace_merge(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __middle, _</span>BidirectionalIterator __last)
{
    std::__1::inplace_merge(__first, <span class="gs">__middle, __</span>last,
                        __less&lt;typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>InputIterator1, class _InputIterator2&gt;
void
__merge_move_construct(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
        <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2,
        typename iterator_traits&lt;_InputIterator1&gt;::value_type* __result, <span class="ge">_Compare _</span>_comp)
{
    typedef typename iterator_traits&lt;_InputIterator1&gt;::value_type value_type;
    __destruct_n __d(0);
    unique_ptr&lt;value_type, __destruct_n&amp;&gt; <span class="gs">__h(__</span>result, __d);
    for (; true; ++__result)
    {
        if (<span class="gs">__first1 == __</span>last1)
        {
            for (; <span class="gs">__first2 != __</span>last2; ++__first2, ++__result, (void) <span class="gs">__d.__</span>incr((value_type*)0))
                ::new (__result) value_type(std::__1::move(*__first2));
            __h.release();
            return;
        }
        if (<span class="gs">__first2 == __</span>last2)
        {
            for (; <span class="gs">__first1 != __</span>last1; ++__first1, ++__result, (void) <span class="gs">__d.__</span>incr((value_type*)0))
                ::new (__result) value_type(std::__1::move(*__first1));
            __h.release();
            return;
        }
        if (<span class="gs">__comp(*__</span>first2, *__first1))
        {
            ::new (__result) value_type(std::__1::move(*__first2));
            <span class="gs">__d.__</span>incr((value_type*)0);
            ++__first2;
        }
        else
        {
            ::new (__result) value_type(std::__1::move(*__first1));
            <span class="gs">__d.__</span>incr((value_type*)0);
            ++__first1;
        }
    }
}

template &lt;class <span class="ge">_Compare, class _</span>InputIterator1, class <span class="ge">_InputIterator2, class _</span>OutputIterator&gt;
void
__merge_move_assign(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
        <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2,
        <span class="ge">_OutputIterator __result, _</span>Compare __comp)
{
    for (; <span class="gs">__first1 != __</span>last1; ++__result)
    {
        if (<span class="gs">__first2 == __</span>last2)
        {
            for (; <span class="gs">__first1 != __</span>last1; ++__first1, (void) ++__result)
                <span class="ge">*__result = std::__1::move(*</span>__first1);
            return;
        }
        if (<span class="gs">__comp(*__</span>first2, *__first1))
        {
            <span class="ge">*__result = std::__1::move(*</span>__first2);
            ++__first2;
        }
        else
        {
            <span class="ge">*__result = std::__1::move(*</span>__first1);
            ++__first1;
        }
    }
    for (; <span class="gs">__first2 != __</span>last2; ++__first2, (void) ++__result)
        <span class="ge">*__result = std::__1::move(*</span>__first2);
}

template &lt;class <span class="ge">_Compare, class _</span>RandomAccessIterator&gt;
void
__stable_sort(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp,
              typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type __len,
              typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type* __buff, ptrdiff_t __buff_size);

template &lt;class <span class="ge">_Compare, class _</span>RandomAccessIterator&gt;
void
__stable_sort_move(_RandomAccessIterator __first1, <span class="ge">_RandomAccessIterator __last1, _</span>Compare __comp,
                   typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type __len,
                   typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type* __first2)
{
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type value_type;
    switch (__len)
    {
    case 0:
        return;
    case 1:
        ::new(__first2) value_type(std::__1::move(*__first1));
        return;
    case 2:
        __destruct_n __d(0);
        unique_ptr&lt;value_type, __destruct_n&amp;&gt; <span class="gs">__h2(__</span>first2, __d);
        if (<span class="gs">__comp(*--__</span>last1, *__first1))
        {
            ::new(__first2) value_type(std::__1::move(*__last1));
            <span class="gs">__d.__</span>incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__1::move(*__first1));
        }
        else
        {
            ::new(__first2) value_type(std::__1::move(*__first1));
            <span class="gs">__d.__</span>incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__1::move(*__last1));
        }
        __h2.release();
        return;
    }
    if (__len &lt;= 8)
    {
        __insertion_sort_move&lt;_Compare&gt;(__first1, <span class="gs">__last1, __</span>first2, __comp);
        return;
    }
    typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type <span class="gs">__l2 = __</span>len / 2;
    <span class="ge">_RandomAccessIterator __m = __first1 + _</span>_l2;
    __stable_sort&lt;_Compare&gt;(__first1, <span class="gs">__m, __</span>comp, <span class="gs">__l2, __</span>first2, __l2);
    __stable_sort&lt;_Compare&gt;(__m, <span class="gs">__last1, __</span>comp, <span class="gs">__len - __</span>l2, <span class="gs">__first2 + __</span>l2, <span class="gs">__len - __</span>l2);
    __merge_move_construct&lt;_Compare&gt;(__first1, <span class="gs">__m, __</span>m, <span class="gs">__last1, __</span>first2, __comp);
}

template &lt;class _Tp&gt;
struct __stable_sort_switch
{
    static const unsigned value = 128*is_trivially_copy_assignable&lt;_Tp&gt;::value;
};

template &lt;class <span class="ge">_Compare, class _</span>RandomAccessIterator&gt;
void
__stable_sort(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp,
              typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type __len,
              typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type value_type;
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type difference_type;
    switch (__len)
    {
    case 0:
    case 1:
        return;
    case 2:
        if (<span class="gs">__comp(*--__</span>last, *__first))
            swap(*__first, *__last);
        return;
    }
    if (__len &lt;= static_cast&lt;difference_type&gt;(__stable_sort_switch&lt;value_type&gt;::value))
    {
        __insertion_sort&lt;_Compare&gt;(__first, <span class="gs">__last, __</span>comp);
        return;
    }
    typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type <span class="gs">__l2 = __</span>len / 2;
    <span class="ge">_RandomAccessIterator __m = __first + _</span>_l2;
    if (<span class="gs">__len &lt;= __</span>buff_size)
    {
        __destruct_n __d(0);
        unique_ptr&lt;value_type, __destruct_n&amp;&gt; <span class="gs">__h2(__</span>buff, __d);
        __stable_sort_move&lt;_Compare&gt;(__first, <span class="gs">__m, __</span>comp, <span class="gs">__l2, __</span>buff);
        <span class="gs">__d.__</span>set(__l2, (value_type*)0);
        __stable_sort_move&lt;_Compare&gt;(__m, <span class="gs">__last, __</span>comp, <span class="gs">__len - __</span>l2, <span class="gs">__buff + __</span>l2);
        <span class="gs">__d.__</span>set(__len, (value_type*)0);
        __merge_move_assign&lt;_Compare&gt;(__buff, <span class="gs">__buff + __</span>l2, <span class="gs">__buff + __</span>l2, <span class="gs">__buff + __</span>len, <span class="gs">__first, __</span>comp);





        return;
    }
    __stable_sort&lt;_Compare&gt;(__first, <span class="gs">__m, __</span>comp, <span class="gs">__l2, __</span>buff, __buff_size);
    __stable_sort&lt;_Compare&gt;(__m, <span class="gs">__last, __</span>comp, <span class="gs">__len - __</span>l2, <span class="gs">__buff, __</span>buff_size);
    __inplace_merge&lt;_Compare&gt;(__first, <span class="gs">__m, __</span>last, <span class="gs">__comp, __</span>l2, <span class="gs">__len - __</span>l2, <span class="gs">__buff, __</span>buff_size);
}

template &lt;class <span class="ge">_RandomAccessIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
stable_sort(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp)
{
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type value_type;
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type difference_type;
    difference_type <span class="gs">__len = __</span>last - __first;
    pair&lt;value_type*, ptrdiff_t&gt; __buf(0, 0);
    unique_ptr&lt;value_type, __return_temporary_buffer&gt; __h;
    if (__len &gt; static_cast&lt;difference_type&gt;(__stable_sort_switch&lt;value_type&gt;::value))
    {
        <span class="gs">__buf = std::__</span>1::get_temporary_buffer&lt;value_type&gt;(__len);
        <span class="gs">__h.reset(__</span>buf.first);
    }
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    __stable_sort&lt;_Comp_ref&gt;(__first, <span class="gs">__last, __</span>comp, <span class="gs">__len, __</span>buf.first, __buf.second);
}

template &lt;class _RandomAccessIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
stable_sort(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator _</span>_last)
{
    std::__1::stable_sort(__first, <span class="gs">__last, __</span>less&lt;typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_RandomAccessIterator, class _</span>Compare&gt;
                                                    _RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp)
{
    typedef typename std::__1::iterator_traits&lt;_RandomAccessIterator&gt;::difference_type difference_type;
    difference_type <span class="gs">__len = __</span>last - __first;
    difference_type __p = 0;
    difference_type __c = 1;
    <span class="ge">_RandomAccessIterator __pp = _</span>_first;
    while (<span class="gs">__c &lt; __</span>len)
    {
        <span class="ge">_RandomAccessIterator __cp = __first + _</span>_c;
        if (<span class="gs">__comp(*__</span>pp, *__cp))
            return __cp;
        ++__c;
        ++__cp;
        if (<span class="gs">__c == __</span>len)
            return __last;
        if (<span class="gs">__comp(*__</span>pp, *__cp))
            return __cp;
        ++__p;
        ++__pp;
        <span class="gs">__c = 2 * __</span>p + 1;
    }
    return __last;
}

template&lt;class _RandomAccessIterator&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator _</span>_last)
{
    return std::__1::is_heap_until(__first, <span class="gs">__last, __</span>less&lt;typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_RandomAccessIterator, class _</span>Compare&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
is_heap(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp)
{
    return std::__1::is_heap_until(__first, <span class="gs">__last, __</span>comp) == __last;
}

template&lt;class _RandomAccessIterator&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
is_heap(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator _</span>_last)
{
    return std::__1::is_heap(__first, <span class="gs">__last, __</span>less&lt;typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>RandomAccessIterator&gt;
void
__sift_up(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp,
          typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type __len)
{
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type value_type;
    if (__len &gt; 1)
    {
        <span class="gs">__len = (__</span>len - 2) / 2;
        <span class="ge">_RandomAccessIterator __ptr = __first + _</span>_len;
        if (<span class="gs">__comp(*__</span>ptr, *--__last))
        {
            value_type <span class="gs">__t(std::__</span>1::move(*__last));
            do
            {
                <span class="ge">*__last = std::__1::move(*</span>__ptr);
                <span class="gs">__last = __</span>ptr;
                if (__len == 0)
                    break;
                <span class="gs">__len = (__</span>len - 1) / 2;
                <span class="gs">__ptr = __</span>first + __len;
            } while (<span class="gs">__comp(*__</span>ptr, __t));
            *<span class="gs">__last = std::__</span>1::move(__t);
        }
    }
}

template &lt;class <span class="ge">_RandomAccessIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
push_heap(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    __sift_up&lt;_Comp_ref&gt;(__first, <span class="gs">__last, __</span>comp, <span class="gs">__last - __</span>first);
}

template &lt;class _RandomAccessIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
push_heap(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator _</span>_last)
{
    std::__1::push_heap(__first, <span class="gs">__last, __</span>less&lt;typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>RandomAccessIterator&gt;
void
__sift_down(_RandomAccessIterator __first, _RandomAccessIterator ,
            <span class="ge">_Compare _</span>_comp,
            typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type __len,
            <span class="ge">_RandomAccessIterator _</span>_start)
{
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type difference_type;
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type value_type;


    difference_type <span class="gs">__child = __</span>start - __first;

    if (<span class="gs">__len &lt; 2 || (__</span>len - 2) / 2 &lt; __child)
        return;

    <span class="gs">__child = 2 * __</span>child + 1;
    <span class="ge">_RandomAccessIterator __child_</span>i = <span class="gs">__first + __</span>child;

    if ((__child + 1) &lt; <span class="gs">__len &amp;&amp; __</span>comp(*__child_i, *(__child_i + 1))) {

        ++__child_i;
        ++__child;
    }


    if (<span class="gs">__comp(*__</span>child_i, *__start))

        return;

    value_type <span class="gs">__top(std::__</span>1::move(*__start));
    do
    {

        <span class="ge">*__start = std::__1::move(*</span>__child_i);
        <span class="gs">__start = __</span>child_i;

        if ((__len - 2) / 2 &lt; __child)
            break;


        <span class="gs">__child = 2 * __</span>child + 1;
        __child_i = <span class="gs">__first + __</span>child;

        if ((__child + 1) &lt; <span class="gs">__len &amp;&amp; __</span>comp(*__child_i, *(__child_i + 1))) {

            ++__child_i;
            ++__child;
        }


    } while (!__comp(*__child_i, __top));
    *<span class="gs">__start = std::__</span>1::move(__top);
}

template &lt;class <span class="ge">_Compare, class _</span>RandomAccessIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
__pop_heap(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp,
           typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type __len)
{
    if (__len &gt; 1)
    {
        swap(*__first, *--__last);
        __sift_down&lt;_Compare&gt;(__first, <span class="gs">__last, __</span>comp, <span class="gs">__len - 1, __</span>first);
    }
}

template &lt;class <span class="ge">_RandomAccessIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
pop_heap(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    __pop_heap&lt;_Comp_ref&gt;(__first, <span class="gs">__last, __</span>comp, <span class="gs">__last - __</span>first);
}

template &lt;class _RandomAccessIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
pop_heap(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator _</span>_last)
{
    std::__1::pop_heap(__first, <span class="gs">__last, __</span>less&lt;typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>RandomAccessIterator&gt;
void
__make_heap(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp)
{
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type difference_type;
    difference_type <span class="gs">__n = __</span>last - __first;
    if (__n &gt; 1)
    {

        for (difference_type <span class="gs">__start = (__</span>n - 2) / 2; <span class="gs">__start &gt;= 0; --__</span>start)
        {
            __sift_down&lt;_Compare&gt;(__first, <span class="gs">__last, __</span>comp, <span class="gs">__n, __</span>first + __start);
        }
    }
}

template &lt;class <span class="ge">_RandomAccessIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
make_heap(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    __make_heap&lt;_Comp_ref&gt;(__first, <span class="gs">__last, __</span>comp);
}

template &lt;class _RandomAccessIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
make_heap(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator _</span>_last)
{
    std::__1::make_heap(__first, <span class="gs">__last, __</span>less&lt;typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>RandomAccessIterator&gt;
void
__sort_heap(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp)
{
    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type difference_type;
    for (difference_type <span class="gs">__n = __</span>last - <span class="gs">__first; __</span>n &gt; 1; --__last, (void) --__n)
        __pop_heap&lt;_Compare&gt;(__first, <span class="gs">__last, __</span>comp, __n);
}

template &lt;class <span class="ge">_RandomAccessIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
sort_heap(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __last, _</span>Compare __comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    __sort_heap&lt;_Comp_ref&gt;(__first, <span class="gs">__last, __</span>comp);
}

template &lt;class _RandomAccessIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
sort_heap(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator _</span>_last)
{
    std::__1::sort_heap(__first, <span class="gs">__last, __</span>less&lt;typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>RandomAccessIterator&gt;
void
__partial_sort(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __middle, _</span>RandomAccessIterator __last,
             <span class="ge">_Compare _</span>_comp)
{
    __make_heap&lt;_Compare&gt;(__first, <span class="gs">__middle, __</span>comp);
    typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type <span class="gs">__len = __</span>middle - __first;
    for (<span class="ge">_RandomAccessIterator __i = __middle; __i != __last; ++_</span>_i)
    {
        if (<span class="gs">__comp(*__</span>i, *__first))
        {
            swap(*__i, *__first);
            __sift_down&lt;_Compare&gt;(__first, <span class="gs">__middle, __</span>comp, <span class="gs">__len, __</span>first);
        }
    }
    __sort_heap&lt;_Compare&gt;(__first, <span class="gs">__middle, __</span>comp);
}

template &lt;class <span class="ge">_RandomAccessIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
partial_sort(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __middle, _</span>RandomAccessIterator __last,
             <span class="ge">_Compare _</span>_comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    __partial_sort&lt;_Comp_ref&gt;(__first, <span class="gs">__middle, __</span>last, __comp);
}

template &lt;class _RandomAccessIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
partial_sort(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __middle, _</span>RandomAccessIterator __last)
{
    std::__1::partial_sort(__first, <span class="gs">__middle, __</span>last,
                       __less&lt;typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>InputIterator, class _RandomAccessIterator&gt;
_RandomAccessIterator
__partial_sort_copy(_InputIterator __first, <span class="ge">_InputIterator _</span>_last,
                    <span class="ge">_RandomAccessIterator __result_</span>first, <span class="ge">_RandomAccessIterator __result_</span>last, <span class="ge">_Compare _</span>_comp)
{
    <span class="ge">_RandomAccessIterator __r = __result_</span>first;
    if (<span class="gs">__r != __</span>result_last)
    {
        for (; <span class="gs">__first != __</span>last &amp;&amp; <span class="gs">__r != __</span>result_last; ++__first, (void) ++__r)
            <span class="ge">*__r = *</span>__first;
        __make_heap&lt;_Compare&gt;(__result_first, <span class="gs">__r, __</span>comp);
        typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type <span class="gs">__len = __</span>r - __result_first;
        for (; <span class="gs">__first != __</span>last; ++__first)
            if (<span class="gs">__comp(*__</span>first, *__result_first))
            {
                <span class="ge">*__result_first = *</span>__first;
                __sift_down&lt;_Compare&gt;(__result_first, <span class="gs">__r, __</span>comp, <span class="gs">__len, __</span>result_first);
            }
        __sort_heap&lt;_Compare&gt;(__result_first, <span class="gs">__r, __</span>comp);
    }
    return __r;
}

template &lt;class <span class="ge">_InputIterator, class _</span>RandomAccessIterator, class _Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, <span class="ge">_InputIterator _</span>_last,
                  <span class="ge">_RandomAccessIterator __result_</span>first, <span class="ge">_RandomAccessIterator __result_</span>last, <span class="ge">_Compare _</span>_comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return __partial_sort_copy&lt;_Comp_ref&gt;(__first, <span class="gs">__last, __</span>result_first, __result_last, __comp);
}

template &lt;class <span class="ge">_InputIterator, class _</span>RandomAccessIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, <span class="ge">_InputIterator _</span>_last,
                  <span class="ge">_RandomAccessIterator __result_</span>first, <span class="ge">_RandomAccessIterator __result_</span>last)
{
    return std::__1::partial_sort_copy(__first, <span class="gs">__last, __</span>result_first, __result_last,
                                   __less&lt;typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>RandomAccessIterator&gt;
void
__nth_element(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __nth, _</span>RandomAccessIterator __last, <span class="ge">_Compare _</span>_comp)
{

    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type difference_type;
    const difference_type __limit = 7;
    while (true)
    {
    __restart:
        if (<span class="gs">__nth == __</span>last)
            return;
        difference_type <span class="gs">__len = __</span>last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (<span class="gs">__comp(*--__</span>last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            {
            <span class="ge">_RandomAccessIterator __m = _</span>_first;
            std::__1::__sort3&lt;_Compare&gt;(__first, ++__m, --__last, __comp);
            return;
            }
        }
        if (<span class="gs">__len &lt;= __</span>limit)
        {
            __selection_sort&lt;_Compare&gt;(__first, <span class="gs">__last, __</span>comp);
            return;
        }

        <span class="ge">_RandomAccessIterator __m = __first + _</span>_len/2;
        <span class="ge">_RandomAccessIterator __lm1 = _</span>_last;
        unsigned __n_swaps = std::__1::__sort3&lt;_Compare&gt;(__first, <span class="gs">__m, --__</span>lm1, __comp);



        <span class="ge">_RandomAccessIterator __i = _</span>_first;
        <span class="ge">_RandomAccessIterator __j = _</span>_lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (<span class="gs">__i == --__</span>j)
                {


                    ++__i;
                    <span class="gs">__j = __</span>last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (<span class="gs">__i == __</span>j)
                                return;
                            if (<span class="gs">__comp(*__</span>first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (<span class="gs">__i == __</span>j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (<span class="gs">__comp(*__</span>first, *--__j))
                            ;
                        if (<span class="gs">__i &gt;= __</span>j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }


                    if (<span class="gs">__nth &lt; __</span>i)
                        return;


                    <span class="gs">__first = __</span>i;
                    goto __restart;
                }
                if (<span class="gs">__comp(*__</span>j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }
        ++__i;


        if (<span class="gs">__i &lt; __</span>j)
        {

            while (true)
            {

                while (<span class="gs">__comp(*__</span>i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (<span class="gs">__i &gt;= __</span>j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (<span class="gs">__m == __</span>i)
                    <span class="gs">__m = __</span>j;
                ++__i;
            }
        }

        if (<span class="gs">__i != __</span>m &amp;&amp; <span class="gs">__comp(*__</span>m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }

        if (<span class="gs">__nth == __</span>i)
            return;
        if (__n_swaps == 0)
        {

            if (<span class="gs">__nth &lt; __</span>i)
            {

                <span class="gs">__j = __</span>m = __first;
                while (++__j != __i)
                {
                    if (<span class="gs">__comp(*__</span>j, *__m))

                        goto not_sorted;
                    <span class="gs">__m = __</span>j;
                }

                return;
            }
            else
            {

                <span class="gs">__j = __</span>m = __i;
                while (++__j != __last)
                {
                    if (<span class="gs">__comp(*__</span>j, *__m))

                        goto not_sorted;
                    <span class="gs">__m = __</span>j;
                }

                return;
            }
        }
not_sorted:

        if (<span class="gs">__nth &lt; __</span>i)
        {

            <span class="gs">__last = __</span>i;
        }
        else
        {

            <span class="gs">__first = ++__</span>i;
        }
    }
}

template &lt;class <span class="ge">_RandomAccessIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
nth_element(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __nth, _</span>RandomAccessIterator __last, <span class="ge">_Compare _</span>_comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    __nth_element&lt;_Comp_ref&gt;(__first, <span class="gs">__nth, __</span>last, __comp);
}

template &lt;class _RandomAccessIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
nth_element(_RandomAccessIterator __first, <span class="ge">_RandomAccessIterator __nth, _</span>RandomAccessIterator __last)
{
    std::__1::nth_element(__first, <span class="gs">__nth, __</span>last, __less&lt;typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>InputIterator1, class _InputIterator2&gt;
                              bool
__includes(_InputIterator1 __first1, <span class="ge">_InputIterator1 __last1, _</span>InputIterator2 __first2, <span class="ge">_InputIterator2 _</span>_last2,
           <span class="ge">_Compare _</span>_comp)
{
    for (; <span class="gs">__first2 != __</span>last2; ++__first1)
    {
        if (<span class="gs">__first1 == __</span>last1 || <span class="gs">__comp(*__</span>first2, *__first1))
            return false;
        if (!__comp(*__first1, *__first2))
            ++__first2;
    }
    return true;
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class _Compare&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
includes(_InputIterator1 __first1, <span class="ge">_InputIterator1 __last1, _</span>InputIterator2 __first2, <span class="ge">_InputIterator2 _</span>_last2,
         <span class="ge">_Compare _</span>_comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return __includes&lt;_Comp_ref&gt;(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>comp);
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
includes(_InputIterator1 __first1, <span class="ge">_InputIterator1 __last1, _</span>InputIterator2 __first2, <span class="ge">_InputIterator2 _</span>_last2)
{
    return std::__1::includes(__first1, <span class="gs">__last1, __</span>first2, __last2,
                          __less&lt;typename iterator_traits&lt;_InputIterator1&gt;::value_type,
                                 typename iterator_traits&lt;_InputIterator2&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>InputIterator1, class <span class="ge">_InputIterator2, class _</span>OutputIterator&gt;
_OutputIterator
__set_union(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
            <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator __result, _</span>Compare __comp)
{
    for (; <span class="gs">__first1 != __</span>last1; ++__result)
    {
        if (<span class="gs">__first2 == __</span>last2)
            return std::__1::copy(__first1, <span class="gs">__last1, __</span>result);
        if (<span class="gs">__comp(*__</span>first2, *__first1))
        {
            <span class="ge">*__result = *</span>__first2;
            ++__first2;
        }
        else
        {
            if (!__comp(*__first1, *__first2))
                ++__first2;
            <span class="ge">*__result = *</span>__first1;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, <span class="gs">__last2, __</span>result);
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class <span class="ge">_OutputIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
set_union(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
          <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator __result, _</span>Compare __comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return __set_union&lt;_Comp_ref&gt;(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>result, __comp);
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class _OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
set_union(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
          <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator _</span>_result)
{
    return std::__1::set_union(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>result,
                          __less&lt;typename iterator_traits&lt;_InputIterator1&gt;::value_type,
                                 typename iterator_traits&lt;_InputIterator2&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>InputIterator1, class <span class="ge">_InputIterator2, class _</span>OutputIterator&gt;
                              _OutputIterator
__set_intersection(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
                   <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator __result, _</span>Compare __comp)
{
    while (<span class="gs">__first1 != __</span>last1 &amp;&amp; <span class="gs">__first2 != __</span>last2)
    {
        if (<span class="gs">__comp(*__</span>first1, *__first2))
            ++__first1;
        else
        {
            if (!__comp(*__first2, *__first1))
            {
                <span class="ge">*__result = *</span>__first1;
                ++__result;
                ++__first1;
            }
            ++__first2;
        }
    }
    return __result;
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class <span class="ge">_OutputIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
set_intersection(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
                 <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator __result, _</span>Compare __comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return __set_intersection&lt;_Comp_ref&gt;(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>result, __comp);
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class _OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
set_intersection(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
                 <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator _</span>_result)
{
    return std::__1::set_intersection(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>result,
                                  __less&lt;typename iterator_traits&lt;_InputIterator1&gt;::value_type,
                                         typename iterator_traits&lt;_InputIterator2&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>InputIterator1, class <span class="ge">_InputIterator2, class _</span>OutputIterator&gt;
_OutputIterator
__set_difference(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
                 <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator __result, _</span>Compare __comp)
{
    while (<span class="gs">__first1 != __</span>last1)
    {
        if (<span class="gs">__first2 == __</span>last2)
            return std::__1::copy(__first1, <span class="gs">__last1, __</span>result);
        if (<span class="gs">__comp(*__</span>first1, *__first2))
        {
            <span class="ge">*__result = *</span>__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (!__comp(*__first2, *__first1))
                ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class <span class="ge">_OutputIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
set_difference(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
               <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator __result, _</span>Compare __comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return __set_difference&lt;_Comp_ref&gt;(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>result, __comp);
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class _OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
set_difference(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
               <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator _</span>_result)
{
    return std::__1::set_difference(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>result,
                                __less&lt;typename iterator_traits&lt;_InputIterator1&gt;::value_type,
                                       typename iterator_traits&lt;_InputIterator2&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>InputIterator1, class <span class="ge">_InputIterator2, class _</span>OutputIterator&gt;
_OutputIterator
__set_symmetric_difference(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
                           <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator __result, _</span>Compare __comp)
{
    while (<span class="gs">__first1 != __</span>last1)
    {
        if (<span class="gs">__first2 == __</span>last2)
            return std::__1::copy(__first1, <span class="gs">__last1, __</span>result);
        if (<span class="gs">__comp(*__</span>first1, *__first2))
        {
            <span class="ge">*__result = *</span>__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (<span class="gs">__comp(*__</span>first2, *__first1))
            {
                <span class="ge">*__result = *</span>__first2;
                ++__result;
            }
            else
                ++__first1;
            ++__first2;
        }
    }
    return std::__1::copy(__first2, <span class="gs">__last2, __</span>result);
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class <span class="ge">_OutputIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
                         <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator __result, _</span>Compare __comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return __set_symmetric_difference&lt;_Comp_ref&gt;(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>result, __comp);
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class _OutputIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
                         <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_OutputIterator _</span>_result)
{
    return std::__1::set_symmetric_difference(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>result,
                                          __less&lt;typename iterator_traits&lt;_InputIterator1&gt;::value_type,
                                                 typename iterator_traits&lt;_InputIterator2&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>InputIterator1, class _InputIterator2&gt;
                              bool
__lexicographical_compare(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
                          <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_Compare _</span>_comp)
{
    for (; <span class="gs">__first2 != __</span>last2; ++__first1, (void) ++__first2)
    {
        if (<span class="gs">__first1 == __</span>last1 || <span class="gs">__comp(*__</span>first1, *__first2))
            return true;
        if (<span class="gs">__comp(*__</span>first2, *__first1))
            return false;
    }
    return false;
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2, class _Compare&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
lexicographical_compare(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
                        <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2, <span class="ge">_Compare _</span>_comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return __lexicographical_compare&lt;_Comp_ref&gt;(__first1, <span class="gs">__last1, __</span>first2, <span class="gs">__last2, __</span>comp);
}

template &lt;class <span class="ge">_InputIterator1, class _</span>InputIterator2&gt;
                      inline
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
lexicographical_compare(_InputIterator1 __first1, <span class="ge">_InputIterator1 _</span>_last1,
                        <span class="ge">_InputIterator2 __first2, _</span>InputIterator2 __last2)
{
    return std::__1::lexicographical_compare(__first1, <span class="gs">__last1, __</span>first2, __last2,
                                         __less&lt;typename iterator_traits&lt;_InputIterator1&gt;::value_type,
                                                typename iterator_traits&lt;_InputIterator2&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>BidirectionalIterator&gt;
bool
__next_permutation(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __last, _</span>Compare __comp)
{
    <span class="ge">_BidirectionalIterator __i = _</span>_last;
    if (<span class="gs">__first == __</span>last || <span class="gs">__first == --__</span>i)
        return false;
    while (true)
    {
        <span class="ge">_BidirectionalIterator __ip1 = _</span>_i;
        if (<span class="gs">__comp(*--__</span>i, *__ip1))
        {
            <span class="ge">_BidirectionalIterator __j = _</span>_last;
            while (!__comp(*__i, *--__j))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (<span class="gs">__i == __</span>first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template &lt;class <span class="ge">_BidirectionalIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
next_permutation(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __last, _</span>Compare __comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return __next_permutation&lt;_Comp_ref&gt;(__first, <span class="gs">__last, __</span>comp);
}

template &lt;class _BidirectionalIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
next_permutation(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator _</span>_last)
{
    return std::__1::next_permutation(__first, __last,
                                  __less&lt;typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type&gt;());
}



template &lt;class <span class="ge">_Compare, class _</span>BidirectionalIterator&gt;
bool
__prev_permutation(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __last, _</span>Compare __comp)
{
    <span class="ge">_BidirectionalIterator __i = _</span>_last;
    if (<span class="gs">__first == __</span>last || <span class="gs">__first == --__</span>i)
        return false;
    while (true)
    {
        <span class="ge">_BidirectionalIterator __ip1 = _</span>_i;
        if (<span class="gs">__comp(*__</span>ip1, *--__i))
        {
            <span class="ge">_BidirectionalIterator __j = _</span>_last;
            while (!__comp(*--__j, *__i))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (<span class="gs">__i == __</span>first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template &lt;class <span class="ge">_BidirectionalIterator, class _</span>Compare&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
prev_permutation(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator __last, _</span>Compare __comp)
{
    typedef typename __comp_ref_type&lt;_Compare&gt;::type <span class="ge">_Comp_</span>ref;
    return __prev_permutation&lt;_Comp_ref&gt;(__first, <span class="gs">__last, __</span>comp);
}

template &lt;class _BidirectionalIterator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
prev_permutation(_BidirectionalIterator __first, <span class="ge">_BidirectionalIterator _</span>_last)
{
    return std::__1::prev_permutation(__first, __last,
                                  __less&lt;typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type&gt;());
}

} }


namespace std { inline namespace __1 {



using ::FILE;
using ::fpos_t;
using ::size_t;

using ::fclose;
using ::fflush;
using ::setbuf;
using ::setvbuf;
using ::fprintf;
using ::fscanf;
using ::snprintf;
using ::sprintf;
using ::sscanf;
using ::vfprintf;
using ::vfscanf;
using ::vsscanf;
using ::vsnprintf;
using ::vsprintf;
using ::fgetc;
using ::fgets;
using ::fputc;
using ::fputs;
using ::getc;
using ::putc;
using ::ungetc;
using ::fread;
using ::fwrite;
using ::fgetpos;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::rewind;
using ::clearerr;
using ::feof;
using ::ferror;
using ::perror;


using ::fopen;
using ::freopen;
using ::remove;
using ::rename;
using ::tmpfile;
using ::tmpnam;



using ::getchar;

using ::gets;

using ::scanf;
using ::vscanf;



using ::printf;
using ::putchar;
using ::puts;
using ::vprintf;
} }





namespace std { inline namespace __1 {



template &lt;class _CharT&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) char_traits
{
    typedef <span class="ge">_CharT char_</span>type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline void
        assign(char_type&amp; __c1, const char_type&amp; <span class="gs">__c2) throw() {__</span>c1 = __c2;}
    static inline bool eq(char_type __c1, char_type __c2) throw()
        {return <span class="gs">__c1 == __</span>c2;}
    static inline bool lt(char_type __c1, char_type __c2) throw()
        {return <span class="gs">__c1 &lt; __</span>c2;}

    static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static
    size_t length(const char_type* __s);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static
    const char_type* find(const char_type* __s, size_t __n, const char_type&amp; __a);
    static
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static
    char_type* assign(char_type* __s, size_t __n, char_type __a);

    static inline int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    static inline int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return <span class="gs">__c1 == __</span>c2;}
    static inline int_type eof() throw()
        {return int_type((-1));}
};

template &lt;class _CharT&gt;
                              int
char_traits&lt;_CharT&gt;::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; <span class="gs">__n; --__</span>n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

template &lt;class _CharT&gt;
inline
                              size_t
char_traits&lt;_CharT&gt;::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

template &lt;class _CharT&gt;
inline
                              const _CharT*
char_traits&lt;_CharT&gt;::find(const char_type* __s, size_t __n, const char_type&amp; __a)
{
    for (; <span class="gs">__n; --__</span>n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

template &lt;class _CharT&gt;
                              _CharT*
char_traits&lt;_CharT&gt;::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    if (<span class="gs">__n == 0) return __</span>s1;
    char_type* <span class="gs">__r = __</span>s1;
    if (<span class="gs">__s1 &lt; __</span>s2)
    {
        for (; <span class="gs">__n; --__</span>n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (<span class="gs">__s2 &lt; __</span>s1)
    {
        <span class="gs">__s1 += __</span>n;
        <span class="gs">__s2 += __</span>n;
        for (; <span class="gs">__n; --__</span>n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

template &lt;class _CharT&gt;
inline
_CharT*
char_traits&lt;_CharT&gt;::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* <span class="gs">__r = __</span>s1;
    for (; <span class="gs">__n; --__</span>n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

template &lt;class _CharT&gt;
inline
_CharT*
char_traits&lt;_CharT&gt;::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* <span class="gs">__r = __</span>s;
    for (; <span class="gs">__n; --__</span>n, ++__s)
        assign(*__s, __a);
    return __r;
}



template &lt;class _CharT&gt;
static inline
<span class="ge">_CharT* __move_</span>constexpr(_CharT* __s1, const <span class="ge">_CharT* __s2, size_</span>t __n) throw()
{
    if (<span class="gs">__n == 0) return __</span>s1;
    if (<span class="gs">__s1 &lt; __</span>s2) {
      std::__1::copy(__s2, <span class="gs">__s2 + __</span>n, __s1);
    } else if (<span class="gs">__s2 &lt; __</span>s1) {
      std::__1::copy_backward(__s2, <span class="gs">__s2 + __</span>n, <span class="gs">__s1 + __</span>n);
    }
    return __s1;
}

template &lt;class _CharT&gt;
static inline
<span class="ge">_CharT* __copy_</span>constexpr(_CharT* __s1, const <span class="ge">_CharT* __s2, size_</span>t __n) throw()
{
    std::__1::copy_n(__s2, <span class="gs">__n, __</span>s1);
    return __s1;
}

template &lt;class _CharT&gt;
static inline
<span class="ge">_CharT* __assign_</span>constexpr(_CharT* __s, size_t __n, <span class="ge">_CharT _</span>_a) throw()
{
     std::__1::fill_n(__s, <span class="gs">__n, __</span>a);
     return __s;
}



template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) char_traits&lt;char&gt;
{
    typedef char char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline
    void assign(char_type&amp; __c1, const char_type&amp; <span class="gs">__c2) throw() {__</span>c1 = __c2;}
    static inline bool eq(char_type __c1, char_type __c2) throw()
            {return <span class="gs">__c1 == __</span>c2;}
    static inline bool lt(char_type __c1, char_type __c2) throw()
        {return (unsigned char)__c1 &lt; (unsigned char)__c2;}

    static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) throw();
    static inline size_t
    length(const char_type* <span class="gs">__s) throw() {return __</span>builtin_strlen(__s);}
    static
    const char_type* find(const char_type* __s, size_t __n, const char_type&amp; __a) throw();
    static inline
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n) throw()
        {
            return __libcpp_is_constant_evaluated()
                       ? __move_constexpr(__s1, <span class="gs">__s2, __</span>n)
                       : <span class="gs">__n == 0 ? __</span>s1 : (char_type*)memmove(__s1, <span class="gs">__s2, __</span>n);
        }
    static inline
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) throw()
        {
            ((void)0);
            return __libcpp_is_constant_evaluated()
                       ? __copy_constexpr(__s1, <span class="gs">__s2, __</span>n)
                       : <span class="gs">__n == 0 ? __</span>s1 : (char_type*)memcpy(__s1, <span class="gs">__s2, __</span>n);
        }
    static inline
    char_type* assign(char_type* __s, size_t __n, char_type __a) throw()
        {
            return __libcpp_is_constant_evaluated()
                       ? __assign_constexpr(__s, <span class="gs">__n, __</span>a)
                       : <span class="gs">__n == 0 ? __</span>s : (char_type*)memset(__s, to_int_type(__a), __n);
        }

    static inline int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    static inline int_type to_int_type(char_type __c) throw()
        {return int_type((unsigned char)__c);}
    static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return <span class="gs">__c1 == __</span>c2;}
    static inline int_type eof() throw()
        {return int_type((-1));}
};

inline
int
char_traits&lt;char&gt;::compare(const char_type* __s1, const char_type* __s2, size_t __n) throw()
{
    if (__n == 0)
        return 0;



    return memcmp(__s1, <span class="gs">__s2, __</span>n);
}

inline
const char*
char_traits&lt;char&gt;::find(const char_type* __s, size_t __n, const char_type&amp; __a) throw()
{
    if (__n == 0)
        return std::__1::__get_nullptr_t();



    return (const char_type*) memchr(__s, to_int_type(__a), __n);
}




template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) char_traits&lt;wchar_t&gt;
{
    typedef wchar_t char_type;
    typedef wint_t int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline
    void assign(char_type&amp; __c1, const char_type&amp; <span class="gs">__c2) throw() {__</span>c1 = __c2;}
    static inline bool eq(char_type __c1, char_type __c2) throw()
        {return <span class="gs">__c1 == __</span>c2;}
    static inline bool lt(char_type __c1, char_type __c2) throw()
        {return <span class="gs">__c1 &lt; __</span>c2;}

    static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) throw();
    static
    size_t length(const char_type* __s) throw();
    static
    const char_type* find(const char_type* __s, size_t __n, const char_type&amp; __a) throw();
    static inline
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n) throw()
        {
            return __libcpp_is_constant_evaluated()
                       ? __move_constexpr(__s1, <span class="gs">__s2, __</span>n)
                       : <span class="gs">__n == 0 ? __</span>s1 : wmemmove(__s1, <span class="gs">__s2, __</span>n);
        }
    static inline
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) throw()
        {
            ((void)0);
            return __libcpp_is_constant_evaluated()
                       ? __copy_constexpr(__s1, <span class="gs">__s2, __</span>n)
                       : <span class="gs">__n == 0 ? __</span>s1 : wmemcpy(__s1, <span class="gs">__s2, __</span>n);
        }
    static inline
    char_type* assign(char_type* __s, size_t __n, char_type __a) throw()
        {
            return __libcpp_is_constant_evaluated()
                       ? __assign_constexpr(__s, <span class="gs">__n, __</span>a)
                       : <span class="gs">__n == 0 ? __</span>s : wmemset(__s, <span class="gs">__a, __</span>n);
        }
    static inline int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    static inline int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return <span class="gs">__c1 == __</span>c2;}
    static inline int_type eof() throw()
        {return int_type(((__darwin_wint_t)-1));}
};

inline
int
char_traits&lt;wchar_t&gt;::compare(const char_type* __s1, const char_type* __s2, size_t __n) throw()
{
    if (__n == 0)
        return 0;



    return wmemcmp(__s1, <span class="gs">__s2, __</span>n);
}


template &lt;class _Traits&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

inline size_t __char_traits_length_checked(const typename <span class="ge">_Traits::char_</span>type* __s) throw() {



  return <span class="ge">_Traits::length(_</span>_s);

}

inline
size_t
char_traits&lt;wchar_t&gt;::length(const char_type* __s) throw()
{



    return wcslen(__s);






}

inline
const wchar_t*
char_traits&lt;wchar_t&gt;::find(const char_type* __s, size_t __n, const char_type&amp; __a) throw()
{
    if (__n == 0)
        return std::__1::__get_nullptr_t();



    return wmemchr(__s, <span class="gs">__a, __</span>n);
}
template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) char_traits&lt;char16_t&gt;
{
    typedef char16_t char_type;
    typedef uint_least16_t int_type;
    typedef streamoff off_type;
    typedef u16streampos pos_type;
    typedef mbstate_t state_type;

    static inline
    void assign(char_type&amp; __c1, const char_type&amp; <span class="gs">__c2) throw() {__</span>c1 = __c2;}
    static inline bool eq(char_type __c1, char_type __c2) throw()
        {return <span class="gs">__c1 == __</span>c2;}
    static inline bool lt(char_type __c1, char_type __c2) throw()
        {return <span class="gs">__c1 &lt; __</span>c2;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static
    size_t length(const char_type* __s) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static
    const char_type* find(const char_type* __s, size_t __n, const char_type&amp; __a) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static char_type* assign(char_type* __s, size_t __n, char_type __a) throw();

    static inline int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    static inline int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return <span class="gs">__c1 == __</span>c2;}
    static inline int_type eof() throw()
        {return int_type(0xFFFF);}
};

inline
int
char_traits&lt;char16_t&gt;::compare(const char_type* __s1, const char_type* __s2, size_t __n) throw()
{
    for (; <span class="gs">__n; --__</span>n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline
size_t
char_traits&lt;char16_t&gt;::length(const char_type* __s) throw()
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline
const char16_t*
char_traits&lt;char16_t&gt;::find(const char_type* __s, size_t __n, const char_type&amp; __a) throw()
{
    for (; <span class="gs">__n; --__</span>n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

inline
char16_t*
char_traits&lt;char16_t&gt;::move(char_type* __s1, const char_type* __s2, size_t __n) throw()
{
    if (<span class="gs">__n == 0) return __</span>s1;
    char_type* <span class="gs">__r = __</span>s1;
    if (<span class="gs">__s1 &lt; __</span>s2)
    {
        for (; <span class="gs">__n; --__</span>n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (<span class="gs">__s2 &lt; __</span>s1)
    {
        <span class="gs">__s1 += __</span>n;
        <span class="gs">__s2 += __</span>n;
        for (; <span class="gs">__n; --__</span>n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline
char16_t*
char_traits&lt;char16_t&gt;::copy(char_type* __s1, const char_type* __s2, size_t __n) throw()
{
    ((void)0);
    char_type* <span class="gs">__r = __</span>s1;
    for (; <span class="gs">__n; --__</span>n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline
char16_t*
char_traits&lt;char16_t&gt;::assign(char_type* __s, size_t __n, char_type __a) throw()
{
    char_type* <span class="gs">__r = __</span>s;
    for (; <span class="gs">__n; --__</span>n, ++__s)
        assign(*__s, __a);
    return __r;
}

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) char_traits&lt;char32_t&gt;
{
    typedef char32_t char_type;
    typedef uint_least32_t int_type;
    typedef streamoff off_type;
    typedef u32streampos pos_type;
    typedef mbstate_t state_type;

    static inline
    void assign(char_type&amp; __c1, const char_type&amp; <span class="gs">__c2) throw() {__</span>c1 = __c2;}
    static inline bool eq(char_type __c1, char_type __c2) throw()
        {return <span class="gs">__c1 == __</span>c2;}
    static inline bool lt(char_type __c1, char_type __c2) throw()
        {return <span class="gs">__c1 &lt; __</span>c2;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static
    size_t length(const char_type* __s) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static
    const char_type* find(const char_type* __s, size_t __n, const char_type&amp; __a) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    static char_type* assign(char_type* __s, size_t __n, char_type __a) throw();

    static inline int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    static inline int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return <span class="gs">__c1 == __</span>c2;}
    static inline int_type eof() throw()
        {return int_type(0xFFFFFFFF);}
};

inline
int
char_traits&lt;char32_t&gt;::compare(const char_type* __s1, const char_type* __s2, size_t __n) throw()
{
    for (; <span class="gs">__n; --__</span>n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline
size_t
char_traits&lt;char32_t&gt;::length(const char_type* __s) throw()
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline
const char32_t*
char_traits&lt;char32_t&gt;::find(const char_type* __s, size_t __n, const char_type&amp; __a) throw()
{
    for (; <span class="gs">__n; --__</span>n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

inline
char32_t*
char_traits&lt;char32_t&gt;::move(char_type* __s1, const char_type* __s2, size_t __n) throw()
{
    if (<span class="gs">__n == 0) return __</span>s1;
    char_type* <span class="gs">__r = __</span>s1;
    if (<span class="gs">__s1 &lt; __</span>s2)
    {
        for (; <span class="gs">__n; --__</span>n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (<span class="gs">__s2 &lt; __</span>s1)
    {
        <span class="gs">__s1 += __</span>n;
        <span class="gs">__s2 += __</span>n;
        for (; <span class="gs">__n; --__</span>n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline
char32_t*
char_traits&lt;char32_t&gt;::copy(char_type* __s1, const char_type* __s2, size_t __n) throw()
{
    ((void)0);
    char_type* <span class="gs">__r = __</span>s1;
    for (; <span class="gs">__n; --__</span>n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline
char32_t*
char_traits&lt;char32_t&gt;::assign(char_type* __s, size_t __n, char_type __a) throw()
{
    char_type* <span class="gs">__r = __</span>s;
    for (; <span class="gs">__n; --__</span>n, ++__s)
        assign(*__s, __a);
    return __r;
}






template&lt;class <span class="ge">_CharT, class _</span>SizeT, class <span class="ge">_Traits, _</span>SizeT __npos&gt;
inline <span class="ge">_SizeT __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__str_find(const <span class="ge">_CharT *__p, _</span>SizeT __sz,
             <span class="ge">_CharT __c, _</span>SizeT __pos) throw()
{
    if (<span class="gs">__pos &gt;= __</span>sz)
        return __npos;
    const <span class="ge">_CharT* __r = _</span>Traits::find(__p + <span class="gs">__pos, __</span>sz - <span class="gs">__pos, __</span>c);
    if (__r == 0)
        return __npos;
    return static_cast&lt;_SizeT&gt;(__r - __p);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline const _CharT *
__search_substring(const <span class="ge">_CharT *__first1, const _</span>CharT *__last1,
                   const <span class="ge">_CharT *__first2, const _</span>CharT *__last2) {


  const ptrdiff_t <span class="gs">__len2 = __</span>last2 - __first2;
  if (__len2 == 0)
    return __first1;

  ptrdiff_t <span class="gs">__len1 = __</span>last1 - __first1;
  if (<span class="gs">__len1 &lt; __</span>len2)
    return __last1;


  <span class="ge">_CharT __f2 = *_</span>_first2;
  while (true) {
    <span class="gs">__len1 = __</span>last1 - __first1;

    if (<span class="gs">__len1 &lt; __</span>len2)
      return __last1;


    __first1 = <span class="ge">_Traits::find(__first1, __len1 - __len2 + 1, _</span>_f2);
    if (__first1 == 0)
      return __last1;






    if (<span class="ge">_Traits::compare(__first1, __first2, _</span>_len2) == 0)
      return __first1;

    ++__first1;
  }
}

template&lt;class <span class="ge">_CharT, class _</span>SizeT, class <span class="ge">_Traits, _</span>SizeT __npos&gt;
inline <span class="ge">_SizeT __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__str_find(const <span class="ge">_CharT *__p, _</span>SizeT __sz,
       const <span class="ge">_CharT* __s, _</span>SizeT __pos, <span class="ge">_SizeT _</span>_n) throw()
{
    if (<span class="gs">__pos &gt; __</span>sz)
        return __npos;

    if (__n == 0)
        return __pos;

    const <span class="ge">_CharT *__r = __search_</span>substring&lt;_CharT, _Traits&gt;(
        <span class="gs">__p + __</span>pos, <span class="gs">__p + __</span>sz, <span class="gs">__s, __</span>s + __n);

    if (<span class="gs">__r == __</span>p + __sz)
        return __npos;
    return static_cast&lt;_SizeT&gt;(__r - __p);
}




template&lt;class <span class="ge">_CharT, class _</span>SizeT, class <span class="ge">_Traits, _</span>SizeT __npos&gt;
inline <span class="ge">_SizeT __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__str_rfind(const <span class="ge">_CharT *__p, _</span>SizeT __sz,
              <span class="ge">_CharT __c, _</span>SizeT __pos) throw()
{
    if (__sz &lt; 1)
        return __npos;
    if (<span class="gs">__pos &lt; __</span>sz)
        ++__pos;
    else
        <span class="gs">__pos = __</span>sz;
    for (const <span class="ge">_CharT* __ps = __p + __pos; __ps != _</span>_p;)
    {
        if (<span class="ge">_Traits::eq(*--__ps, _</span>_c))
            return static_cast&lt;_SizeT&gt;(__ps - __p);
    }
    return __npos;
}

template&lt;class <span class="ge">_CharT, class _</span>SizeT, class <span class="ge">_Traits, _</span>SizeT __npos&gt;
inline <span class="ge">_SizeT __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__str_rfind(const <span class="ge">_CharT *__p, _</span>SizeT __sz,
        const <span class="ge">_CharT* __s, _</span>SizeT __pos, <span class="ge">_SizeT _</span>_n) throw()
{
    <span class="gs">__pos = std::__</span>1::min(__pos, __sz);
    if (<span class="gs">__n &lt; __</span>sz - __pos)
        <span class="gs">__pos += __</span>n;
    else
        <span class="gs">__pos = __</span>sz;
    const <span class="ge">_CharT* __r = std::__1::__find_</span>end(
                  <span class="gs">__p, __</span>p + <span class="gs">__pos, __</span>s, <span class="gs">__s + __</span>n, _Traits::eq,
                        random_access_iterator_tag(), random_access_iterator_tag());
    if (<span class="gs">__n &gt; 0 &amp;&amp; __</span>r == <span class="gs">__p + __</span>pos)
        return __npos;
    return static_cast&lt;_SizeT&gt;(__r - __p);
}


template&lt;class <span class="ge">_CharT, class _</span>SizeT, class <span class="ge">_Traits, _</span>SizeT __npos&gt;
inline <span class="ge">_SizeT __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__str_find_first_of(const <span class="ge">_CharT *__p, _</span>SizeT __sz,
                const <span class="ge">_CharT* __s, _</span>SizeT __pos, <span class="ge">_SizeT _</span>_n) throw()
{
    if (<span class="gs">__pos &gt;= __</span>sz || __n == 0)
        return __npos;
    const <span class="ge">_CharT* __r = std::__1::__find_</span>first_of_ce
        (<span class="gs">__p + __</span>pos, <span class="gs">__p + __</span>sz, <span class="gs">__s, __</span>s + __n, _Traits::eq );
    if (<span class="gs">__r == __</span>p + __sz)
        return __npos;
    return static_cast&lt;_SizeT&gt;(__r - __p);
}



template&lt;class <span class="ge">_CharT, class _</span>SizeT, class <span class="ge">_Traits, _</span>SizeT __npos&gt;
inline <span class="ge">_SizeT __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__str_find_last_of(const <span class="ge">_CharT *__p, _</span>SizeT __sz,
               const <span class="ge">_CharT* __s, _</span>SizeT __pos, <span class="ge">_SizeT _</span>_n) throw()
    {
    if (__n != 0)
    {
        if (<span class="gs">__pos &lt; __</span>sz)
            ++__pos;
        else
            <span class="gs">__pos = __</span>sz;
        for (const <span class="ge">_CharT* __ps = __p + __pos; __ps != _</span>_p;)
        {
            const <span class="ge">_CharT* __r = _</span>Traits::find(__s, <span class="gs">__n, *--__</span>ps);
            if (__r)
                return static_cast&lt;_SizeT&gt;(__ps - __p);
        }
    }
    return __npos;
}



template&lt;class <span class="ge">_CharT, class _</span>SizeT, class <span class="ge">_Traits, _</span>SizeT __npos&gt;
inline <span class="ge">_SizeT __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__str_find_first_not_of(const <span class="ge">_CharT *__p, _</span>SizeT __sz,
                    const <span class="ge">_CharT* __s, _</span>SizeT __pos, <span class="ge">_SizeT _</span>_n) throw()
{
    if (<span class="gs">__pos &lt; __</span>sz)
    {
        const <span class="ge">_CharT* __pe = __p + _</span>_sz;
        for (const <span class="ge">_CharT* __ps = __p + __pos; __ps != __pe; ++_</span>_ps)
            if (<span class="ge">_Traits::find(__s, __n, *_</span>_ps) == 0)
                return static_cast&lt;_SizeT&gt;(__ps - __p);
    }
    return __npos;
}


template&lt;class <span class="ge">_CharT, class _</span>SizeT, class <span class="ge">_Traits, _</span>SizeT __npos&gt;
inline <span class="ge">_SizeT __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__str_find_first_not_of(const <span class="ge">_CharT *__p, _</span>SizeT __sz,
                          <span class="ge">_CharT __c, _</span>SizeT __pos) throw()
{
    if (<span class="gs">__pos &lt; __</span>sz)
    {
        const <span class="ge">_CharT* __pe = __p + _</span>_sz;
        for (const <span class="ge">_CharT* __ps = __p + __pos; __ps != __pe; ++_</span>_ps)
            if (!_Traits::eq(*__ps, __c))
                return static_cast&lt;_SizeT&gt;(__ps - __p);
    }
    return __npos;
}



template&lt;class <span class="ge">_CharT, class _</span>SizeT, class <span class="ge">_Traits, _</span>SizeT __npos&gt;
inline <span class="ge">_SizeT __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__str_find_last_not_of(const <span class="ge">_CharT *__p, _</span>SizeT __sz,
                   const <span class="ge">_CharT* __s, _</span>SizeT __pos, <span class="ge">_SizeT _</span>_n) throw()
{
    if (<span class="gs">__pos &lt; __</span>sz)
        ++__pos;
    else
        <span class="gs">__pos = __</span>sz;
    for (const <span class="ge">_CharT* __ps = __p + __pos; __ps != _</span>_p;)
        if (<span class="ge">_Traits::find(__s, __n, *--_</span>_ps) == 0)
            return static_cast&lt;_SizeT&gt;(__ps - __p);
    return __npos;
}


template&lt;class <span class="ge">_CharT, class _</span>SizeT, class <span class="ge">_Traits, _</span>SizeT __npos&gt;
inline <span class="ge">_SizeT __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__str_find_last_not_of(const <span class="ge">_CharT *__p, _</span>SizeT __sz,
                         <span class="ge">_CharT __c, _</span>SizeT __pos) throw()
{
    if (<span class="gs">__pos &lt; __</span>sz)
        ++__pos;
    else
        <span class="gs">__pos = __</span>sz;
    for (const <span class="ge">_CharT* __ps = __p + __pos; __ps != _</span>_p;)
        if (!_Traits::eq(*--__ps, __c))
            return static_cast&lt;_SizeT&gt;(__ps - __p);
    return __npos;
}

template&lt;class _Ptr&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
size_t __do_string_hash(_Ptr __p, <span class="ge">_Ptr _</span>_e)
{
    typedef typename iterator_traits&lt;_Ptr&gt;::value_type value_type;
    return __murmur2_or_cityhash&lt;size_t&gt;()(__p, (<span class="gs">__e-__</span>p)*sizeof(value_type));
}

template &lt;class <span class="ge">_CharT, class _</span>Iter, class <span class="ge">_Traits=char_</span>traits&lt;_CharT&gt; &gt;
struct __quoted_output_proxy
{
    <span class="ge">_Iter _</span>_first;
    <span class="ge">_Iter _</span>_last;
    <span class="ge">_CharT _</span>_delim;
    <span class="ge">_CharT _</span>_escape;

    __quoted_output_proxy(_Iter __f, <span class="ge">_Iter __l, _</span>CharT __d, <span class="ge">_CharT _</span>_e)
    : <span class="gs">__first(__</span>f), <span class="gs">__last(__</span>l), <span class="gs">__delim(__</span>d), <span class="gs">__escape(__</span>e) {}

};

} }





namespace std { inline namespace __1 {

template&lt;class <span class="ge">_CharT, class _</span>Traits = char_traits&lt;_CharT&gt; &gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_string_view {
public:

    typedef <span class="ge">_Traits traits_</span>type;
    typedef <span class="ge">_CharT value_</span>type;
    typedef _CharT* pointer;
    typedef const <span class="ge">_CharT* const_</span>pointer;
    typedef _CharT&amp; reference;
    typedef const <span class="ge">_CharT&amp; const_</span>reference;
    typedef const_pointer const_iterator;
    typedef const_iterator iterator;
    typedef std::__1::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
    typedef const_reverse_iterator reverse_iterator;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    static const size_type npos = -1;

    <span class="ge">_Static_</span>assert((!is_array&lt;value_type&gt;::value), &quot;Character type of basic_string_view must not be an array&quot;);
    <span class="ge">_Static_</span>assert(( is_standard_layout&lt;value_type&gt;::value), &quot;Character type of basic_string_view must be standard-layout&quot;);
    <span class="ge">_Static_</span>assert(( is_trivial&lt;value_type&gt;::value), &quot;Character type of basic_string_view must be trivial&quot;);
    <span class="ge">_Static_</span>assert((is_same&lt;_CharT, typename traits_type::char_type&gt;::value), &quot;traits_type::char_type must be the same type as CharT&quot;);



                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string_view() throw() : <span class="gs">__data (std::__</span>1::__get_nullptr_t()), __size(0) {}

                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string_view(const basic_string_view&amp;) throw() = default;

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string_view&amp; operator=(const basic_string_view&amp;) throw() = default;

                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string_view(const <span class="ge">_CharT* __s, size_</span>type __len) throw()
        : <span class="gs">__data(__</span>s), <span class="gs">__size(__</span>len)
    {



    }

                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string_view(const <span class="ge">_CharT* _</span>_s)
        : <span class="gs">__data(__</span>s), <span class="gs">__size(std::__</span>char_traits_length_checked&lt;_Traits&gt;(__s)) {}


                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_iterator begin() const throw() { return cbegin(); }

                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_iterator end() const throw() { return cend(); }

                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_iterator cbegin() const throw() { return __data; }

                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_iterator cend() const throw() { return <span class="gs">__data + __</span>size; }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_reverse_iterator rbegin() const throw() { return const_reverse_iterator(cend()); }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_reverse_iterator rend() const throw() { return const_reverse_iterator(cbegin()); }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_reverse_iterator crbegin() const throw() { return const_reverse_iterator(cend()); }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_reverse_iterator crend() const throw() { return const_reverse_iterator(cbegin()); }


                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type size() const throw() { return __size; }

                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type length() const throw() { return __size; }

                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type max_size() const throw() { return numeric_limits&lt;size_type&gt;::max(); }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool empty() const throw() { return __size == 0; }


                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_reference operator[](size_type <span class="gs">__pos) const throw() { return __</span>data[__pos]; }

                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_reference at(size_type __pos) const
    {
        return __pos &gt;= size()
            ? (__throw_out_of_range(&quot;string_view::at&quot;), __data[0])
            : <span class="gs">__data[__</span>pos];
    }

                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_reference front() const throw()
    {
        return ((void)0), __data[0];
    }

                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_reference back() const throw()
    {
        return ((void)0), <span class="gs">__data[__</span>size-1];
    }

                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_pointer data() const throw() { return __data; }


                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void remove_prefix(size_type __n) throw()
    {
        ((void)0);
        <span class="gs">__data += __</span>n;
        <span class="gs">__size -= __</span>n;
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void remove_suffix(size_type __n) throw()
    {
        ((void)0);
        <span class="gs">__size -= __</span>n;
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void swap(basic_string_view&amp; __other) throw()
    {
        const value_type *<span class="gs">__p = __</span>data;
        <span class="gs">__data = __</span>other.__data;
        <span class="gs">__other.__</span>data = __p;

        size_type <span class="gs">__sz = __</span>size;
        <span class="gs">__size = __</span>other.__size;
        <span class="gs">__other.__</span>size = __sz;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const
    {
        if (__pos &gt; size())
            __throw_out_of_range(&quot;string_view::copy&quot;);
        size_type <span class="gs">__rlen = std::__</span>1::min(__n, size() - __pos);
        <span class="ge">_Traits::copy(__s, data() + __pos, _</span>_rlen);
        return __rlen;
    }

                      <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string_view substr(size_type __pos = 0, size_type __n = npos) const
    {
        return __pos &gt; size()
            ? (__throw_out_of_range(&quot;string_view::substr&quot;), basic_string_view())
            : basic_string_view(data() + <span class="gs">__pos, std::__</span>1::min(__n, size() - __pos));
    }

                                  int compare(basic_string_view __sv) const throw()
    {
        size_type <span class="gs">__rlen = std::__</span>1::min( size(), __sv.size());
        int __retval = <span class="ge">_Traits::compare(data(), __sv.data(), _</span>_rlen);
        if ( __retval == 0 )
            <span class="gs">__retval = size() == __</span>sv.size() ? 0 : ( size() &lt; __sv.size() ? -1 : 1 );
        return __retval;
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int compare(size_type __pos1, size_type __n1, basic_string_view __sv) const
    {
        return substr(__pos1, <span class="gs">__n1).compare(__</span>sv);
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int compare( size_type __pos1, size_type __n1,
                basic_string_view __sv, size_type __pos2, size_type __n2) const
    {
        return substr(__pos1, <span class="gs">__n1).compare(__</span>sv.substr(__pos2, __n2));
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int compare(const <span class="ge">_CharT* _</span>_s) const throw()
    {
        return compare(basic_string_view(__s));
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int compare(size_type __pos1, size_type __n1, const <span class="ge">_CharT* _</span>_s) const
    {
        return substr(__pos1, __n1).compare(basic_string_view(__s));
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int compare(size_type __pos1, size_type __n1, const <span class="ge">_CharT* __s, size_</span>type __n2) const
    {
        return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));
    }


                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find(basic_string_view __s, size_type __pos = 0) const throw()
    {
        ((void)0);
        return __str_find&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s.data(), __</span>pos, __s.size());
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find(_CharT __c, size_type __pos = 0) const throw()
    {
        return __str_find&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__c, __</span>pos);
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find(const <span class="ge">_CharT* __s, size_</span>type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s, __</span>pos, __n);
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find(const <span class="ge">_CharT* __s, size_</span>type __pos = 0) const
    {
        ((void)0);
        return __str_find&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s, __</span>pos, traits_type::length(__s));
    }


                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type rfind(basic_string_view __s, size_type __pos = npos) const throw()
    {
        ((void)0);
        return __str_rfind&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s.data(), __</span>pos, __s.size());
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type rfind(_CharT __c, size_type __pos = npos) const throw()
    {
        return __str_rfind&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__c, __</span>pos);
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type rfind(const <span class="ge">_CharT* __s, size_</span>type __pos, size_type __n) const
    {
        ((void)0);
        return __str_rfind&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s, __</span>pos, __n);
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type rfind(const <span class="ge">_CharT* __s, size_</span>type __pos=npos) const
    {
        ((void)0);
        return __str_rfind&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s, __</span>pos, traits_type::length(__s));
    }


                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_first_of(basic_string_view __s, size_type __pos = 0) const throw()
    {
        ((void)0);
        return __str_find_first_of&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s.data(), __</span>pos, __s.size());
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_first_of(_CharT __c, size_type __pos = 0) const throw()
    { return find(__c, __pos); }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_first_of(const <span class="ge">_CharT* __s, size_</span>type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find_first_of&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s, __</span>pos, __n);
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_first_of(const <span class="ge">_CharT* __s, size_</span>type __pos=0) const
    {
        ((void)0);
        return __str_find_first_of&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s, __</span>pos, traits_type::length(__s));
    }


                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_last_of(basic_string_view __s, size_type __pos=npos) const throw()
    {
        ((void)0);
        return __str_find_last_of&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s.data(), __</span>pos, __s.size());
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_last_of(_CharT __c, size_type __pos = npos) const throw()
    { return rfind(__c, __pos); }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_last_of(const <span class="ge">_CharT* __s, size_</span>type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find_last_of&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s, __</span>pos, __n);
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_last_of(const <span class="ge">_CharT* __s, size_</span>type __pos=npos) const
    {
        ((void)0);
        return __str_find_last_of&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s, __</span>pos, traits_type::length(__s));
    }


                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_first_not_of(basic_string_view __s, size_type __pos=0) const throw()
    {
        ((void)0);
        return __str_find_first_not_of&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s.data(), __</span>pos, __s.size());
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_first_not_of(_CharT __c, size_type __pos=0) const throw()
    {
        return __str_find_first_not_of&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__c, __</span>pos);
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_first_not_of(const <span class="ge">_CharT* __s, size_</span>type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find_first_not_of&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s, __</span>pos, __n);
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_first_not_of(const <span class="ge">_CharT* __s, size_</span>type __pos=0) const
    {
        ((void)0);
        return __str_find_first_not_of&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s, __</span>pos, traits_type::length(__s));
    }


                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_last_not_of(basic_string_view __s, size_type __pos=npos) const throw()
    {
        ((void)0);
        return __str_find_last_not_of&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s.data(), __</span>pos, __s.size());
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_last_not_of(_CharT __c, size_type __pos=npos) const throw()
    {
        return __str_find_last_not_of&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__c, __</span>pos);
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_last_not_of(const <span class="ge">_CharT* __s, size_</span>type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find_last_not_of&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s, __</span>pos, __n);
    }

                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_last_not_of(const <span class="ge">_CharT* __s, size_</span>type __pos=npos) const
    {
        ((void)0);
        return __str_find_last_not_of&lt;value_type, size_type, traits_type, npos&gt;
            (data(), size(), <span class="gs">__s, __</span>pos, traits_type::length(__s));
    }
private:
    const value_type* __data;
    size_type __size;
};




template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator==(basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_lhs,
                basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_rhs) throw()
{
    if ( <span class="gs">__lhs.size() != __</span>rhs.size()) return false;
    return <span class="gs">__lhs.compare(__</span>rhs) == 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator==(basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_lhs,
                typename common_type&lt;basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; &gt;::type _</span>_rhs) throw()
{
    if ( <span class="gs">__lhs.size() != __</span>rhs.size()) return false;
    return <span class="gs">__lhs.compare(__</span>rhs) == 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator==(typename common_type&lt;basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; &gt;::type _</span>_lhs,
                basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_rhs) throw()
{
    if ( <span class="gs">__lhs.size() != __</span>rhs.size()) return false;
    return <span class="gs">__lhs.compare(__</span>rhs) == 0;
}



template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator!=(basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; __lhs, basic_</span>string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_rhs) throw()
{
    if ( <span class="gs">__lhs.size() != __</span>rhs.size())
        return true;
    return <span class="gs">__lhs.compare(__</span>rhs) != 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator!=(basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_lhs,
                typename common_type&lt;basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; &gt;::type _</span>_rhs) throw()
{
    if ( <span class="gs">__lhs.size() != __</span>rhs.size())
        return true;
    return <span class="gs">__lhs.compare(__</span>rhs) != 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator!=(typename common_type&lt;basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; &gt;::type _</span>_lhs,
                basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_rhs) throw()
{
    if ( <span class="gs">__lhs.size() != __</span>rhs.size())
        return true;
    return <span class="gs">__lhs.compare(__</span>rhs) != 0;
}



template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator&lt;(basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; __lhs, basic_</span>string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_rhs) throw()
{
    return <span class="gs">__lhs.compare(__</span>rhs) &lt; 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator&lt;(basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_lhs,
                typename common_type&lt;basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; &gt;::type _</span>_rhs) throw()
{
    return <span class="gs">__lhs.compare(__</span>rhs) &lt; 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator&lt;(typename common_type&lt;basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; &gt;::type _</span>_lhs,
                basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_rhs) throw()
{
    return <span class="gs">__lhs.compare(__</span>rhs) &lt; 0;
}



template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator&gt; (basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; __lhs, basic_</span>string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_rhs) throw()
{
    return <span class="gs">__lhs.compare(__</span>rhs) &gt; 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator&gt;(basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_lhs,
                typename common_type&lt;basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; &gt;::type _</span>_rhs) throw()
{
    return <span class="gs">__lhs.compare(__</span>rhs) &gt; 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator&gt;(typename common_type&lt;basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; &gt;::type _</span>_lhs,
                basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_rhs) throw()
{
    return <span class="gs">__lhs.compare(__</span>rhs) &gt; 0;
}



template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator&lt;=(basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; __lhs, basic_</span>string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_rhs) throw()
{
    return <span class="gs">__lhs.compare(__</span>rhs) &lt;= 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator&lt;=(basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_lhs,
                typename common_type&lt;basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; &gt;::type _</span>_rhs) throw()
{
    return <span class="gs">__lhs.compare(__</span>rhs) &lt;= 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator&lt;=(typename common_type&lt;basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; &gt;::type _</span>_lhs,
                basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_rhs) throw()
{
    return <span class="gs">__lhs.compare(__</span>rhs) &lt;= 0;
}



template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator&gt;=(basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; __lhs, basic_</span>string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_rhs) throw()
{
    return <span class="gs">__lhs.compare(__</span>rhs) &gt;= 0;
}


template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator&gt;=(basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_lhs,
                typename common_type&lt;basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; &gt;::type _</span>_rhs) throw()
{
    return <span class="gs">__lhs.compare(__</span>rhs) &gt;= 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
                              <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator&gt;=(typename common_type&lt;basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; &gt;::type _</span>_lhs,
                basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_rhs) throw()
{
    return <span class="gs">__lhs.compare(__</span>rhs) &gt;= 0;
}


template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_os,
           basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_str);

typedef basic_string_view&lt;char&gt; string_view;



typedef basic_string_view&lt;char16_t&gt; u16string_view;
typedef basic_string_view&lt;char32_t&gt; u32string_view;
typedef basic_string_view&lt;wchar_t&gt; wstring_view;


template&lt;class _CharT&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;basic_string_view&lt;_CharT, char_traits&lt;_CharT&gt; &gt; &gt;
    : public unary_function&lt;basic_string_view&lt;_CharT, char_traits&lt;_CharT&gt; &gt;, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(const basic_string_view&lt;_CharT, char_traits&lt;_CharT&gt; &gt; __val) const throw() {
        return __do_string_hash(__val.data(), <span class="gs">__val.data() + __</span>val.size());
    }
};
} }





namespace std { inline namespace __1 {
using ::isalnum;
using ::isalpha;
using ::isblank;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;

} }


typedef __darwin_wctrans_t wctrans_t;
inline int
iswblank(wint_t _wc)
{
 return (__istype(_wc, 0x00020000L));
}


inline int
iswascii(wint_t _wc)
{
 return ((_wc &amp; ~0x7F) == 0);
}

inline int
iswhexnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00010000L));
}

inline int
iswideogram(wint_t _wc)
{
 return (__istype(_wc, 0x00080000L));
}

inline int
iswnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00000400L));
}

inline int
iswphonogram(wint_t _wc)
{
 return (__istype(_wc, 0x00200000L));
}

inline int
iswrune(wint_t _wc)
{
 return (__istype(_wc, 0xFFFFFFF0L));
}

inline int
iswspecial(wint_t _wc)
{
 return (__istype(_wc, 0x00100000L));
}
extern &quot;C&quot; {

wint_t nextwctype(wint_t, wctype_t);

wint_t towctrans(wint_t, wctrans_t);
wctrans_t
 wctrans(const char *);
}


namespace std { inline namespace __1 {

using ::wint_t;
using ::wctrans_t;
using ::wctype_t;
using ::iswalnum;
using ::iswalpha;
using ::iswblank;
using ::iswcntrl;
using ::iswdigit;
using ::iswgraph;
using ::iswlower;
using ::iswprint;
using ::iswpunct;
using ::iswspace;
using ::iswupper;
using ::iswxdigit;
using ::iswctype;
using ::wctype;
using ::towlower;
using ::towupper;
using ::towctrans;
using ::wctrans;

} }


namespace std { inline namespace __1 {



using ::mbstate_t;
using ::size_t;
using ::tm;
using ::wint_t;
using ::FILE;
using ::fwprintf;
using ::fwscanf;
using ::swprintf;
using ::vfwprintf;
using ::vswprintf;
using ::swscanf;
using ::vfwscanf;
using ::vswscanf;
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::getwc;
using ::putwc;
using ::ungetwc;
using ::wcstod;
using ::wcstof;
using ::wcstold;
using ::wcstol;

using ::wcstoll;

using ::wcstoul;

using ::wcstoull;

using ::wcscpy;
using ::wcsncpy;
using ::wcscat;
using ::wcsncat;
using ::wcscmp;
using ::wcscoll;
using ::wcsncmp;
using ::wcsxfrm;
using ::wcschr;
using ::wcspbrk;
using ::wcsrchr;
using ::wcsstr;
using ::wmemchr;
using ::wcscspn;
using ::wcslen;
using ::wcsspn;
using ::wcstok;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wcsftime;
using ::btowc;
using ::wctob;
using ::mbsinit;
using ::mbrlen;
using ::mbrtowc;
using ::wcrtomb;
using ::mbsrtowcs;
using ::wcsrtombs;


using ::getwchar;
using ::vwscanf;
using ::wscanf;



using ::putwchar;
using ::vwprintf;
using ::wprintf;
} }





namespace std { inline namespace __1 {



template &lt;class _StateT&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) fpos
{
private:
    <span class="ge">_StateT __st_</span>;
    streamoff __off_;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) fpos(streamoff <span class="gs">__off = streamoff()) : __</span>st_(), __off_(__off) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) operator streamoff() const {return __off_;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) <span class="ge">_StateT state() const {return __st_</span>;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void state(_StateT <span class="gs">__st) {__</span>st_ = __st;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) fpos&amp; operator+=(streamoff <span class="gs">__off) {__</span>off_ += __off; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) fpos operator+ (streamoff <span class="gs">__off) const {fpos __</span>t(*this); <span class="gs">__t += __</span>off; return __t;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) fpos&amp; operator-=(streamoff <span class="gs">__off) {__</span>off_ -= __off; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) fpos operator- (streamoff <span class="gs">__off) const {fpos __</span>t(*this); <span class="gs">__t -= __</span>off; return __t;}
};

template &lt;class _StateT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
streamoff operator-(const fpos&lt;_StateT&gt;&amp; __x, const fpos&lt;_StateT&gt;&amp; __y)
    {return streamoff(__x) - streamoff(__y);}

template &lt;class _StateT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator==(const fpos&lt;_StateT&gt;&amp; __x, const fpos&lt;_StateT&gt;&amp; __y)
    {return streamoff(__x) == streamoff(__y);}

template &lt;class _StateT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool operator!=(const fpos&lt;_StateT&gt;&amp; __x, const fpos&lt;_StateT&gt;&amp; __y)
    {return streamoff(__x) != streamoff(__y);}



template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;
operator+(const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __x,
          const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __y);

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;
operator+(const <span class="ge">_CharT* __x, const basic_</span>string&lt;_CharT,_Traits,_Allocator&gt;&amp; __y);

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;
operator+(_CharT __x, const basic_string&lt;_CharT,_Traits,_Allocator&gt;&amp; __y);

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;
operator+(const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __x, const <span class="ge">_CharT* _</span>_y);

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;
operator+(const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __x, <span class="ge">_CharT _</span>_y);

extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) string operator+&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt;(char const*, string const&amp;);

template &lt;bool&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) __basic_string_common
{
protected:
    <span class="gs">__attribute__</span> ((noreturn)) void __throw_length_error() const;
    <span class="gs">__attribute__</span> ((noreturn)) void __throw_out_of_range() const;
};

template &lt;bool __b&gt;
void
__basic_string_common&lt;__b&gt;::__throw_length_error() const
{
    std::__1::__throw_length_error(&quot;basic_string&quot;);
}

template &lt;bool __b&gt;
void
__basic_string_common&lt;__b&gt;::__throw_out_of_range() const
{
    std::__1::__throw_out_of_range(&quot;basic_string&quot;);
}

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __basic_string_common&lt;true&gt;;





template &lt;class _Iter&gt;
struct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};
template &lt;class _Iter&gt;
struct __libcpp_string_gets_noexcept_iterator
    : public integral_constant&lt;bool,(__libcpp_is_trivial_iterator&lt;_Iter&gt;::value || __libcpp_string_gets_noexcept_iterator_impl&lt;_Iter&gt;::value)&gt; {};

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Tp&gt;
struct __can_be_converted_to_string_view : public integral_constant&lt;bool,(( is_convertible&lt;const <span class="ge">_Tp&amp;, basic_</span>string_view&lt;_CharT, <span class="ge">_Traits&gt; &gt;::value &amp;&amp; !is_</span>convertible&lt;const <span class="ge">_Tp&amp;, const _</span>CharT*&gt;::value))&gt; {};
template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_string
    : private __basic_string_common&lt;true&gt;
{
public:
    typedef basic_string __self;
    typedef basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; __self_</span>view;
    typedef <span class="ge">_Traits traits_</span>type;
    typedef <span class="ge">_CharT value_</span>type;
    typedef <span class="ge">_Allocator allocator_</span>type;
    typedef allocator_traits&lt;allocator_type&gt; __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef value_type&amp; reference;
    typedef const value_type&amp; const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    <span class="ge">_Static_</span>assert((!is_array&lt;value_type&gt;::value), &quot;Character type of basic_string must not be an array&quot;);
    <span class="ge">_Static_</span>assert(( is_standard_layout&lt;value_type&gt;::value), &quot;Character type of basic_string must be standard-layout&quot;);
    <span class="ge">_Static_</span>assert(( is_trivial&lt;value_type&gt;::value), &quot;Character type of basic_string must be trivial&quot;);
    <span class="ge">_Static_</span>assert(( is_same&lt;_CharT, typename traits_type::char_type&gt;::value), &quot;traits_type::char_type must be the same type as CharT&quot;);

    <span class="ge">_Static_</span>assert(( is_same&lt;typename allocator_type::value_type, value_type&gt;::value), &quot;Allocator::value_type must be same type as value_type&quot;);






    typedef __wrap_iter&lt;pointer&gt; iterator;
    typedef __wrap_iter&lt;const_pointer&gt; const_iterator;

    typedef std::__1::reverse_iterator&lt;iterator&gt; reverse_iterator;
    typedef std::__1::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;

private:
    struct __long
    {
        size_type __cap_;
        size_type __size_;
        pointer __data_;
    };





    static const size_type __short_mask = 0x01;
    static const size_type __long_mask = 0x1ul;


    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) &gt; 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        union
        {
            unsigned char __size_;
            value_type __lx;
        };
        value_type __data_[__min_cap];
    };



    union <span class="gs">__ulx{__</span>long <span class="gs">__lx; __</span>short __lxx;};

    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};

    struct __raw
    {
        size_type <span class="gs">__words[__</span>n_words];
    };

    struct __rep
    {
        union
        {
            <span class="gs">__long __</span>l;
            <span class="gs">__short __</span>s;
            <span class="gs">__raw __</span>r;
        };
    };

    __compressed_pair&lt;__rep, allocator_type&gt; __r_;

public:
    static const size_type npos = -1;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) basic_string()
                                                                           ;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit basic_string(const allocator_type&amp; __a)

                                                                        ;




    basic_string(const basic_string&amp; __str);
    basic_string(const basic_string&amp; __str, const allocator_type&amp; __a);
    template &lt;class = typename enable_if&lt;__is_allocator&lt;_Allocator&gt;::value, nullptr_t&gt;::type&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string(const <span class="ge">_CharT* __s) : __r_</span>(__default_init_tag(), __default_init_tag()) {
      ((void)0);
      <span class="gs">__init(__</span>s, traits_type::length(__s));



    }

    template &lt;class = typename enable_if&lt;__is_allocator&lt;_Allocator&gt;::value, nullptr_t&gt;::type&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        basic_string(const <span class="ge">_CharT* __s, const _</span>Allocator&amp; __a);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string(const <span class="ge">_CharT* __s, size_</span>type __n);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string(const <span class="ge">_CharT* __s, size_</span>type __n, const <span class="ge">_Allocator&amp; _</span>_a);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string(size_type __n, <span class="ge">_CharT _</span>_c);

    template &lt;class = typename enable_if&lt;__is_allocator&lt;_Allocator&gt;::value, nullptr_t&gt;::type&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        basic_string(size_type __n, <span class="ge">_CharT __c, const _</span>Allocator&amp; __a);

    basic_string(const basic_string&amp; __str, size_type __pos, size_type __n,
                 const <span class="ge">_Allocator&amp; __a = _</span>Allocator());
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string(const basic_string&amp; __str, size_type __pos,
                 const <span class="ge">_Allocator&amp; __a = _</span>Allocator());

    template&lt;class <span class="ge">_Tp, class = typename enable_</span>if&lt;__can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value, void&gt;::type&gt;
        inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
        basic_string(const <span class="ge">_Tp&amp; __t, size_</span>type __pos, size_type __n,
                              const allocator_type&amp; __a = allocator_type());

    template&lt;class <span class="ge">_Tp, class = typename enable_</span>if&lt;__can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value, void&gt;::type&gt;
        inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
        explicit basic_string(const <span class="ge">_Tp&amp; _</span>_t);

    template&lt;class <span class="ge">_Tp, class = typename enable_</span>if&lt;__can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value, void&gt;::type&gt;
        inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
        explicit basic_string(const <span class="ge">_Tp&amp; __t, const allocator_</span>type&amp; __a);

    template&lt;class <span class="ge">_InputIterator, class = typename enable_</span>if&lt;__is_cpp17_input_iterator&lt;_InputIterator&gt;::value&gt;::type&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        basic_string(_InputIterator __first, <span class="ge">_InputIterator _</span>_last);
    template&lt;class <span class="ge">_InputIterator, class = typename enable_</span>if&lt;__is_cpp17_input_iterator&lt;_InputIterator&gt;::value&gt;::type&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        basic_string(_InputIterator __first, <span class="ge">_InputIterator __last, const allocator_</span>type&amp; __a);







    inline ~basic_string();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    operator __self_view() const throw() { return __self_view(data(), size()); }

    basic_string&amp; operator=(const basic_string&amp; __str);

    template &lt;class <span class="ge">_Tp, class = typename enable_</span>if&lt;__can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value, void&gt;::type&gt;
    basic_string&amp; operator=(const <span class="ge">_Tp&amp; _</span>_t)
        {__self_view <span class="gs">__sv = __</span>t; return assign(__sv);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) basic_string&amp; operator=(const value_type* <span class="gs">__s) {return assign(__</span>s);}
    basic_string&amp; operator=(value_type __c);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iterator begin() throw()
        {return iterator(__get_pointer());}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_iterator begin() const throw()
        {return const_iterator(__get_pointer());}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iterator end() throw()
        {return iterator(__get_pointer() + size());}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_iterator end() const throw()
        {return const_iterator(__get_pointer() + size());}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reverse_iterator rbegin() throw()
        {return reverse_iterator(end());}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_reverse_iterator rbegin() const throw()
        {return const_reverse_iterator(end());}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    reverse_iterator rend() throw()
        {return reverse_iterator(begin());}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_reverse_iterator rend() const throw()
        {return const_reverse_iterator(begin());}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_iterator cbegin() const throw()
        {return begin();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_iterator cend() const throw()
        {return end();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_reverse_iterator crbegin() const throw()
        {return rbegin();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_reverse_iterator crend() const throw()
        {return rend();}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) size_type size() const throw()
        {return __is_long() ? __get_long_size() : __get_short_size();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) size_type length() const throw() {return size();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) size_type max_size() const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) size_type capacity() const throw()
        {return (__is_long() ? __get_long_cap()
                             : static_cast&lt;size_type&gt;(__min_cap)) - 1;}

    void resize(size_type __n, value_type __c);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void resize(size_type <span class="gs">__n) {resize(__</span>n, value_type());}

    void reserve(size_type __res_arg);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __resize_default_init(size_type __n);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void reserve() throw() {reserve(0);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void shrink_to_fit() throw() {reserve();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void clear() throw();
                                  <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool empty() const throw() {return size() == 0;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) const_reference operator[](size_type __pos) const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) reference operator[](size_type __pos) throw();

    const_reference at(size_type __n) const;
    reference at(size_type __n);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) basic_string&amp; operator+=(const basic_string&amp; <span class="gs">__str) {return append(__</span>str);}

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            basic_string&amp;
        &gt;::type
                                            operator+=(const <span class="ge">_Tp&amp; __t) {__self_</span>view <span class="gs">__sv = __</span>t; return append(__sv);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) basic_string&amp; operator+=(const value_type* <span class="gs">__s) {return append(__</span>s);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) basic_string&amp; operator+=(value_type __c) {push_back(__c); return *this;}




    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string&amp; append(const basic_string&amp; __str);

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            basic_string&amp;
        &gt;::type
                  append(const <span class="ge">_Tp&amp; __t) { __self_</span>view <span class="gs">__sv = __</span>t; return append(__sv.data(), __sv.size()); }
    basic_string&amp; append(const basic_string&amp; __str, size_type __pos, size_type __n=npos);

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            basic_string&amp;
        &gt;::type
                  append(const <span class="ge">_Tp&amp; __t, size_</span>type __pos, size_type __n=npos);
    basic_string&amp; append(const value_type* __s, size_type __n);
    basic_string&amp; append(const value_type* __s);
    basic_string&amp; append(size_type __n, value_type __c);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __append_default_init(size_type __n);

    template &lt;class _ForwardIterator&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    basic_string&amp; __append_forward_unsafe(_ForwardIterator, _ForwardIterator);
    template&lt;class _InputIterator&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __is_exactly_cpp17_input_iterator&lt;_InputIterator&gt;::value
                || !__libcpp_string_gets_noexcept_iterator&lt;_InputIterator&gt;::value,
            basic_string&amp;
        &gt;::type
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    append(_InputIterator __first, <span class="ge">_InputIterator _</span>_last) {
      const basic_string <span class="gs">__temp (__</span>first, <span class="gs">__last, __</span>alloc());
      append(__temp.data(), __temp.size());
      return *this;
    }
    template&lt;class _ForwardIterator&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __is_cpp17_forward_iterator&lt;_ForwardIterator&gt;::value
                &amp;&amp; __libcpp_string_gets_noexcept_iterator&lt;_ForwardIterator&gt;::value,
            basic_string&amp;
        &gt;::type
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    append(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last) {
      return __append_forward_unsafe(__first, __last);
    }






    void push_back(value_type __c);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void pop_back();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) reference front() throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) const_reference front() const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) reference back() throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) const_reference back() const throw();

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            basic_string&amp;
        &gt;::type
                 assign(const <span class="ge">_Tp &amp; __t) { __self_</span>view <span class="gs">__sv = __</span>t; return assign(__sv.data(), __sv.size()); }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string&amp; assign(const basic_string&amp; <span class="gs">__str) { return *this = __</span>str; }






    basic_string&amp; assign(const basic_string&amp; __str, size_type __pos, size_type __n=npos);
    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            basic_string&amp;
        &gt;::type
                  assign(const <span class="ge">_Tp &amp; __t, size_</span>type __pos, size_type __n=npos);
    basic_string&amp; assign(const value_type* __s, size_type __n);
    basic_string&amp; assign(const value_type* __s);
    basic_string&amp; assign(size_type __n, value_type __c);
    template&lt;class _InputIterator&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
           __is_exactly_cpp17_input_iterator&lt;_InputIterator&gt;::value
                || !__libcpp_string_gets_noexcept_iterator&lt;_InputIterator&gt;::value,
            basic_string&amp;
        &gt;::type
        assign(_InputIterator __first, <span class="ge">_InputIterator _</span>_last);
    template&lt;class _ForwardIterator&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __is_cpp17_forward_iterator&lt;_ForwardIterator&gt;::value
                 &amp;&amp; __libcpp_string_gets_noexcept_iterator&lt;_ForwardIterator&gt;::value,
            basic_string&amp;
        &gt;::type
        assign(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last);





    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string&amp; insert(size_type __pos1, const basic_string&amp; __str);

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            basic_string&amp;
        &gt;::type
                 insert(size_type __pos1, const <span class="ge">_Tp&amp; _</span>_t)
    { __self_view <span class="gs">__sv = __</span>t; return insert(__pos1, <span class="gs">__sv.data(), __</span>sv.size()); }

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            basic_string&amp;
        &gt;::type
                  insert(size_type __pos1, const <span class="ge">_Tp&amp; __t, size_</span>type __pos2, size_type __n=npos);
    basic_string&amp; insert(size_type __pos1, const basic_string&amp; __str, size_type __pos2, size_type __n=npos);
    basic_string&amp; insert(size_type __pos, const value_type* __s, size_type __n);
    basic_string&amp; insert(size_type __pos, const value_type* __s);
    basic_string&amp; insert(size_type __pos, size_type __n, value_type __c);
    iterator insert(const_iterator __pos, value_type __c);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iterator insert(const_iterator __pos, size_type __n, value_type __c);
    template&lt;class _InputIterator&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
           __is_exactly_cpp17_input_iterator&lt;_InputIterator&gt;::value
                || !__libcpp_string_gets_noexcept_iterator&lt;_InputIterator&gt;::value,
            iterator
        &gt;::type
        insert(const_iterator __pos, <span class="ge">_InputIterator __first, _</span>InputIterator __last);
    template&lt;class _ForwardIterator&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __is_cpp17_forward_iterator&lt;_ForwardIterator&gt;::value
                 &amp;&amp; __libcpp_string_gets_noexcept_iterator&lt;_ForwardIterator&gt;::value,
            iterator
        &gt;::type
        insert(const_iterator __pos, <span class="ge">_ForwardIterator __first, _</span>ForwardIterator __last);






    basic_string&amp; erase(size_type __pos = 0, size_type __n = npos);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iterator erase(const_iterator __pos);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iterator erase(const_iterator __first, const_iterator __last);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string&amp; replace(size_type __pos1, size_type __n1, const basic_string&amp; __str);

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            basic_string&amp;
        &gt;::type
                  replace(size_type __pos1, size_type __n1, const <span class="ge">_Tp&amp; __t) { __self_</span>view <span class="gs">__sv = __</span>t; return replace(__pos1, <span class="gs">__n1, __</span>sv.data(), __sv.size()); }
    basic_string&amp; replace(size_type __pos1, size_type __n1, const basic_string&amp; __str, size_type __pos2, size_type __n2=npos);
    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            basic_string&amp;
        &gt;::type
                  replace(size_type __pos1, size_type __n1, const <span class="ge">_Tp&amp; __t, size_</span>type __pos2, size_type __n2=npos);
    basic_string&amp; replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
    basic_string&amp; replace(size_type __pos, size_type __n1, const value_type* __s);
    basic_string&amp; replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string&amp; replace(const_iterator __i1, const_iterator __i2, const basic_string&amp; __str);

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            basic_string&amp;
        &gt;::type
                  replace(const_iterator __i1, const_iterator __i2, const <span class="ge">_Tp&amp; __t) { __self_</span>view <span class="gs">__sv = __</span>t; return replace(__i1 - begin(), <span class="gs">__i2 - __</span>i1, __sv); }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string&amp; replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string&amp; replace(const_iterator __i1, const_iterator __i2, const value_type* __s);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string&amp; replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
    template&lt;class _InputIterator&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __is_cpp17_input_iterator&lt;_InputIterator&gt;::value,
            basic_string&amp;
        &gt;::type
        replace(const_iterator __i1, const_iterator __i2, <span class="ge">_InputIterator __j1, _</span>InputIterator __j2);






    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string substr(size_type __pos = 0, size_type __n = npos) const;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void swap(basic_string&amp; __str)




                                                                  ;


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const value_type* c_str() const throw() {return data();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const value_type* data() const throw() {return std::__1::__to_address(__get_pointer());}





    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    allocator_type get_allocator() const throw() {return __alloc();}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find(const basic_string&amp; __str, size_type __pos = 0) const throw();

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            size_type
        &gt;::type
              find(const <span class="ge">_Tp&amp; __t, size_</span>type __pos = 0) const;
    size_type find(const value_type* __s, size_type __pos, size_type __n) const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find(const value_type* __s, size_type __pos = 0) const throw();
    size_type find(value_type __c, size_type __pos = 0) const throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type rfind(const basic_string&amp; __str, size_type __pos = npos) const throw();

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            size_type
        &gt;::type
              rfind(const <span class="ge">_Tp&amp; __t, size_</span>type __pos = npos) const;
    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type rfind(const value_type* __s, size_type __pos = npos) const throw();
    size_type rfind(value_type __c, size_type __pos = npos) const throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_first_of(const basic_string&amp; __str, size_type __pos = 0) const throw();

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            size_type
        &gt;::type
              find_first_of(const <span class="ge">_Tp&amp; __t, size_</span>type __pos = 0) const;
    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_first_of(const value_type* __s, size_type __pos = 0) const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_first_of(value_type __c, size_type __pos = 0) const throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_last_of(const basic_string&amp; __str, size_type __pos = npos) const throw();

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            size_type
        &gt;::type
              find_last_of(const <span class="ge">_Tp&amp; __t, size_</span>type __pos = npos) const;
    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_last_of(const value_type* __s, size_type __pos = npos) const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_last_of(value_type __c, size_type __pos = npos) const throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_first_not_of(const basic_string&amp; __str, size_type __pos = 0) const throw();

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            size_type
        &gt;::type
              find_first_not_of(const <span class="ge">_Tp &amp;__t, size_</span>type __pos = 0) const;
    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_first_not_of(value_type __c, size_type __pos = 0) const throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_last_not_of(const basic_string&amp; __str, size_type __pos = npos) const throw();

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            size_type
        &gt;::type
              find_last_not_of(const <span class="ge">_Tp&amp; __t, size_</span>type __pos = npos) const;
    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type find_last_not_of(value_type __c, size_type __pos = npos) const throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int compare(const basic_string&amp; __str) const throw();

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            int
        &gt;::type
        compare(const <span class="ge">_Tp &amp;_</span>_t) const;

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            int
        &gt;::type
         compare(size_type __pos1, size_type __n1, const <span class="ge">_Tp&amp; _</span>_t) const;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int compare(size_type __pos1, size_type __n1, const basic_string&amp; __str) const;
    int compare(size_type __pos1, size_type __n1, const basic_string&amp; __str, size_type __pos2, size_type __n2=npos) const;

    template &lt;class _Tp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        typename enable_if
        &lt;
            __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
            int
        &gt;::type
        compare(size_type __pos1, size_type __n1, const <span class="ge">_Tp&amp; __t, size_</span>type __pos2, size_type __n2=npos) const;
    int compare(const value_type* __s) const throw();
    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool __invariants() const;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __clear_and_shrink() throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool __is_long() const throw()
        {return bool(__r_.first().__s.__size_ &amp; __short_mask);}
private:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    allocator_type&amp; __alloc() throw()
        {return __r_.second();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const allocator_type&amp; __alloc() const throw()
        {return __r_.second();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __set_short_size(size_type __s) throw()



        {__r_.first().__s.__size_ = (unsigned char)(__s &lt;&lt; 1);}


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type __get_short_size() const throw()



        {return __r_.first().__s.__size_ &gt;&gt; 1;}




    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __set_long_size(size_type __s) throw()
        {__r_.first().__l.__size_ = __s;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type __get_long_size() const throw()
        {return __r_.first().__l.__size_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __set_size(size_type __s) throw()
        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __set_long_cap(size_type __s) throw()
        {__r_.first().__l.__cap_ = __long_mask | __s;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type __get_long_cap() const throw()
        {return __r_.first().__l.__cap_ &amp; size_type(~__long_mask);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __set_long_pointer(pointer __p) throw()
        {__r_.first().__l.__data_ = __p;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pointer __get_long_pointer() throw()
        {return __r_.first().__l.__data_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_pointer __get_long_pointer() const throw()
        {return __r_.first().__l.__data_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pointer __get_short_pointer() throw()
        {return pointer_traits&lt;pointer&gt;::pointer_to(__r_.first().__s.__data_[0]);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_pointer __get_short_pointer() const throw()
        {return pointer_traits&lt;const_pointer&gt;::pointer_to(__r_.first().__s.__data_[0]);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pointer __get_pointer() throw()
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const_pointer __get_pointer() const throw()
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __zero() throw()
        {
            size_type (&amp;__a)[__n_words] = __r_.first().__r.__words;
            for (unsigned <span class="gs">__i = 0; __</span>i &lt; __n_words; ++__i)
                <span class="gs">__a[__</span>i] = 0;
        }

    template &lt;size_type __a&gt; static
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        size_type __align_it(size_type __s) throw()
            {return (<span class="gs">__s + (__</span>a-1)) &amp; ~(__a-1);}
    enum {__alignment = 16};
    static <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_type __recommend(size_type __s) throw()
        {
        if (<span class="gs">__s &lt; __</span>min_cap) return static_cast&lt;size_type&gt;(__min_cap) - 1;
        size_type <span class="gs">__guess = __</span>align_it&lt;sizeof(value_type) &lt; __alignment ?
                     __alignment/sizeof(value_type) : 1 &gt; (__s+1) - 1;
        if (<span class="gs">__guess == __</span>min_cap) ++__guess;
        return __guess;
        }

    inline
    void __init(const value_type* __s, size_type __sz, size_type __reserve);
    inline
    void __init(const value_type* __s, size_type __sz);
    inline
    void __init(size_type __n, value_type __c);

    template &lt;class _InputIterator&gt;
    inline
    typename enable_if
    &lt;
        __is_exactly_cpp17_input_iterator&lt;_InputIterator&gt;::value,
        void
    &gt;::type
    __init(_InputIterator __first, <span class="ge">_InputIterator _</span>_last);

    template &lt;class _ForwardIterator&gt;
    inline
    typename enable_if
    &lt;
        __is_cpp17_forward_iterator&lt;_ForwardIterator&gt;::value,
        void
    &gt;::type
    __init(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last);

    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                   size_type __n_copy, size_type __n_del, size_type __n_add = 0);
    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                               size_type __n_copy, size_type __n_del,
                               size_type __n_add, const value_type* __p_new_stuff);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __erase_to_end(size_type __pos);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __copy_assign_alloc(const basic_string&amp; __str)
        {__copy_assign_alloc(__str, integral_constant&lt;bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value&gt;());}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __copy_assign_alloc(const basic_string&amp; __str, true_type)
        {
            if (<span class="gs">__alloc() == __</span>str.__alloc())
                <span class="gs">__alloc() = __</span>str.__alloc();
            else
            {
                if (!__str.__is_long())
                {
                    __clear_and_shrink();
                    <span class="gs">__alloc() = __</span>str.__alloc();
                }
                else
                {
                    allocator_type <span class="gs">__a = __</span>str.__alloc();
                    pointer <span class="gs">__p = __</span>alloc_traits::allocate(__a, <span class="gs">__str.__</span>get_long_cap());
                    __clear_and_shrink();
                    <span class="gs">__alloc() = std::__</span>1::move(__a);
                    __set_long_pointer(__p);
                    __set_long_cap(__str.__get_long_cap());
                    __set_long_size(__str.size());
                }
            }
        }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __copy_assign_alloc(const basic_string&amp;, false_type) throw()
        {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void
    __move_assign_alloc(basic_string&amp; __str)



    {__move_assign_alloc(__str, integral_constant&lt;bool,
                      __alloc_traits::propagate_on_container_move_assignment::value&gt;());}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __move_assign_alloc(basic_string&amp; __c, true_type)

        {
            <span class="gs">__alloc() = std::__</span>1::move(__c.__alloc());
        }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __move_assign_alloc(basic_string&amp;, false_type)
        throw()
        {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __invalidate_all_iterators();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void __invalidate_iterators_past(size_type);

    friend basic_string operator+&lt;&gt;(const basic_string&amp;, const basic_string&amp;);
    friend basic_string operator+&lt;&gt;(const value_type*, const basic_string&amp;);
    friend basic_string operator+&lt;&gt;(value_type, const basic_string&amp;);
    friend basic_string operator+&lt;&gt;(const basic_string&amp;, const value_type*);
    friend basic_string operator+&lt;&gt;(const basic_string&amp;, value_type);
};
template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__invalidate_all_iterators()
{



}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__invalidate_iterators_past(size_type



                                                                      )
{
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string()

     : __r_(__default_init_tag(), __default_init_tag())
{



    __zero();
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(const allocator_type&amp; __a)





: __r_(__default_init_tag(), __a)
{



    __zero();
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
void basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__init(const value_type* __s,
                                                       size_type __sz,
                                                       size_type __reserve)
{
    if (__reserve &gt; max_size())
        this-&gt;__throw_length_error();
    pointer __p;
    if (<span class="gs">__reserve &lt; __</span>min_cap)
    {
        __set_short_size(__sz);
        <span class="gs">__p = __</span>get_short_pointer();
    }
    else
    {
        size_type <span class="gs">__cap = __</span>recommend(__reserve);
        <span class="gs">__p = __</span>alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_address(__p), <span class="gs">__s, __</span>sz);
    traits_type::assign(__p[__sz], value_type());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__init(const value_type* __s, size_type __sz)
{
    if (__sz &gt; max_size())
        this-&gt;__throw_length_error();
    pointer __p;
    if (<span class="gs">__sz &lt; __</span>min_cap)
    {
        __set_short_size(__sz);
        <span class="gs">__p = __</span>get_short_pointer();
    }
    else
    {
        size_type <span class="gs">__cap = __</span>recommend(__sz);
        <span class="gs">__p = __</span>alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_address(__p), <span class="gs">__s, __</span>sz);
    traits_type::assign(__p[__sz], value_type());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(const <span class="ge">_CharT* __s, const _</span>Allocator&amp; __a)
    : __r_(__default_init_tag(), __a)
{
    ((void)0);
    <span class="gs">__init(__</span>s, traits_type::length(__s));



}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(const <span class="ge">_CharT* __s, size_</span>type __n)
     : __r_(__default_init_tag(), __default_init_tag())
{
    ((void)0);
    <span class="gs">__init(__</span>s, __n);



}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(const <span class="ge">_CharT* __s, size_</span>type __n, const <span class="ge">_Allocator&amp; _</span>_a)
    : __r_(__default_init_tag(), __a)
{
    ((void)0);
    <span class="gs">__init(__</span>s, __n);



}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(const basic_string&amp; __str)
    : __r_(__default_init_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc()))
{
    if (!__str.__is_long())
        __r_.first().__r = <span class="gs">__str.__</span>r<span class="ge">_.first()._</span>_r;
    else
        <span class="gs">__init(std::__</span>1::__to_address(__str.__get_long_pointer()), <span class="gs">__str.__</span>get_long_size());



}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(
    const basic_string&amp; __str, const allocator_type&amp; __a)
    : __r_(__default_init_tag(), __a)
{
    if (!__str.__is_long())
        __r_.first().__r = <span class="gs">__str.__</span>r<span class="ge">_.first()._</span>_r;
    else
        <span class="gs">__init(std::__</span>1::__to_address(__str.__get_long_pointer()), <span class="gs">__str.__</span>get_long_size());



}
template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__init(size_type __n, value_type __c)
{
    if (__n &gt; max_size())
        this-&gt;__throw_length_error();
    pointer __p;
    if (<span class="gs">__n &lt; __</span>min_cap)
    {
        __set_short_size(__n);
        <span class="gs">__p = __</span>get_short_pointer();
    }
    else
    {
        size_type <span class="gs">__cap = __</span>recommend(__n);
        <span class="gs">__p = __</span>alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__n);
    }
    traits_type::assign(std::__1::__to_address(__p), <span class="gs">__n, __</span>c);
    traits_type::assign(__p[__n], value_type());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(size_type __n, <span class="ge">_CharT _</span>_c)
     : __r_(__default_init_tag(), __default_init_tag())
{
    <span class="gs">__init(__</span>n, __c);



}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(size_type __n, <span class="ge">_CharT __c, const _</span>Allocator&amp; __a)
    : __r_(__default_init_tag(), __a)
{
    <span class="gs">__init(__</span>n, __c);



}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(const basic_string&amp; __str,
                                                        size_type __pos, size_type __n,
                                                        const <span class="ge">_Allocator&amp; _</span>_a)
    : __r_(__default_init_tag(), __a)
{
    size_type __str_sz = __str.size();
    if (<span class="gs">__pos &gt; __</span>str_sz)
        this-&gt;__throw_out_of_range();
    <span class="gs">__init(__</span>str.data() + <span class="gs">__pos, std::__</span>1::min(__n, __str_sz - __pos));



}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(const basic_string&amp; __str, size_type __pos,
                                                        const <span class="ge">_Allocator&amp; _</span>_a)
    : __r_(__default_init_tag(), __a)
{
    size_type __str_sz = __str.size();
    if (<span class="gs">__pos &gt; __</span>str_sz)
        this-&gt;__throw_out_of_range();
    <span class="gs">__init(__</span>str.data() + <span class="gs">__pos, __</span>str_sz - __pos);



}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp, class&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(
             const <span class="ge">_Tp&amp; __t, size_</span>type __pos, size_type __n, const allocator_type&amp; __a)
    : __r_(__default_init_tag(), __a)
{
    __self_view <span class="gs">__sv0 = __</span>t;
    __self_view <span class="gs">__sv = __</span>sv0.substr(__pos, __n);
    <span class="gs">__init(__</span>sv.data(), __sv.size());



}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp, class&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(const <span class="ge">_Tp &amp; _</span>_t)
     : __r_(__default_init_tag(), __default_init_tag())
{
    __self_view <span class="gs">__sv = __</span>t;
    <span class="gs">__init(__</span>sv.data(), __sv.size());



}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp, class&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(const <span class="ge">_Tp &amp; __t, const _</span>Allocator&amp; __a)
    : __r_(__default_init_tag(), __a)
{
    __self_view <span class="gs">__sv = __</span>t;
    <span class="gs">__init(__</span>sv.data(), __sv.size());



}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _InputIterator&gt;
typename enable_if
&lt;
    __is_exactly_cpp17_input_iterator&lt;_InputIterator&gt;::value,
    void
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__init(_InputIterator __first, <span class="ge">_InputIterator _</span>_last)
{
    __zero();

    try
    {

    for (; <span class="gs">__first != __</span>last; ++__first)
        push_back(*__first);

    }
    catch (...)
    {
        if (__is_long())
            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
        throw;
    }

}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _ForwardIterator&gt;
typename enable_if
&lt;
    __is_cpp17_forward_iterator&lt;_ForwardIterator&gt;::value,
    void
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__init(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last)
{
    size_type __sz = static_cast&lt;size_type&gt;(std::__1::distance(__first, __last));
    if (__sz &gt; max_size())
        this-&gt;__throw_length_error();
    pointer __p;
    if (<span class="gs">__sz &lt; __</span>min_cap)
    {
        __set_short_size(__sz);
        <span class="gs">__p = __</span>get_short_pointer();
    }
    else
    {
        size_type <span class="gs">__cap = __</span>recommend(__sz);
        <span class="gs">__p = __</span>alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    for (; <span class="gs">__first != __</span>last; ++__first, (void) ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template&lt;class _InputIterator, class&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(_InputIterator __first, <span class="ge">_InputIterator _</span>_last)
     : __r_(__default_init_tag(), __default_init_tag())
{
    <span class="gs">__init(__</span>first, __last);



}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template&lt;class _InputIterator, class&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::basic_string(_InputIterator __first, <span class="ge">_InputIterator _</span>_last,
                                                        const allocator_type&amp; __a)
    : __r_(__default_init_tag(), __a)
{
    <span class="gs">__init(__</span>first, __last);



}
template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::~basic_string()
{



    if (__is_long())
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__grow_by_and_replace
    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,
     size_type __n_copy, size_type __n_del, size_type __n_add, const value_type* __p_new_stuff)
{
    size_type __ms = max_size();
    if (__delta_cap &gt; <span class="gs">__ms - __</span>old_cap - 1)
        this-&gt;__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type <span class="gs">__cap = __</span>old_cap &lt; <span class="gs">__ms / 2 - __</span>alignment ?
                          <span class="gs">__recommend(std::__</span>1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer <span class="gs">__p = __</span>alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_address(__p),
                          std::__1::__to_address(__old_p), __n_copy);
    if (__n_add != 0)
        traits_type::copy(std::__1::__to_address(__p) + __n_copy, __p_new_stuff, __n_add);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_address(__p) + __n_copy + __n_add,
                          std::__1::__to_address(__old_p) + __n_copy + __n_del, __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
    __old_sz = __n_copy + __n_add + __sec_cp_sz;
    __set_long_size(__old_sz);
    traits_type::assign(__p[__old_sz], value_type());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                                                     size_type __n_copy, size_type __n_del, size_type __n_add)
{
    size_type __ms = max_size();
    if (__delta_cap &gt; <span class="gs">__ms - __</span>old_cap)
        this-&gt;__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type <span class="gs">__cap = __</span>old_cap &lt; <span class="gs">__ms / 2 - __</span>alignment ?
                          <span class="gs">__recommend(std::__</span>1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer <span class="gs">__p = __</span>alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_address(__p),
                          std::__1::__to_address(__old_p), __n_copy);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_address(__p) + __n_copy + __n_add,
                          std::__1::__to_address(__old_p) + __n_copy + __n_del,
                          __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
}



template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::assign(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    if (<span class="gs">__cap &gt;= __</span>n)
    {
        value_type* <span class="gs">__p = std::__</span>1::__to_address(__get_pointer());
        traits_type::move(__p, <span class="gs">__s, __</span>n);
        traits_type::assign(__p[__n], value_type());
        __set_size(__n);
        __invalidate_iterators_past(__n);
    }
    else
    {
        size_type __sz = size();
        __grow_by_and_replace(__cap, <span class="gs">__n - __</span>cap, <span class="gs">__sz, 0, __</span>sz, <span class="gs">__n, __</span>s);
    }
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::assign(size_type __n, value_type __c)
{
    size_type __cap = capacity();
    if (<span class="gs">__cap &lt; __</span>n)
    {
        size_type __sz = size();
        __grow_by(__cap, <span class="gs">__n - __</span>cap, <span class="gs">__sz, 0, __</span>sz);
    }
    else
        __invalidate_iterators_past(__n);
    value_type* <span class="gs">__p = std::__</span>1::__to_address(__get_pointer());
    traits_type::assign(__p, <span class="gs">__n, __</span>c);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::operator=(value_type __c)
{
    pointer __p;
    if (__is_long())
    {
        <span class="gs">__p = __</span>get_long_pointer();
        __set_long_size(1);
    }
    else
    {
        <span class="gs">__p = __</span>get_short_pointer();
        __set_short_size(1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
    __invalidate_iterators_past(1);
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::operator=(const basic_string&amp; __str)
{
    if (this != &amp;__str)
    {
        __copy_assign_alloc(__str);
        return assign(__str.data(), __str.size());
    }
    return *this;
}
template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template&lt;class _InputIterator&gt;
typename enable_if
&lt;
     __is_exactly_cpp17_input_iterator &lt;_InputIterator&gt;::value
          || !__libcpp_string_gets_noexcept_iterator&lt;_InputIterator&gt;::value,
    basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::assign(_InputIterator __first, <span class="ge">_InputIterator _</span>_last)
{
    const basic_string <span class="gs">__temp(__</span>first, <span class="gs">__last, __</span>alloc());
    assign(__temp.data(), __temp.size());
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template&lt;class _ForwardIterator&gt;
typename enable_if
&lt;
    __is_cpp17_forward_iterator&lt;_ForwardIterator&gt;::value
         &amp;&amp; __libcpp_string_gets_noexcept_iterator&lt;_ForwardIterator&gt;::value,
    basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::assign(_ForwardIterator __first, <span class="ge">_ForwardIterator _</span>_last)
{
    size_type __n = static_cast&lt;size_type&gt;(std::__1::distance(__first, __last));
    size_type __cap = capacity();
    if (<span class="gs">__cap &lt; __</span>n)
    {
        size_type __sz = size();
        __grow_by(__cap, <span class="gs">__n - __</span>cap, <span class="gs">__sz, 0, __</span>sz);
    }
    else
        __invalidate_iterators_past(__n);
    pointer <span class="gs">__p = __</span>get_pointer();
    for (; <span class="gs">__first != __</span>last; ++__first, ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
    __set_size(__n);
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::assign(const basic_string&amp; __str, size_type __pos, size_type __n)
{
    size_type <span class="gs">__sz = __</span>str.size();
    if (<span class="gs">__pos &gt; __</span>sz)
        this-&gt;__throw_out_of_range();
    return assign(__str.data() + <span class="gs">__pos, std::__</span>1::min(__n, <span class="gs">__sz - __</span>pos));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp&gt;
typename enable_if
&lt;
    __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
    basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::assign(const <span class="ge">_Tp &amp; __t, size_</span>type __pos, size_type __n)
{
    __self_view <span class="gs">__sv = __</span>t;
    size_type <span class="gs">__sz = __</span>sv.size();
    if (<span class="gs">__pos &gt; __</span>sz)
        this-&gt;__throw_out_of_range();
    return assign(__sv.data() + <span class="gs">__pos, std::__</span>1::min(__n, <span class="gs">__sz - __</span>pos));
}


template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::assign(const value_type* __s)
{
    ((void)0);
    return assign(__s, traits_type::length(__s));
}



template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::append(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    size_type __sz = size();
    if (<span class="gs">__cap - __</span>sz &gt;= __n)
    {
        if (__n)
        {
            value_type* <span class="gs">__p = std::__</span>1::__to_address(__get_pointer());
            traits_type::copy(__p + <span class="gs">__sz, __</span>s, __n);
            <span class="gs">__sz += __</span>n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, <span class="gs">__sz + __</span>n - <span class="gs">__cap, __</span>sz, <span class="gs">__sz, 0, __</span>n, __s);
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::append(size_type __n, value_type __c)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (<span class="gs">__cap - __</span>sz &lt; __n)
            __grow_by(__cap, <span class="gs">__sz + __</span>n - <span class="gs">__cap, __</span>sz, __sz, 0);
        pointer <span class="gs">__p = __</span>get_pointer();
        traits_type::assign(std::__1::__to_address(__p) + <span class="gs">__sz, __</span>n, __c);
        <span class="gs">__sz += __</span>n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__append_default_init(size_type __n)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (<span class="gs">__cap - __</span>sz &lt; __n)
            __grow_by(__cap, <span class="gs">__sz + __</span>n - <span class="gs">__cap, __</span>sz, __sz, 0);
        pointer <span class="gs">__p = __</span>get_pointer();
        <span class="gs">__sz += __</span>n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::push_back(value_type __c)
{
    bool __is_short = !__is_long();
    size_type __cap;
    size_type __sz;
    if (__is_short)
    {
        <span class="gs">__cap = __</span>min_cap - 1;
        <span class="gs">__sz = __</span>get_short_size();
    }
    else
    {
        <span class="gs">__cap = __</span>get_long_cap() - 1;
        <span class="gs">__sz = __</span>get_long_size();
    }
    if (<span class="gs">__sz == __</span>cap)
    {
        __grow_by(__cap, 1, <span class="gs">__sz, __</span>sz, 0);
        __is_short = !__is_long();
    }
    pointer __p;
    if (__is_short)
    {
        <span class="gs">__p = __</span>get_short_pointer() + __sz;
        __set_short_size(__sz+1);
    }
    else
    {
        <span class="gs">__p = __</span>get_long_pointer() + __sz;
        __set_long_size(__sz+1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
}

template &lt;class _Tp&gt;
bool __ptr_in_range (const <span class="ge">_Tp* __p, const _</span>Tp* __first, const <span class="ge">_Tp* _</span>_last)
{
    return <span class="gs">__first &lt;= __</span>p &amp;&amp; <span class="gs">__p &lt; __</span>last;
}

template &lt;class <span class="ge">_Tp1, class _</span>Tp2&gt;
bool __ptr_in_range (const <span class="ge">_Tp1*, const _</span>Tp2*, const _Tp2*)
{
    return false;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template&lt;class _ForwardIterator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__append_forward_unsafe(
    <span class="ge">_ForwardIterator __first, _</span>ForwardIterator __last)
{
    <span class="ge">_Static_</span>assert(__is_cpp17_forward_iterator&lt;_ForwardIterator&gt;::value, &quot;function requires a ForwardIterator&quot;);

    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast&lt;size_type&gt;(std::__1::distance(__first, __last));
    if (__n)
    {
        typedef typename iterator_traits&lt;_ForwardIterator&gt;::reference _CharRef;
        <span class="ge">_CharRef __tmp_</span>ref = *__first;
        if (__ptr_in_range(std::__1::addressof(__tmp_ref), data(), data() + size()))
        {
            const basic_string <span class="gs">__temp (__</span>first, <span class="gs">__last, __</span>alloc());
            append(__temp.data(), __temp.size());
        }
        else
        {
            if (<span class="gs">__cap - __</span>sz &lt; __n)
                __grow_by(__cap, <span class="gs">__sz + __</span>n - <span class="gs">__cap, __</span>sz, __sz, 0);
            pointer <span class="gs">__p = __</span>get_pointer() + __sz;
            for (; <span class="gs">__first != __</span>last; ++__p, ++__first)
                traits_type::assign(*__p, *__first);
            traits_type::assign(*__p, value_type());
            __set_size(__sz + __n);
        }
    }
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::append(const basic_string&amp; __str)
{
    return append(__str.data(), __str.size());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::append(const basic_string&amp; __str, size_type __pos, size_type __n)
{
    size_type <span class="gs">__sz = __</span>str.size();
    if (<span class="gs">__pos &gt; __</span>sz)
        this-&gt;__throw_out_of_range();
    return append(__str.data() + <span class="gs">__pos, std::__</span>1::min(__n, <span class="gs">__sz - __</span>pos));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp&gt;
    typename enable_if
    &lt;
        __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
        basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
    &gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::append(const <span class="ge">_Tp &amp; __t, size_</span>type __pos, size_type __n)
{
    __self_view <span class="gs">__sv = __</span>t;
    size_type <span class="gs">__sz = __</span>sv.size();
    if (<span class="gs">__pos &gt; __</span>sz)
        this-&gt;__throw_out_of_range();
    return append(__sv.data() + <span class="gs">__pos, std::__</span>1::min(__n, <span class="gs">__sz - __</span>pos));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::append(const value_type* __s)
{
    ((void)0);
    return append(__s, traits_type::length(__s));
}



template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::insert(size_type __pos, const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __sz = size();
    if (<span class="gs">__pos &gt; __</span>sz)
        this-&gt;__throw_out_of_range();
    size_type __cap = capacity();
    if (<span class="gs">__cap - __</span>sz &gt;= __n)
    {
        if (__n)
        {
            value_type* <span class="gs">__p = std::__</span>1::__to_address(__get_pointer());
            size_type __n_move = <span class="gs">__sz - __</span>pos;
            if (__n_move != 0)
            {
                if (<span class="gs">__p + __</span>pos &lt;= <span class="gs">__s &amp;&amp; __</span>s &lt; <span class="gs">__p + __</span>sz)
                    <span class="gs">__s += __</span>n;
                traits_type::move(__p + <span class="gs">__pos + __</span>n, <span class="gs">__p + __</span>pos, __n_move);
            }
            traits_type::move(__p + <span class="gs">__pos, __</span>s, __n);
            <span class="gs">__sz += __</span>n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, <span class="gs">__sz + __</span>n - <span class="gs">__cap, __</span>sz, <span class="gs">__pos, 0, __</span>n, __s);
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::insert(size_type __pos, size_type __n, value_type __c)
{
    size_type __sz = size();
    if (<span class="gs">__pos &gt; __</span>sz)
        this-&gt;__throw_out_of_range();
    if (__n)
    {
        size_type __cap = capacity();
        value_type* __p;
        if (<span class="gs">__cap - __</span>sz &gt;= __n)
        {
            <span class="gs">__p = std::__</span>1::__to_address(__get_pointer());
            size_type __n_move = <span class="gs">__sz - __</span>pos;
            if (__n_move != 0)
                traits_type::move(__p + <span class="gs">__pos + __</span>n, <span class="gs">__p + __</span>pos, __n_move);
        }
        else
        {
            __grow_by(__cap, <span class="gs">__sz + __</span>n - <span class="gs">__cap, __</span>sz, <span class="gs">__pos, 0, __</span>n);
            <span class="gs">__p = std::__</span>1::__to_address(__get_long_pointer());
        }
        traits_type::assign(__p + <span class="gs">__pos, __</span>n, __c);
        <span class="gs">__sz += __</span>n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template&lt;class _InputIterator&gt;
typename enable_if
&lt;
   __is_exactly_cpp17_input_iterator&lt;_InputIterator&gt;::value
        || !__libcpp_string_gets_noexcept_iterator&lt;_InputIterator&gt;::value,
   typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::iterator
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::insert(const_iterator __pos, <span class="ge">_InputIterator __first, _</span>InputIterator __last)
{





    const basic_string <span class="gs">__temp(__</span>first, <span class="gs">__last, __</span>alloc());
    return insert(__pos, <span class="gs">__temp.data(), __</span>temp.data() + __temp.size());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template&lt;class _ForwardIterator&gt;
typename enable_if
&lt;
    __is_cpp17_forward_iterator&lt;_ForwardIterator&gt;::value
        &amp;&amp; __libcpp_string_gets_noexcept_iterator&lt;_ForwardIterator&gt;::value,
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::iterator
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::insert(const_iterator __pos, <span class="ge">_ForwardIterator __first, _</span>ForwardIterator __last)
{





    size_type __ip = static_cast&lt;size_type&gt;(__pos - begin());
    size_type __n = static_cast&lt;size_type&gt;(std::__1::distance(__first, __last));
    if (__n)
    {
        typedef typename iterator_traits&lt;_ForwardIterator&gt;::reference _CharRef;
        <span class="ge">_CharRef __tmp_</span>char = *__first;
        if (__ptr_in_range(std::__1::addressof(__tmp_char), data(), data() + size()))
        {
            const basic_string <span class="gs">__temp(__</span>first, <span class="gs">__last, __</span>alloc());
            return insert(__pos, <span class="gs">__temp.data(), __</span>temp.data() + __temp.size());
        }

        size_type __sz = size();
        size_type __cap = capacity();
        value_type* __p;
        if (<span class="gs">__cap - __</span>sz &gt;= __n)
        {
            <span class="gs">__p = std::__</span>1::__to_address(__get_pointer());
            size_type __n_move = <span class="gs">__sz - __</span>ip;
            if (__n_move != 0)
                traits_type::move(__p + <span class="gs">__ip + __</span>n, <span class="gs">__p + __</span>ip, __n_move);
        }
        else
        {
            __grow_by(__cap, <span class="gs">__sz + __</span>n - <span class="gs">__cap, __</span>sz, <span class="gs">__ip, 0, __</span>n);
            <span class="gs">__p = std::__</span>1::__to_address(__get_long_pointer());
        }
        <span class="gs">__sz += __</span>n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
        for (<span class="gs">__p += __</span>ip; <span class="gs">__first != __</span>last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);
    }
    return begin() + __ip;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::insert(size_type __pos1, const basic_string&amp; __str)
{
    return insert(__pos1, <span class="gs">__str.data(), __</span>str.size());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::insert(size_type __pos1, const basic_string&amp; __str,
                                                  size_type __pos2, size_type __n)
{
    size_type __str_sz = __str.size();
    if (<span class="gs">__pos2 &gt; __</span>str_sz)
        this-&gt;__throw_out_of_range();
    return insert(__pos1, <span class="gs">__str.data() + __</span>pos2, std::__1::min(__n, __str_sz - __pos2));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp&gt;
typename enable_if
&lt;
    __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
    basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::insert(size_type __pos1, const <span class="ge">_Tp&amp; _</span>_t,
                                                  size_type __pos2, size_type __n)
{
    __self_view <span class="gs">__sv = __</span>t;
    size_type __str_sz = __sv.size();
    if (<span class="gs">__pos2 &gt; __</span>str_sz)
        this-&gt;__throw_out_of_range();
    return insert(__pos1, <span class="gs">__sv.data() + __</span>pos2, std::__1::min(__n, __str_sz - __pos2));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::insert(size_type __pos, const value_type* __s)
{
    ((void)0);
    return insert(__pos, __s, traits_type::length(__s));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::iterator
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::insert(const_iterator __pos, value_type __c)
{
    size_type __ip = static_cast&lt;size_type&gt;(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    value_type* __p;
    if (<span class="gs">__cap == __</span>sz)
    {
        __grow_by(__cap, 1, <span class="gs">__sz, __</span>ip, 0, 1);
        <span class="gs">__p = std::__</span>1::__to_address(__get_long_pointer());
    }
    else
    {
        <span class="gs">__p = std::__</span>1::__to_address(__get_pointer());
        size_type __n_move = <span class="gs">__sz - __</span>ip;
        if (__n_move != 0)
            traits_type::move(__p + <span class="gs">__ip + 1, __</span>p + <span class="gs">__ip, __</span>n_move);
    }
    traits_type::assign(__p[__ip], __c);
    traits_type::assign(__p[++__sz], value_type());
    __set_size(__sz);
    return begin() + static_cast&lt;difference_type&gt;(__ip);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::iterator
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::insert(const_iterator __pos, size_type __n, value_type __c)
{





    difference_type <span class="gs">__p = __</span>pos - begin();
    insert(static_cast&lt;size_type&gt;(__p), <span class="gs">__n, __</span>c);
    return begin() + __p;
}



template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
    <span class="gs">__attribute__</span>((__no_sanitize__(&quot;unsigned-integer-overflow&quot;)))
{
    ((void)0);
    size_type __sz = size();
    if (<span class="gs">__pos &gt; __</span>sz)
        this-&gt;__throw_out_of_range();
    <span class="gs">__n1 = std::__</span>1::min(__n1, <span class="gs">__sz - __</span>pos);
    size_type __cap = capacity();
    if (<span class="gs">__cap - __</span>sz + <span class="gs">__n1 &gt;= __</span>n2)
    {
        value_type* <span class="gs">__p = std::__</span>1::__to_address(__get_pointer());
        if (<span class="gs">__n1 != __</span>n2)
        {
            size_type __n_move = <span class="gs">__sz - __</span>pos - __n1;
            if (__n_move != 0)
            {
                if (<span class="gs">__n1 &gt; __</span>n2)
                {
                    traits_type::move(__p + <span class="gs">__pos, __</span>s, __n2);
                    traits_type::move(__p + <span class="gs">__pos + __</span>n2, <span class="gs">__p + __</span>pos + <span class="gs">__n1, __</span>n_move);
                    goto __finish;
                }
                if (<span class="gs">__p + __</span>pos &lt; <span class="gs">__s &amp;&amp; __</span>s &lt; <span class="gs">__p + __</span>sz)
                {
                    if (<span class="gs">__p + __</span>pos + <span class="gs">__n1 &lt;= __</span>s)
                        <span class="gs">__s += __</span>n2 - __n1;
                    else
                    {
                        traits_type::move(__p + <span class="gs">__pos, __</span>s, __n1);
                        <span class="gs">__pos += __</span>n1;
                        <span class="gs">__s += __</span>n2;
                        <span class="gs">__n2 -= __</span>n1;
                        __n1 = 0;
                    }
                }
                traits_type::move(__p + <span class="gs">__pos + __</span>n2, <span class="gs">__p + __</span>pos + <span class="gs">__n1, __</span>n_move);
            }
        }
        traits_type::move(__p + <span class="gs">__pos, __</span>s, __n2);
__finish:


        <span class="gs">__sz += __</span>n2 - __n1;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    else
        __grow_by_and_replace(__cap, <span class="gs">__sz - __</span>n1 + <span class="gs">__n2 - __</span>cap, <span class="gs">__sz, __</span>pos, <span class="gs">__n1, __</span>n2, __s);
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)
    <span class="gs">__attribute__</span>((__no_sanitize__(&quot;unsigned-integer-overflow&quot;)))
{
    size_type __sz = size();
    if (<span class="gs">__pos &gt; __</span>sz)
        this-&gt;__throw_out_of_range();
    <span class="gs">__n1 = std::__</span>1::min(__n1, <span class="gs">__sz - __</span>pos);
    size_type __cap = capacity();
    value_type* __p;
    if (<span class="gs">__cap - __</span>sz + <span class="gs">__n1 &gt;= __</span>n2)
    {
        <span class="gs">__p = std::__</span>1::__to_address(__get_pointer());
        if (<span class="gs">__n1 != __</span>n2)
        {
            size_type __n_move = <span class="gs">__sz - __</span>pos - __n1;
            if (__n_move != 0)
                traits_type::move(__p + <span class="gs">__pos + __</span>n2, <span class="gs">__p + __</span>pos + <span class="gs">__n1, __</span>n_move);
        }
    }
    else
    {
        __grow_by(__cap, <span class="gs">__sz - __</span>n1 + <span class="gs">__n2 - __</span>cap, <span class="gs">__sz, __</span>pos, <span class="gs">__n1, __</span>n2);
        <span class="gs">__p = std::__</span>1::__to_address(__get_long_pointer());
    }
    traits_type::assign(__p + <span class="gs">__pos, __</span>n2, __c);
    <span class="gs">__sz += __</span>n2 - __n1;
    __set_size(__sz);
    __invalidate_iterators_past(__sz);
    traits_type::assign(__p[__sz], value_type());
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template&lt;class _InputIterator&gt;
typename enable_if
&lt;
    __is_cpp17_input_iterator&lt;_InputIterator&gt;::value,
    basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::replace(const_iterator __i1, const_iterator __i2,
                                                   <span class="ge">_InputIterator __j1, _</span>InputIterator __j2)
{
    const basic_string <span class="gs">__temp(__</span>j1, <span class="gs">__j2, __</span>alloc());
    return this-&gt;replace(__i1, <span class="gs">__i2, __</span>temp);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::replace(size_type __pos1, size_type __n1, const basic_string&amp; __str)
{
    return replace(__pos1, <span class="gs">__n1, __</span>str.data(), __str.size());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::replace(size_type __pos1, size_type __n1, const basic_string&amp; __str,
                                                   size_type __pos2, size_type __n2)
{
    size_type __str_sz = __str.size();
    if (<span class="gs">__pos2 &gt; __</span>str_sz)
        this-&gt;__throw_out_of_range();
    return replace(__pos1, <span class="gs">__n1, __</span>str.data() + <span class="gs">__pos2, std::__</span>1::min(__n2, __str_sz - __pos2));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp&gt;
typename enable_if
&lt;
    __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
    basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::replace(size_type __pos1, size_type __n1, const <span class="ge">_Tp&amp; _</span>_t,
                                                   size_type __pos2, size_type __n2)
{
    __self_view <span class="gs">__sv = __</span>t;
    size_type __str_sz = __sv.size();
    if (<span class="gs">__pos2 &gt; __</span>str_sz)
        this-&gt;__throw_out_of_range();
    return replace(__pos1, <span class="gs">__n1, __</span>sv.data() + <span class="gs">__pos2, std::__</span>1::min(__n2, __str_sz - __pos2));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::replace(size_type __pos, size_type __n1, const value_type* __s)
{
    ((void)0);
    return replace(__pos, <span class="gs">__n1, __</span>s, traits_type::length(__s));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::replace(const_iterator __i1, const_iterator __i2, const basic_string&amp; __str)
{
    return replace(static_cast&lt;size_type&gt;(__i1 - begin()), static_cast&lt;size_type&gt;(__i2 - __i1),
                   <span class="gs">__str.data(), __</span>str.size());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)
{
    return replace(static_cast&lt;size_type&gt;(__i1 - begin()), static_cast&lt;size_type&gt;(__i2 - <span class="gs">__i1), __</span>s, __n);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)
{
    return replace(static_cast&lt;size_type&gt;(__i1 - begin()), static_cast&lt;size_type&gt;(__i2 - <span class="gs">__i1), __</span>s);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)
{
    return replace(static_cast&lt;size_type&gt;(__i1 - begin()), static_cast&lt;size_type&gt;(__i2 - <span class="gs">__i1), __</span>n, __c);
}



template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::erase(size_type __pos, size_type __n)
{
    size_type __sz = size();
    if (<span class="gs">__pos &gt; __</span>sz)
        this-&gt;__throw_out_of_range();
    if (__n)
    {
        value_type* <span class="gs">__p = std::__</span>1::__to_address(__get_pointer());
        <span class="gs">__n = std::__</span>1::min(__n, <span class="gs">__sz - __</span>pos);
        size_type __n_move = <span class="gs">__sz - __</span>pos - __n;
        if (__n_move != 0)
            traits_type::move(__p + <span class="gs">__pos, __</span>p + <span class="gs">__pos + __</span>n, __n_move);
        <span class="gs">__sz -= __</span>n;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::iterator
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::erase(const_iterator __pos)
{





    ((void)0);

    iterator __b = begin();
    size_type __r = static_cast&lt;size_type&gt;(__pos - __b);
    erase(__r, 1);
    return __b + static_cast&lt;difference_type&gt;(__r);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::iterator
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::erase(const_iterator __first, const_iterator __last)
{





    ((void)0);
    iterator __b = begin();
    size_type __r = static_cast&lt;size_type&gt;(__first - __b);
    erase(__r, static_cast&lt;size_type&gt;(__last - __first));
    return __b + static_cast&lt;difference_type&gt;(__r);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::pop_back()
{
    ((void)0);
    size_type __sz;
    if (__is_long())
    {
        <span class="gs">__sz = __</span>get_long_size() - 1;
        __set_long_size(__sz);
        traits_type::assign(*(__get_long_pointer() + __sz), value_type());
    }
    else
    {
        <span class="gs">__sz = __</span>get_short_size() - 1;
        __set_short_size(__sz);
        traits_type::assign(*(__get_short_pointer() + __sz), value_type());
    }
    __invalidate_iterators_past(__sz);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::clear() throw()
{
    __invalidate_all_iterators();
    if (__is_long())
    {
        traits_type::assign(*__get_long_pointer(), value_type());
        __set_long_size(0);
    }
    else
    {
        traits_type::assign(*__get_short_pointer(), value_type());
        __set_short_size(0);
    }
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__erase_to_end(size_type __pos)
{
    if (__is_long())
    {
        traits_type::assign(*(__get_long_pointer() + __pos), value_type());
        __set_long_size(__pos);
    }
    else
    {
        traits_type::assign(*(__get_short_pointer() + __pos), value_type());
        __set_short_size(__pos);
    }
    __invalidate_iterators_past(__pos);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::resize(size_type __n, value_type __c)
{
    size_type __sz = size();
    if (<span class="gs">__n &gt; __</span>sz)
        append(__n - <span class="gs">__sz, __</span>c);
    else
        __erase_to_end(__n);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__resize_default_init(size_type __n)
{
    size_type __sz = size();
    if (<span class="gs">__n &gt; __</span>sz) {
       __append_default_init(__n - __sz);
    } else
        __erase_to_end(__n);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::max_size() const throw()
{
    size_type <span class="gs">__m = __</span>alloc_traits::max_size(__alloc());



    return <span class="gs">__m - __</span>alignment;

}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::reserve(size_type __res_arg)
{
    if (__res_arg &gt; max_size())
        this-&gt;__throw_length_error();
    size_type __cap = capacity();
    size_type __sz = size();
    __res_arg = std::__1::max(__res_arg, __sz);
    __res_arg = <span class="gs">__recommend(__</span>res_arg);
    if (__res_arg != __cap)
    {
        pointer __new_data, __p;
        bool __was_long, __now_long;
        if (__res_arg == __min_cap - 1)
        {
            __was_long = true;
            __now_long = false;
            __new_data = __get_short_pointer();
            <span class="gs">__p = __</span>get_long_pointer();
        }
        else
        {
            if (__res_arg &gt; __cap)
                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);
            else
            {

                try
                {

                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);

                }
                catch (...)
                {
                    return;
                }




            }
            __now_long = true;
            __was_long = __is_long();
            <span class="gs">__p = __</span>get_pointer();
        }
        traits_type::copy(std::__1::__to_address(__new_data),
                          std::__1::__to_address(__p), size()+1);
        if (__was_long)
            __alloc_traits::deallocate(__alloc(), <span class="gs">__p, __</span>cap+1);
        if (__now_long)
        {
            __set_long_cap(__res_arg+1);
            __set_long_size(__sz);
            __set_long_pointer(__new_data);
        }
        else
            __set_short_size(__sz);
        __invalidate_all_iterators();
    }
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::const_reference
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::operator[](size_type __pos) const throw()
{
    ((void)0);
    return *(data() + __pos);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::reference
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::operator[](size_type __pos) throw()
{
    ((void)0);
    return *(__get_pointer() + __pos);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::const_reference
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::at(size_type __n) const
{
    if (__n &gt;= size())
        this-&gt;__throw_out_of_range();
    return (*this)[__n];
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::reference
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::at(size_type __n)
{
    if (__n &gt;= size())
        this-&gt;__throw_out_of_range();
    return (*this)[__n];
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::reference
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::front() throw()
{
    ((void)0);
    return *__get_pointer();
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::const_reference
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::front() const throw()
{
    ((void)0);
    return *data();
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::reference
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::back() throw()
{
    ((void)0);
    return *(__get_pointer() + size() - 1);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::const_reference
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::back() const throw()
{
    ((void)0);
    return *(data() + size() - 1);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::copy(value_type* __s, size_type __n, size_type __pos) const
{
    size_type __sz = size();
    if (<span class="gs">__pos &gt; __</span>sz)
        this-&gt;__throw_out_of_range();
    size_type <span class="gs">__rlen = std::__</span>1::min(__n, <span class="gs">__sz - __</span>pos);
    traits_type::copy(__s, data() + <span class="gs">__pos, __</span>rlen);
    return __rlen;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::substr(size_type __pos, size_type __n) const
{
    return basic_string(*this, <span class="gs">__pos, __</span>n, __alloc());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::swap(basic_string&amp; __str)






{







    ((void)0);



    std::__1::swap(__r_.first(), <span class="gs">__str.__</span>r_.first());
    __swap_allocator(__alloc(), <span class="gs">__str.__</span>alloc());
}



template &lt;class _Traits&gt;
struct <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) __traits_eq
{
    typedef typename <span class="ge">_Traits::char_</span>type char_type;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const char_type&amp; __x, const char_type&amp; __y) throw()
        {return <span class="ge">_Traits::eq(__x, _</span>_y);}
};

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find(const value_type* __s,
                                                size_type __pos,
                                                size_type __n) const throw()
{
    ((void)0);
    return __str_find&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__s, __</span>pos, __n);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find(const basic_string&amp; __str,
                                                size_type __pos) const throw()
{
    return __str_find&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__str.data(), __</span>pos, __str.size());
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp&gt;
typename enable_if
&lt;
    __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find(const <span class="ge">_Tp &amp;_</span>_t,
                                                size_type __pos) const
{
    __self_view <span class="gs">__sv = __</span>t;
    return __str_find&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__sv.data(), __</span>pos, __sv.size());
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find(const value_type* __s,
                                                size_type __pos) const throw()
{
    ((void)0);
    return __str_find&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__s, __</span>pos, traits_type::length(__s));
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find(value_type __c,
                                                size_type __pos) const throw()
{
    return __str_find&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__c, __</span>pos);
}



template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::rfind(const value_type* __s,
                                                 size_type __pos,
                                                 size_type __n) const throw()
{
    ((void)0);
    return __str_rfind&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__s, __</span>pos, __n);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::rfind(const basic_string&amp; __str,
                                                 size_type __pos) const throw()
{
    return __str_rfind&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__str.data(), __</span>pos, __str.size());
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp&gt;
typename enable_if
&lt;
    __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::rfind(const <span class="ge">_Tp&amp; _</span>_t,
                                                size_type __pos) const
{
    __self_view <span class="gs">__sv = __</span>t;
    return __str_rfind&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__sv.data(), __</span>pos, __sv.size());
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::rfind(const value_type* __s,
                                                 size_type __pos) const throw()
{
    ((void)0);
    return __str_rfind&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__s, __</span>pos, traits_type::length(__s));
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::rfind(value_type __c,
                                                 size_type __pos) const throw()
{
    return __str_rfind&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__c, __</span>pos);
}



template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_first_of(const value_type* __s,
                                                         size_type __pos,
                                                         size_type __n) const throw()
{
    ((void)0);
    return __str_find_first_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__s, __</span>pos, __n);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_first_of(const basic_string&amp; __str,
                                                         size_type __pos) const throw()
{
    return __str_find_first_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__str.data(), __</span>pos, __str.size());
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp&gt;
typename enable_if
&lt;
    __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_first_of(const <span class="ge">_Tp&amp; _</span>_t,
                                                size_type __pos) const
{
    __self_view <span class="gs">__sv = __</span>t;
    return __str_find_first_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__sv.data(), __</span>pos, __sv.size());
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_first_of(const value_type* __s,
                                                         size_type __pos) const throw()
{
    ((void)0);
    return __str_find_first_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__s, __</span>pos, traits_type::length(__s));
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_first_of(value_type __c,
                                                         size_type __pos) const throw()
{
    return find(__c, __pos);
}



template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_last_of(const value_type* __s,
                                                        size_type __pos,
                                                        size_type __n) const throw()
{
    ((void)0);
    return __str_find_last_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__s, __</span>pos, __n);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_last_of(const basic_string&amp; __str,
                                                        size_type __pos) const throw()
{
    return __str_find_last_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__str.data(), __</span>pos, __str.size());
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp&gt;
typename enable_if
&lt;
    __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_last_of(const <span class="ge">_Tp&amp; _</span>_t,
                                                size_type __pos) const
{
    __self_view <span class="gs">__sv = __</span>t;
    return __str_find_last_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__sv.data(), __</span>pos, __sv.size());
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_last_of(const value_type* __s,
                                                        size_type __pos) const throw()
{
    ((void)0);
    return __str_find_last_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__s, __</span>pos, traits_type::length(__s));
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_last_of(value_type __c,
                                                        size_type __pos) const throw()
{
    return rfind(__c, __pos);
}



template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_first_not_of(const value_type* __s,
                                                             size_type __pos,
                                                             size_type __n) const throw()
{
    ((void)0);
    return __str_find_first_not_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__s, __</span>pos, __n);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_first_not_of(const basic_string&amp; __str,
                                                             size_type __pos) const throw()
{
    return __str_find_first_not_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__str.data(), __</span>pos, __str.size());
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp&gt;
typename enable_if
&lt;
    __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_first_not_of(const <span class="ge">_Tp&amp; _</span>_t,
                                                size_type __pos) const
{
    __self_view <span class="gs">__sv = __</span>t;
    return __str_find_first_not_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__sv.data(), __</span>pos, __sv.size());
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_first_not_of(const value_type* __s,
                                                             size_type __pos) const throw()
{
    ((void)0);
    return __str_find_first_not_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__s, __</span>pos, traits_type::length(__s));
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_first_not_of(value_type __c,
                                                             size_type __pos) const throw()
{
    return __str_find_first_not_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__c, __</span>pos);
}



template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_last_not_of(const value_type* __s,
                                                            size_type __pos,
                                                            size_type __n) const throw()
{
    ((void)0);
    return __str_find_last_not_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__s, __</span>pos, __n);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_last_not_of(const basic_string&amp; __str,
                                                            size_type __pos) const throw()
{
    return __str_find_last_not_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__str.data(), __</span>pos, __str.size());
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp&gt;
typename enable_if
&lt;
    __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_last_not_of(const <span class="ge">_Tp&amp; _</span>_t,
                                                size_type __pos) const
{
    __self_view <span class="gs">__sv = __</span>t;
    return __str_find_last_not_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__sv.data(), __</span>pos, __sv.size());
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_last_not_of(const value_type* __s,
                                                            size_type __pos) const throw()
{
    ((void)0);
    return __str_find_last_not_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__s, __</span>pos, traits_type::length(__s));
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::find_last_not_of(value_type __c,
                                                            size_type __pos) const throw()
{
    return __str_find_last_not_of&lt;value_type, size_type, traits_type, npos&gt;
        (data(), size(), <span class="gs">__c, __</span>pos);
}



template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp&gt;
typename enable_if
&lt;
    __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
    int
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::compare(const <span class="ge">_Tp&amp; _</span>_t) const
{
    __self_view <span class="gs">__sv = __</span>t;
    size_t __lhs_sz = size();
    size_t __rhs_sz = __sv.size();
    int __result = traits_type::compare(data(), __sv.data(),
                                        std::__1::min(__lhs_sz, __rhs_sz));
    if (__result != 0)
        return __result;
    if (__lhs_sz &lt; __rhs_sz)
        return -1;
    if (__lhs_sz &gt; __rhs_sz)
        return 1;
    return 0;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
int
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::compare(const basic_string&amp; __str) const throw()
{
    return compare(__self_view(__str));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
int
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s,
                                                   size_type __n2) const
{
    ((void)0);
    size_type __sz = size();
    if (<span class="gs">__pos1 &gt; __</span>sz || __n2 == npos)
        this-&gt;__throw_out_of_range();
    size_type <span class="gs">__rlen = std::__</span>1::min(__n1, <span class="gs">__sz - __</span>pos1);
    int __r = traits_type::compare(data() + <span class="gs">__pos1, __</span>s, std::__1::min(__rlen, __n2));
    if (__r == 0)
    {
        if (<span class="gs">__rlen &lt; __</span>n2)
            __r = -1;
        else if (<span class="gs">__rlen &gt; __</span>n2)
            __r = 1;
    }
    return __r;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp&gt;
typename enable_if
&lt;
    __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
    int
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const <span class="ge">_Tp&amp; _</span>_t) const
{
    __self_view <span class="gs">__sv = __</span>t;
    return compare(__pos1, <span class="gs">__n1, __</span>sv.data(), __sv.size());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
int
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string&amp; __str) const
{
    return compare(__pos1, <span class="gs">__n1, __</span>str.data(), __str.size());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
template &lt;class _Tp&gt;
typename enable_if
&lt;
    __can_be_converted_to_string_view&lt;_CharT, <span class="ge">_Traits, _</span>Tp&gt;::value,
    int
&gt;::type
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const <span class="ge">_Tp&amp; _</span>_t,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
    __self_view <span class="gs">__sv = __</span>t;
    return __self_view(*this).substr(__pos1, <span class="gs">__n1).compare(__</span>sv.substr(__pos2, __n2));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
int
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string&amp; __str,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
        return compare(__pos1, <span class="gs">__n1, __</span>self_view(__str), <span class="gs">__pos2, __</span>n2);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
int
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::compare(const value_type* __s) const throw()
{
    ((void)0);
    return compare(0, npos, __s, traits_type::length(__s));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
int
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s) const
{
    ((void)0);
    return compare(__pos1, <span class="gs">__n1, __</span>s, traits_type::length(__s));
}



template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
bool
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__invariants() const
{
    if (size() &gt; capacity())
        return false;
    if (capacity() &lt; __min_cap - 1)
        return false;
    if (data() == 0)
        return false;
    if (data()[size()] != value_type(0))
        return false;
    return true;
}



template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
void
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::__clear_and_shrink() throw()
{
    clear();
    if(__is_long())
    {
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), capacity() + 1);
        __set_long_cap(0);
        __set_short_size(0);
    }
}



template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __lhs,
           const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __rhs) throw()
{
    size_t __lhs_sz = __lhs.size();
    return __lhs_sz == __rhs.size() &amp;&amp; <span class="ge">_Traits::compare(_</span>_lhs.data(),
                                                        __rhs.data(),
                                                        __lhs_sz) == 0;
}

template&lt;class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const basic_string&lt;char, char_traits&lt;char&gt;, <span class="ge">_Allocator&gt;&amp; _</span>_lhs,
           const basic_string&lt;char, char_traits&lt;char&gt;, <span class="ge">_Allocator&gt;&amp; _</span>_rhs) throw()
{
    size_t __lhs_sz = __lhs.size();
    if (__lhs_sz != __rhs.size())
        return false;
    const char* <span class="gs">__lp = __</span>lhs.data();
    const char* <span class="gs">__rp = __</span>rhs.data();
    if (<span class="gs">__lhs.__</span>is_long())
        return char_traits&lt;char&gt;::compare(__lp, <span class="gs">__rp, __</span>lhs_sz) == 0;
    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
        if (<span class="ge">*__lp != *</span>__rp)
            return false;
    return true;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const <span class="ge">_CharT* _</span>_lhs,
           const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __rhs) throw()
{
    typedef basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt; _String;
    ((void)0);
    size_t __lhs_len = <span class="ge">_Traits::length(_</span>_lhs);
    if (__lhs_len != __rhs.size()) return false;
    return __rhs.compare(0, <span class="ge">_String::npos, __lhs, __lhs_</span>len) == 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const basic_string&lt;_CharT,_Traits,_Allocator&gt;&amp; __lhs,
           const <span class="ge">_CharT* _</span>_rhs) throw()
{
    typedef basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt; _String;
    ((void)0);
    size_t __rhs_len = <span class="ge">_Traits::length(_</span>_rhs);
    if (__rhs_len != __lhs.size()) return false;
    return __lhs.compare(0, <span class="ge">_String::npos, __rhs, __rhs_</span>len) == 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const basic_string&lt;_CharT,_Traits,_Allocator&gt;&amp; __lhs,
           const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __rhs) throw()
{
    return !(__lhs == __rhs);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const <span class="ge">_CharT* _</span>_lhs,
           const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __rhs) throw()
{
    return !(__lhs == __rhs);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __lhs,
           const <span class="ge">_CharT* _</span>_rhs) throw()
{
    return !(__lhs == __rhs);
}



template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt; (const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __lhs,
           const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __rhs) throw()
{
    return <span class="gs">__lhs.compare(__</span>rhs) &lt; 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt; (const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __lhs,
           const <span class="ge">_CharT* _</span>_rhs) throw()
{
    return <span class="gs">__lhs.compare(__</span>rhs) &lt; 0;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt; (const <span class="ge">_CharT* _</span>_lhs,
           const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __rhs) throw()
{
    return <span class="gs">__rhs.compare(__</span>lhs) &gt; 0;
}



template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt; (const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __lhs,
           const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __rhs) throw()
{
    return <span class="gs">__rhs &lt; __</span>lhs;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt; (const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __lhs,
           const <span class="ge">_CharT* _</span>_rhs) throw()
{
    return <span class="gs">__rhs &lt; __</span>lhs;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt; (const <span class="ge">_CharT* _</span>_lhs,
           const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __rhs) throw()
{
    return <span class="gs">__rhs &lt; __</span>lhs;
}



template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __lhs,
           const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __rhs) throw()
{
    return !(__rhs &lt; __lhs);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __lhs,
           const <span class="ge">_CharT* _</span>_rhs) throw()
{
    return !(__rhs &lt; __lhs);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const <span class="ge">_CharT* _</span>_lhs,
           const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __rhs) throw()
{
    return !(__rhs &lt; __lhs);
}



template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __lhs,
           const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __rhs) throw()
{
    return !(__lhs &lt; __rhs);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __lhs,
           const <span class="ge">_CharT* _</span>_rhs) throw()
{
    return !(__lhs &lt; __rhs);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const <span class="ge">_CharT* _</span>_lhs,
           const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __rhs) throw()
{
    return !(__lhs &lt; __rhs);
}



template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;
operator+(const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __lhs,
          const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __rhs)
{
    basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt; <span class="gs">__r(__</span>lhs.get_allocator());
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type __lhs_sz = __lhs.size();
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type __rhs_sz = __rhs.size();
    <span class="gs">__r.__</span>init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    <span class="gs">__r.append(__</span>rhs.data(), __rhs_sz);
    return __r;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;
operator+(const <span class="ge">_CharT* __lhs , const basic_</span>string&lt;_CharT,_Traits,_Allocator&gt;&amp; __rhs)
{
    basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt; <span class="gs">__r(__</span>rhs.get_allocator());
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type __lhs_sz = <span class="ge">_Traits::length(_</span>_lhs);
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type __rhs_sz = __rhs.size();
    <span class="gs">__r.__</span>init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
    <span class="gs">__r.append(__</span>rhs.data(), __rhs_sz);
    return __r;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;
operator+(_CharT __lhs, const basic_string&lt;_CharT,_Traits,_Allocator&gt;&amp; __rhs)
{
    basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt; <span class="gs">__r(__</span>rhs.get_allocator());
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type __rhs_sz = __rhs.size();
    <span class="gs">__r.__</span>init(&amp;__lhs, 1, 1 + __rhs_sz);
    <span class="gs">__r.append(__</span>rhs.data(), __rhs_sz);
    return __r;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;
operator+(const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __lhs, const <span class="ge">_CharT* _</span>_rhs)
{
    basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt; <span class="gs">__r(__</span>lhs.get_allocator());
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type __lhs_sz = __lhs.size();
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type __rhs_sz = <span class="ge">_Traits::length(_</span>_rhs);
    <span class="gs">__r.__</span>init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    <span class="gs">__r.append(__</span>rhs, __rhs_sz);
    return __r;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;
operator+(const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __lhs, <span class="ge">_CharT _</span>_rhs)
{
    basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt; <span class="gs">__r(__</span>lhs.get_allocator());
    typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type __lhs_sz = __lhs.size();
    <span class="gs">__r.__</span>init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
    __r.push_back(__rhs);
    return __r;
}
template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
swap(basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __lhs,
     basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __rhs)

{
    <span class="gs">__lhs.swap(__</span>rhs);
}






typedef basic_string&lt;char16_t&gt; u16string;
typedef basic_string&lt;char32_t&gt; u32string;


<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) int stoi (const string&amp; __str, size_t* <span class="gs">__idx = 0, int __</span>base = 10);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) long stol (const string&amp; __str, size_t* <span class="gs">__idx = 0, int __</span>base = 10);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) unsigned long stoul (const string&amp; __str, size_t* <span class="gs">__idx = 0, int __</span>base = 10);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) long long stoll (const string&amp; __str, size_t* <span class="gs">__idx = 0, int __</span>base = 10);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) unsigned long long stoull(const string&amp; __str, size_t* <span class="gs">__idx = 0, int __</span>base = 10);

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) float stof (const string&amp; __str, size_t* __idx = 0);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) double stod (const string&amp; __str, size_t* __idx = 0);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) long double stold(const string&amp; __str, size_t* __idx = 0);

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) string to_string(int __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) string to_string(unsigned __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) string to_string(long __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) string to_string(unsigned long __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) string to_string(long long __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) string to_string(unsigned long long __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) string to_string(float __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) string to_string(double __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) string to_string(long double __val);

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) int stoi (const wstring&amp; __str, size_t* <span class="gs">__idx = 0, int __</span>base = 10);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) long stol (const wstring&amp; __str, size_t* <span class="gs">__idx = 0, int __</span>base = 10);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) unsigned long stoul (const wstring&amp; __str, size_t* <span class="gs">__idx = 0, int __</span>base = 10);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) long long stoll (const wstring&amp; __str, size_t* <span class="gs">__idx = 0, int __</span>base = 10);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) unsigned long long stoull(const wstring&amp; __str, size_t* <span class="gs">__idx = 0, int __</span>base = 10);

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) float stof (const wstring&amp; __str, size_t* __idx = 0);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) double stod (const wstring&amp; __str, size_t* __idx = 0);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) long double stold(const wstring&amp; __str, size_t* __idx = 0);

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) wstring to_wstring(int __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) wstring to_wstring(unsigned __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) wstring to_wstring(long __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) wstring to_wstring(unsigned long __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) wstring to_wstring(long long __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) wstring to_wstring(unsigned long long __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) wstring to_wstring(float __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) wstring to_wstring(double __val);
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) wstring to_wstring(long double __val);

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
    const typename basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::size_type
                   basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;::npos;

template &lt;class <span class="ge">_CharT, class _</span>Allocator&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;)))
    hash&lt;basic_string&lt;_CharT, char_traits&lt;_CharT&gt;, _Allocator&gt; &gt;
    : public unary_function&lt;
          basic_string&lt;_CharT, char_traits&lt;_CharT&gt;, <span class="ge">_Allocator&gt;, size_</span>t&gt;
{
    size_t
    operator()(const basic_string&lt;_CharT, char_traits&lt;_CharT&gt;, <span class="ge">_Allocator&gt;&amp; _</span>_val) const throw()
    { return __do_string_hash(__val.data(), <span class="gs">__val.data() + __</span>val.size()); }
};


template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_os,
           const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __str);

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_is,
           basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __str);

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
getline(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_is,
        basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __str, <span class="ge">_CharT _</span>_dlm);

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_istream&lt;_CharT, _Traits&gt;&amp;
getline(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_is,
        basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __str);
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) basic_string&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) basic_string&lt;wchar_t&gt;;
} }




namespace std { inline namespace __1 {

using ::clock_t;
using ::size_t;
using ::time_t;
using ::tm;



using ::clock;
using ::difftime;
using ::mktime;
using ::time;

using ::asctime;
using ::ctime;
using ::gmtime;
using ::localtime;

using ::strftime;




} }












namespace std { inline namespace __1 {



template &lt;intmax_t <span class="ge">_Xp, intmax_</span>t _Yp&gt;
struct __static_gcd
{
    static const intmax_t value = __static_gcd&lt;_Yp, <span class="ge">_Xp % _</span>Yp&gt;::value;
};

template &lt;intmax_t _Xp&gt;
struct __static_gcd&lt;_Xp, 0&gt;
{
    static const intmax_t value = _Xp;
};

template &lt;&gt;
struct __static_gcd&lt;0, 0&gt;
{
    static const intmax_t value = 1;
};



template &lt;intmax_t <span class="ge">_Xp, intmax_</span>t _Yp&gt;
struct __static_lcm
{
    static const intmax_t value = <span class="ge">_Xp / __static_</span>gcd&lt;_Xp, <span class="ge">_Yp&gt;::value * _</span>Yp;
};

template &lt;intmax_t _Xp&gt;
struct __static_abs
{
    static const intmax_t value = <span class="ge">_Xp &lt; 0 ? -_</span>Xp : _Xp;
};

template &lt;intmax_t _Xp&gt;
struct __static_sign
{
    static const intmax_t value = <span class="ge">_Xp == 0 ? 0 : (_</span>Xp &lt; 0 ? -1 : 1);
};

template &lt;intmax_t <span class="ge">_Xp, intmax_</span>t <span class="ge">_Yp, intmax_</span>t = __static_sign&lt;_Yp&gt;::value&gt;
class __ll_add;

template &lt;intmax_t <span class="ge">_Xp, intmax_</span>t _Yp&gt;
class __ll_add&lt;_Xp, _Yp, 1&gt;
{
    static const intmax_t min = (1LL &lt;&lt; (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    <span class="ge">_Static_</span>assert(_Xp &lt;= max - <span class="ge">_Yp, &quot;overflow in __ll_</span>add&quot;);
public:
    static const intmax_t value = <span class="ge">_Xp + _</span>Yp;
};

template &lt;intmax_t <span class="ge">_Xp, intmax_</span>t _Yp&gt;
class __ll_add&lt;_Xp, _Yp, 0&gt;
{
public:
    static const intmax_t value = _Xp;
};

template &lt;intmax_t <span class="ge">_Xp, intmax_</span>t _Yp&gt;
class __ll_add&lt;_Xp, _Yp, -1&gt;
{
    static const intmax_t min = (1LL &lt;&lt; (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    <span class="ge">_Static_</span>assert(min - <span class="ge">_Yp &lt;= _</span>Xp, &quot;overflow in __ll_add&quot;);
public:
    static const intmax_t value = <span class="ge">_Xp + _</span>Yp;
};

template &lt;intmax_t <span class="ge">_Xp, intmax_</span>t <span class="ge">_Yp, intmax_</span>t = __static_sign&lt;_Yp&gt;::value&gt;
class __ll_sub;

template &lt;intmax_t <span class="ge">_Xp, intmax_</span>t _Yp&gt;
class __ll_sub&lt;_Xp, _Yp, 1&gt;
{
    static const intmax_t min = (1LL &lt;&lt; (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    <span class="ge">_Static_</span>assert(min + <span class="ge">_Yp &lt;= _</span>Xp, &quot;overflow in __ll_sub&quot;);
public:
    static const intmax_t value = <span class="ge">_Xp - _</span>Yp;
};

template &lt;intmax_t <span class="ge">_Xp, intmax_</span>t _Yp&gt;
class __ll_sub&lt;_Xp, _Yp, 0&gt;
{
public:
    static const intmax_t value = _Xp;
};

template &lt;intmax_t <span class="ge">_Xp, intmax_</span>t _Yp&gt;
class __ll_sub&lt;_Xp, _Yp, -1&gt;
{
    static const intmax_t min = (1LL &lt;&lt; (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    <span class="ge">_Static_</span>assert(_Xp &lt;= max + <span class="ge">_Yp, &quot;overflow in __ll_</span>sub&quot;);
public:
    static const intmax_t value = <span class="ge">_Xp - _</span>Yp;
};

template &lt;intmax_t <span class="ge">_Xp, intmax_</span>t _Yp&gt;
class __ll_mul
{
    static const intmax_t nan = (1LL &lt;&lt; (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;
    static const intmax_t __a_x = __static_abs&lt;_Xp&gt;::value;
    static const intmax_t __a_y = __static_abs&lt;_Yp&gt;::value;

    <span class="ge">_Static_</span>assert(_Xp != nan &amp;&amp; <span class="ge">_Yp != nan &amp;&amp; __a_</span>x &lt;= max / __a_y, &quot;overflow in __ll_mul&quot;);
public:
    static const intmax_t value = <span class="ge">_Xp * _</span>Yp;
};

template &lt;intmax_t _Yp&gt;
class __ll_mul&lt;0, _Yp&gt;
{
public:
    static const intmax_t value = 0;
};

template &lt;intmax_t _Xp&gt;
class __ll_mul&lt;_Xp, 0&gt;
{
public:
    static const intmax_t value = 0;
};

template &lt;&gt;
class __ll_mul&lt;0, 0&gt;
{
public:
    static const intmax_t value = 0;
};


template &lt;intmax_t <span class="ge">_Xp, intmax_</span>t _Yp&gt;
class __ll_div
{
    static const intmax_t nan = (1LL &lt;&lt; (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;

    <span class="ge">_Static_</span>assert(_Xp != nan &amp;&amp; <span class="ge">_Yp != nan &amp;&amp; _</span>Yp != 0, &quot;overflow in __ll_div&quot;);
public:
    static const intmax_t value = <span class="ge">_Xp / _</span>Yp;
};

template &lt;intmax_t <span class="ge">_Num, intmax_</span>t _Den = 1&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) ratio
{
    <span class="ge">_Static_</span>assert(__static_abs&lt;_Num&gt;::value &gt;= 0, &quot;ratio numerator is out of range&quot;);
    <span class="ge">_Static_</span>assert(_Den != 0, &quot;ratio divide by 0&quot;);
    <span class="ge">_Static_</span>assert(__static_abs&lt;_Den&gt;::value &gt; 0, &quot;ratio denominator is out of range&quot;);
    static const intmax_t <span class="gs">__na = __</span>static_abs&lt;_Num&gt;::value;
    static const intmax_t <span class="gs">__da = __</span>static_abs&lt;_Den&gt;::value;
    static const intmax_t <span class="gs">__s = __</span>static_sign&lt;_Num&gt;::value * __static_sign&lt;_Den&gt;::value;
    static const intmax_t <span class="gs">__gcd = __</span>static_gcd&lt;__na, __da&gt;::value;
public:
    static const intmax_t num = <span class="gs">__s * __</span>na / __gcd;
    static const intmax_t den = <span class="gs">__da / __</span>gcd;

    typedef ratio&lt;num, den&gt; type;
};

template &lt;intmax_t <span class="ge">_Num, intmax_</span>t _Den&gt;
                  const intmax_t ratio&lt;_Num, _Den&gt;::num;

template &lt;intmax_t <span class="ge">_Num, intmax_</span>t _Den&gt;
                  const intmax_t ratio&lt;_Num, _Den&gt;::den;

template &lt;class <span class="ge">_Tp&gt; struct __is_</span>ratio : false_type {};
template &lt;intmax_t <span class="ge">_Num, intmax_</span>t <span class="ge">_Den&gt; struct __is_</span>ratio&lt;ratio&lt;_Num, <span class="ge">_Den&gt; &gt; : true_</span>type {};

typedef ratio&lt;1LL, 1000000000000000000LL&gt; atto;
typedef ratio&lt;1LL, 1000000000000000LL&gt; femto;
typedef ratio&lt;1LL, 1000000000000LL&gt; pico;
typedef ratio&lt;1LL, 1000000000LL&gt; nano;
typedef ratio&lt;1LL, 1000000LL&gt; micro;
typedef ratio&lt;1LL, 1000LL&gt; milli;
typedef ratio&lt;1LL, 100LL&gt; centi;
typedef ratio&lt;1LL, 10LL&gt; deci;
typedef ratio&lt; 10LL, 1LL&gt; deca;
typedef ratio&lt; 100LL, 1LL&gt; hecto;
typedef ratio&lt; 1000LL, 1LL&gt; kilo;
typedef ratio&lt; 1000000LL, 1LL&gt; mega;
typedef ratio&lt; 1000000000LL, 1LL&gt; giga;
typedef ratio&lt; 1000000000000LL, 1LL&gt; tera;
typedef ratio&lt; 1000000000000000LL, 1LL&gt; peta;
typedef ratio&lt;1000000000000000000LL, 1LL&gt; exa;

template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct __ratio_multiply
{
private:
    static const intmax_t __gcd_n1_d2 = __static_gcd&lt;_R1::num, _R2::den&gt;::value;
    static const intmax_t __gcd_d1_n2 = __static_gcd&lt;_R1::den, _R2::num&gt;::value;
public:
    typedef typename ratio
        &lt;
            __ll_mul&lt;_R1::num / __gcd_n1_d2, <span class="ge">_R2::num / __gcd_</span>d1_n2&gt;::value,
            __ll_mul&lt;_R2::den / __gcd_n1_d2, <span class="ge">_R1::den / __gcd_</span>d1_n2&gt;::value
        &gt;::type type;
};
template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) ratio_multiply
    : public __ratio_multiply&lt;_R1, _R2&gt;::type {};



template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct __ratio_divide
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd&lt;_R1::num, _R2::num&gt;::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd&lt;_R1::den, _R2::den&gt;::value;
public:
    typedef typename ratio
        &lt;
            __ll_mul&lt;_R1::num / __gcd_n1_n2, <span class="ge">_R2::den / __gcd_</span>d1_d2&gt;::value,
            __ll_mul&lt;_R2::num / __gcd_n1_n2, <span class="ge">_R1::den / __gcd_</span>d1_d2&gt;::value
        &gt;::type type;
};
template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) ratio_divide
    : public __ratio_divide&lt;_R1, _R2&gt;::type {};



template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct __ratio_add
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd&lt;_R1::num, _R2::num&gt;::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd&lt;_R1::den, _R2::den&gt;::value;
public:
    typedef typename ratio_multiply
        &lt;
            ratio&lt;__gcd_n1_n2, <span class="ge">_R1::den / __gcd_</span>d1_d2&gt;,
            ratio
            &lt;
                __ll_add
                &lt;
                    __ll_mul&lt;_R1::num / __gcd_n1_n2, <span class="ge">_R2::den / __gcd_</span>d1_d2&gt;::value,
                    __ll_mul&lt;_R2::num / __gcd_n1_n2, <span class="ge">_R1::den / __gcd_</span>d1_d2&gt;::value
                &gt;::value,
                _R2::den
<span class="k">            &gt;</span>
<span class="ge">        &gt;::type type;</span>
};
template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) ratio_add
    : public __ratio_add&lt;_R1, _R2&gt;::type {};



template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct __ratio_subtract
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd&lt;_R1::num, _R2::num&gt;::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd&lt;_R1::den, _R2::den&gt;::value;
public:
    typedef typename ratio_multiply
        &lt;
            ratio&lt;__gcd_n1_n2, <span class="ge">_R1::den / __gcd_</span>d1_d2&gt;,
            ratio
            &lt;
                __ll_sub
                &lt;
                    __ll_mul&lt;_R1::num / __gcd_n1_n2, <span class="ge">_R2::den / __gcd_</span>d1_d2&gt;::value,
                    __ll_mul&lt;_R2::num / __gcd_n1_n2, <span class="ge">_R1::den / __gcd_</span>d1_d2&gt;::value
                &gt;::value,
                _R2::den
<span class="k">            &gt;</span>
<span class="ge">        &gt;::type type;</span>
};
template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) ratio_subtract
    : public __ratio_subtract&lt;_R1, _R2&gt;::type {};





template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) ratio_equal
    : public integral_constant&lt;bool,((_R1::num == <span class="ge">_R2::num &amp;&amp; _</span>R1::den == _R2::den))&gt; {};

template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) ratio_not_equal
    : public integral_constant&lt;bool,((!ratio_equal&lt;_R1, _R2&gt;::value))&gt; {};



template &lt;class <span class="ge">_R1, class _</span>R2, bool _Odd = false,
          intmax_t <span class="ge">_Q1 = _</span>R1::num / <span class="ge">_R1::den, intmax_</span>t <span class="ge">_M1 = _</span>R1::num % _R1::den,
          intmax_t <span class="ge">_Q2 = _</span>R2::num / <span class="ge">_R2::den, intmax_</span>t <span class="ge">_M2 = _</span>R2::num % _R2::den&gt;
struct __ratio_less1
{
    static const bool value = <span class="ge">_Odd ? _</span>Q2 &lt; <span class="ge">_Q1 : _</span>Q1 &lt; _Q2;
};

template &lt;class <span class="ge">_R1, class _</span>R2, bool <span class="ge">_Odd, intmax_</span>t _Qp&gt;
struct __ratio_less1&lt;_R1, <span class="ge">_R2, _</span>Odd, <span class="ge">_Qp, 0, _</span>Qp, 0&gt;
{
    static const bool value = false;
};

template &lt;class <span class="ge">_R1, class _</span>R2, bool <span class="ge">_Odd, intmax_</span>t <span class="ge">_Qp, intmax_</span>t _M2&gt;
struct __ratio_less1&lt;_R1, <span class="ge">_R2, _</span>Odd, <span class="ge">_Qp, 0, _</span>Qp, _M2&gt;
{
    static const bool value = !_Odd;
};

template &lt;class <span class="ge">_R1, class _</span>R2, bool <span class="ge">_Odd, intmax_</span>t <span class="ge">_Qp, intmax_</span>t _M1&gt;
struct __ratio_less1&lt;_R1, <span class="ge">_R2, _</span>Odd, <span class="ge">_Qp, _</span>M1, _Qp, 0&gt;
{
    static const bool value = _Odd;
};

template &lt;class <span class="ge">_R1, class _</span>R2, bool <span class="ge">_Odd, intmax_</span>t <span class="ge">_Qp, intmax_</span>t _M1,
                                                        intmax_t _M2&gt;
struct __ratio_less1&lt;_R1, <span class="ge">_R2, _</span>Odd, <span class="ge">_Qp, _</span>M1, <span class="ge">_Qp, _</span>M2&gt;
{
    static const bool value = __ratio_less1&lt;ratio&lt;_R1::den, _M1&gt;,
                                            ratio&lt;_R2::den, <span class="ge">_M2&gt;, !_</span>Odd&gt;::value;
};

template &lt;class <span class="ge">_R1, class _</span>R2, intmax_t <span class="ge">_S1 = __static_</span>sign&lt;_R1::num&gt;::value,
                                intmax_t <span class="ge">_S2 = __static_</span>sign&lt;_R2::num&gt;::value&gt;
struct __ratio_less
{
    static const bool value = <span class="ge">_S1 &lt; _</span>S2;
};

template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct __ratio_less&lt;_R1, _R2, 1LL, 1LL&gt;
{
    static const bool value = __ratio_less1&lt;_R1, _R2&gt;::value;
};

template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct __ratio_less&lt;_R1, _R2, -1LL, -1LL&gt;
{
    static const bool value = __ratio_less1&lt;ratio&lt;-_R2::num, <span class="ge">_R2::den&gt;, ratio&lt;-_</span>R1::num, _R1::den&gt; &gt;::value;
};

template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) ratio_less
    : public integral_constant&lt;bool,((__ratio_less&lt;_R1, _R2&gt;::value))&gt; {};

template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) ratio_less_equal
    : public integral_constant&lt;bool,((!ratio_less&lt;_R2, _R1&gt;::value))&gt; {};

template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) ratio_greater
    : public integral_constant&lt;bool,((ratio_less&lt;_R2, _R1&gt;::value))&gt; {};

template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) ratio_greater_equal
    : public integral_constant&lt;bool,((!ratio_less&lt;_R1, _R2&gt;::value))&gt; {};

template &lt;class <span class="ge">_R1, class _</span>R2&gt;
struct __ratio_gcd
{
    typedef ratio&lt;__static_gcd&lt;_R1::num, _R2::num&gt;::value,
                  __static_lcm&lt;_R1::den, _R2::den&gt;::value&gt; type;
};
} }










namespace std { inline namespace __1 {

namespace chrono
{

template &lt;class <span class="ge">_Rep, class _</span>Period = ratio&lt;1&gt; &gt; class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) duration;

template &lt;class _Tp&gt;
struct __is_duration : false_type {};

template &lt;class <span class="ge">_Rep, class _</span>Period&gt;
struct __is_duration&lt;duration&lt;_Rep, <span class="ge">_Period&gt; &gt; : true_</span>type {};

template &lt;class <span class="ge">_Rep, class _</span>Period&gt;
struct __is_duration&lt;const duration&lt;_Rep, <span class="ge">_Period&gt; &gt; : true_</span>type {};

template &lt;class <span class="ge">_Rep, class _</span>Period&gt;
struct __is_duration&lt;volatile duration&lt;_Rep, <span class="ge">_Period&gt; &gt; : true_</span>type {};

template &lt;class <span class="ge">_Rep, class _</span>Period&gt;
struct __is_duration&lt;const volatile duration&lt;_Rep, <span class="ge">_Period&gt; &gt; : true_</span>type {};

}

template &lt;class <span class="ge">_Rep1, class _</span>Period1, class <span class="ge">_Rep2, class _</span>Period2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) common_type&lt;chrono::duration&lt;_Rep1, _Period1&gt;,
                                         chrono::duration&lt;_Rep2, _Period2&gt; &gt;
{
    typedef chrono::duration&lt;typename common_type&lt;_Rep1, _Rep2&gt;::type,
                             typename __ratio_gcd&lt;_Period1, _Period2&gt;::type&gt; type;
};

namespace chrono {



template &lt;class <span class="ge">_FromDuration, class _</span>ToDuration,
          class <span class="ge">_Period = typename ratio_</span>divide&lt;typename <span class="ge">_FromDuration::period, typename _</span>ToDuration::period&gt;::type,
          bool = _Period::num == 1,
          bool = _Period::den == 1&gt;
struct __duration_cast;

template &lt;class <span class="ge">_FromDuration, class _</span>ToDuration, class _Period&gt;
struct __duration_cast&lt;_FromDuration, <span class="ge">_ToDuration, _</span>Period, true, true&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_ToDuration operator()(const _</span>FromDuration&amp; __fd) const
    {
        return <span class="ge">_ToDuration(static_</span>cast&lt;typename <span class="ge">_ToDuration::rep&gt;(_</span>_fd.count()));
    }
};

template &lt;class <span class="ge">_FromDuration, class _</span>ToDuration, class _Period&gt;
struct __duration_cast&lt;_FromDuration, <span class="ge">_ToDuration, _</span>Period, true, false&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_ToDuration operator()(const _</span>FromDuration&amp; __fd) const
    {
        typedef typename common_type&lt;typename <span class="ge">_ToDuration::rep, typename _</span>FromDuration::rep, intmax_t&gt;::type _Ct;
        return <span class="ge">_ToDuration(static_</span>cast&lt;typename _ToDuration::rep&gt;(
                           static_cast&lt;_Ct&gt;(__fd.count()) / static_cast&lt;_Ct&gt;(_Period::den)));
    }
};

template &lt;class <span class="ge">_FromDuration, class _</span>ToDuration, class _Period&gt;
struct __duration_cast&lt;_FromDuration, <span class="ge">_ToDuration, _</span>Period, false, true&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_ToDuration operator()(const _</span>FromDuration&amp; __fd) const
    {
        typedef typename common_type&lt;typename <span class="ge">_ToDuration::rep, typename _</span>FromDuration::rep, intmax_t&gt;::type _Ct;
        return <span class="ge">_ToDuration(static_</span>cast&lt;typename _ToDuration::rep&gt;(
                           static_cast&lt;_Ct&gt;(__fd.count()) * static_cast&lt;_Ct&gt;(_Period::num)));
    }
};

template &lt;class <span class="ge">_FromDuration, class _</span>ToDuration, class _Period&gt;
struct __duration_cast&lt;_FromDuration, <span class="ge">_ToDuration, _</span>Period, false, false&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="ge">_ToDuration operator()(const _</span>FromDuration&amp; __fd) const
    {
        typedef typename common_type&lt;typename <span class="ge">_ToDuration::rep, typename _</span>FromDuration::rep, intmax_t&gt;::type _Ct;
        return <span class="ge">_ToDuration(static_</span>cast&lt;typename _ToDuration::rep&gt;(
                           static_cast&lt;_Ct&gt;(__fd.count()) * static_cast&lt;_Ct&gt;(_Period::num)
                                                          / static_cast&lt;_Ct&gt;(_Period::den)));
    }
};

template &lt;class <span class="ge">_ToDuration, class _</span>Rep, class _Period&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

typename enable_if
&lt;
    __is_duration&lt;_ToDuration&gt;::value,
    _ToDuration
&gt;::type
duration_cast(const duration&lt;_Rep, <span class="ge">_Period&gt;&amp; _</span>_fd)
{
    return __duration_cast&lt;duration&lt;_Rep, <span class="ge">_Period&gt;, _</span>ToDuration&gt;()(__fd);
}

template &lt;class _Rep&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) treat_as_floating_point : is_floating_point&lt;_Rep&gt; {};







template &lt;class _Rep&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) duration_values
{
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static <span class="ge">_Rep zero() throw() {return _</span>Rep(0);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static <span class="ge">_Rep max() throw() {return numeric_</span>limits&lt;_Rep&gt;::max();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static <span class="ge">_Rep min() throw() {return numeric_</span>limits&lt;_Rep&gt;::lowest();}
};
template &lt;class <span class="ge">_Rep, class _</span>Period&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) duration
{
    <span class="ge">_Static_</span>assert(!__is_duration&lt;_Rep&gt;::value, &quot;A duration representation can not be a duration&quot;);
    <span class="ge">_Static_</span>assert(__is_ratio&lt;_Period&gt;::value, &quot;Second template parameter of duration must be a std::ratio&quot;);
    <span class="ge">_Static_</span>assert(_Period::num &gt; 0, &quot;duration period must be positive&quot;);

    template &lt;class <span class="ge">_R1, class _</span>R2&gt;
    struct __no_overflow
    {
    private:
        static const intmax_t __gcd_n1_n2 = __static_gcd&lt;_R1::num, _R2::num&gt;::value;
        static const intmax_t __gcd_d1_d2 = __static_gcd&lt;_R1::den, _R2::den&gt;::value;
        static const intmax_t __n1 = <span class="ge">_R1::num / __gcd_</span>n1_n2;
        static const intmax_t __d1 = <span class="ge">_R1::den / __gcd_</span>d1_d2;
        static const intmax_t __n2 = <span class="ge">_R2::num / __gcd_</span>n1_n2;
        static const intmax_t __d2 = <span class="ge">_R2::den / __gcd_</span>d1_d2;
        static const intmax_t max = -((intmax_t(1) &lt;&lt; (sizeof(intmax_t) * 8 - 1)) + 1);

        template &lt;intmax_t <span class="ge">_Xp, intmax_</span>t <span class="ge">_Yp, bool _</span>_overflow&gt;
        struct __mul
        {
            static const intmax_t value = <span class="ge">_Xp * _</span>Yp;
        };

        template &lt;intmax_t <span class="ge">_Xp, intmax_</span>t _Yp&gt;
        struct __mul&lt;_Xp, _Yp, true&gt;
        {
            static const intmax_t value = 1;
        };

    public:
        static const bool value = (<span class="gs">__n1 &lt;= max / __</span>d2) &amp;&amp; (<span class="gs">__n2 &lt;= max / __</span>d1);
        typedef ratio&lt;__mul&lt;__n1, __d2, !value&gt;::value,
                      <span class="gs">__mul&lt;__</span>n2, __d1, !value&gt;::value&gt; type;
    };

public:
    typedef _Rep rep;
    typedef typename _Period::type period;
private:
    rep __rep_;
public:

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))



        duration() {}


    template &lt;class _Rep2&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        explicit duration(const <span class="ge">_Rep2&amp; _</span>_r,
            typename enable_if
            &lt;
               is_convertible&lt;_Rep2, rep&gt;::value &amp;&amp;
               (treat_as_floating_point&lt;rep&gt;::value ||
               !treat_as_floating_point&lt;_Rep2&gt;::value)
            &gt;::type* = 0)
                : __rep_(__r) {}


    template &lt;class <span class="ge">_Rep2, class _</span>Period2&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        duration(const duration&lt;_Rep2, <span class="ge">_Period2&gt;&amp; _</span>_d,
            typename enable_if
            &lt;
                __no_overflow&lt;_Period2, period&gt;::value &amp;&amp; (
                treat_as_floating_point&lt;rep&gt;::value ||
                (__no_overflow&lt;_Period2, period&gt;::type::den == 1 &amp;&amp;
                 !treat_as_floating_point&lt;_Rep2&gt;::value))
            &gt;::type* = 0)
                : __rep_(std::__1::chrono::duration_cast&lt;duration&gt;(__d).count()) {}



    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) rep count() const {return __rep_;}



    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) typename common_type&lt;duration&gt;::type operator+() const {return typename common_type&lt;duration&gt;::type(*this);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) typename common_type&lt;duration&gt;::type operator-() const {return typename common_type&lt;duration&gt;::type(-__rep_);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) duration&amp; operator++() {++__rep_; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) duration operator++(int) {return duration(__rep_++);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) duration&amp; operator--() {--__rep_; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) duration operator--(int) {return duration(__rep_--);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) duration&amp; operator+=(const duration&amp; <span class="gs">__d) {__</span>rep_ += __d.count(); return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) duration&amp; operator-=(const duration&amp; <span class="gs">__d) {__</span>rep_ -= __d.count(); return *this;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) duration&amp; operator*=(const rep&amp; rhs) {__rep_ <span class="ge">*= rhs; return *</span>this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) duration&amp; operator/=(const rep&amp; rhs) {__rep_ /= rhs; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) duration&amp; operator%=(const rep&amp; rhs) {__rep_ %= rhs; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) duration&amp; operator%=(const duration&amp; rhs) {__rep_ %= rhs.count(); return *this;}



    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static duration zero() throw() {return duration(duration_values&lt;rep&gt;::zero());}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static duration min() throw() {return duration(duration_values&lt;rep&gt;::min());}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static duration max() throw() {return duration(duration_values&lt;rep&gt;::max());}
};

typedef duration&lt;long long, nano&gt; nanoseconds;
typedef duration&lt;long long, micro&gt; microseconds;
typedef duration&lt;long long, milli&gt; milliseconds;
typedef duration&lt;long long &gt; seconds;
typedef duration&lt; long, ratio&lt; 60&gt; &gt; minutes;
typedef duration&lt; long, ratio&lt;3600&gt; &gt; hours;
template &lt;class <span class="ge">_LhsDuration, class _</span>RhsDuration&gt;
struct __duration_eq
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_LhsDuration&amp; __lhs, const _</span>RhsDuration&amp; __rhs) const
        {
            typedef typename common_type&lt;_LhsDuration, <span class="ge">_RhsDuration&gt;::type _</span>Ct;
            return <span class="ge">_Ct(__lhs).count() == _</span>Ct(__rhs).count();
        }
};

template &lt;class _LhsDuration&gt;
struct __duration_eq&lt;_LhsDuration, _LhsDuration&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_LhsDuration&amp; __lhs, const _</span>LhsDuration&amp; __rhs) const
        {return <span class="gs">__lhs.count() == __</span>rhs.count();}
};

template &lt;class <span class="ge">_Rep1, class _</span>Period1, class <span class="ge">_Rep2, class _</span>Period2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

bool
operator==(const duration&lt;_Rep1, <span class="ge">_Period1&gt;&amp; __lhs, const duration&lt;_</span>Rep2, <span class="ge">_Period2&gt;&amp; _</span>_rhs)
{
    return __duration_eq&lt;duration&lt;_Rep1, <span class="ge">_Period1&gt;, duration&lt;_</span>Rep2, <span class="ge">_Period2&gt; &gt;()(__lhs, _</span>_rhs);
}



template &lt;class <span class="ge">_Rep1, class _</span>Period1, class <span class="ge">_Rep2, class _</span>Period2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

bool
operator!=(const duration&lt;_Rep1, <span class="ge">_Period1&gt;&amp; __lhs, const duration&lt;_</span>Rep2, <span class="ge">_Period2&gt;&amp; _</span>_rhs)
{
    return !(__lhs == __rhs);
}



template &lt;class <span class="ge">_LhsDuration, class _</span>RhsDuration&gt;
struct __duration_lt
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_LhsDuration&amp; __lhs, const _</span>RhsDuration&amp; __rhs) const
        {
            typedef typename common_type&lt;_LhsDuration, <span class="ge">_RhsDuration&gt;::type _</span>Ct;
            return <span class="ge">_Ct(__lhs).count() &lt; _</span>Ct(__rhs).count();
        }
};

template &lt;class _LhsDuration&gt;
struct __duration_lt&lt;_LhsDuration, _LhsDuration&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator()(const <span class="ge">_LhsDuration&amp; __lhs, const _</span>LhsDuration&amp; __rhs) const
        {return <span class="gs">__lhs.count() &lt; __</span>rhs.count();}
};

template &lt;class <span class="ge">_Rep1, class _</span>Period1, class <span class="ge">_Rep2, class _</span>Period2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

bool
operator&lt; (const duration&lt;_Rep1, <span class="ge">_Period1&gt;&amp; __lhs, const duration&lt;_</span>Rep2, <span class="ge">_Period2&gt;&amp; _</span>_rhs)
{
    return __duration_lt&lt;duration&lt;_Rep1, <span class="ge">_Period1&gt;, duration&lt;_</span>Rep2, <span class="ge">_Period2&gt; &gt;()(__lhs, _</span>_rhs);
}



template &lt;class <span class="ge">_Rep1, class _</span>Period1, class <span class="ge">_Rep2, class _</span>Period2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

bool
operator&gt; (const duration&lt;_Rep1, <span class="ge">_Period1&gt;&amp; __lhs, const duration&lt;_</span>Rep2, <span class="ge">_Period2&gt;&amp; _</span>_rhs)
{
    return <span class="gs">__rhs &lt; __</span>lhs;
}



template &lt;class <span class="ge">_Rep1, class _</span>Period1, class <span class="ge">_Rep2, class _</span>Period2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

bool
operator&lt;=(const duration&lt;_Rep1, <span class="ge">_Period1&gt;&amp; __lhs, const duration&lt;_</span>Rep2, <span class="ge">_Period2&gt;&amp; _</span>_rhs)
{
    return !(__rhs &lt; __lhs);
}



template &lt;class <span class="ge">_Rep1, class _</span>Period1, class <span class="ge">_Rep2, class _</span>Period2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

bool
operator&gt;=(const duration&lt;_Rep1, <span class="ge">_Period1&gt;&amp; __lhs, const duration&lt;_</span>Rep2, <span class="ge">_Period2&gt;&amp; _</span>_rhs)
{
    return !(__lhs &lt; __rhs);
}



template &lt;class <span class="ge">_Rep1, class _</span>Period1, class <span class="ge">_Rep2, class _</span>Period2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

typename common_type&lt;duration&lt;_Rep1, <span class="ge">_Period1&gt;, duration&lt;_</span>Rep2, _Period2&gt; &gt;::type
operator+(const duration&lt;_Rep1, <span class="ge">_Period1&gt;&amp; __lhs, const duration&lt;_</span>Rep2, <span class="ge">_Period2&gt;&amp; _</span>_rhs)
{
    typedef typename common_type&lt;duration&lt;_Rep1, <span class="ge">_Period1&gt;, duration&lt;_</span>Rep2, <span class="ge">_Period2&gt; &gt;::type _</span>Cd;
    return <span class="ge">_Cd(_</span>Cd(__lhs).count() + <span class="ge">_Cd(_</span>_rhs).count());
}



template &lt;class <span class="ge">_Rep1, class _</span>Period1, class <span class="ge">_Rep2, class _</span>Period2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

typename common_type&lt;duration&lt;_Rep1, <span class="ge">_Period1&gt;, duration&lt;_</span>Rep2, _Period2&gt; &gt;::type
operator-(const duration&lt;_Rep1, <span class="ge">_Period1&gt;&amp; __lhs, const duration&lt;_</span>Rep2, <span class="ge">_Period2&gt;&amp; _</span>_rhs)
{
    typedef typename common_type&lt;duration&lt;_Rep1, <span class="ge">_Period1&gt;, duration&lt;_</span>Rep2, <span class="ge">_Period2&gt; &gt;::type _</span>Cd;
    return <span class="ge">_Cd(_</span>Cd(__lhs).count() - <span class="ge">_Cd(_</span>_rhs).count());
}



template &lt;class <span class="ge">_Rep1, class _</span>Period, class _Rep2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

typename enable_if
&lt;
    is_convertible&lt;_Rep2, typename common_type&lt;_Rep1, _Rep2&gt;::type&gt;::value,
    duration&lt;typename common_type&lt;_Rep1, <span class="ge">_Rep2&gt;::type, _</span>Period&gt;
&gt;::type
operator*(const duration&lt;_Rep1, <span class="ge">_Period&gt;&amp; __d, const _</span>Rep2&amp; __s)
{
    typedef typename common_type&lt;_Rep1, <span class="ge">_Rep2&gt;::type _</span>Cr;
    typedef duration&lt;_Cr, <span class="ge">_Period&gt; _</span>Cd;
    return <span class="ge">_Cd(_</span>Cd(__d).count() * static_cast&lt;_Cr&gt;(__s));
}

template &lt;class <span class="ge">_Rep1, class _</span>Period, class _Rep2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

typename enable_if
&lt;
    is_convertible&lt;_Rep1, typename common_type&lt;_Rep1, _Rep2&gt;::type&gt;::value,
    duration&lt;typename common_type&lt;_Rep1, <span class="ge">_Rep2&gt;::type, _</span>Period&gt;
&gt;::type
operator*(const <span class="ge">_Rep1&amp; __s, const duration&lt;_</span>Rep2, <span class="ge">_Period&gt;&amp; _</span>_d)
{
    return <span class="gs">__d * __</span>s;
}



template &lt;class <span class="ge">_Rep1, class _</span>Period, class _Rep2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

typename enable_if
&lt;
    !__is_duration&lt;_Rep2&gt;::value &amp;&amp;
      is_convertible&lt;_Rep2, typename common_type&lt;_Rep1, _Rep2&gt;::type&gt;::value,
    duration&lt;typename common_type&lt;_Rep1, <span class="ge">_Rep2&gt;::type, _</span>Period&gt;
&gt;::type
operator/(const duration&lt;_Rep1, <span class="ge">_Period&gt;&amp; __d, const _</span>Rep2&amp; __s)
{
    typedef typename common_type&lt;_Rep1, <span class="ge">_Rep2&gt;::type _</span>Cr;
    typedef duration&lt;_Cr, <span class="ge">_Period&gt; _</span>Cd;
    return <span class="ge">_Cd(_</span>Cd(__d).count() / static_cast&lt;_Cr&gt;(__s));
}

template &lt;class <span class="ge">_Rep1, class _</span>Period1, class <span class="ge">_Rep2, class _</span>Period2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

typename common_type&lt;_Rep1, _Rep2&gt;::type
operator/(const duration&lt;_Rep1, <span class="ge">_Period1&gt;&amp; __lhs, const duration&lt;_</span>Rep2, <span class="ge">_Period2&gt;&amp; _</span>_rhs)
{
    typedef typename common_type&lt;duration&lt;_Rep1, <span class="ge">_Period1&gt;, duration&lt;_</span>Rep2, <span class="ge">_Period2&gt; &gt;::type _</span>Ct;
    return <span class="ge">_Ct(__lhs).count() / _</span>Ct(__rhs).count();
}



template &lt;class <span class="ge">_Rep1, class _</span>Period, class _Rep2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

typename enable_if
&lt;
    !__is_duration&lt;_Rep2&gt;::value &amp;&amp;
      is_convertible&lt;_Rep2, typename common_type&lt;_Rep1, _Rep2&gt;::type&gt;::value,
    duration&lt;typename common_type&lt;_Rep1, <span class="ge">_Rep2&gt;::type, _</span>Period&gt;
&gt;::type
operator%(const duration&lt;_Rep1, <span class="ge">_Period&gt;&amp; __d, const _</span>Rep2&amp; __s)
{
    typedef typename common_type&lt;_Rep1, <span class="ge">_Rep2&gt;::type _</span>Cr;
    typedef duration&lt;_Cr, <span class="ge">_Period&gt; _</span>Cd;
    return <span class="ge">_Cd(_</span>Cd(__d).count() % static_cast&lt;_Cr&gt;(__s));
}

template &lt;class <span class="ge">_Rep1, class _</span>Period1, class <span class="ge">_Rep2, class _</span>Period2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

typename common_type&lt;duration&lt;_Rep1, <span class="ge">_Period1&gt;, duration&lt;_</span>Rep2, _Period2&gt; &gt;::type
operator%(const duration&lt;_Rep1, <span class="ge">_Period1&gt;&amp; __lhs, const duration&lt;_</span>Rep2, <span class="ge">_Period2&gt;&amp; _</span>_rhs)
{
    typedef typename common_type&lt;_Rep1, <span class="ge">_Rep2&gt;::type _</span>Cr;
    typedef typename common_type&lt;duration&lt;_Rep1, <span class="ge">_Period1&gt;, duration&lt;_</span>Rep2, <span class="ge">_Period2&gt; &gt;::type _</span>Cd;
    return <span class="ge">_Cd(static_</span>cast&lt;_Cr&gt;(_Cd(__lhs).count()) % static_cast&lt;_Cr&gt;(_Cd(__rhs).count()));
}





template &lt;class <span class="ge">_Clock, class _</span>Duration = typename _Clock::duration&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) time_point
{
    <span class="ge">_Static_</span>assert(__is_duration&lt;_Duration&gt;::value, &quot;Second template parameter of time_point must be a std::chrono::duration&quot;);

public:
    typedef _Clock clock;
    typedef _Duration duration;
    typedef typename duration::rep rep;
    typedef typename duration::period period;
private:
    duration __d_;

public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) time_point() : __d_(duration::zero()) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit time_point(const duration&amp; <span class="gs">__d) : __</span>d<span class="ge">_(_</span>_d) {}


    template &lt;class _Duration2&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    time_point(const time_point&lt;clock, _Duration2&gt;&amp; t,
        typename enable_if
        &lt;
            is_convertible&lt;_Duration2, duration&gt;::value
        &gt;::type* = 0)
            : __d_(t.time_since_epoch()) {}



    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) duration time_since_epoch() const {return __d_;}



    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) time_point&amp; operator+=(const duration&amp; <span class="gs">__d) {__</span>d_ += __d; return *this;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) time_point&amp; operator-=(const duration&amp; <span class="gs">__d) {__</span>d_ -= __d; return *this;}



    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static time_point min() throw() {return time_point(duration::min());}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static time_point max() throw() {return time_point(duration::max());}
};

}

template &lt;class <span class="ge">_Clock, class _</span>Duration1, class _Duration2&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) common_type&lt;chrono::time_point&lt;_Clock, _Duration1&gt;,
                                         chrono::time_point&lt;_Clock, _Duration2&gt; &gt;
{
    typedef chrono::time_point&lt;_Clock, typename common_type&lt;_Duration1, _Duration2&gt;::type&gt; type;
};

namespace chrono {

template &lt;class <span class="ge">_ToDuration, class _</span>Clock, class _Duration&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
time_point&lt;_Clock, _ToDuration&gt;
time_point_cast(const time_point&lt;_Clock, <span class="ge">_Duration&gt;&amp; _</span>_t)
{
    return time_point&lt;_Clock, <span class="ge">_ToDuration&gt;(std::__1::chrono::duration_</span>cast&lt;_ToDuration&gt;(__t.time_since_epoch()));
}
template &lt;class <span class="ge">_Clock, class _</span>Duration1, class _Duration2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const time_point&lt;_Clock, <span class="ge">_Duration1&gt;&amp; __lhs, const time_</span>point&lt;_Clock, <span class="ge">_Duration2&gt;&amp; _</span>_rhs)
{
    return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}



template &lt;class <span class="ge">_Clock, class _</span>Duration1, class _Duration2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const time_point&lt;_Clock, <span class="ge">_Duration1&gt;&amp; __lhs, const time_</span>point&lt;_Clock, <span class="ge">_Duration2&gt;&amp; _</span>_rhs)
{
    return !(__lhs == __rhs);
}



template &lt;class <span class="ge">_Clock, class _</span>Duration1, class _Duration2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;(const time_point&lt;_Clock, <span class="ge">_Duration1&gt;&amp; __lhs, const time_</span>point&lt;_Clock, <span class="ge">_Duration2&gt;&amp; _</span>_rhs)
{
    return __lhs.time_since_epoch() &lt; __rhs.time_since_epoch();
}



template &lt;class <span class="ge">_Clock, class _</span>Duration1, class _Duration2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;(const time_point&lt;_Clock, <span class="ge">_Duration1&gt;&amp; __lhs, const time_</span>point&lt;_Clock, <span class="ge">_Duration2&gt;&amp; _</span>_rhs)
{
    return <span class="gs">__rhs &lt; __</span>lhs;
}



template &lt;class <span class="ge">_Clock, class _</span>Duration1, class _Duration2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;=(const time_point&lt;_Clock, <span class="ge">_Duration1&gt;&amp; __lhs, const time_</span>point&lt;_Clock, <span class="ge">_Duration2&gt;&amp; _</span>_rhs)
{
    return !(__rhs &lt; __lhs);
}



template &lt;class <span class="ge">_Clock, class _</span>Duration1, class _Duration2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&gt;=(const time_point&lt;_Clock, <span class="ge">_Duration1&gt;&amp; __lhs, const time_</span>point&lt;_Clock, <span class="ge">_Duration2&gt;&amp; _</span>_rhs)
{
    return !(__lhs &lt; __rhs);
}



template &lt;class <span class="ge">_Clock, class _</span>Duration1, class <span class="ge">_Rep2, class _</span>Period2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
time_point&lt;_Clock, typename common_type&lt;_Duration1, duration&lt;_Rep2, _Period2&gt; &gt;::type&gt;
operator+(const time_point&lt;_Clock, <span class="ge">_Duration1&gt;&amp; __lhs, const duration&lt;_</span>Rep2, <span class="ge">_Period2&gt;&amp; _</span>_rhs)
{
    typedef time_point&lt;_Clock, typename common_type&lt;_Duration1, duration&lt;_Rep2, <span class="ge">_Period2&gt; &gt;::type&gt; _</span>Tr;
    return <span class="ge">_Tr (__lhs.time_</span>since_epoch() + __rhs);
}



template &lt;class <span class="ge">_Rep1, class _</span>Period1, class <span class="ge">_Clock, class _</span>Duration2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
time_point&lt;_Clock, typename common_type&lt;duration&lt;_Rep1, <span class="ge">_Period1&gt;, _</span>Duration2&gt;::type&gt;
operator+(const duration&lt;_Rep1, <span class="ge">_Period1&gt;&amp; __lhs, const time_</span>point&lt;_Clock, <span class="ge">_Duration2&gt;&amp; _</span>_rhs)
{
    return <span class="gs">__rhs + __</span>lhs;
}



template &lt;class <span class="ge">_Clock, class _</span>Duration1, class <span class="ge">_Rep2, class _</span>Period2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
time_point&lt;_Clock, typename common_type&lt;_Duration1, duration&lt;_Rep2, _Period2&gt; &gt;::type&gt;
operator-(const time_point&lt;_Clock, <span class="ge">_Duration1&gt;&amp; __lhs, const duration&lt;_</span>Rep2, <span class="ge">_Period2&gt;&amp; _</span>_rhs)
{
    typedef time_point&lt;_Clock, typename common_type&lt;_Duration1, duration&lt;_Rep2, <span class="ge">_Period2&gt; &gt;::type&gt; _</span>Ret;
    return <span class="ge">_Ret(__lhs.time_</span>since_epoch() -__rhs);
}



template &lt;class <span class="ge">_Clock, class _</span>Duration1, class _Duration2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename common_type&lt;_Duration1, _Duration2&gt;::type
operator-(const time_point&lt;_Clock, <span class="ge">_Duration1&gt;&amp; __lhs, const time_</span>point&lt;_Clock, <span class="ge">_Duration2&gt;&amp; _</span>_rhs)
{
    return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}





class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) system_clock
{
public:
    typedef microseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point&lt;system_clock&gt; time_point;
    static const bool is_steady = false;

    static time_point now() throw();
    static time_t to_time_t (const time_point&amp; __t) throw();
    static time_point from_time_t(time_t __t) throw();
};


class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) steady_clock
{
public:
    typedef nanoseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point&lt;steady_clock, duration&gt; time_point;
    static const bool is_steady = true;

    static time_point now() throw();
};

typedef steady_clock high_resolution_clock;
}
} }


extern &quot;C&quot; {
extern int * __error(void);

}


namespace std { inline namespace __1 {





struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) errc { enum __lx
{
    address_family_not_supported = 47,
    address_in_use = 48,
    address_not_available = 49,
    already_connected = 56,
    argument_list_too_long = 7,
    argument_out_of_domain = 33,
    bad_address = 14,
    bad_file_descriptor = 9,
    bad_message = 94,
    broken_pipe = 32,
    connection_aborted = 53,
    connection_already_in_progress = 37,
    connection_refused = 61,
    connection_reset = 54,
    cross_device_link = 18,
    destination_address_required = 39,
    device_or_resource_busy = 16,
    directory_not_empty = 66,
    executable_format_error = 8,
    file_exists = 17,
    file_too_large = 27,
    filename_too_long = 63,
    function_not_supported = 78,
    host_unreachable = 65,
    identifier_removed = 90,
    illegal_byte_sequence = 92,
    inappropriate_io_control_operation = 25,
    interrupted = 4,
    invalid_argument = 22,
    invalid_seek = 29,
    io_error = 5,
    is_a_directory = 21,
    message_size = 40,
    network_down = 50,
    network_reset = 52,
    network_unreachable = 51,
    no_buffer_space = 55,
    no_child_process = 10,
    no_link = 97,
    no_lock_available = 77,

    no_message_available = 96,



    no_message = 91,
    no_protocol_option = 42,
    no_space_on_device = 28,

    no_stream_resources = 98,



    no_such_device_or_address = 6,
    no_such_device = 19,
    no_such_file_or_directory = 2,
    no_such_process = 3,
    not_a_directory = 20,
    not_a_socket = 38,

    not_a_stream = 99,



    not_connected = 57,
    not_enough_memory = 12,
    not_supported = 45,
    operation_canceled = 89,
    operation_in_progress = 36,
    operation_not_permitted = 1,
    operation_not_supported = 102,
    operation_would_block = 35,
    owner_dead = 105,
    permission_denied = 13,
    protocol_error = 100,
    protocol_not_supported = 43,
    read_only_file_system = 30,
    resource_deadlock_would_occur = 11,
    resource_unavailable_try_again = 35,
    result_out_of_range = 34,
    state_not_recoverable = 104,

    stream_timeout = 101,



    text_file_busy = 26,
    timed_out = 60,
    too_many_files_open_in_system = 23,
    too_many_files_open = 24,
    too_many_links = 31,
    too_many_symbolic_link_levels = 62,
    value_too_large = 84,
    wrong_protocol_type = 41
};
<span class="gs">__lx __</span>v<span class="ge">_; __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) errc(__lx <span class="gs">__v) : __</span>v<span class="ge">_(__v) {} __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit errc(int <span class="gs">__v) : __</span>v<span class="ge">_(static_</span>cast&lt;__lx&gt;(__v)) {} <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) operator int() const {return __v_;} };

} }


namespace std { inline namespace __1 {



template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_error_code_enum
    : public false_type {};
template &lt;class _Tp&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_error_condition_enum
    : public false_type {};






template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_error_condition_enum&lt;errc&gt;
    : true_type { };


template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_error_condition_enum&lt;errc::__lx&gt;
    : true_type { };


class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) error_condition;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) error_code;



class <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) __do_message;

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) error_category
{
public:
    virtual ~error_category() throw();





    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                                  error_category() throw() {}

private:
    error_category(const error_category&amp;);
    error_category&amp; operator=(const error_category&amp;);

public:
    virtual const char* name() const throw() = 0;
    virtual error_condition default_error_condition(int __ev) const throw();
    virtual bool equivalent(int __code, const error_condition&amp; __condition) const throw();
    virtual bool equivalent(const error_code&amp; <span class="gs">__code, int __</span>condition) const throw();
    virtual string message(int __ev) const = 0;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator==(const error_category&amp; <span class="gs">__rhs) const throw() {return this == &amp;__</span>rhs;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator!=(const error_category&amp; <span class="gs">__rhs) const throw() {return !(*this == __</span>rhs);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator&lt; (const error_category&amp; <span class="gs">__rhs) const throw() {return this &lt; &amp;__</span>rhs;}

    friend class <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) __do_message;
};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) __do_message
    : public error_category
{
public:
    virtual string message(int ev) const;
};

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const error_category&amp; generic_category() throw();
<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const error_category&amp; system_category() throw();

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) error_condition
{
    int __val_;
    const error_category* __cat_;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    error_condition() throw() : __val_(0), __cat_(&amp;generic_category()) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    error_condition(int __val, const error_category&amp; __cat) throw()
        : __val_(__val), __cat_(&amp;__cat) {}

    template &lt;class _Ep&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        error_condition(_Ep __e,
              typename enable_if&lt;is_error_condition_enum&lt;_Ep&gt;::value&gt;::type* = 0
                                                                     ) throw()
            {*this = make_error_condition(__e);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void assign(int __val, const error_category&amp; __cat) throw()
    {
        __val_ = __val;
        __cat_ = &amp;__cat;
    }

    template &lt;class _Ep&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        typename enable_if
        &lt;
            is_error_condition_enum&lt;_Ep&gt;::value,
            error_condition&amp;
        &gt;::type
        operator=(_Ep __e) throw()
            {<span class="ge">*this = make_error_condition(__e); return *</span>this;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void clear() throw()
    {
        __val_ = 0;
        __cat_ = &amp;generic_category();
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int value() const throw() {return __val_;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const error_category&amp; category() const throw() {return *__cat_;}
    string message() const;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

        operator bool() const throw() {return __val_ != 0;}
};

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
error_condition
make_error_condition(errc __e) throw()
{
    return error_condition(static_cast&lt;int&gt;(__e), generic_category());
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;(const error_condition&amp; __x, const error_condition&amp; __y) throw()
{
    return <span class="gs">__x.category() &lt; __</span>y.category()
        || (<span class="gs">__x.category() == __</span>y.category() &amp;&amp; <span class="gs">__x.value() &lt; __</span>y.value());
}



class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) error_code
{
    int __val_;
    const error_category* __cat_;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    error_code() throw() : __val_(0), __cat_(&amp;system_category()) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    error_code(int __val, const error_category&amp; __cat) throw()
        : __val_(__val), __cat_(&amp;__cat) {}

    template &lt;class _Ep&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        error_code(_Ep __e,
                   typename enable_if&lt;is_error_code_enum&lt;_Ep&gt;::value&gt;::type* = 0
                                                                     ) throw()
            {*this = make_error_code(__e);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void assign(int __val, const error_category&amp; __cat) throw()
    {
        __val_ = __val;
        __cat_ = &amp;__cat;
    }

    template &lt;class _Ep&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        typename enable_if
        &lt;
            is_error_code_enum&lt;_Ep&gt;::value,
            error_code&amp;
        &gt;::type
        operator=(_Ep __e) throw()
            {<span class="ge">*this = make_error_code(__e); return *</span>this;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void clear() throw()
    {
        __val_ = 0;
        __cat_ = &amp;system_category();
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int value() const throw() {return __val_;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const error_category&amp; category() const throw() {return *__cat_;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    error_condition default_error_condition() const throw()
        {return __cat_-&gt;default_error_condition(__val_);}

    string message() const;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

        operator bool() const throw() {return __val_ != 0;}
};

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
error_code
make_error_code(errc __e) throw()
{
    return error_code(static_cast&lt;int&gt;(__e), generic_category());
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator&lt;(const error_code&amp; __x, const error_code&amp; __y) throw()
{
    return <span class="gs">__x.category() &lt; __</span>y.category()
        || (<span class="gs">__x.category() == __</span>y.category() &amp;&amp; <span class="gs">__x.value() &lt; __</span>y.value());
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const error_code&amp; __x, const error_code&amp; __y) throw()
{
    return <span class="gs">__x.category() == __</span>y.category() &amp;&amp; <span class="gs">__x.value() == __</span>y.value();
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const error_code&amp; __x, const error_condition&amp; __y) throw()
{
    return <span class="gs">__x.category().equivalent(__</span>x.value(), __y)
        || <span class="gs">__y.category().equivalent(__</span>x, __y.value());
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const error_condition&amp; __x, const error_code&amp; __y) throw()
{
    return <span class="gs">__y == __</span>x;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator==(const error_condition&amp; __x, const error_condition&amp; __y) throw()
{
    return <span class="gs">__x.category() == __</span>y.category() &amp;&amp; <span class="gs">__x.value() == __</span>y.value();
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const error_code&amp; __x, const error_code&amp; __y) throw()
{return !(__x == __y);}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const error_code&amp; __x, const error_condition&amp; __y) throw()
{return !(__x == __y);}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const error_condition&amp; __x, const error_code&amp; __y) throw()
{return !(__x == __y);}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
operator!=(const error_condition&amp; __x, const error_condition&amp; __y) throw()
{return !(__x == __y);}

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;error_code&gt;
    : public unary_function&lt;error_code, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(const error_code&amp; __ec) const throw()
    {
        return static_cast&lt;size_t&gt;(__ec.value());
    }
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;error_condition&gt;
    : public unary_function&lt;error_condition, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(const error_condition&amp; __ec) const throw()
    {
        return static_cast&lt;size_t&gt;(__ec.value());
    }
};



class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) system_error
    : public runtime_error
{
    error_code __ec_;
public:
    system_error(error_code <span class="gs">__ec, const string&amp; __</span>what_arg);
    system_error(error_code <span class="gs">__ec, const char* __</span>what_arg);
    system_error(error_code __ec);
    system_error(int __ev, const error_category&amp; <span class="gs">__ecat, const string&amp; __</span>what_arg);
    system_error(int __ev, const error_category&amp; <span class="gs">__ecat, const char* __</span>what_arg);
    system_error(int __ev, const error_category&amp; __ecat);
    ~system_error() throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const error_code&amp; code() const throw() {return __ec_;}

private:
    static string __init(const error_code&amp;, string);
};

<span class="gs">__attribute__</span> ((noreturn)) <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;)))
void __throw_system_error(int ev, const char* what_arg);

} }







<span class="gh">#pragma clang assume_nonnull begin</span>
<span class="gh">#pragma clang assume_nonnull end</span>

extern &quot;C&quot; {




struct sched_param { int sched_priority; char __opaque[4]; };




extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}



typedef __darwin_pthread_cond_t pthread_cond_t;
typedef __darwin_pthread_condattr_t pthread_condattr_t;
typedef __darwin_pthread_key_t pthread_key_t;
typedef __darwin_pthread_mutex_t pthread_mutex_t;
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
typedef __darwin_pthread_once_t pthread_once_t;
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
typedef __darwin_pthread_t pthread_t;

enum { QOS_CLASS_USER_INTERACTIVE <span class="gs">__attribute__</span>((availability(macos,introduced=10.10))) <span class="gs">__attribute__</span>((availability(ios,introduced=8.0))) = 0x21, QOS_CLASS_USER_INITIATED <span class="gs">__attribute__</span>((availability(macos,introduced=10.10))) <span class="gs">__attribute__</span>((availability(ios,introduced=8.0))) = 0x19, QOS_CLASS_DEFAULT <span class="gs">__attribute__</span>((availability(macos,introduced=10.10))) <span class="gs">__attribute__</span>((availability(ios,introduced=8.0))) = 0x15, QOS_CLASS_UTILITY <span class="gs">__attribute__</span>((availability(macos,introduced=10.10))) <span class="gs">__attribute__</span>((availability(ios,introduced=8.0))) = 0x11, QOS_CLASS_BACKGROUND <span class="gs">__attribute__</span>((availability(macos,introduced=10.10))) <span class="gs">__attribute__</span>((availability(ios,introduced=8.0))) = 0x09, QOS_CLASS_UNSPECIFIED <span class="gs">__attribute__</span>((availability(macos,introduced=10.10))) <span class="gs">__attribute__</span>((availability(ios,introduced=8.0))) = 0x00, }; typedef unsigned int qos_class_t;
extern &quot;C&quot; {
<span class="gs">__attribute__</span>((availability(macos,introduced=10.10))) <span class="gs">__attribute__</span>((availability(ios,introduced=8.0)))
qos_class_t
qos_class_self(void);
<span class="gs">__attribute__</span>((availability(macos,introduced=10.10))) <span class="gs">__attribute__</span>((availability(ios,introduced=8.0)))
qos_class_t
qos_class_main(void);

}




<span class="gh">#pragma clang assume_nonnull begin</span>

extern &quot;C&quot; {
<span class="gs">__attribute__</span>((availability(macos,introduced=10.10))) <span class="gs">__attribute__</span>((availability(ios,introduced=8.0)))
int
pthread_attr_set_qos_class_np(pthread_attr_t *__attr,
  qos_class_t __qos_class, int __relative_priority);
<span class="gs">__attribute__</span>((availability(macos,introduced=10.10))) <span class="gs">__attribute__</span>((availability(ios,introduced=8.0)))
int
pthread_attr_get_qos_class_np(pthread_attr_t * __attr,
  qos_class_t * <span class="ge">_Nullable __qos_</span>class,
  int * <span class="ge">_Nullable __relative_</span>priority);
<span class="gs">__attribute__</span>((availability(macos,introduced=10.10))) <span class="gs">__attribute__</span>((availability(ios,introduced=8.0)))
int
pthread_set_qos_class_self_np(qos_class_t __qos_class,
  int __relative_priority);
<span class="gs">__attribute__</span>((availability(macos,introduced=10.10))) <span class="gs">__attribute__</span>((availability(ios,introduced=8.0)))
int
pthread_get_qos_class_np(pthread_t __pthread,
  qos_class_t * <span class="ge">_Nullable __qos_</span>class,
  int * <span class="ge">_Nullable __relative_</span>priority);
typedef struct pthread_override_s* pthread_override_t;
<span class="gs">__attribute__</span>((availability(macos,introduced=10.10))) <span class="gs">__attribute__</span>((availability(ios,introduced=8.0)))
pthread_override_t
pthread_override_qos_class_start_np(pthread_t __pthread,
  qos_class_t __qos_class, int __relative_priority);
<span class="gs">__attribute__</span>((availability(macos,introduced=10.10))) <span class="gs">__attribute__</span>((availability(ios,introduced=8.0)))
int
pthread_override_qos_class_end_np(pthread_override_t __override);

}
<span class="gh">#pragma clang assume_nonnull end</span>



typedef __darwin_mach_port_t mach_port_t;
<span class="gh">#pragma clang assume_nonnull begin</span>

extern &quot;C&quot; {
<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_atfork(void (* <span class="ge">_Nullable)(void), void (* _</span>Nullable)(void),
  void (* _Nullable)(void));

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_destroy(pthread_attr_t *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_getdetachstate(const pthread_attr_t <span class="ge">*, int *</span>);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_getguardsize(const pthread_attr_t * , size_t * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_getinheritsched(const pthread_attr_t * , int * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_getschedparam(const pthread_attr_t * ,
  struct sched_param * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_getschedpolicy(const pthread_attr_t * , int * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_getscope(const pthread_attr_t * , int * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_getstack(const pthread_attr_t * ,
  void * <span class="ge">_Nullable * _</span>Nonnull , size_t * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_getstackaddr(const pthread_attr_t * ,
  void * <span class="ge">_Nullable * _</span>Nonnull );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_getstacksize(const pthread_attr_t * , size_t * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_init(pthread_attr_t *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_setdetachstate(pthread_attr_t *, int);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_setguardsize(pthread_attr_t *, size_t);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_setinheritsched(pthread_attr_t *, int);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_setschedparam(pthread_attr_t * ,
  const struct sched_param * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_setschedpolicy(pthread_attr_t *, int);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_setscope(pthread_attr_t *, int);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_setstack(pthread_attr_t <span class="ge">*, void *</span>, size_t);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_setstackaddr(pthread_attr_t <span class="ge">*, void *</span>);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_attr_setstacksize(pthread_attr_t *, size_t);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_cancel(pthread_t) __asm(&quot;_&quot; &quot;pthread_cancel&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_cond_broadcast(pthread_cond_t *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_cond_destroy(pthread_cond_t *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_cond_init(
  pthread_cond_t * ,
  const pthread_condattr_t * _Nullable )
  __asm(&quot;_&quot; &quot;pthread_cond_init&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_cond_signal(pthread_cond_t *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_cond_timedwait(
  pthread_cond_t * , pthread_mutex_t * ,
  const struct timespec * _Nullable )
  __asm(&quot;_&quot; &quot;pthread_cond_timedwait&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_cond_wait(pthread_cond_t * ,
  pthread_mutex_t * ) __asm(&quot;_&quot; &quot;pthread_cond_wait&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_condattr_destroy(pthread_condattr_t *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_condattr_init(pthread_condattr_t *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_condattr_getpshared(const pthread_condattr_t * ,
  int * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_condattr_setpshared(pthread_condattr_t *, int);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))

int pthread_create(pthread_t <span class="ge">_Nullable * _</span>Nonnull ,
  const pthread_attr_t * _Nullable ,
  void * <span class="ge">_Nullable (* _</span>Nonnull)(void * _Nullable),
  void * _Nullable );






<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_detach(pthread_t);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_equal(pthread_t <span class="ge">_Nullable, pthread_</span>t _Nullable);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
void pthread_exit(void * <span class="ge">_Nullable) __attribute__((__noreturn_</span>_));

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_getconcurrency(void);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_getschedparam(pthread_t , int * _Nullable ,
  struct sched_param * _Nullable );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
void* <span class="ge">_Nullable pthread_</span>getspecific(pthread_key_t);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_join(pthread_t , void * <span class="ge">_Nullable * _</span>Nullable)
  __asm(&quot;_&quot; &quot;pthread_join&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_key_create(pthread_key_t <span class="ge">*, void (*</span> _Nullable)(void *));

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_key_delete(pthread_key_t);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutex_destroy(pthread_mutex_t *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutex_getprioceiling(const pthread_mutex_t * ,
  int * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutex_init(pthread_mutex_t * ,
  const pthread_mutexattr_t * _Nullable );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutex_lock(pthread_mutex_t *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutex_setprioceiling(pthread_mutex_t * , int,
  int * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutex_trylock(pthread_mutex_t *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutex_unlock(pthread_mutex_t *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm(&quot;_&quot; &quot;pthread_mutexattr_destroy&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * ,
  int * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * ,
  int * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutexattr_getpshared(const pthread_mutexattr_t * ,
  int * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutexattr_gettype(const pthread_mutexattr_t * ,
  int * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.13.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=11.3))) <span class="gs">__attribute__</span>((availability(watchos,introduced=4.3))) <span class="gs">__attribute__</span>((availability(tvos,introduced=11.3)))
int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t * ,
  int * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutexattr_init(pthread_mutexattr_t *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.7))) <span class="gs">__attribute__</span>((availability(ios,introduced=5.0)))
int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t *, int);

<span class="gs">__attribute__</span>((availability(swift,unavailable,message=&quot;Use lazily initialized globals instead&quot;)))
<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_once(pthread_once_t <span class="ge">*, void (*</span> _Nonnull)(void));

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm(&quot;_&quot; &quot;pthread_rwlock_destroy&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_rwlock_init(pthread_rwlock_t * ,
  const pthread_rwlockattr_t * _Nullable )
  __asm(&quot;_&quot; &quot;pthread_rwlock_init&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm(&quot;_&quot; &quot;pthread_rwlock_rdlock&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm(&quot;_&quot; &quot;pthread_rwlock_tryrdlock&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm(&quot;_&quot; &quot;pthread_rwlock_trywrlock&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm(&quot;_&quot; &quot;pthread_rwlock_wrlock&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_rwlock_unlock(pthread_rwlock_t *) __asm(&quot;_&quot; &quot;pthread_rwlock_unlock&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * ,
  int * );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_rwlockattr_init(pthread_rwlockattr_t *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
pthread_t pthread_self(void);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_setcancelstate(int , int * _Nullable)
  __asm(&quot;_&quot; &quot;pthread_setcancelstate&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_setcanceltype(int , int * _Nullable)
  __asm(&quot;_&quot; &quot;pthread_setcanceltype&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_setconcurrency(int);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_setschedparam(pthread_t, int, const struct sched_param *);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_setspecific(pthread_key_t , const void * _Nullable);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
void pthread_testcancel(void) __asm(&quot;_&quot; &quot;pthread_testcancel&quot; );




<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_is_threaded_np(void);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.6))) <span class="gs">__attribute__</span>((availability(ios,introduced=3.2)))
int pthread_threadid_np(pthread_t <span class="ge">_Nullable,__uint64_</span>t* _Nullable);


<span class="gs">__attribute__</span>((availability(macos,introduced=10.6))) <span class="gs">__attribute__</span>((availability(ios,introduced=3.2)))
int pthread_getname_np(pthread_t,char*,size_t);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.6))) <span class="gs">__attribute__</span>((availability(ios,introduced=3.2)))
int pthread_setname_np(const char*);


<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_main_np(void);


<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
mach_port_t pthread_mach_thread_np(pthread_t);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
size_t pthread_get_stacksize_np(pthread_t);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
void* pthread_get_stackaddr_np(pthread_t);


<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t _Nullable);


<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_cond_timedwait_relative_np(pthread_cond_t <span class="ge">*, pthread_mutex_t *</span>,
  const struct timespec * _Nullable);


<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))

int pthread_create_suspended_np(
  pthread_t <span class="ge">_Nullable * _</span>Nonnull, const pthread_attr_t * _Nullable,
  void * <span class="ge">_Nullable (* _</span>Nonnull)(void * <span class="ge">_Nullable), void * _</span>Nullable);





<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_kill(pthread_t, int);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.5))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
<span class="ge">_Nullable pthread_</span>t pthread_from_mach_thread_np(mach_port_t);

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
int pthread_sigmask(int, const sigset_t * <span class="ge">_Nullable, sigset_</span>t * _Nullable)
  __asm(&quot;_&quot; &quot;pthread_sigmask&quot; );

<span class="gs">__attribute__</span>((availability(macos,introduced=10.4))) <span class="gs">__attribute__</span>((availability(ios,introduced=2.0)))
void pthread_yield_np(void);

<span class="gs">__attribute__</span>((availability(macos,introduced=11.0)))
<span class="gs">__attribute__</span>((availability(ios,unavailable))) <span class="gs">__attribute__</span>((availability(tvos,unavailable))) <span class="gs">__attribute__</span>((availability(watchos,unavailable)))
void pthread_jit_write_protect_np(int enabled);

<span class="gs">__attribute__</span>((availability(macos,introduced=11.0)))
<span class="gs">__attribute__</span>((availability(ios,unavailable))) <span class="gs">__attribute__</span>((availability(tvos,unavailable))) <span class="gs">__attribute__</span>((availability(watchos,unavailable)))
int pthread_jit_write_protect_supported_np(void);
<span class="gs">__attribute__</span>((availability(macos,introduced=11.0))) <span class="gs">__attribute__</span>((availability(ios,introduced=14.2))) <span class="gs">__attribute__</span>((availability(tvos,introduced=14.2))) <span class="gs">__attribute__</span>((availability(watchos,introduced=7.1)))
int
pthread_cpu_number_np(size_t *cpu_number_out);


}
<span class="gh">#pragma clang assume_nonnull end</span>
typedef ::timespec __libcpp_timespec_t;





namespace std { inline namespace __1 {





typedef pthread_mutex_t __libcpp_mutex_t;


typedef pthread_mutex_t __libcpp_recursive_mutex_t;


typedef pthread_cond_t __libcpp_condvar_t;



typedef pthread_once_t __libcpp_exec_once_flag;



typedef pthread_t __libcpp_thread_id;




typedef pthread_t __libcpp_thread_t;


typedef pthread_key_t __libcpp_tls_key;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_mutex_lock(__libcpp_mutex_t *__m);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_mutex_unlock(__libcpp_mutex_t *__m);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_mutex_destroy(__libcpp_mutex_t *__m);


inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_condvar_signal(__libcpp_condvar_t* __cv);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_condvar_broadcast(__libcpp_condvar_t* __cv);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_condvar_wait(__libcpp_condvar_t* <span class="gs">__cv, __</span>libcpp_mutex_t* __m);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_condvar_timedwait(__libcpp_condvar_t <span class="ge">*__cv, __libcpp_mutex_t *</span>__m,
                               __libcpp_timespec_t *__ts);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_condvar_destroy(__libcpp_condvar_t* __cv);


inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_execute_once(__libcpp_exec_once_flag *flag,
                          void (*init_routine)());


inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2);


inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool __libcpp_thread_isnull(const __libcpp_thread_t *__t);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_thread_create(__libcpp_thread_t <span class="ge">*__t, void *</span>(<span class="ge">*__func)(void *</span>),
                           void *__arg);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__libcpp_thread_id __libcpp_thread_get_current_id();

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_thread_join(__libcpp_thread_t *__t);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_thread_detach(__libcpp_thread_t *__t);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __libcpp_thread_yield();

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __libcpp_thread_sleep_for(const chrono::nanoseconds&amp; __ns);


inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_tls_create(__libcpp_tls_key* __key,
                        void(* __at_exit)(void*));

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void *__libcpp_tls_get(__libcpp_tls_key __key);

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
int __libcpp_tls_set(__libcpp_tls_key <span class="gs">__key, void *__</span>p);







int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m)
{
  pthread_mutexattr_t attr;
  int __ec = pthread_mutexattr_init(&amp;attr);
  if (__ec)
    return __ec;
  __ec = pthread_mutexattr_settype(&amp;attr, 2);
  if (__ec) {
    pthread_mutexattr_destroy(&amp;attr);
    return __ec;
  }
  __ec = pthread_mutex_init(__m, &amp;attr);
  if (__ec) {
    pthread_mutexattr_destroy(&amp;attr);
    return __ec;
  }
  __ec = pthread_mutexattr_destroy(&amp;attr);
  if (__ec) {
    pthread_mutex_destroy(__m);
    return __ec;
  }
  return 0;
}

int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_lock(__m);
}

bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_trylock(__m) == 0;
}

int __libcpp_recursive_mutex_unlock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_unlock(__m);
}

int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_destroy(__m);
}

int __libcpp_mutex_lock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_lock(__m);
}

bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_trylock(__m) == 0;
}

int __libcpp_mutex_unlock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_unlock(__m);
}

int __libcpp_mutex_destroy(__libcpp_mutex_t *__m)
{
  return pthread_mutex_destroy(__m);
}


int __libcpp_condvar_signal(__libcpp_condvar_t *__cv)
{
  return pthread_cond_signal(__cv);
}

int __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv)
{
  return pthread_cond_broadcast(__cv);
}

int __libcpp_condvar_wait(__libcpp_condvar_t <span class="ge">*__cv, __libcpp_mutex_t *</span>__m)
{
  return pthread_cond_wait(__cv, __m);
}

int __libcpp_condvar_timedwait(__libcpp_condvar_t <span class="ge">*__cv, __libcpp_mutex_t *</span>__m,
                               __libcpp_timespec_t *__ts)
{
  return pthread_cond_timedwait(__cv, <span class="gs">__m, __</span>ts);
}

int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv)
{
  return pthread_cond_destroy(__cv);
}


int __libcpp_execute_once(__libcpp_exec_once_flag *flag,
                          void (*init_routine)()) {
  return pthread_once(flag, init_routine);
}



bool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2)
{
  return pthread_equal(t1, t2) != 0;
}


bool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2)
{
  return t1 &lt; t2;
}


bool __libcpp_thread_isnull(const __libcpp_thread_t *__t) {
  return *__t == 0;
}

int __libcpp_thread_create(__libcpp_thread_t <span class="ge">*__t, void *</span>(<span class="ge">*__func)(void *</span>),
                           void *__arg)
{
  return pthread_create(__t, 0, <span class="gs">__func, __</span>arg);
}

__libcpp_thread_id __libcpp_thread_get_current_id()
{
  return pthread_self();
}

__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t)
{
  return *__t;
}

int __libcpp_thread_join(__libcpp_thread_t *__t)
{
  return pthread_join(*__t, 0);
}

int __libcpp_thread_detach(__libcpp_thread_t *__t)
{
  return pthread_detach(*__t);
}

void __libcpp_thread_yield()
{
  sched_yield();
}

void __libcpp_thread_sleep_for(const chrono::nanoseconds&amp; __ns)
{
   using namespace chrono;
   seconds __s = duration_cast&lt;seconds&gt;(__ns);
   __libcpp_timespec_t __ts;
   typedef <span class="gs">__decltype(__</span>ts.tv_sec) ts_sec;
                     ts_sec __ts_sec_max = numeric_limits&lt;ts_sec&gt;::max();

   if (<span class="gs">__s.count() &lt; __</span>ts_sec_max)
   {
     __ts.tv_sec = static_cast&lt;ts_sec&gt;(__s.count());
     __ts.tv_nsec = static_cast&lt;__decltype(__ts.tv_nsec)&gt;((__ns - __s).count());
   }
   else
   {
     __ts.tv_sec = __ts_sec_max;
     __ts.tv_nsec = 999999999;
   }

   while (nanosleep(&amp;__ts, &amp;<span class="gs">__ts) == -1 &amp;&amp; (*__</span>error()) == 4);
}


int __libcpp_tls_create(__libcpp_tls_key <span class="ge">*__key, void (*</span>__at_exit)(void *))
{
  return pthread_key_create(__key, __at_exit);
}

void *__libcpp_tls_get(__libcpp_tls_key __key)
{
  return pthread_getspecific(__key);
}

int __libcpp_tls_set(__libcpp_tls_key <span class="gs">__key, void *__</span>p)
{
    return pthread_setspecific(__key, __p);
}



class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) thread;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __thread_id;

namespace this_thread
{

<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __thread_id get_id() throw();

}

template&lt;&gt; struct hash&lt;__thread_id&gt;;

class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) __thread_id
{



    __libcpp_thread_id __id_;

public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __thread_id() throw() : __id_(0) {}

    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        bool operator==(__thread_id <span class="gs">__x, __</span>thread_id __y) throw()
        {
        if (<span class="gs">__x.__</span>id_ == 0) return <span class="gs">__y.__</span>id_ == 0;
        if (<span class="gs">__y.__</span>id_ == 0) return false;
        return __libcpp_thread_id_equal(__x.__id_, <span class="gs">__y.__</span>id_);
        }
    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        bool operator!=(__thread_id <span class="gs">__x, __</span>thread_id __y) throw()
        {return !(__x == __y);}
    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        bool operator&lt; (__thread_id <span class="gs">__x, __</span>thread_id __y) throw()
        {
        if (<span class="gs">__x.__</span>id_ == 0) return <span class="gs">__y.__</span>id_ != 0;
        if (<span class="gs">__y.__</span>id_ == 0) return false;
        return __libcpp_thread_id_less(__x.__id_, <span class="gs">__y.__</span>id_);
        }
    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        bool operator&lt;=(__thread_id <span class="gs">__x, __</span>thread_id __y) throw()
        {return !(__y &lt; __x);}
    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        bool operator&gt; (__thread_id <span class="gs">__x, __</span>thread_id __y) throw()
        {return <span class="gs">__y &lt; __</span>x ;}
    friend <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        bool operator&gt;=(__thread_id <span class="gs">__x, __</span>thread_id __y) throw()
        {return !(__x &lt; __y);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void <span class="gs">__reset() { __</span>id_ = 0; }

    template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
    friend
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_ostream&lt;_CharT, _Traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __os, __thread_</span>id __id);

private:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __thread_id(__libcpp_thread_id <span class="gs">__id) : __</span>id_(__id) {}

    friend __thread_id this_thread::get_id() throw();
    friend class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) thread;
    friend struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;__thread_id&gt;;
};

namespace this_thread
{

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__thread_id
get_id() throw()
{
    return __libcpp_thread_get_current_id();
}

}



} }





namespace std { inline namespace __1 {



class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) mutex
{
    __libcpp_mutex_t __m_ = {0x32AAABA7, {0}};

public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                      mutex() = default;

    mutex(const mutex&amp;) = delete;
    mutex&amp; operator=(const mutex&amp;) = delete;




    ~mutex() throw();


    void lock() ;
    bool try_lock() throw() ;
    void unlock() throw() ;

    typedef __libcpp_mutex_t* native_handle_type;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) native_handle_type native_handle() {return &amp;__m_;}
};

<span class="ge">_Static_</span>assert(is_nothrow_default_constructible&lt;mutex&gt;::value, &quot;the default constructor for std::mutex must be nothrow&quot;);


struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) defer_lock_t { explicit defer_lock_t() = default; };
struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) try_to_lock_t { explicit try_to_lock_t() = default; };
struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) adopt_lock_t { explicit adopt_lock_t() = default; };



extern <span class="gs">__attribute__</span>((__visibility__(&quot;default&quot;))) const defer_lock_t defer_lock;
extern <span class="gs">__attribute__</span>((__visibility__(&quot;default&quot;))) const try_to_lock_t try_to_lock;
extern <span class="gs">__attribute__</span>((__visibility__(&quot;default&quot;))) const adopt_lock_t adopt_lock;
template &lt;class _Mutex&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;)))
lock_guard
{
public:
    typedef <span class="ge">_Mutex mutex_</span>type;

private:
    mutex_type&amp; __m_;
public:

                          <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit lock_guard(mutex_type&amp; __m)
        : __m_(__m) {__m_.lock();}

                          <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    lock_guard(mutex_type&amp; __m, adopt_lock_t)
        : __m_(__m) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~lock_guard() {__m_.unlock();}

private:
    lock_guard(lock_guard const&amp;) ;
    lock_guard&amp; operator=(lock_guard const&amp;) ;
};

template &lt;class _Mutex&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) unique_lock
{
public:
    typedef <span class="ge">_Mutex mutex_</span>type;

private:
    mutex_type* __m_;
    bool __owns_;

public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    unique_lock() throw() : __m_(std::__1::__get_nullptr_t()), __owns_(false) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit unique_lock(mutex_type&amp; __m)
        : __m_(std::__1::addressof(__m)), __owns_(true) {__m_-&gt;lock();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    unique_lock(mutex_type&amp; __m, defer_lock_t) throw()
        : __m_(std::__1::addressof(__m)), __owns_(false) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    unique_lock(mutex_type&amp; __m, try_to_lock_t)
        : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock()) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    unique_lock(mutex_type&amp; __m, adopt_lock_t)
        : __m_(std::__1::addressof(__m)), __owns_(true) {}
    template &lt;class <span class="ge">_Clock, class _</span>Duration&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        unique_lock(mutex_type&amp; __m, const chrono::time_point&lt;_Clock, <span class="ge">_Duration&gt;&amp; _</span>_t)
            : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock_until(__t)) {}
    template &lt;class <span class="ge">_Rep, class _</span>Period&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        unique_lock(mutex_type&amp; __m, const chrono::duration&lt;_Rep, <span class="ge">_Period&gt;&amp; _</span>_d)
            : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock_for(__d)) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~unique_lock()
    {
        if (__owns_)
            __m_-&gt;unlock();
    }

private:
    unique_lock(unique_lock const&amp;);
    unique_lock&amp; operator=(unique_lock const&amp;);

public:
    void lock();
    bool try_lock();

    template &lt;class <span class="ge">_Rep, class _</span>Period&gt;
        bool try_lock_for(const chrono::duration&lt;_Rep, <span class="ge">_Period&gt;&amp; _</span>_d);
    template &lt;class <span class="ge">_Clock, class _</span>Duration&gt;
        bool try_lock_until(const chrono::time_point&lt;_Clock, <span class="ge">_Duration&gt;&amp; _</span>_t);

    void unlock();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void swap(unique_lock&amp; __u) throw()
    {
        std::__1::swap(__m_, <span class="gs">__u.__</span>m_);
        std::__1::swap(__owns_, <span class="gs">__u.__</span>owns_);
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    mutex_type* release() throw()
    {
        mutex_type* <span class="gs">__m = __</span>m_;
        __m_ = std::__1::__get_nullptr_t();
        __owns_ = false;
        return __m;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool owns_lock() const throw() {return __owns_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

        operator bool () const throw() {return __owns_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    mutex_type* mutex() const throw() {return __m_;}
};

template &lt;class _Mutex&gt;
void
unique_lock&lt;_Mutex&gt;::lock()
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, &quot;unique_lock::lock: references null mutex&quot;);
    if (__owns_)
        __throw_system_error(11, &quot;unique_lock::lock: already locked&quot;);
    __m_-&gt;lock();
    __owns_ = true;
}

template &lt;class _Mutex&gt;
bool
unique_lock&lt;_Mutex&gt;::try_lock()
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, &quot;unique_lock::try_lock: references null mutex&quot;);
    if (__owns_)
        __throw_system_error(11, &quot;unique_lock::try_lock: already locked&quot;);
    __owns_ = __m_-&gt;try_lock();
    return __owns_;
}

template &lt;class _Mutex&gt;
template &lt;class <span class="ge">_Rep, class _</span>Period&gt;
bool
unique_lock&lt;_Mutex&gt;::try_lock_for(const chrono::duration&lt;_Rep, <span class="ge">_Period&gt;&amp; _</span>_d)
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, &quot;unique_lock::try_lock_for: references null mutex&quot;);
    if (__owns_)
        __throw_system_error(11, &quot;unique_lock::try_lock_for: already locked&quot;);
    __owns_ = __m_-&gt;try_lock_for(__d);
    return __owns_;
}

template &lt;class _Mutex&gt;
template &lt;class <span class="ge">_Clock, class _</span>Duration&gt;
bool
unique_lock&lt;_Mutex&gt;::try_lock_until(const chrono::time_point&lt;_Clock, <span class="ge">_Duration&gt;&amp; _</span>_t)
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, &quot;unique_lock::try_lock_until: references null mutex&quot;);
    if (__owns_)
        __throw_system_error(11, &quot;unique_lock::try_lock_until: already locked&quot;);
    __owns_ = __m_-&gt;try_lock_until(__t);
    return __owns_;
}

template &lt;class _Mutex&gt;
void
unique_lock&lt;_Mutex&gt;::unlock()
{
    if (!__owns_)
        __throw_system_error(1, &quot;unique_lock::unlock: not locked&quot;);
    __m_-&gt;unlock();
    __owns_ = false;
}

template &lt;class _Mutex&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
swap(unique_lock&lt;_Mutex&gt;&amp; __x, unique_lock&lt;_Mutex&gt;&amp; __y) throw()
    {<span class="gs">__x.swap(__</span>y);}


struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) cv_status { enum __lx
{
    no_timeout,
    timeout
};
<span class="gs">__lx __</span>v<span class="ge">_; __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) cv_status(__lx <span class="gs">__v) : __</span>v<span class="ge">_(__v) {} __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit cv_status(int <span class="gs">__v) : __</span>v<span class="ge">_(static_</span>cast&lt;__lx&gt;(__v)) {} <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) operator int() const {return __v_;} };

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) condition_variable
{
    __libcpp_condvar_t __cv_ = {0x3CB0B1BB, {0}};
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                      condition_variable() throw() = default;




    ~condition_variable();


    condition_variable(const condition_variable&amp;) = delete;
    condition_variable&amp; operator=(const condition_variable&amp;) = delete;

    void notify_one() throw();
    void notify_all() throw();

    void wait(unique_lock&lt;mutex&gt;&amp; __lk) throw();
    template &lt;class _Predicate&gt;
        inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
        void wait(unique_lock&lt;mutex&gt;&amp; __lk, <span class="ge">_Predicate _</span>_pred);

    template &lt;class <span class="ge">_Clock, class _</span>Duration&gt;
        inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
        cv_status
        wait_until(unique_lock&lt;mutex&gt;&amp; __lk,
                   const chrono::time_point&lt;_Clock, <span class="ge">_Duration&gt;&amp; _</span>_t);

    template &lt;class <span class="ge">_Clock, class _</span>Duration, class _Predicate&gt;
        inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
        bool
        wait_until(unique_lock&lt;mutex&gt;&amp; __lk,
                   const chrono::time_point&lt;_Clock, <span class="ge">_Duration&gt;&amp; _</span>_t,
                   <span class="ge">_Predicate _</span>_pred);

    template &lt;class <span class="ge">_Rep, class _</span>Period&gt;
        inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
        cv_status
        wait_for(unique_lock&lt;mutex&gt;&amp; __lk,
                 const chrono::duration&lt;_Rep, <span class="ge">_Period&gt;&amp; _</span>_d);

    template &lt;class <span class="ge">_Rep, class _</span>Period, class _Predicate&gt;
        bool
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        wait_for(unique_lock&lt;mutex&gt;&amp; __lk,
                 const chrono::duration&lt;_Rep, <span class="ge">_Period&gt;&amp; _</span>_d,
                 <span class="ge">_Predicate _</span>_pred);

    typedef __libcpp_condvar_t* native_handle_type;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) native_handle_type native_handle() {return &amp;__cv_;}

private:
    void __do_timed_wait(unique_lock&lt;mutex&gt;&amp; __lk,
       chrono::time_point&lt;chrono::system_clock, chrono::nanoseconds&gt;) throw();




    template &lt;class _Clock&gt;
    void __do_timed_wait(unique_lock&lt;mutex&gt;&amp; __lk,
       chrono::time_point&lt;_Clock, chrono::nanoseconds&gt;) throw();
};


template &lt;class <span class="ge">_Rep, class _</span>Period&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_floating_point&lt;_Rep&gt;::value,
    chrono::nanoseconds
&gt;::type
__safe_nanosecond_cast(chrono::duration&lt;_Rep, <span class="ge">_Period&gt; _</span>_d)
{
    using namespace chrono;
    using __ratio = ratio_divide&lt;_Period, nano&gt;;
    using __ns_rep = nanoseconds::rep;
    <span class="ge">_Rep __result_</span>float = <span class="gs">__d.count() * __</span>ratio::num / __ratio::den;

    <span class="ge">_Rep __result_</span>max = numeric_limits&lt;__ns_rep&gt;::max();
    if (__result_float &gt;= __result_max) {
        return nanoseconds::max();
    }

    <span class="ge">_Rep __result_</span>min = numeric_limits&lt;__ns_rep&gt;::min();
    if (__result_float &lt;= __result_min) {
        return nanoseconds::min();
    }

    return nanoseconds(static_cast&lt;__ns_rep&gt;(__result_float));
}

template &lt;class <span class="ge">_Rep, class _</span>Period&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    !is_floating_point&lt;_Rep&gt;::value,
    chrono::nanoseconds
&gt;::type
__safe_nanosecond_cast(chrono::duration&lt;_Rep, <span class="ge">_Period&gt; _</span>_d)
{
    using namespace chrono;
    if (__d.count() == 0) {
        return nanoseconds(0);
    }

    using __ratio = ratio_divide&lt;_Period, nano&gt;;
    using __ns_rep = nanoseconds::rep;
    __ns_rep __result_max = std::numeric_limits&lt;__ns_rep&gt;::max();
    if (<span class="gs">__d.count() &gt; 0 &amp;&amp; __</span>d.count() &gt; __result_max / __ratio::num) {
        return nanoseconds::max();
    }

    __ns_rep __result_min = std::numeric_limits&lt;__ns_rep&gt;::min();
    if (<span class="gs">__d.count() &lt; 0 &amp;&amp; __</span>d.count() &lt; __result_min / __ratio::num) {
        return nanoseconds::min();
    }

    __ns_rep <span class="gs">__result = __</span>d.count() * <span class="gs">__ratio::num / __</span>ratio::den;
    if (__result == 0) {
        return nanoseconds(1);
    }

    return nanoseconds(__result);
}


template &lt;class _Predicate&gt;
void
condition_variable::wait(unique_lock&lt;mutex&gt;&amp; __lk, <span class="ge">_Predicate _</span>_pred)
{
    while (!__pred())
        wait(__lk);
}

template &lt;class <span class="ge">_Clock, class _</span>Duration&gt;
cv_status
condition_variable::wait_until(unique_lock&lt;mutex&gt;&amp; __lk,
                               const chrono::time_point&lt;_Clock, <span class="ge">_Duration&gt;&amp; _</span>_t)
{
    using namespace chrono;
    using __clock_tp_ns = time_point&lt;_Clock, nanoseconds&gt;;

    typename <span class="ge">_Clock::time_</span>point __now = _Clock::now();
    if (<span class="gs">__t &lt;= __</span>now)
        return cv_status::timeout;

    __clock_tp_ns __t_ns = __clock_tp_ns(__safe_nanosecond_cast(__t.time_since_epoch()));

    __do_timed_wait(__lk, __t_ns);
    return <span class="ge">_Clock::now() &lt; __t ? cv_</span>status::no_timeout : cv_status::timeout;
}

template &lt;class <span class="ge">_Clock, class _</span>Duration, class _Predicate&gt;
bool
condition_variable::wait_until(unique_lock&lt;mutex&gt;&amp; __lk,
                   const chrono::time_point&lt;_Clock, <span class="ge">_Duration&gt;&amp; _</span>_t,
                   <span class="ge">_Predicate _</span>_pred)
{
    while (!__pred())
    {
        if (wait_until(__lk, __t) == cv_status::timeout)
            return __pred();
    }
    return true;
}

template &lt;class <span class="ge">_Rep, class _</span>Period&gt;
cv_status
condition_variable::wait_for(unique_lock&lt;mutex&gt;&amp; __lk,
                             const chrono::duration&lt;_Rep, <span class="ge">_Period&gt;&amp; _</span>_d)
{
    using namespace chrono;
    if (<span class="gs">__d &lt;= __</span>d.zero())
        return cv_status::timeout;
    using __ns_rep = nanoseconds::rep;
    steady_clock::time_point __c_now = steady_clock::now();





    using __clock_tp_ns = time_point&lt;system_clock, nanoseconds&gt;;
    __ns_rep __now_count_ns = __safe_nanosecond_cast(system_clock::now().time_since_epoch()).count();


    __ns_rep __d_ns_count = __safe_nanosecond_cast(__d).count();

    if (__now_count_ns &gt; numeric_limits&lt;__ns_rep&gt;::max() - __d_ns_count) {
        __do_timed_wait(__lk, __clock_tp_ns::max());
    } else {
        __do_timed_wait(__lk, __clock_tp_ns(nanoseconds(__now_count_ns + __d_ns_count)));
    }

    return steady_clock::now() - __c_now &lt; __d ? cv_status::no_timeout :
                                                 cv_status::timeout;
}

template &lt;class <span class="ge">_Rep, class _</span>Period, class _Predicate&gt;
inline
bool
condition_variable::wait_for(unique_lock&lt;mutex&gt;&amp; __lk,
                             const chrono::duration&lt;_Rep, <span class="ge">_Period&gt;&amp; _</span>_d,
                             <span class="ge">_Predicate _</span>_pred)
{
    return wait_until(__lk, chrono::steady_clock::now() + __d,
                      std::__1::move(__pred));
}
template &lt;class _Clock&gt;
inline
void
condition_variable::__do_timed_wait(unique_lock&lt;mutex&gt;&amp; __lk,
     chrono::time_point&lt;_Clock, chrono::nanoseconds&gt; __tp) throw()
{
    wait_for(__lk, __tp - _Clock::now());
}



} }





namespace std { inline namespace __1 {



class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) recursive_mutex
{
    __libcpp_recursive_mutex_t __m_;

public:
     recursive_mutex();
     ~recursive_mutex();

private:
    recursive_mutex(const recursive_mutex&amp;);
    recursive_mutex&amp; operator=(const recursive_mutex&amp;);

public:
    void lock();
    bool try_lock() throw();
    void unlock() throw();

    typedef __libcpp_recursive_mutex_t* native_handle_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    native_handle_type native_handle() {return &amp;__m_;}
};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    bool __locked_;
public:
     timed_mutex();
     ~timed_mutex();

private:
    timed_mutex(const timed_mutex&amp;);
    timed_mutex&amp; operator=(const timed_mutex&amp;);

public:
    void lock();
    bool try_lock() throw();
    template &lt;class <span class="ge">_Rep, class _</span>Period&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        bool try_lock_for(const chrono::duration&lt;_Rep, <span class="ge">_Period&gt;&amp; _</span>_d)
            {return try_lock_until(chrono::steady_clock::now() + __d);}
    template &lt;class <span class="ge">_Clock, class _</span>Duration&gt;
        inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
        bool try_lock_until(const chrono::time_point&lt;_Clock, <span class="ge">_Duration&gt;&amp; _</span>_t);
    void unlock() throw();
};

template &lt;class <span class="ge">_Clock, class _</span>Duration&gt;
bool
timed_mutex::try_lock_until(const chrono::time_point&lt;_Clock, <span class="ge">_Duration&gt;&amp; _</span>_t)
{
    using namespace chrono;
    unique_lock&lt;mutex&gt; <span class="gs">__lk(__</span>m_);
    bool no_timeout = <span class="ge">_Clock::now() &lt; _</span>_t;
    while (no_timeout &amp;&amp; __locked_)
        no_timeout = __cv_.wait_until(__lk, __t) == cv_status::no_timeout;
    if (!__locked_)
    {
        __locked_ = true;
        return true;
    }
    return false;
}

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) recursive_timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    size_t __count_;
    __thread_id __id_;
public:
     recursive_timed_mutex();
     ~recursive_timed_mutex();

private:
    recursive_timed_mutex(const recursive_timed_mutex&amp;);
    recursive_timed_mutex&amp; operator=(const recursive_timed_mutex&amp;);

public:
    void lock();
    bool try_lock() throw();
    template &lt;class <span class="ge">_Rep, class _</span>Period&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        bool try_lock_for(const chrono::duration&lt;_Rep, <span class="ge">_Period&gt;&amp; _</span>_d)
            {return try_lock_until(chrono::steady_clock::now() + __d);}
    template &lt;class <span class="ge">_Clock, class _</span>Duration&gt;
        inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
        bool try_lock_until(const chrono::time_point&lt;_Clock, <span class="ge">_Duration&gt;&amp; _</span>_t);
    void unlock() throw();
};

template &lt;class <span class="ge">_Clock, class _</span>Duration&gt;
bool
recursive_timed_mutex::try_lock_until(const chrono::time_point&lt;_Clock, <span class="ge">_Duration&gt;&amp; _</span>_t)
{
    using namespace chrono;
    __thread_id __id = this_thread::get_id();
    unique_lock&lt;mutex&gt; lk(__m_);
    if (<span class="gs">__id == __</span>id_)
    {
        if (__count_ == numeric_limits&lt;size_t&gt;::max())
            return false;
        ++__count_;
        return true;
    }
    bool no_timeout = <span class="ge">_Clock::now() &lt; _</span>_t;
    while (no_timeout &amp;&amp; __count_ != 0)
        no_timeout = __cv_.wait_until(lk, __t) == cv_status::no_timeout;
    if (__count_ == 0)
    {
        __count_ = 1;
        __id_ = __id;
        return true;
    }
    return false;
}

template &lt;class <span class="ge">_L0, class _</span>L1&gt;
int
try_lock(_L0&amp; __l0, <span class="ge">_L1&amp; _</span>_l1)
{
    unique_lock&lt;_L0&gt; <span class="gs">__u0(__</span>l0, try_to_lock);
    if (__u0.owns_lock())
    {
        if (__l1.try_lock())
        {
            __u0.release();
            return -1;
        }
        else
            return 1;
    }
    return 0;
}
template &lt;class <span class="ge">_L0, class _</span>L1&gt;
void
lock(_L0&amp; __l0, <span class="ge">_L1&amp; _</span>_l1)
{
    while (true)
    {
        {
            unique_lock&lt;_L0&gt; <span class="gs">__u0(__</span>l0);
            if (__l1.try_lock())
            {
                __u0.release();
                break;
            }
        }
        __libcpp_thread_yield();
        {
            unique_lock&lt;_L1&gt; <span class="gs">__u1(__</span>l1);
            if (__l0.try_lock())
            {
                __u1.release();
                break;
            }
        }
        __libcpp_thread_yield();
    }
}
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) once_flag;
template&lt;class _Callable&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void call_once(once_flag&amp;, _Callable&amp;);

template&lt;class _Callable&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void call_once(once_flag&amp;, const _Callable&amp;);



struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) once_flag
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

        once_flag() throw() : __state_(0) {}




   typedef unsigned long <span class="ge">_State_</span>type;



private:
    once_flag(const once_flag&amp;);
    once_flag&amp; operator=(const once_flag&amp;);

    <span class="ge">_State_</span>type __state_;






    template&lt;class _Callable&gt;
    friend
    void call_once(once_flag&amp;, _Callable&amp;);

    template&lt;class _Callable&gt;
    friend
    void call_once(once_flag&amp;, const _Callable&amp;);

};
template &lt;class _Fp&gt;
class __call_once_param
{
    <span class="ge">_Fp&amp; __f_</span>;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit __call_once_param(_Fp&amp; <span class="gs">__f) : __</span>f<span class="ge">_(_</span>_f) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void operator()()
    {
        __f_();
    }
};



template &lt;class _Fp&gt;
void <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__call_once_proxy(void* __vp)
{
    __call_once_param&lt;_Fp&gt;* __p = static_cast&lt;__call_once_param&lt;_Fp&gt;*&gt;(__vp);
    (*__p)();
}

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void __call_once(volatile once_flag::_State_type&amp;, void*,
                                  void (<span class="ge">*)(void*</span>));
template&lt;class _Callable&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
call_once(once_flag&amp; __flag, <span class="ge">_Callable&amp; _</span>_func)
{
    if (__libcpp_acquire_load(&amp;__flag.__state_) != ~once_flag::_State_type(0))
    {
        __call_once_param&lt;_Callable&gt; <span class="gs">__p(__</span>func);
        __call_once(__flag.__state_, &amp;<span class="gs">__p, &amp;__</span>call_once_proxy&lt;_Callable&gt;);
    }
}

template&lt;class _Callable&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
call_once(once_flag&amp; __flag, const <span class="ge">_Callable&amp; _</span>_func)
{
    if (__libcpp_acquire_load(&amp;__flag.__state_) != ~once_flag::_State_type(0))
    {
        __call_once_param&lt;const <span class="ge">_Callable&gt; __p(_</span>_func);
        __call_once(__flag.__state_, &amp;<span class="gs">__p, &amp;__</span>call_once_proxy&lt;const _Callable&gt;);
    }
}



} }




struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p<span class="ge">_cs_</span>precedes;
 char p<span class="ge">_sep_</span>by_space;
 char n<span class="ge">_cs_</span>precedes;
 char n<span class="ge">_sep_</span>by_space;
 char p<span class="ge">_sign_</span>posn;
 char n<span class="ge">_sign_</span>posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};



extern &quot;C&quot; {
struct lconv *localeconv(void);
}
extern &quot;C&quot; {
char <span class="ge">*setlocale(int, const char *</span>);
}
struct _xlocale;
typedef struct <span class="ge">_xlocale * locale_</span>t;

extern &quot;C&quot; {
int ___mb_cur_max(void);
int ___mb_cur_max_l(locale_t);
}
extern &quot;C&quot; {
extern const locale_t <span class="ge">_c_</span>locale;

locale_t duplocale(locale_t);
int freelocale(locale_t);
struct lconv * localeconv_l(locale_t);
locale_t newlocale(int, const char *, locale_t);
const char * querylocale(int, locale_t);
locale_t uselocale(locale_t);
}



extern &quot;C&quot; {
unsigned long ___runetype_l(__darwin_ct_rune_t, locale_t);
__darwin_ct_rune_t ___tolower_l(__darwin_ct_rune_t, locale_t);
__darwin_ct_rune_t ___toupper_l(__darwin_ct_rune_t, locale_t);
}

extern &quot;C&quot; {
int __maskrune_l(__darwin_ct_rune_t, unsigned long, locale_t);
}

inline int
__istype_l(__darwin_ct_rune_t <span class="ge">_c, unsigned long _</span>f, locale_t _l)
{
 return !!(isascii(_c) ? (<span class="ge">_DefaultRuneLocale.__runetype[_</span>c] &amp; _f)
  : __maskrune_l(_c, <span class="ge">_f, _</span>l));
}

inline __darwin_ct_rune_t
__toupper_l(__darwin_ct_rune_t <span class="ge">_c, locale_</span>t _l)
{
 return isascii(_c) ? <span class="ge">_DefaultRuneLocale.__mapupper[_</span>c]
  : ___toupper_l(_c, _l);
}

inline __darwin_ct_rune_t
__tolower_l(__darwin_ct_rune_t <span class="ge">_c, locale_</span>t _l)
{
 return isascii(_c) ? <span class="ge">_DefaultRuneLocale.__maplower[_</span>c]
  : ___tolower_l(_c, _l);
}

inline int
__wcwidth_l(__darwin_ct_rune_t <span class="ge">_c, locale_</span>t _l)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 <span class="ge">_x = (unsigned int)__maskrune_</span>l(_c, 0xe0000000L|0x00040000L, _l);
 if ((_x &amp; 0xe0000000L) != 0)
  return ((_x &amp; 0xe0000000L) &gt;&gt; 30);
 return ((_x &amp; 0x00040000L) != 0 ? 1 : -1);
}



inline int
digittoint_l(int c, locale_t l)
{
 return (__maskrune_l(c, 0x0F, l));
}

inline int
isalnum_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000100L|0x00000400L, l));
}

inline int
isalpha_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000100L, l));
}

inline int
isblank_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00020000L, l));
}

inline int
iscntrl_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000200L, l));
}

inline int
isdigit_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000400L, l));
}

inline int
isgraph_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000800L, l));
}

inline int
ishexnumber_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00010000L, l));
}

inline int
isideogram_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00080000L, l));
}

inline int
islower_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00001000L, l));
}

inline int
isnumber_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000400L, l));
}

inline int
isphonogram_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00200000L, l));
}

inline int
isprint_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00040000L, l));
}

inline int
ispunct_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00002000L, l));
}

inline int
isrune_l(int c, locale_t l)
{
 return (__istype_l(c, 0xFFFFFFF0L, l));
}

inline int
isspace_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00004000L, l));
}

inline int
isspecial_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00100000L, l));
}

inline int
isupper_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00008000L, l));
}

inline int
isxdigit_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00010000L, l));
}

inline int
tolower_l(int c, locale_t l)
{
        return (__tolower_l(c, l));
}

inline int
toupper_l(int c, locale_t l)
{
        return (__toupper_l(c, l));
}


inline int
iswalnum_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00000100L|0x00000400L, _l));
}

inline int
iswalpha_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00000100L, _l));
}

inline int
iswcntrl_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00000200L, _l));
}

inline int
iswctype_l(wint_t <span class="ge">_wc, wctype_</span>t <span class="ge">_charclass, locale_</span>t _l)
{
 return (__istype_l(_wc, <span class="ge">_charclass, _</span>l));
}

inline int
iswdigit_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00000400L, _l));
}

inline int
iswgraph_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00000800L, _l));
}

inline int
iswlower_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00001000L, _l));
}

inline int
iswprint_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00040000L, _l));
}

inline int
iswpunct_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00002000L, _l));
}

inline int
iswspace_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00004000L, _l));
}

inline int
iswupper_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00008000L, _l));
}

inline int
iswxdigit_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00010000L, _l));
}

inline wint_t
towlower_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
        return (__tolower_l(_wc, _l));
}

inline wint_t
towupper_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
        return (__toupper_l(_wc, _l));
}
extern &quot;C&quot; {
wctype_t
 wctype_l(const char *, locale_t);
}
extern &quot;C&quot; {

int fprintf_l(FILE * , locale_t , const char * , ...)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 3, 4)));
int fscanf_l(FILE * , locale_t , const char * , ...)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__scanf__</span>, 3, 4)));
int printf_l(locale_t , const char * , ...)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 2, 3)));
int scanf_l(locale_t , const char * , ...)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__scanf__</span>, 2, 3)));
int sprintf_l(char * , locale_t , const char * , ...)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 3, 4))) <span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use snprintf_l instead.&quot;)));
int sscanf_l(const char * , locale_t , const char * , ...)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__scanf__</span>, 3, 4)));
int vfprintf_l(FILE * , locale_t , const char * , va_list)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 3, 0)));
int vprintf_l(locale_t , const char * , va_list)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 2, 0)));
int vsprintf_l(char * , locale_t , const char * , va_list)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 3, 0))) <span class="gs">__attribute__</span>((__availability__(swift, unavailable, message=&quot;Use vsnprintf_l instead.&quot;)));


int snprintf_l(char * , size_t, locale_t , const char * , ...)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 4, 5)));
int vfscanf_l(FILE * , locale_t , const char * , va_list)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__scanf__</span>, 3, 0)));
int vscanf_l(locale_t , const char * , va_list)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__scanf__</span>, 2, 0)));
int vsnprintf_l(char * , size_t, locale_t , const char * , va_list)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 4, 0)));
int vsscanf_l(const char * , locale_t , const char * , va_list)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__scanf__</span>, 3, 0)));



int dprintf_l(int, locale_t , const char * , ...)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 3, 4))) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
int vdprintf_l(int, locale_t , const char * , va_list)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 3, 0))) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));




int asprintf_l(char ** , locale_t , const char * , ...)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 3, 4)));
int vasprintf_l(char ** , locale_t , const char * , va_list)
        <span class="gs">__attribute__</span>((__format__ (<span class="gs">__printf__</span>, 3, 0)));


}




extern &quot;C&quot; {
double atof_l(const char *, locale_t);
int atoi_l(const char *, locale_t);
long atol_l(const char *, locale_t);

long long
  atoll_l(const char *, locale_t);

int mblen_l(const char *, size_t, locale_t);
size_t mbstowcs_l(wchar_t * , const char * , size_t,
     locale_t);
int mbtowc_l(wchar_t * , const char * , size_t,
     locale_t);
double strtod_l(const char <span class="ge">*, char *</span>*, locale_t) __asm(&quot;_&quot; &quot;strtod_l&quot; );
float strtof_l(const char <span class="ge">*, char *</span>*, locale_t) __asm(&quot;_&quot; &quot;strtof_l&quot; );
long strtol_l(const char <span class="ge">*, char *</span>*, int, locale_t);
long double
  strtold_l(const char <span class="ge">*, char *</span>*, locale_t);
long long
  strtoll_l(const char <span class="ge">*, char *</span>*, int, locale_t);

long long
  strtoq_l(const char <span class="ge">*, char *</span>*, int, locale_t);

unsigned long
  strtoul_l(const char <span class="ge">*, char *</span>*, int, locale_t);
unsigned long long
  strtoull_l(const char <span class="ge">*, char *</span>*, int, locale_t);

unsigned long long
  strtouq_l(const char <span class="ge">*, char *</span>*, int, locale_t);

size_t wcstombs_l(char * , const wchar_t * , size_t,
     locale_t);
int wctomb_l(char *, wchar_t, locale_t);





}


extern &quot;C&quot; {
int strcoll_l(const char <span class="ge">*, const char *</span>, locale_t);
size_t strxfrm_l(char <span class="ge">*, const char *</span>, size_t, locale_t);
int strcasecmp_l(const char <span class="ge">*, const char *</span>, locale_t);
char <span class="ge">*strcasestr_l(const char *</span>, const char *, locale_t);
int strncasecmp_l(const char <span class="ge">*, const char *</span>, size_t, locale_t);
}


extern &quot;C&quot; {
size_t strftime_l(char * , size_t, const char * ,
  const struct tm * , locale_t)
  __asm(&quot;_&quot; &quot;strftime_l&quot; ) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__strftime__</span>, 3, 0)));
char <span class="ge">*strptime_l(const char *</span> , const char * ,
  struct tm * , locale_t)
  __asm(&quot;_&quot; &quot;strptime_l&quot; ) <span class="gs">__attribute__</span>((__format__ (<span class="gs">__strftime__</span>, 2, 0)));
}







extern &quot;C++&quot; {

using std::nullptr_t;
}




typedef long double max_align_t;


extern &quot;C&quot; {
wint_t btowc_l(int, locale_t);
wint_t fgetwc_l(FILE *, locale_t);
wchar_t <span class="ge">*fgetws_l(wchar_t *</span> , int, FILE * , locale_t);
wint_t fputwc_l(wchar_t, FILE *, locale_t);
int fputws_l(const wchar_t * , FILE * , locale_t);
int fwprintf_l(FILE * , locale_t, const wchar_t * , ...);
int fwscanf_l(FILE * , locale_t, const wchar_t * , ...);
wint_t getwc_l(FILE *, locale_t);
wint_t getwchar_l(locale_t);
size_t mbrlen_l(const char * , size_t, mbstate_t * ,
     locale_t);
size_t mbrtowc_l(wchar_t * , const char * , size_t,
     mbstate_t * , locale_t);
int mbsinit_l(const mbstate_t *, locale_t);
size_t mbsrtowcs_l(wchar_t * , const char ** , size_t,
     mbstate_t * , locale_t);
wint_t putwc_l(wchar_t, FILE *, locale_t);
wint_t putwchar_l(wchar_t, locale_t);
int swprintf_l(wchar_t * , size_t n, locale_t,
  const wchar_t * , ...);
int swscanf_l(const wchar_t * , locale_t,
  const wchar_t * , ...);
wint_t ungetwc_l(wint_t, FILE *, locale_t);
int vfwprintf_l(FILE * , locale_t, const wchar_t * ,
  __darwin_va_list);
int vswprintf_l(wchar_t * , size_t n, locale_t,
  const wchar_t * , __darwin_va_list);
int vwprintf_l(locale_t, const wchar_t * , __darwin_va_list);
size_t wcrtomb_l(char * , wchar_t, mbstate_t * ,
     locale_t);
int wcscoll_l(const wchar_t <span class="ge">*, const wchar_t *</span>, locale_t);
size_t wcsftime_l(wchar_t * , size_t, const wchar_t * ,
  const struct tm * , locale_t)
  __asm(&quot;_&quot; &quot;wcsftime_l&quot; );
size_t wcsrtombs_l(char * , const wchar_t ** , size_t,
     mbstate_t * , locale_t);
double wcstod_l(const wchar_t * , wchar_t ** , locale_t);
long wcstol_l(const wchar_t * , wchar_t ** , int,
     locale_t);
unsigned long
 wcstoul_l(const wchar_t * , wchar_t ** , int,
     locale_t);
int wcswidth_l(const wchar_t *, size_t, locale_t);
size_t wcsxfrm_l(wchar_t * , const wchar_t * , size_t,
     locale_t);
int wctob_l(wint_t, locale_t);
int wcwidth_l(wchar_t, locale_t);
int wprintf_l(locale_t, const wchar_t * , ...);
int wscanf_l(locale_t, const wchar_t * , ...);
}
extern &quot;C&quot; {
int vfwscanf_l(FILE * , locale_t, const wchar_t * ,
  __darwin_va_list);
int vswscanf_l(const wchar_t * , locale_t,
  const wchar_t * , __darwin_va_list);
int vwscanf_l(locale_t, const wchar_t * , __darwin_va_list);
float wcstof_l(const wchar_t * , wchar_t ** , locale_t);
long double
 wcstold_l(const wchar_t * , wchar_t ** , locale_t);

long long
 wcstoll_l(const wchar_t * , wchar_t ** , int,
     locale_t);
unsigned long long
 wcstoull_l(const wchar_t * , wchar_t ** , int,
     locale_t);

}
extern &quot;C&quot; {
size_t mbsnrtowcs_l(wchar_t * , const char ** , size_t,
     size_t, mbstate_t * , locale_t);
int wcscasecmp_l(const wchar_t <span class="ge">*, const wchar_t *</span>, locale_t) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
int wcsncasecmp_l(const wchar_t <span class="ge">*, const wchar_t *</span>, size_t n, locale_t) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
size_t wcsnrtombs_l(char * , const wchar_t ** , size_t,
     size_t, mbstate_t * , locale_t);
}







extern &quot;C&quot; {
wchar_t <span class="ge">*fgetwln_l(FILE *</span> , size_t *, locale_t) <span class="gs">__attribute__</span>((availability(macosx,introduced=10.7)));
}


inline int
iswblank_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00020000L, _l));
}

inline int
iswhexnumber_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00010000L, _l));
}

inline int
iswideogram_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00080000L, _l));
}

inline int
iswnumber_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00000400L, _l));
}

inline int
iswphonogram_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00200000L, _l));
}

inline int
iswrune_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0xFFFFFFF0L, _l));
}

inline int
iswspecial_l(wint_t <span class="ge">_wc, locale_</span>t _l)
{
 return (__istype_l(_wc, 0x00100000L, _l));
}
extern &quot;C&quot; {
wint_t nextwctype_l(wint_t, wctype_t, locale_t);
wint_t towctrans_l(wint_t, wctrans_t, locale_t);
wctrans_t
 wctrans_l(const char *, locale_t);
}


namespace std { inline namespace __1 {
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) locale;

template &lt;class _Facet&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
has_facet(const locale&amp;) throw();

template &lt;class _Facet&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
const _Facet&amp;
use_facet(const locale&amp;);

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) locale
{
public:

    class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) facet;
    class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) id;

    typedef int category;
    <span class="gs">__attribute__</span>((availability(macosx,strict,introduced=10.9))) <span class="gs">__attribute__</span>((availability(ios,strict,introduced=7.0)))
    static const category
        none = 0,
        collate = (1 &lt;&lt; 0),
        ctype = (1 &lt;&lt; 1),
        monetary = (1 &lt;&lt; 3),
        numeric = (1 &lt;&lt; 4),
        time = (1 &lt;&lt; 5),
        messages = (1 &lt;&lt; 2),
        all = collate | ctype | monetary | numeric | time | messages;


    locale() throw();
    locale(const locale&amp;) throw();
    explicit locale(const char*);
    explicit locale(const string&amp;);
    locale(const locale&amp;, const char*, category);
    locale(const locale&amp;, const string&amp;, category);
    template &lt;class _Facet&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) locale(const locale&amp;, _Facet*);
    locale(const locale&amp;, const locale&amp;, category);

    ~locale();

    const locale&amp; operator=(const locale&amp;) throw();

    template &lt;class _Facet&gt;
      inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
      locale combine(const locale&amp;) const;


    string name() const;
    bool operator==(const locale&amp;) const;
    bool operator!=(const locale&amp; <span class="gs">__y) const {return !(*this == __</span>y);}
    template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
      inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
      bool operator()(const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;,
                      const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp;) const;


    static locale global(const locale&amp;);
    static const locale&amp; classic();

private:
    class __imp;
    <span class="gs">__imp* __</span>locale_;

    void __install_ctor(const locale&amp;, facet*, long);
    static locale&amp; __global();
    bool has_facet(id&amp;) const;
    const facet* use_facet(id&amp;) const;

    template &lt;class <span class="ge">_Facet&gt; friend bool has_</span>facet(const locale&amp;) throw();
    template &lt;class <span class="ge">_Facet&gt; friend const _</span>Facet&amp; use_facet(const locale&amp;);
};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) locale::facet
    : public __shared_count
{
protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit facet(size_t __refs = 0)
        : __shared_count(static_cast&lt;long&gt;(__refs)-1) {}

    virtual ~facet();



private:
    virtual void __on_zero_shared() throw();
};

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) locale::id
{
    once_flag __flag_;
    int32_t __id_;

    static int32_t __next_id;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) id() :__id_(0) {}
private:
    void __init();
    void operator=(const id&amp;);
    id(const id&amp;);
public:
    long __get();

    friend class locale;
    friend class locale::__imp;
};

template &lt;class _Facet&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
locale::locale(const locale&amp; __other, <span class="ge">_Facet* _</span>_f)
{
    __install_ctor(__other, <span class="gs">__f, __</span>f ? <span class="gs">__f-&gt;id.__</span>get() : 0);
}

template &lt;class _Facet&gt;
locale
locale::combine(const locale&amp; __other) const
{
    if (!std::__1::has_facet&lt;_Facet&gt;(__other))
        __throw_runtime_error(&quot;locale::combine: locale missing facet&quot;);

    return locale(*this, &amp;const_cast&lt;_Facet&amp;&gt;(std::__1::use_facet&lt;_Facet&gt;(__other)));
}

template &lt;class _Facet&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
has_facet(const locale&amp; __l) throw()
{
    return __l.has_facet(_Facet::id);
}

template &lt;class _Facet&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
const _Facet&amp;
use_facet(const locale&amp; __l)
{
    return static_cast&lt;const <span class="ge">_Facet&amp;&gt;(*__l.use_</span>facet(_Facet::id));
}



template &lt;class _CharT&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) collate
    : public locale::facet
{
public:
    typedef <span class="ge">_CharT char_</span>type;
    typedef basic_string&lt;char_type&gt; string_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit collate(size_t __refs = 0)
        : locale::facet(__refs) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int compare(const char_type* __lo1, const char_type* __hi1,
                const char_type* __lo2, const char_type* __hi2) const
    {
        return do_compare(__lo1, <span class="gs">__hi1, __</span>lo2, __hi2);
    }



    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    <span class="gs">__attribute__</span> ((__always_inline__))
    string_type transform(const char_type* __lo, const char_type* __hi) const
    {
        return do_transform(__lo, __hi);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    long hash(const char_type* __lo, const char_type* __hi) const
    {
        return do_hash(__lo, __hi);
    }

    static locale::id id;

protected:
    ~collate();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const
        {return string_type(__lo, __hi);}
    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;
};

template &lt;class <span class="ge">_CharT&gt; locale::id collate&lt;_</span>CharT&gt;::id;

template &lt;class _CharT&gt;
collate&lt;_CharT&gt;::~collate()
{
}

template &lt;class _CharT&gt;
int
collate&lt;_CharT&gt;::do_compare(const char_type* __lo1, const char_type* __hi1,
                            const char_type* __lo2, const char_type* __hi2) const
{
    for (; <span class="gs">__lo2 != __</span>hi2; ++__lo1, ++__lo2)
    {
        if (<span class="gs">__lo1 == __</span>hi1 || <span class="ge">*__lo1 &lt; *</span>__lo2)
            return -1;
        if (<span class="ge">*__lo2 &lt; *</span>__lo1)
            return 1;
    }
    return <span class="gs">__lo1 != __</span>hi1;
}

template &lt;class _CharT&gt;
long
collate&lt;_CharT&gt;::do_hash(const char_type* __lo, const char_type* __hi) const
{
    size_t __h = 0;
    const size_t __sr = 8 * sizeof(size_t) - 8;
    const size_t __mask = size_t(0xF) &lt;&lt; (__sr + 4);
    for(const char_type* <span class="gs">__p = __</span>lo; <span class="gs">__p != __</span>hi; ++__p)
    {
        <span class="gs">__h = (__</span>h &lt;&lt; 4) + static_cast&lt;size_t&gt;(*__p);
        size_t <span class="gs">__g = __</span>h &amp; __mask;
        <span class="gs">__h ^= __</span>g | (<span class="gs">__g &gt;&gt; __</span>sr);
    }
    return static_cast&lt;long&gt;(__h);
}

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) collate&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) collate&lt;wchar_t&gt;;



template &lt;class <span class="ge">_CharT&gt; class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) collate_byname;

template &lt;&gt;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) collate_byname&lt;char&gt;
    : public collate&lt;char&gt;
{
    locale_t __l;
public:
    typedef char char_type;
    typedef basic_string&lt;char_type&gt; string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string&amp; __n, size_t __refs = 0);

protected:
    ~collate_byname();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template &lt;&gt;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) collate_byname&lt;wchar_t&gt;
    : public collate&lt;wchar_t&gt;
{
    locale_t __l;
public:
    typedef wchar_t char_type;
    typedef basic_string&lt;char_type&gt; string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string&amp; __n, size_t __refs = 0);

protected:
    ~collate_byname();

    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
bool
locale::operator()(const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __x,
                   const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __y) const
{
    return std::__1::use_facet&lt;std::__1::collate&lt;_CharT&gt; &gt;(*this).compare(
                                       <span class="gs">__x.data(), __</span>x.data() + __x.size(),
                                       <span class="gs">__y.data(), __</span>y.data() + __y.size()) &lt; 0;
}



class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) ctype_base
{
public:
    typedef __uint32_t mask;





    static const mask space = 0x00004000L;
    static const mask print = 0x00040000L;
    static const mask cntrl = 0x00000200L;
    static const mask upper = 0x00008000L;
    static const mask lower = 0x00001000L;
    static const mask alpha = 0x00000100L;
    static const mask digit = 0x00000400L;
    static const mask punct = 0x00002000L;
    static const mask xdigit = 0x00010000L;







    static const mask blank = 0x00020000L;
    static const mask __regex_word = 0x80;
    static const mask alnum = alpha | digit;
    static const mask graph = alnum | punct;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ctype_base() {}
};

template &lt;class <span class="ge">_CharT&gt; class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) ctype;

template &lt;&gt;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) ctype&lt;wchar_t&gt;
    : public locale::facet,
      public ctype_base
{
public:
    typedef wchar_t char_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit ctype(size_t __refs = 0)
        : locale::facet(__refs) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool is(mask __m, char_type __c) const
    {
        return do_is(__m, __c);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char_type* is(const char_type* __low, const char_type* <span class="gs">__high, mask* __</span>vec) const
    {
        return do_is(__low, <span class="gs">__high, __</span>vec);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_is(__m, <span class="gs">__low, __</span>high);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_not(__m, <span class="gs">__low, __</span>high);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char* widen(const char* <span class="gs">__low, const char* __</span>high, char_type* __to) const
    {
        return do_widen(__low, <span class="gs">__high, __</span>to);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    char narrow(char_type <span class="gs">__c, char __</span>dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char_type* narrow(const char_type* __low, const char_type* <span class="gs">__high, char __</span>dfault, char* __to) const
    {
        return do_narrow(__low, <span class="gs">__high, __</span>dfault, __to);
    }

    static locale::id id;

protected:
    ~ctype();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* <span class="gs">__high, mask* __</span>vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* <span class="gs">__low, const char* __</span>high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* <span class="gs">__high, char __</span>dfault, char* __dest) const;
};

template &lt;&gt;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) ctype&lt;char&gt;
    : public locale::facet, public ctype_base
{
    const mask* __tab_;
    bool __del_;
public:
    typedef char char_type;

    explicit ctype(const mask* <span class="gs">__tab = 0, bool __</span>del = false, size_t __refs = 0);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool is(mask __m, char_type __c) const
    {
        return isascii(__c) ? (__tab_[static_cast&lt;int&gt;(__c)] &amp; __m) !=0 : false;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char_type* is(const char_type* __low, const char_type* <span class="gs">__high, mask* __</span>vec) const
    {
        for (; <span class="gs">__low != __</span>high; ++__low, ++__vec)
            <span class="ge">*__vec = isascii(*</span><span class="gs">__low) ? __</span>tab_[static_cast&lt;int&gt;(*__low)] : 0;
        return __low;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; <span class="gs">__low != __</span>high; ++__low)
            if (isascii(*__low) &amp;&amp; (__tab_[static_cast&lt;int&gt;(*__low)] &amp; __m))
                break;
        return __low;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; <span class="gs">__low != __</span>high; ++__low)
            if (!(isascii(*__low) &amp;&amp; (__tab_[static_cast&lt;int&gt;(*__low)] &amp; __m)))
                break;
        return __low;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char* widen(const char* <span class="gs">__low, const char* __</span>high, char_type* __to) const
    {
        return do_widen(__low, <span class="gs">__high, __</span>to);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    char narrow(char_type <span class="gs">__c, char __</span>dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    const char* narrow(const char_type* __low, const char_type* <span class="gs">__high, char __</span>dfault, char* __to) const
    {
        return do_narrow(__low, <span class="gs">__high, __</span>dfault, __to);
    }

    static locale::id id;


    static const size_t table_size = (1 &lt;&lt;8 );



    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) const mask* table() const throw() {return __tab_;}
    static const mask* classic_table() throw();
protected:
    ~ctype();
    virtual char_type do_toupper(char_type __c) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type __c) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char __c) const;
    virtual const char* do_widen(const char* <span class="gs">__low, const char* __</span>high, char_type* __to) const;
    virtual char do_narrow(char_type <span class="gs">__c, char __</span>dfault) const;
    virtual const char* do_narrow(const char_type* __low, const char_type* <span class="gs">__high, char __</span>dfault, char* __to) const;
};



template &lt;class <span class="ge">_CharT&gt; class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) ctype_byname;

template &lt;&gt;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) ctype_byname&lt;char&gt;
    : public ctype&lt;char&gt;
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&amp;, size_t = 0);

protected:
    ~ctype_byname();
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
};

template &lt;&gt;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) ctype_byname&lt;wchar_t&gt;
    : public ctype&lt;wchar_t&gt;
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&amp;, size_t = 0);

protected:
    ~ctype_byname();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* <span class="gs">__high, mask* __</span>vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* <span class="gs">__low, const char* __</span>high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* <span class="gs">__high, char __</span>dfault, char* __dest) const;
};

template &lt;class _CharT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
isspace(_CharT <span class="gs">__c, const locale&amp; __</span>loc)
{
    return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::space, __c);
}

template &lt;class _CharT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
isprint(_CharT <span class="gs">__c, const locale&amp; __</span>loc)
{
    return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::print, __c);
}

template &lt;class _CharT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
iscntrl(_CharT <span class="gs">__c, const locale&amp; __</span>loc)
{
    return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::cntrl, __c);
}

template &lt;class _CharT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
isupper(_CharT <span class="gs">__c, const locale&amp; __</span>loc)
{
    return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::upper, __c);
}

template &lt;class _CharT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
islower(_CharT <span class="gs">__c, const locale&amp; __</span>loc)
{
    return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::lower, __c);
}

template &lt;class _CharT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
isalpha(_CharT <span class="gs">__c, const locale&amp; __</span>loc)
{
    return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::alpha, __c);
}

template &lt;class _CharT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
isdigit(_CharT <span class="gs">__c, const locale&amp; __</span>loc)
{
    return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::digit, __c);
}

template &lt;class _CharT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
ispunct(_CharT <span class="gs">__c, const locale&amp; __</span>loc)
{
    return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::punct, __c);
}

template &lt;class _CharT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
isxdigit(_CharT <span class="gs">__c, const locale&amp; __</span>loc)
{
    return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::xdigit, __c);
}

template &lt;class _CharT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
isalnum(_CharT <span class="gs">__c, const locale&amp; __</span>loc)
{
    return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::alnum, __c);
}

template &lt;class _CharT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
isgraph(_CharT <span class="gs">__c, const locale&amp; __</span>loc)
{
    return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::graph, __c);
}

template &lt;class _CharT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_CharT
toupper(_CharT <span class="gs">__c, const locale&amp; __</span>loc)
{
    return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).toupper(__c);
}

template &lt;class _CharT&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_CharT
tolower(_CharT <span class="gs">__c, const locale&amp; __</span>loc)
{
    return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).tolower(__c);
}



class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) codecvt_base
{
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) codecvt_base() {}
    enum result {ok, partial, error, noconv};
};



template &lt;class <span class="ge">_InternT, class _</span>ExternT, class <span class="ge">_StateT&gt; class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) codecvt;



template &lt;&gt;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) codecvt&lt;char, char, mbstate_t&gt;
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    result out(state_type&amp; __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*&amp; __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const
    {
        return do_out(__st, <span class="gs">__frm, __</span>frm_end, __frm_nxt, <span class="gs">__to, __</span>to_end, __to_nxt);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    result unshift(state_type&amp; __st,
                   extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const
    {
        return do_unshift(__st, <span class="gs">__to, __</span>to_end, __to_nxt);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    result in(state_type&amp; __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*&amp; __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*&amp; __to_nxt) const
    {
        return do_in(__st, <span class="gs">__frm, __</span>frm_end, __frm_nxt, <span class="gs">__to, __</span>to_end, __to_nxt);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int encoding() const throw()
    {
        return do_encoding();
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int length(state_type&amp; __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, <span class="gs">__frm, __</span>end, __mx);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type&amp; __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*&amp; __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const;
    virtual result do_in(state_type&amp; __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*&amp; __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*&amp; __to_nxt) const;
    virtual result do_unshift(state_type&amp; __st,
                              extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type&amp; __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};



template &lt;&gt;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) codecvt&lt;wchar_t, char, mbstate_t&gt;
    : public locale::facet,
      public codecvt_base
{
    locale_t __l;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    explicit codecvt(size_t __refs = 0);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    result out(state_type&amp; __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*&amp; __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const
    {
        return do_out(__st, <span class="gs">__frm, __</span>frm_end, __frm_nxt, <span class="gs">__to, __</span>to_end, __to_nxt);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    result unshift(state_type&amp; __st,
                   extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const
    {
        return do_unshift(__st, <span class="gs">__to, __</span>to_end, __to_nxt);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    result in(state_type&amp; __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*&amp; __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*&amp; __to_nxt) const
    {
        return do_in(__st, <span class="gs">__frm, __</span>frm_end, __frm_nxt, <span class="gs">__to, __</span>to_end, __to_nxt);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int encoding() const throw()
    {
        return do_encoding();
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int length(state_type&amp; __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, <span class="gs">__frm, __</span>end, __mx);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    explicit codecvt(const char*, size_t __refs = 0);

    ~codecvt();

    virtual result do_out(state_type&amp; __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*&amp; __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const;
    virtual result do_in(state_type&amp; __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*&amp; __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*&amp; __to_nxt) const;
    virtual result do_unshift(state_type&amp; __st,
                              extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type&amp;, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};



template &lt;&gt;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) codecvt&lt;char16_t, char, mbstate_t&gt;
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    result out(state_type&amp; __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*&amp; __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const
    {
        return do_out(__st, <span class="gs">__frm, __</span>frm_end, __frm_nxt, <span class="gs">__to, __</span>to_end, __to_nxt);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    result unshift(state_type&amp; __st,
                   extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const
    {
        return do_unshift(__st, <span class="gs">__to, __</span>to_end, __to_nxt);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    result in(state_type&amp; __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*&amp; __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*&amp; __to_nxt) const
    {
        return do_in(__st, <span class="gs">__frm, __</span>frm_end, __frm_nxt, <span class="gs">__to, __</span>to_end, __to_nxt);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int encoding() const throw()
    {
        return do_encoding();
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int length(state_type&amp; __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, <span class="gs">__frm, __</span>end, __mx);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type&amp; __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*&amp; __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const;
    virtual result do_in(state_type&amp; __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*&amp; __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*&amp; __to_nxt) const;
    virtual result do_unshift(state_type&amp; __st,
                              extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type&amp;, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};



template &lt;&gt;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) codecvt&lt;char32_t, char, mbstate_t&gt;
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    result out(state_type&amp; __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*&amp; __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const
    {
        return do_out(__st, <span class="gs">__frm, __</span>frm_end, __frm_nxt, <span class="gs">__to, __</span>to_end, __to_nxt);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    result unshift(state_type&amp; __st,
                   extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const
    {
        return do_unshift(__st, <span class="gs">__to, __</span>to_end, __to_nxt);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    result in(state_type&amp; __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*&amp; __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*&amp; __to_nxt) const
    {
        return do_in(__st, <span class="gs">__frm, __</span>frm_end, __frm_nxt, <span class="gs">__to, __</span>to_end, __to_nxt);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int encoding() const throw()
    {
        return do_encoding();
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int length(state_type&amp; __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, <span class="gs">__frm, __</span>end, __mx);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type&amp; __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*&amp; __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const;
    virtual result do_in(state_type&amp; __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*&amp; __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*&amp; __to_nxt) const;
    virtual result do_unshift(state_type&amp; __st,
                              extern_type* __to, extern_type* __to_end, extern_type*&amp; __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type&amp;, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};



template &lt;class <span class="ge">_InternT, class _</span>ExternT, class _StateT&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) codecvt_byname
    : public codecvt&lt;_InternT, <span class="ge">_ExternT, _</span>StateT&gt;
{
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit codecvt_byname(const char* __nm, size_t __refs = 0)
        : codecvt&lt;_InternT, <span class="ge">_ExternT, _</span>StateT&gt;(__nm, __refs) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit codecvt_byname(const string&amp; __nm, size_t __refs = 0)
        : codecvt&lt;_InternT, <span class="ge">_ExternT, _</span>StateT&gt;(__nm.c_str(), __refs) {}
protected:
    ~codecvt_byname();
};

template &lt;class <span class="ge">_InternT, class _</span>ExternT, class _StateT&gt;
codecvt_byname&lt;_InternT, <span class="ge">_ExternT, _</span>StateT&gt;::~codecvt_byname()
{
}

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) codecvt_byname&lt;char, char, mbstate_t&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) codecvt_byname&lt;wchar_t, char, mbstate_t&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) codecvt_byname&lt;char16_t, char, mbstate_t&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) codecvt_byname&lt;char32_t, char, mbstate_t&gt;;

template &lt;size_t _Np&gt;
struct __narrow_to_utf8
{
    template &lt;class <span class="ge">_OutputIterator, class _</span>CharT&gt;
    _OutputIterator
    operator()(_OutputIterator __s, const <span class="ge">_CharT* __wb, const _</span>CharT* __we) const;
};

template &lt;&gt;
struct __narrow_to_utf8&lt;8&gt;
{
    template &lt;class <span class="ge">_OutputIterator, class _</span>CharT&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    _OutputIterator
    operator()(_OutputIterator __s, const <span class="ge">_CharT* __wb, const _</span>CharT* __we) const
    {
        for (; <span class="gs">__wb &lt; __</span>we; ++__wb, ++__s)
            <span class="ge">*__s = *</span>__wb;
        return __s;
    }
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) __narrow_to_utf8&lt;16&gt;
    : public codecvt&lt;char16_t, char, mbstate_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __narrow_to_utf8() : codecvt&lt;char16_t, char, mbstate_t&gt;(1) {}

    <span class="gs">__attribute__</span>((__visibility__(&quot;default&quot;))) ~__narrow_to_utf8();

    template &lt;class <span class="ge">_OutputIterator, class _</span>CharT&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    _OutputIterator
    operator()(_OutputIterator __s, const <span class="ge">_CharT* __wb, const _</span>CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (<span class="gs">__wb &lt; __</span>we &amp;&amp; __r != error)
        {
            const int __sz = 32;
            char <span class="gs">__buf[__</span>sz];
            char* __bn;
            const char16_t* __wn = (const char16_t*)__wb;
            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,
                         <span class="gs">__buf, __</span>buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)
                __throw_runtime_error(&quot;locale not supported&quot;);
            for (const char* <span class="gs">__p = __</span>buf; <span class="gs">__p &lt; __</span>bn; ++__p, ++__s)
                <span class="ge">*__s = *</span>__p;
            __wb = (const <span class="ge">_CharT*)_</span>_wn;
        }
        return __s;
    }
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) __narrow_to_utf8&lt;32&gt;
    : public codecvt&lt;char32_t, char, mbstate_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __narrow_to_utf8() : codecvt&lt;char32_t, char, mbstate_t&gt;(1) {}

    <span class="gs">__attribute__</span>((__visibility__(&quot;default&quot;))) ~__narrow_to_utf8();

    template &lt;class <span class="ge">_OutputIterator, class _</span>CharT&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    _OutputIterator
    operator()(_OutputIterator __s, const <span class="ge">_CharT* __wb, const _</span>CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (<span class="gs">__wb &lt; __</span>we &amp;&amp; __r != error)
        {
            const int __sz = 32;
            char <span class="gs">__buf[__</span>sz];
            char* __bn;
            const char32_t* __wn = (const char32_t*)__wb;
            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,
                         <span class="gs">__buf, __</span>buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)
                __throw_runtime_error(&quot;locale not supported&quot;);
            for (const char* <span class="gs">__p = __</span>buf; <span class="gs">__p &lt; __</span>bn; ++__p, ++__s)
                <span class="ge">*__s = *</span>__p;
            __wb = (const <span class="ge">_CharT*)_</span>_wn;
        }
        return __s;
    }
};

template &lt;size_t _Np&gt;
struct __widen_from_utf8
{
    template &lt;class _OutputIterator&gt;
    _OutputIterator
    operator()(_OutputIterator <span class="gs">__s, const char* __</span>nb, const char* __ne) const;
};

template &lt;&gt;
struct __widen_from_utf8&lt;8&gt;
{
    template &lt;class _OutputIterator&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    _OutputIterator
    operator()(_OutputIterator <span class="gs">__s, const char* __</span>nb, const char* __ne) const
    {
        for (; <span class="gs">__nb &lt; __</span>ne; ++__nb, ++__s)
            <span class="ge">*__s = *</span>__nb;
        return __s;
    }
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) __widen_from_utf8&lt;16&gt;
    : public codecvt&lt;char16_t, char, mbstate_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __widen_from_utf8() : codecvt&lt;char16_t, char, mbstate_t&gt;(1) {}

    <span class="gs">__attribute__</span>((__visibility__(&quot;default&quot;))) ~__widen_from_utf8();

    template &lt;class _OutputIterator&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    _OutputIterator
    operator()(_OutputIterator <span class="gs">__s, const char* __</span>nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (<span class="gs">__nb &lt; __</span>ne &amp;&amp; __r != error)
        {
            const int __sz = 32;
            char16_t <span class="gs">__buf[__</span>sz];
            char16_t* __bn;
            const char* <span class="gs">__nn = __</span>nb;
            __r = do_in(__mb, <span class="gs">__nb, __</span>ne - <span class="gs">__nb &gt; __</span>sz ? <span class="gs">__nb+__</span>sz : <span class="gs">__ne, __</span>nn,
                        <span class="gs">__buf, __</span>buf+__sz, __bn);
            if (__r == codecvt_base::error || <span class="gs">__nn == __</span>nb)
                __throw_runtime_error(&quot;locale not supported&quot;);
            for (const char16_t* <span class="gs">__p = __</span>buf; <span class="gs">__p &lt; __</span>bn; ++__p, ++__s)
                <span class="ge">*__s = (wchar_t)*</span>__p;
            <span class="gs">__nb = __</span>nn;
        }
        return __s;
    }
};

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) __widen_from_utf8&lt;32&gt;
    : public codecvt&lt;char32_t, char, mbstate_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __widen_from_utf8() : codecvt&lt;char32_t, char, mbstate_t&gt;(1) {}

    <span class="gs">__attribute__</span>((__visibility__(&quot;default&quot;))) ~__widen_from_utf8();

    template &lt;class _OutputIterator&gt;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    _OutputIterator
    operator()(_OutputIterator <span class="gs">__s, const char* __</span>nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (<span class="gs">__nb &lt; __</span>ne &amp;&amp; __r != error)
        {
            const int __sz = 32;
            char32_t <span class="gs">__buf[__</span>sz];
            char32_t* __bn;
            const char* <span class="gs">__nn = __</span>nb;
            __r = do_in(__mb, <span class="gs">__nb, __</span>ne - <span class="gs">__nb &gt; __</span>sz ? <span class="gs">__nb+__</span>sz : <span class="gs">__ne, __</span>nn,
                        <span class="gs">__buf, __</span>buf+__sz, __bn);
            if (__r == codecvt_base::error || <span class="gs">__nn == __</span>nb)
                __throw_runtime_error(&quot;locale not supported&quot;);
            for (const char32_t* <span class="gs">__p = __</span>buf; <span class="gs">__p &lt; __</span>bn; ++__p, ++__s)
                <span class="ge">*__s = (wchar_t)*</span>__p;
            <span class="gs">__nb = __</span>nn;
        }
        return __s;
    }
};



template &lt;class <span class="ge">_CharT&gt; class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) numpunct;

template &lt;&gt;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) numpunct&lt;char&gt;
    : public locale::facet
{
public:
    typedef char char_type;
    typedef basic_string&lt;char_type&gt; string_type;

    explicit numpunct(size_t __refs = 0);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) char_type decimal_point() const {return do_decimal_point();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) char_type thousands_sep() const {return do_thousands_sep();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) string grouping() const {return do_grouping();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) string_type truename() const {return do_truename();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};

template &lt;&gt;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) numpunct&lt;wchar_t&gt;
    : public locale::facet
{
public:
    typedef wchar_t char_type;
    typedef basic_string&lt;char_type&gt; string_type;

    explicit numpunct(size_t __refs = 0);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) char_type decimal_point() const {return do_decimal_point();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) char_type thousands_sep() const {return do_thousands_sep();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) string grouping() const {return do_grouping();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) string_type truename() const {return do_truename();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};



template &lt;class <span class="ge">_CharT&gt; class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) numpunct_byname;

template &lt;&gt;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) numpunct_byname&lt;char&gt;
: public numpunct&lt;char&gt;
{
public:
    typedef char char_type;
    typedef basic_string&lt;char_type&gt; string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string&amp; __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

template &lt;&gt;
class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) numpunct_byname&lt;wchar_t&gt;
: public numpunct&lt;wchar_t&gt;
{
public:
    typedef wchar_t char_type;
    typedef basic_string&lt;char_type&gt; string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string&amp; __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

} }


namespace std { inline namespace __1 {

typedef ptrdiff_t streamsize;

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) ios_base
{
public:
    class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) failure;

    typedef unsigned int fmtflags;
    static const fmtflags boolalpha = 0x0001;
    static const fmtflags dec = 0x0002;
    static const fmtflags fixed = 0x0004;
    static const fmtflags hex = 0x0008;
    static const fmtflags internal = 0x0010;
    static const fmtflags left = 0x0020;
    static const fmtflags oct = 0x0040;
    static const fmtflags right = 0x0080;
    static const fmtflags scientific = 0x0100;
    static const fmtflags showbase = 0x0200;
    static const fmtflags showpoint = 0x0400;
    static const fmtflags showpos = 0x0800;
    static const fmtflags skipws = 0x1000;
    static const fmtflags unitbuf = 0x2000;
    static const fmtflags uppercase = 0x4000;
    static const fmtflags adjustfield = left | right | internal;
    static const fmtflags basefield = dec | oct | hex;
    static const fmtflags floatfield = scientific | fixed;

    typedef unsigned int iostate;
    static const iostate badbit = 0x1;
    static const iostate eofbit = 0x2;
    static const iostate failbit = 0x4;
    static const iostate goodbit = 0x0;

    typedef unsigned int openmode;
    static const openmode app = 0x01;
    static const openmode ate = 0x02;
    static const openmode binary = 0x04;
    static const openmode in = 0x08;
    static const openmode out = 0x10;
    static const openmode trunc = 0x20;

    enum seekdir {beg, cur, end};


    typedef iostate io_state;
    typedef openmode open_mode;
    typedef seekdir seek_dir;

    typedef std::__1::streamoff streamoff;
    typedef std::__1::streampos streampos;


    class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) Init;


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) fmtflags flags() const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) fmtflags flags(fmtflags __fmtfl);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) fmtflags setf(fmtflags __fmtfl);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) fmtflags setf(fmtflags <span class="gs">__fmtfl, fmtflags __</span>mask);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void unsetf(fmtflags __mask);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) streamsize precision() const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) streamsize precision(streamsize __prec);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) streamsize width() const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) streamsize width(streamsize __wide);


    locale imbue(const locale&amp; __loc);
    locale getloc() const;


    static int xalloc();
    long&amp; iword(int __index);
    void*&amp; pword(int __index);


    virtual ~ios_base();


    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&amp;, int __index);
    void register_callback(event_callback <span class="gs">__fn, int __</span>index);

private:
    ios_base(const ios_base&amp;);
    ios_base&amp; operator=(const ios_base&amp;);

public:
    static bool sync_with_stdio(bool __sync = true);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) iostate rdstate() const;
    void clear(iostate __state = goodbit);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void setstate(iostate __state);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool good() const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool eof() const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool fail() const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool bad() const;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) iostate exceptions() const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void exceptions(iostate __iostate);

    void __set_badbit_and_consider_rethrow();
    void __set_failbit_and_consider_rethrow();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void __setstate_nothrow(iostate __state)
    {
        if (__rdbuf_)
            __rdstate_ |= __state;
        else
            __rdstate_ |= __state | ios_base::badbit;
    }

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ios_base() {
               }

    void init(void* __sb);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void* rdbuf() const {return __rdbuf_;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
        clear();
    }

    void __call_callbacks(event);
    void copyfmt(const ios_base&amp;);
    void move(ios_base&amp;);
    void swap(ios_base&amp;) throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void set_rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
    }

private:

    fmtflags __fmtflags_;
    streamsize __precision_;
    streamsize __width_;
    iostate __rdstate_;
    iostate __exceptions_;
    void* __rdbuf_;
    void* __loc_;
    event_callback* __fn_;
    int* __index_;
    size_t __event_size_;
    size_t __event_cap_;



    static atomic&lt;int&gt; __xindex_;



    long* __iarray_;
    size_t __iarray_size_;
    size_t __iarray_cap_;
    void** __parray_;
    size_t __parray_size_;
    size_t __parray_cap_;
};


struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) io_errc { enum __lx
{
    stream = 1
};
<span class="gs">__lx __</span>v<span class="ge">_; __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) io_errc(__lx <span class="gs">__v) : __</span>v<span class="ge">_(__v) {} __attribute_</span>_ ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit io_errc(int <span class="gs">__v) : __</span>v<span class="ge">_(static_</span>cast&lt;__lx&gt;(__v)) {} <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) operator int() const {return __v_;} };

template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_error_code_enum&lt;io_errc&gt; : public true_type { };


template &lt;&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) is_error_code_enum&lt;io_errc::__lx&gt; : public true_type { };


<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;)))
const error_category&amp; iostream_category() throw();

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
error_code
make_error_code(io_errc __e) throw()
{
    return error_code(static_cast&lt;int&gt;(__e), iostream_category());
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
error_condition
make_error_condition(io_errc __e) throw()
{
    return error_condition(static_cast&lt;int&gt;(__e), iostream_category());
}

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) ios_base::failure
    : public system_error
{
public:
    explicit failure(const string&amp; __msg, const error_code&amp; __ec = io_errc::stream);
    explicit failure(const char* __msg, const error_code&amp; __ec = io_errc::stream);
    virtual ~failure() throw();
};

<span class="gs">__attribute__</span> ((noreturn)) inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void __throw_failure(char const* __msg) {

    throw ios_base::failure(__msg);




}

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) ios_base::Init
{
public:
    Init();
    ~Init();
};



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base::fmtflags
ios_base::flags() const
{
    return __fmtflags_;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base::fmtflags
ios_base::flags(fmtflags __fmtfl)
{
    fmtflags <span class="gs">__r = __</span>fmtflags_;
    __fmtflags_ = __fmtfl;
    return __r;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl)
{
    fmtflags <span class="gs">__r = __</span>fmtflags_;
    __fmtflags_ |= __fmtfl;
    return __r;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
ios_base::unsetf(fmtflags __mask)
{
    __fmtflags_ &amp;= ~__mask;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base::fmtflags
ios_base::setf(fmtflags <span class="gs">__fmtfl, fmtflags __</span>mask)
{
    fmtflags <span class="gs">__r = __</span>fmtflags_;
    unsetf(__mask);
    __fmtflags_ |= <span class="gs">__fmtfl &amp; __</span>mask;
    return __r;
}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
streamsize
ios_base::precision() const
{
    return __precision_;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
streamsize
ios_base::precision(streamsize __prec)
{
    streamsize <span class="gs">__r = __</span>precision_;
    __precision_ = __prec;
    return __r;
}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
streamsize
ios_base::width() const
{
    return __width_;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
streamsize
ios_base::width(streamsize __wide)
{
    streamsize <span class="gs">__r = __</span>width_;
    __width_ = __wide;
    return __r;
}



inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base::iostate
ios_base::rdstate() const
{
    return __rdstate_;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
ios_base::setstate(iostate __state)
{
    clear(__rdstate_ | __state);
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
ios_base::good() const
{
    return __rdstate_ == 0;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
ios_base::eof() const
{
    return (__rdstate_ &amp; eofbit) != 0;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
ios_base::fail() const
{
    return (__rdstate_ &amp; (failbit | badbit)) != 0;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
ios_base::bad() const
{
    return (__rdstate_ &amp; badbit) != 0;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base::iostate
ios_base::exceptions() const
{
    return __exceptions_;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
ios_base::exceptions(iostate __iostate)
{
    __exceptions_ = __iostate;
    clear(__rdstate_);
}


struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __cxx03_bool {
  typedef void (__cxx03_bool::*__bool_type)();
  void __true_value() {}
};


template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_ios
    : public ios_base
{
public:

    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_Traits traits_</span>type;

    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    <span class="ge">_Static_</span>assert((is_same&lt;_CharT, typename traits_type::char_type&gt;::value), &quot;traits_type::char_type must be the same type as CharT&quot;);






    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    operator __cxx03_bool::__bool_type() const {
        return !fail() ? &amp;__cxx03_bool::__true_value : std::__1::__get_nullptr_t();
    }





    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool operator!() const {return fail();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) iostate rdstate() const {return ios_base::rdstate();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void clear(iostate __state = goodbit) {ios_base::clear(__state);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void setstate(iostate __state) {ios_base::setstate(__state);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool good() const {return ios_base::good();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool eof() const {return ios_base::eof();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool fail() const {return ios_base::fail();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool bad() const {return ios_base::bad();}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) iostate exceptions() const {return ios_base::exceptions();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit basic_ios(basic_streambuf&lt;char_type,traits_type&gt;* __sb);
    virtual ~basic_ios();


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_ostream&lt;char_type, traits_type&gt;* tie() const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_ostream&lt;char_type, traits_type&gt;* tie(basic_ostream&lt;char_type, traits_type&gt;* __tiestr);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_streambuf&lt;char_type, traits_type&gt;* rdbuf() const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_streambuf&lt;char_type, traits_type&gt;* rdbuf(basic_streambuf&lt;char_type, traits_type&gt;* __sb);

    basic_ios&amp; copyfmt(const basic_ios&amp; __rhs);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    char_type fill() const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    char_type fill(char_type __ch);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    locale imbue(const locale&amp; __loc);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    char narrow(char_type <span class="gs">__c, char __</span>dfault) const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    char_type widen(char __c) const;

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_ios() {
                }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void init(basic_streambuf&lt;char_type, traits_type&gt;* __sb);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void move(basic_ios&amp; __rhs);




    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void swap(basic_ios&amp; __rhs) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void set_rdbuf(basic_streambuf&lt;char_type, traits_type&gt;* __sb);
private:
    basic_ostream&lt;char_type, traits_type&gt;* __tie_;
    mutable int_type __fill_;
};

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_ios&lt;_CharT, <span class="ge">_Traits&gt;::basic_</span>ios(basic_streambuf&lt;char_type,traits_type&gt;* __sb)
{
    init(__sb);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ios&lt;_CharT, <span class="ge">_Traits&gt;::~basic_</span>ios()
{
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
basic_ios&lt;_CharT, <span class="ge">_Traits&gt;::init(basic_</span>streambuf&lt;char_type, traits_type&gt;* __sb)
{
    ios_base::init(__sb);
    __tie_ = 0;
    __fill_ = traits_type::eof();
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_ostream&lt;_CharT, _Traits&gt;*
basic_ios&lt;_CharT, _Traits&gt;::tie() const
{
    return __tie_;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_ostream&lt;_CharT, _Traits&gt;*
basic_ios&lt;_CharT, <span class="ge">_Traits&gt;::tie(basic_</span>ostream&lt;char_type, traits_type&gt;* __tiestr)
{
    basic_ostream&lt;char_type, traits_type&gt;* <span class="gs">__r = __</span>tie_;
    __tie_ = __tiestr;
    return __r;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_streambuf&lt;_CharT, _Traits&gt;*
basic_ios&lt;_CharT, _Traits&gt;::rdbuf() const
{
    return static_cast&lt;basic_streambuf&lt;char_type, traits_type&gt;*&gt;(ios_base::rdbuf());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_streambuf&lt;_CharT, _Traits&gt;*
basic_ios&lt;_CharT, <span class="ge">_Traits&gt;::rdbuf(basic_</span>streambuf&lt;char_type, traits_type&gt;* __sb)
{
    basic_streambuf&lt;char_type, traits_type&gt;* __r = rdbuf();
    ios_base::rdbuf(__sb);
    return __r;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
locale
basic_ios&lt;_CharT, <span class="ge">_Traits&gt;::imbue(const locale&amp; _</span>_loc)
{
    locale __r = getloc();
    ios_base::imbue(__loc);
    if (rdbuf())
        rdbuf()-&gt;pubimbue(__loc);
    return __r;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
char
basic_ios&lt;_CharT, <span class="ge">_Traits&gt;::narrow(char_</span>type <span class="gs">__c, char __</span>dfault) const
{
    return use_facet&lt;ctype&lt;char_type&gt; &gt;(getloc()).narrow(__c, __dfault);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_CharT
basic_ios&lt;_CharT, <span class="ge">_Traits&gt;::widen(char _</span>_c) const
{
    return use_facet&lt;ctype&lt;char_type&gt; &gt;(getloc()).widen(__c);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_CharT
basic_ios&lt;_CharT, _Traits&gt;::fill() const
{
    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
        __fill_ = widen(&#39; &#39;);
    return __fill_;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
_CharT
basic_ios&lt;_CharT, <span class="ge">_Traits&gt;::fill(char_</span>type __ch)
{
    char_type <span class="gs">__r = __</span>fill_;
    __fill_ = __ch;
    return __r;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ios&lt;_CharT, _Traits&gt;&amp;
basic_ios&lt;_CharT, <span class="ge">_Traits&gt;::copyfmt(const basic_</span>ios&amp; __rhs)
{
    if (this != &amp;__rhs)
    {
        __call_callbacks(erase_event);
        ios_base::copyfmt(__rhs);
        __tie_ = <span class="gs">__rhs.__</span>tie_;
        __fill_ = <span class="gs">__rhs.__</span>fill_;
        __call_callbacks(copyfmt_event);
        exceptions(__rhs.exceptions());
    }
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
basic_ios&lt;_CharT, <span class="ge">_Traits&gt;::move(basic_</span>ios&amp; __rhs)
{
    ios_base::move(__rhs);
    __tie_ = <span class="gs">__rhs.__</span>tie_;
    <span class="gs">__rhs.__</span>tie_ = 0;
    __fill_ = <span class="gs">__rhs.__</span>fill_;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
basic_ios&lt;_CharT, <span class="ge">_Traits&gt;::swap(basic_</span>ios&amp; __rhs) throw()
{
    ios_base::swap(__rhs);
    std::__1::swap(__tie_, <span class="gs">__rhs.__</span>tie_);
    std::__1::swap(__fill_, <span class="gs">__rhs.__</span>fill_);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
basic_ios&lt;_CharT, <span class="ge">_Traits&gt;::set_</span>rdbuf(basic_streambuf&lt;char_type, traits_type&gt;* __sb)
{
    ios_base::set_rdbuf(__sb);
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
boolalpha(ios_base&amp; __str)
{
    __str.setf(ios_base::boolalpha);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
noboolalpha(ios_base&amp; __str)
{
    __str.unsetf(ios_base::boolalpha);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
showbase(ios_base&amp; __str)
{
    __str.setf(ios_base::showbase);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
noshowbase(ios_base&amp; __str)
{
    __str.unsetf(ios_base::showbase);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
showpoint(ios_base&amp; __str)
{
    __str.setf(ios_base::showpoint);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
noshowpoint(ios_base&amp; __str)
{
    __str.unsetf(ios_base::showpoint);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
showpos(ios_base&amp; __str)
{
    __str.setf(ios_base::showpos);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
noshowpos(ios_base&amp; __str)
{
    __str.unsetf(ios_base::showpos);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
skipws(ios_base&amp; __str)
{
    __str.setf(ios_base::skipws);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
noskipws(ios_base&amp; __str)
{
    __str.unsetf(ios_base::skipws);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
uppercase(ios_base&amp; __str)
{
    __str.setf(ios_base::uppercase);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
nouppercase(ios_base&amp; __str)
{
    __str.unsetf(ios_base::uppercase);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
unitbuf(ios_base&amp; __str)
{
    __str.setf(ios_base::unitbuf);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
nounitbuf(ios_base&amp; __str)
{
    __str.unsetf(ios_base::unitbuf);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
internal(ios_base&amp; __str)
{
    __str.setf(ios_base::internal, ios_base::adjustfield);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
left(ios_base&amp; __str)
{
    __str.setf(ios_base::left, ios_base::adjustfield);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
right(ios_base&amp; __str)
{
    __str.setf(ios_base::right, ios_base::adjustfield);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
dec(ios_base&amp; __str)
{
    __str.setf(ios_base::dec, ios_base::basefield);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
hex(ios_base&amp; __str)
{
    __str.setf(ios_base::hex, ios_base::basefield);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
oct(ios_base&amp; __str)
{
    __str.setf(ios_base::oct, ios_base::basefield);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
fixed(ios_base&amp; __str)
{
    __str.setf(ios_base::fixed, ios_base::floatfield);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
scientific(ios_base&amp; __str)
{
    __str.setf(ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
hexfloat(ios_base&amp; __str)
{
    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
ios_base&amp;
defaultfloat(ios_base&amp; __str)
{
    __str.unsetf(ios_base::floatfield);
    return __str;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
class __save_flags
{
    typedef basic_ios&lt;_CharT, <span class="ge">_Traits&gt; __stream_</span>type;
    typedef typename __stream_type::fmtflags fmtflags;

    __stream_type&amp; __stream_;
    fmtflags __fmtflags_;
    <span class="ge">_CharT __fill_</span>;

    __save_flags(const __save_flags&amp;);
    __save_flags&amp; operator=(const __save_flags&amp;);
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit __save_flags(__stream_type&amp; __stream)
        : __stream_(__stream),
          __fmtflags_(__stream.flags()),
          __fill_(__stream.fill())
        {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~__save_flags()
    {
        __stream_.flags(__fmtflags_);
        __stream_.fill(__fill_);
    }
};

} }




namespace std { inline namespace __1 {

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_streambuf
{
public:

    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_Traits traits_</span>type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    <span class="ge">_Static_</span>assert((is_same&lt;_CharT, typename traits_type::char_type&gt;::value), &quot;traits_type::char_type must be the same type as CharT&quot;);


    virtual ~basic_streambuf();


    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    locale pubimbue(const locale&amp; __loc) {
        imbue(__loc);
        locale <span class="gs">__r = __</span>loc_;
        __loc_ = __loc;
        return __r;
    }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    locale getloc() const { return __loc_; }


    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_streambuf* pubsetbuf(char_type* <span class="gs">__s, streamsize __</span>n)
    { return setbuf(__s, __n); }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,
                        ios_base::openmode __which = ios_base::in | ios_base::out)
    { return seekoff(__off, <span class="gs">__way, __</span>which); }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pos_type pubseekpos(pos_type __sp,
                        ios_base::openmode __which = ios_base::in | ios_base::out)
    { return seekpos(__sp, __which); }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int pubsync() { return sync(); }



    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    streamsize in_avail() {
        if (__ninp_ &lt; __einp_)
            return static_cast&lt;streamsize&gt;(__einp_ - __ninp_);
        return showmanyc();
    }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int_type snextc() {
        if (sbumpc() == traits_type::eof())
            return traits_type::eof();
        return sgetc();
    }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int_type sbumpc() {
        if (__ninp_ == __einp_)
            return uflow();
        return traits_type::to_int_type(*__ninp_++);
    }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int_type sgetc() {
        if (__ninp_ == __einp_)
            return underflow();
        return traits_type::to_int_type(*__ninp_);
    }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    streamsize sgetn(char_type* <span class="gs">__s, streamsize __</span>n)
    { return xsgetn(__s, __n); }


    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int_type sputbackc(char_type __c) {
        if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
            return pbackfail(traits_type::to_int_type(__c));
        return traits_type::to_int_type(*--__ninp_);
    }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int_type sungetc() {
        if (__binp_ == __ninp_)
          return pbackfail();
        return traits_type::to_int_type(*--__ninp_);
    }


    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    int_type sputc(char_type __c) {
        if (__nout_ == __eout_)
            return overflow(traits_type::to_int_type(__c));
        *__nout_++ = __c;
        return traits_type::to_int_type(__c);
    }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    streamsize sputn(const char_type* <span class="gs">__s, streamsize __</span>n)
    { return xsputn(__s, __n); }

protected:
    basic_streambuf();
    basic_streambuf(const basic_streambuf&amp; __rhs);
    basic_streambuf&amp; operator=(const basic_streambuf&amp; __rhs);
    void swap(basic_streambuf&amp; __rhs);


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) char_type* eback() const {return __binp_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) char_type* gptr() const {return __ninp_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) char_type* egptr() const {return __einp_;}

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void gbump(int <span class="gs">__n) { __</span>ninp_ += __n; }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {
        __binp_ = __gbeg;
        __ninp_ = __gnext;
        __einp_ = __gend;
    }


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) char_type* pbase() const {return __bout_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) char_type* pptr() const {return __nout_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) char_type* epptr() const {return __eout_;}

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void pbump(int <span class="gs">__n) { __</span>nout_ += __n; }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void <span class="gs">__pbump(streamsize __</span>n) { __nout_ += __n; }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void setp(char_type* __pbeg, char_type* __pend) {
        __bout_ = __nout_ = __pbeg;
        __eout_ = __pend;
    }



    virtual void imbue(const locale&amp; __loc);


    virtual basic_streambuf* setbuf(char_type* <span class="gs">__s, streamsize __</span>n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual int sync();


    virtual streamsize showmanyc();
    virtual streamsize xsgetn(char_type* <span class="gs">__s, streamsize __</span>n);
    virtual int_type underflow();
    virtual int_type uflow();


    virtual int_type pbackfail(int_type __c = traits_type::eof());


    virtual streamsize xsputn(const char_type* <span class="gs">__s, streamsize __</span>n);
    virtual int_type overflow(int_type __c = traits_type::eof());

private:
    locale __loc_;
    char_type* __binp_;
    char_type* __ninp_;
    char_type* __einp_;
    char_type* __bout_;
    char_type* __nout_;
    char_type* __eout_;
};

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::~basic_</span>streambuf()
{
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::basic_</span>streambuf()
    : __binp_(0),
      __ninp_(0),
      __einp_(0),
      __bout_(0),
      __nout_(0),
      __eout_(0)
{
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::basic_</span>streambuf(const basic_streambuf&amp; __sb)
    : __loc_(__sb.__loc_),
      __binp_(__sb.__binp_),
      __ninp_(__sb.__ninp_),
      __einp_(__sb.__einp_),
      __bout_(__sb.__bout_),
      __nout_(__sb.__nout_),
      __eout_(__sb.__eout_)
{
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_streambuf&lt;_CharT, _Traits&gt;&amp;
basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::operator=(const basic_</span>streambuf&amp; __sb)
{
    __loc_ = <span class="gs">__sb.__</span>loc_;
    __binp_ = <span class="gs">__sb.__</span>binp_;
    __ninp_ = <span class="gs">__sb.__</span>ninp_;
    __einp_ = <span class="gs">__sb.__</span>einp_;
    __bout_ = <span class="gs">__sb.__</span>bout_;
    __nout_ = <span class="gs">__sb.__</span>nout_;
    __eout_ = <span class="gs">__sb.__</span>eout_;
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
void
basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::swap(basic_</span>streambuf&amp; __sb)
{
    std::__1::swap(__loc_, <span class="gs">__sb.__</span>loc_);
    std::__1::swap(__binp_, <span class="gs">__sb.__</span>binp_);
    std::__1::swap(__ninp_, <span class="gs">__sb.__</span>ninp_);
    std::__1::swap(__einp_, <span class="gs">__sb.__</span>einp_);
    std::__1::swap(__bout_, <span class="gs">__sb.__</span>bout_);
    std::__1::swap(__nout_, <span class="gs">__sb.__</span>nout_);
    std::__1::swap(__eout_, <span class="gs">__sb.__</span>eout_);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
void
basic_streambuf&lt;_CharT, _Traits&gt;::imbue(const locale&amp;)
{
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_streambuf&lt;_CharT, _Traits&gt;*
basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::setbuf(char_</span>type*, streamsize)
{
    return this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
typename basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::pos_</span>type
basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::seekoff(off_</span>type, ios_base::seekdir,
                                          ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
typename basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::pos_</span>type
basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::seekpos(pos_</span>type, ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
int
basic_streambuf&lt;_CharT, _Traits&gt;::sync()
{
    return 0;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
streamsize
basic_streambuf&lt;_CharT, _Traits&gt;::showmanyc()
{
    return 0;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
streamsize
basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::xsgetn(char_</span>type* <span class="gs">__s, streamsize __</span>n)
{
    const int_type __eof = traits_type::eof();
    int_type __c;
    streamsize __i = 0;
    while(__i &lt; __n)
    {
        if (__ninp_ &lt; __einp_)
        {
            const streamsize <span class="gs">__len = std::__</span>1::min(static_cast&lt;streamsize&gt;(2147483647),
                                std::__1::min(__einp_ - __ninp_, <span class="gs">__n - __</span>i));
            traits_type::copy(__s, __ninp_, __len);
            <span class="gs">__s += __</span>len;
            <span class="gs">__i += __</span>len;
            this-&gt;gbump(__len);
        }
        else if ((__c = uflow()) != __eof)
        {
            *__s = traits_type::to_char_type(__c);
            ++__s;
            ++__i;
        }
        else
            break;
    }
    return __i;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
typename basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::int_</span>type
basic_streambuf&lt;_CharT, _Traits&gt;::underflow()
{
    return traits_type::eof();
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
typename basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::int_</span>type
basic_streambuf&lt;_CharT, _Traits&gt;::uflow()
{
    if (underflow() == traits_type::eof())
        return traits_type::eof();
    return traits_type::to_int_type(*__ninp_++);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
typename basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::int_</span>type
basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::pbackfail(int_</span>type)
{
    return traits_type::eof();
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
streamsize
basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::xsputn(const char_</span>type* <span class="gs">__s, streamsize __</span>n)
{
    streamsize __i = 0;
    int_type __eof = traits_type::eof();
    while( <span class="gs">__i &lt; __</span>n)
    {
        if (__nout_ &gt;= __eout_)
        {
            if (overflow(traits_type::to_int_type(*__s)) == __eof)
                break;
            ++__s;
            ++__i;
        }
        else
        {
            streamsize __chunk_size = std::__1::min(__eout_ - __nout_, <span class="gs">__n - __</span>i);
            traits_type::copy(__nout_, <span class="gs">__s, __</span>chunk_size);
            __nout_ += __chunk_size;
            <span class="gs">__s += __</span>chunk_size;
            <span class="gs">__i += __</span>chunk_size;
        }
    }
    return __i;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
typename basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::int_</span>type
basic_streambuf&lt;_CharT, <span class="ge">_Traits&gt;::overflow(int_</span>type)
{
    return traits_type::eof();
}


extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) basic_streambuf&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) basic_streambuf&lt;wchar_t&gt;;

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) basic_ios&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) basic_ios&lt;wchar_t&gt;;


} }



typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;

typedef unsigned long u_long;


typedef unsigned short ushort;
typedef unsigned int uint;


typedef u<span class="ge">_int64_</span>t u<span class="ge">_quad_</span>t;
typedef int64_t quad_t;
typedef quad_t * qaddr_t;


typedef char * caddr_t;

typedef int32_t daddr_t;



typedef u<span class="ge">_int32_</span>t fixpt_t;


typedef __darwin_blkcnt_t blkcnt_t;
typedef __darwin_blksize_t blksize_t;
typedef __darwin_gid_t gid_t;
typedef __uint32_t in_addr_t;
typedef __uint16_t in_port_t;
typedef __darwin_ino_t ino_t;


typedef __darwin_ino64_t ino64_t;


typedef __int32_t key_t;

typedef __uint16_t nlink_t;




typedef int32_t segsz_t;
typedef int32_t swblk_t;
static inline __int32_t
major(__uint32_t _x)
{
 return (__int32_t)(((__uint32_t)_x &gt;&gt; 24) &amp; 0xff);
}

static inline __int32_t
minor(__uint32_t _x)
{
 return (__int32_t)((_x) &amp; 0xffffff);
}

static inline dev_t
makedev(__uint32_t <span class="ge">_major, __uint32_</span>t _minor)
{
 return (dev_t)(((_major) &lt;&lt; 24) | (_minor));
}
typedef __darwin_useconds_t useconds_t;
typedef __darwin_suseconds_t suseconds_t;


extern &quot;C&quot; {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;

int __darwin_check_fd_set_overflow(int, const void *, int) <span class="gs">__attribute__</span>((availability(macosx,introduced=11.0))) <span class="gs">__attribute__</span>((availability(ios,introduced=14.0))) <span class="gs">__attribute__</span>((availability(tvos,introduced=14.0))) <span class="gs">__attribute__</span>((availability(watchos,introduced=7.0)));
}

inline <span class="gs">__attribute__</span> ((__always_inline__)) int
__darwin_check_fd_set(int <span class="ge">_a, const void *_</span>b)
{

<span class="gh">#pragma clang diagnostic push</span>
<span class="gh">#pragma clang diagnostic ignored &quot;-Wunguarded-availability-new&quot;</span>

 if ((uintptr_t)&amp;__darwin_check_fd_set_overflow != (uintptr_t) 0) {



  return __darwin_check_fd_set_overflow(_a, _b, 0);

 } else {
  return 1;
 }

<span class="gh">#pragma clang diagnostic pop</span>

}


inline <span class="gs">__attribute__</span> ((__always_inline__)) int
__darwin_fd_isset(int <span class="ge">_fd, const struct fd_</span>set *_p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  return <span class="ge">_p-&gt;fds_</span>bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] &amp; ((__int32_t)(((unsigned long)1) &lt;&lt; ((unsigned long)_fd % (sizeof(__int32_t) * 8))));
 }

 return 0;
}

inline <span class="gs">__attribute__</span> ((__always_inline__)) void
__darwin_fd_set(int <span class="ge">_fd, struct fd_</span>set *const _p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  (<span class="ge">_p-&gt;fds_</span>bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] |= ((__int32_t)(((unsigned long)1) &lt;&lt; ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
 }
}

inline <span class="gs">__attribute__</span> ((__always_inline__)) void
__darwin_fd_clr(int <span class="ge">_fd, struct fd_</span>set *const _p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  (<span class="ge">_p-&gt;fds_</span>bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] &amp;= ~((__int32_t)(((unsigned long)1) &lt;&lt; ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
 }
}




typedef __int32_t fd_mask;










typedef __darwin_fsblkcnt_t fsblkcnt_t;
typedef __darwin_fsfilcnt_t fsfilcnt_t;
typedef struct __nl_cat_d {
 void *__data;
 int __size;
} *nl_catd;


typedef __darwin_nl_item nl_item;

extern &quot;C&quot; {
nl_catd catopen(const char *, int);
char <span class="ge">*catgets(nl_catd, int, int, const char *</span>)
 <span class="gs">__attribute__</span>((__format_arg__(4)));
int catclose(nl_catd);
}












namespace std { inline namespace __1 {
template &lt;class <span class="ge">_InputIterator, class _</span>ForwardIterator, class _Ctype&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
_ForwardIterator
__scan_keyword(_InputIterator&amp; __b, <span class="ge">_InputIterator _</span>_e,
               <span class="ge">_ForwardIterator __kb, _</span>ForwardIterator __ke,
               const <span class="ge">_Ctype&amp; __ct, ios_</span>base::iostate&amp; __err,
               bool __case_sensitive = true)
{
    typedef typename iterator_traits&lt;_InputIterator&gt;::value_type _CharT;
    size_t __nkw = static_cast&lt;size_t&gt;(std::__1::distance(__kb, __ke));
    const unsigned char __doesnt_match = &#39;\0&#39;;
    const unsigned char __might_match = &#39;\1&#39;;
    const unsigned char __does_match = &#39;\2&#39;;
    unsigned char __statbuf[100];
    unsigned char* <span class="gs">__status = __</span>statbuf;
    unique_ptr&lt;unsigned char, void(*)(void*)&gt; __stat_hold(0, free);
    if (<span class="gs">__nkw &gt; sizeof(__</span>statbuf))
    {
        <span class="gs">__status = (unsigned char*)malloc(__</span>nkw);
        if (__status == 0)
            __throw_bad_alloc();
        __stat_hold.reset(__status);
    }
    size_t __n_might_match = __nkw;
    size_t __n_does_match = 0;

    unsigned char* <span class="gs">__st = __</span>status;
    for (<span class="ge">_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++_</span>_st)
    {
        if (!__ky-&gt;empty())
            *<span class="gs">__st = __</span>might_match;
        else
        {
            *<span class="gs">__st = __</span>does_match;
            --__n_might_match;
            ++__n_does_match;
        }
    }

    for (size_t <span class="gs">__indx = 0; __</span>b != <span class="gs">__e &amp;&amp; __</span>n<span class="ge">_might_</span>match &gt; 0; ++__indx)
    {

        <span class="ge">_CharT __c = *_</span>_b;
        if (!__case_sensitive)
            <span class="gs">__c = __</span>ct.toupper(__c);
        bool __consume = false;






        <span class="gs">__st = __</span>status;
        for (<span class="ge">_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++_</span>_st)
        {
            if (*__st == __might_match)
            {
                <span class="ge">_CharT __kc = (*__ky)[_</span>_indx];
                if (!__case_sensitive)
                    <span class="gs">__kc = __</span>ct.toupper(__kc);
                if (<span class="gs">__c == __</span>kc)
                {
                    __consume = true;
                    if (<span class="gs">__ky-&gt;size() == __</span>indx+1)
                    {
                        *<span class="gs">__st = __</span>does_match;
                        --__n_might_match;
                        ++__n_does_match;
                    }
                }
                else
                {
                    *<span class="gs">__st = __</span>doesnt_match;
                    --__n_might_match;
                }
            }
        }

        if (__consume)
        {
            ++__b;



            if (__n_might_match + __n_does_match &gt; 1)
            {
                <span class="gs">__st = __</span>status;
                for (<span class="ge">_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++_</span>_st)
                {
                    if (*__st == __does_match &amp;&amp; <span class="gs">__ky-&gt;size() != __</span>indx+1)
                    {
                        *<span class="gs">__st = __</span>doesnt_match;
                        --__n_does_match;
                    }
                }
            }
        }
    }

    if (<span class="gs">__b == __</span>e)
        __err |= ios_base::eofbit;

    for (<span class="gs">__st = __</span>status; <span class="gs">__kb != __</span>ke; ++__kb, (void) ++__st)
        if (*__st == __does_match)
            break;
    if (<span class="gs">__kb == __</span>ke)
        __err |= ios_base::failbit;
    return __kb;
}

struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __num_get_base
{
    static const int __num_get_buf_sz = 40;

    static int __get_base(ios_base&amp;);
    static const char __src[33];
};

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;)))
void __check_grouping(const string&amp; <span class="gs">__grouping, unsigned* __</span>g, unsigned* __g_end,
                      ios_base::iostate&amp; __err);

template &lt;class _CharT&gt;
struct __num_get
    : protected __num_get_base
{
    static string __stage2_float_prep(ios_base&amp; __iob, <span class="ge">_CharT* __atoms, _</span>CharT&amp; __decimal_point,
                                      <span class="ge">_CharT&amp; __thousands_</span>sep);

    static int __stage2_float_loop(_CharT <span class="gs">__ct, bool&amp; __</span>in_units, char&amp; __exp,
                                   char* <span class="gs">__a, char*&amp; __</span>a_end,
                                   <span class="ge">_CharT __decimal_</span>point, <span class="ge">_CharT __thousands_</span>sep,
                                   const string&amp; <span class="gs">__grouping, unsigned* __</span>g,
                                   unsigned*&amp; __g_end, unsigned&amp; __dc, <span class="ge">_CharT* _</span>_atoms);

    static string __stage2_int_prep(ios_base&amp; __iob, <span class="ge">_CharT* __atoms, _</span>CharT&amp; __thousands_sep);
    static int __stage2_int_loop(_CharT <span class="gs">__ct, int __</span>base, char* <span class="gs">__a, char*&amp; __</span>a_end,
                  unsigned&amp; __dc, <span class="ge">_CharT __thousands_</span>sep, const string&amp; __grouping,
                  unsigned* <span class="gs">__g, unsigned*&amp; __</span>g<span class="ge">_end, _</span>CharT* __atoms);
};


template &lt;class _CharT&gt;
string
__num_get&lt;_CharT&gt;::__stage2_int_prep(ios_base&amp; __iob, <span class="ge">_CharT* __atoms, _</span>CharT&amp; __thousands_sep)
{
    locale <span class="gs">__loc = __</span>iob.getloc();
    use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).widen(__src, <span class="gs">__src + 26, __</span>atoms);
    const numpunct&lt;_CharT&gt;&amp; __np = use_facet&lt;numpunct&lt;_CharT&gt; &gt;(__loc);
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}


template &lt;class _CharT&gt;
string
__num_get&lt;_CharT&gt;::__stage2_float_prep(ios_base&amp; __iob, <span class="ge">_CharT* __atoms, _</span>CharT&amp; __decimal_point,
                    <span class="ge">_CharT&amp; __thousands_</span>sep)
{
    locale <span class="gs">__loc = __</span>iob.getloc();
    use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).widen(__src, <span class="gs">__src + 32, __</span>atoms);
    const numpunct&lt;_CharT&gt;&amp; __np = use_facet&lt;numpunct&lt;_CharT&gt; &gt;(__loc);
    __decimal_point = __np.decimal_point();
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}

template &lt;class _CharT&gt;
int

__num_get&lt;_CharT&gt;::__stage2_int_loop(_CharT <span class="gs">__ct, int __</span>base, char* <span class="gs">__a, char*&amp; __</span>a_end,
                  unsigned&amp; __dc, <span class="ge">_CharT __thousands_</span>sep, const string&amp; __grouping,
                  unsigned* <span class="gs">__g, unsigned*&amp; __</span>g<span class="ge">_end, _</span>CharT* __atoms)






{
    if (__a_end == <span class="gs">__a &amp;&amp; (__</span>ct == <span class="gs">__atoms[24] || __</span>ct == __atoms[25]))
    {
        *__a_end++ = <span class="gs">__ct == __</span>atoms[24] ? &#39;+&#39; : &#39;-&#39;;
        __dc = 0;
        return 0;
    }
    if (<span class="gs">__grouping.size() != 0 &amp;&amp; __</span>ct == __thousands_sep)
    {
        if (__g_end-__g &lt; __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t <span class="gs">__f = find(__</span>atoms, <span class="gs">__atoms + 26, __</span>ct) - __atoms;
    if (__f &gt;= 24)
        return -1;
    switch (__base)
    {
    case 8:
    case 10:
        if (<span class="gs">__f &gt;= __</span>base)
            return -1;
        break;
    case 16:
        if (__f &lt; 22)
            break;
        if (__a_end != <span class="gs">__a &amp;&amp; __</span>a<span class="ge">_end - __a &lt;= 2 &amp;&amp; __a_</span>end[-1] == &#39;0&#39;)
        {
            __dc = 0;
            *__a_end++ = <span class="gs">__src[__</span>f];
            return 0;
        }
        return -1;
    }
    *__a_end++ = <span class="gs">__src[__</span>f];
    ++__dc;
    return 0;
}

template &lt;class _CharT&gt;
int
__num_get&lt;_CharT&gt;::__stage2_float_loop(_CharT <span class="gs">__ct, bool&amp; __</span>in_units, char&amp; <span class="gs">__exp, char* __</span>a, char*&amp; __a_end,
                    <span class="ge">_CharT __decimal_</span>point, <span class="ge">_CharT __thousands_</span>sep, const string&amp; __grouping,
                    unsigned* <span class="gs">__g, unsigned*&amp; __</span>g<span class="ge">_end, unsigned&amp; __dc, _</span>CharT* __atoms)
{
    if (<span class="gs">__ct == __</span>decimal_point)
    {
        if (!__in_units)
            return -1;
        __in_units = false;
        *__a_end++ = &#39;.&#39;;
        if (<span class="gs">__grouping.size() != 0 &amp;&amp; __</span>g<span class="ge">_end-__g &lt; __num_</span>get_buf_sz)
            *__g_end++ = __dc;
        return 0;
    }
    if (<span class="gs">__ct == __</span>thousands_sep &amp;&amp; __grouping.size() != 0)
    {
        if (!__in_units)
            return -1;
        if (__g_end-__g &lt; __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t <span class="gs">__f = find(__</span>atoms, <span class="gs">__atoms + 32, __</span>ct) - __atoms;
    if (__f &gt;= 32)
        return -1;
    char <span class="gs">__x = __</span>src[__f];
    if (<span class="gs">__x == &#39;-&#39; || __</span>x == &#39;+&#39;)
    {
        if (__a_end == <span class="gs">__a || (__</span>a<span class="ge">_end[-1] &amp; 0x5F) == (_</span>_exp &amp; 0x7F))
        {
            *__a_end++ = __x;
            return 0;
        }
        return -1;
    }
    if (<span class="gs">__x == &#39;x&#39; || __</span>x == &#39;X&#39;)
        __exp = &#39;P&#39;;
    else if ((__x &amp; 0x5F) == __exp)
    {
        __exp |= (char) 0x80;
        if (__in_units)
        {
            __in_units = false;
            if (<span class="gs">__grouping.size() != 0 &amp;&amp; __</span>g<span class="ge">_end-__g &lt; __num_</span>get_buf_sz)
                *__g_end++ = __dc;
        }
    }
    *__a_end++ = __x;
    if (__f &gt;= 22)
        return 0;
    ++__dc;
    return 0;
}

extern template struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __num_get&lt;char&gt;;
extern template struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __num_get&lt;wchar_t&gt;;

template &lt;class <span class="ge">_CharT, class _</span>InputIterator = istreambuf_iterator&lt;_CharT&gt; &gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) num_get
    : public locale::facet,
      private __num_get&lt;_CharT&gt;
{
public:
    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_InputIterator iter_</span>type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit num_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                  ios_base::iostate&amp; <span class="gs">__err, bool&amp; __</span>v) const
    {
        return do_get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                  ios_base::iostate&amp; <span class="gs">__err, long&amp; __</span>v) const
    {
        return do_get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                  ios_base::iostate&amp; <span class="gs">__err, long long&amp; __</span>v) const
    {
        return do_get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                  ios_base::iostate&amp; <span class="gs">__err, unsigned short&amp; __</span>v) const
    {
        return do_get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                  ios_base::iostate&amp; <span class="gs">__err, unsigned int&amp; __</span>v) const
    {
        return do_get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                  ios_base::iostate&amp; <span class="gs">__err, unsigned long&amp; __</span>v) const
    {
        return do_get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                  ios_base::iostate&amp; <span class="gs">__err, unsigned long long&amp; __</span>v) const
    {
        return do_get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                  ios_base::iostate&amp; <span class="gs">__err, float&amp; __</span>v) const
    {
        return do_get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                  ios_base::iostate&amp; <span class="gs">__err, double&amp; __</span>v) const
    {
        return do_get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                  ios_base::iostate&amp; <span class="gs">__err, long double&amp; __</span>v) const
    {
        return do_get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                  ios_base::iostate&amp; <span class="gs">__err, void*&amp; __</span>v) const
    {
        return do_get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>v);
    }

    static locale::id id;

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~num_get() {}

    template &lt;class _Fp&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    iter_type __do_get_floating_point
                            (iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; __err, <span class="ge">_Fp&amp; _</span>_v) const;

    template &lt;class _Signed&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    iter_type __do_get_signed
                            (iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; __err, <span class="ge">_Signed&amp; _</span>_v) const;

    template &lt;class _Unsigned&gt;
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
    iter_type __do_get_unsigned
                            (iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; __err, <span class="ge">_Unsigned&amp; _</span>_v) const;


    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; <span class="gs">__err, bool&amp; __</span>v) const;

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; <span class="gs">__err, long&amp; __</span>v) const
    { return this-&gt;__do_get_signed ( <span class="gs">__b, __</span>e, <span class="gs">__iob, __</span>err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; <span class="gs">__err, long long&amp; __</span>v) const
    { return this-&gt;__do_get_signed ( <span class="gs">__b, __</span>e, <span class="gs">__iob, __</span>err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; <span class="gs">__err, unsigned short&amp; __</span>v) const
    { return this-&gt;__do_get_unsigned ( <span class="gs">__b, __</span>e, <span class="gs">__iob, __</span>err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; <span class="gs">__err, unsigned int&amp; __</span>v) const
    { return this-&gt;__do_get_unsigned ( <span class="gs">__b, __</span>e, <span class="gs">__iob, __</span>err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; <span class="gs">__err, unsigned long&amp; __</span>v) const
    { return this-&gt;__do_get_unsigned ( <span class="gs">__b, __</span>e, <span class="gs">__iob, __</span>err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; <span class="gs">__err, unsigned long long&amp; __</span>v) const
    { return this-&gt;__do_get_unsigned ( <span class="gs">__b, __</span>e, <span class="gs">__iob, __</span>err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; <span class="gs">__err, float&amp; __</span>v) const
    { return this-&gt;__do_get_floating_point ( <span class="gs">__b, __</span>e, <span class="gs">__iob, __</span>err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; <span class="gs">__err, double&amp; __</span>v) const
    { return this-&gt;__do_get_floating_point ( <span class="gs">__b, __</span>e, <span class="gs">__iob, __</span>err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; <span class="gs">__err, long double&amp; __</span>v) const
    { return this-&gt;__do_get_floating_point ( <span class="gs">__b, __</span>e, <span class="gs">__iob, __</span>err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; <span class="gs">__err, void*&amp; __</span>v) const;
};

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
locale::id
num_get&lt;_CharT, _InputIterator&gt;::id;

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) _Tp
__num_get_signed_integral(const char* <span class="gs">__a, const char* __</span>a_end,
                          ios_base::iostate&amp; <span class="gs">__err, int __</span>base)
{
    if (<span class="gs">__a != __</span>a_end)
    {
        typename remove_reference&lt;__decltype((*__error()))&gt;::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        long long __ll = strtoll_l(__a, &amp;<span class="gs">__p2, __</span>base, 0);
        typename remove_reference&lt;__decltype((*__error()))&gt;::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (<span class="gs">__p2 != __</span>a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 ||
                 __ll &lt; numeric_limits&lt;_Tp&gt;::min() ||
                 numeric_limits&lt;_Tp&gt;::max() &lt; __ll)
        {
            __err = ios_base::failbit;
            if (__ll &gt; 0)
                return numeric_limits&lt;_Tp&gt;::max();
            else
                return numeric_limits&lt;_Tp&gt;::min();
        }
        return static_cast&lt;_Tp&gt;(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) _Tp
__num_get_unsigned_integral(const char* <span class="gs">__a, const char* __</span>a_end,
                            ios_base::iostate&amp; <span class="gs">__err, int __</span>base)
{
    if (<span class="gs">__a != __</span>a_end)
    {
        const bool <span class="gs">__negate = *__</span>a == &#39;-&#39;;
        if (<span class="gs">__negate &amp;&amp; ++__</span>a == __a_end) {
          __err = ios_base::failbit;
          return 0;
        }
        typename remove_reference&lt;__decltype((*__error()))&gt;::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        unsigned long long __ll = strtoull_l(__a, &amp;<span class="gs">__p2, __</span>base, 0);
        typename remove_reference&lt;__decltype((*__error()))&gt;::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (<span class="gs">__p2 != __</span>a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 || numeric_limits&lt;_Tp&gt;::max() &lt; __ll)
        {
            __err = ios_base::failbit;
            return numeric_limits&lt;_Tp&gt;::max();
        }
        <span class="ge">_Tp __res = static_</span>cast&lt;_Tp&gt;(__ll);
        if (<span class="gs">__negate) __</span>res = -__res;
        return __res;
    }
    __err = ios_base::failbit;
    return 0;
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_Tp __do_</span>strtod(const char* <span class="gs">__a, char** __</span>p2);

template &lt;&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
float __do_strtod&lt;float&gt;(const char* <span class="gs">__a, char** __</span>p2) {
    return strtof_l(__a, __p2, 0);
}

template &lt;&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
double __do_strtod&lt;double&gt;(const char* <span class="gs">__a, char** __</span>p2) {
    return strtod_l(__a, __p2, 0);
}

template &lt;&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
long double __do_strtod&lt;long double&gt;(const char* <span class="gs">__a, char** __</span>p2) {
    return strtold_l(__a, __p2, 0);
}

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
_Tp
__num_get_float(const char* <span class="gs">__a, const char* __</span>a<span class="ge">_end, ios_</span>base::iostate&amp; __err)
{
    if (<span class="gs">__a != __</span>a_end)
    {
        typename remove_reference&lt;__decltype((*__error()))&gt;::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        <span class="ge">_Tp __ld = __do_</span>strtod&lt;_Tp&gt;(__a, &amp;__p2);
        typename remove_reference&lt;__decltype((*__error()))&gt;::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (<span class="gs">__p2 != __</span>a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34)
            __err = ios_base::failbit;
        return __ld;
    }
    __err = ios_base::failbit;
    return 0;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
_InputIterator
num_get&lt;_CharT, <span class="ge">_InputIterator&gt;::do_</span>get(iter_type __b, iter_type __e,
                                        ios_base&amp; __iob,
                                        ios_base::iostate&amp; __err,
                                        bool&amp; __v) const
{
    if ((__iob.flags() &amp; ios_base::boolalpha) == 0)
    {
        long __lv = -1;
        __b = do_get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>lv);
        switch (__lv)
        {
        case 0:
            __v = false;
            break;
        case 1:
            __v = true;
            break;
        default:
            __v = true;
            __err = ios_base::failbit;
            break;
        }
        return __b;
    }
    const ctype&lt;_CharT&gt;&amp; __ct = use_facet&lt;ctype&lt;_CharT&gt; &gt;(__iob.getloc());
    const numpunct&lt;_CharT&gt;&amp; __np = use_facet&lt;numpunct&lt;_CharT&gt; &gt;(__iob.getloc());
    typedef typename numpunct&lt;_CharT&gt;::string_type string_type;
    const string_type <span class="gs">__names[2] = {__</span>np.truename(), __np.falsename()};
    const string_type* <span class="gs">__i = __</span>scan_keyword(__b, <span class="gs">__e, __</span>names, __names+2,
                                            <span class="gs">__ct, __</span>err);
    <span class="gs">__v = __</span>i == __names;
    return __b;
}



template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
template &lt;class _Signed&gt;
_InputIterator
num_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__do_</span>get_signed(iter_type __b, iter_type __e,
                                        ios_base&amp; __iob,
                                        ios_base::iostate&amp; __err,
                                        <span class="ge">_Signed&amp; _</span>_v) const
{

    int <span class="gs">__base = this-&gt;__</span>get_base(__iob);

    char_type __thousands_sep;
    const int __atoms_size = 26;





    char_type <span class="gs">__atoms[__</span>atoms_size];
    string <span class="gs">__grouping = this-&gt;__</span>stage2_int_prep(__iob, <span class="gs">__atoms, __</span>thousands_sep);

    string __buf;
    <span class="gs">__buf.resize(__</span>buf.capacity());
    char* <span class="gs">__a = &amp;__</span>buf[0];
    char* __a_end = __a;
    unsigned <span class="gs">__g[__</span>num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; <span class="gs">__b != __</span>e; ++__b)
    {
        if (__a_end == <span class="gs">__a + __</span>buf.size())
        {
            size_t <span class="gs">__tmp = __</span>buf.size();
            <span class="gs">__buf.resize(2*__</span>buf.size());
            <span class="gs">__buf.resize(__</span>buf.capacity());
            <span class="gs">__a = &amp;__</span>buf[0];
            __a_end = <span class="gs">__a + __</span>tmp;
        }
        if (this-&gt;__stage2_int_loop(*__b, <span class="gs">__base, __</span>a, __a_end, __dc,
                                    __thousands_sep, <span class="gs">__grouping, __</span>g, __g_end,
                                    __atoms))
            break;
    }
    if (<span class="gs">__grouping.size() != 0 &amp;&amp; __</span>g<span class="ge">_end-__g &lt; __num_</span>get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    <span class="gs">__v = __</span>num_get_signed_integral&lt;_Signed&gt;(__a, __a_end, <span class="gs">__err, __</span>base);

    __check_grouping(__grouping, <span class="gs">__g, __</span>g<span class="ge">_end, _</span>_err);

    if (<span class="gs">__b == __</span>e)
        __err |= ios_base::eofbit;
    return __b;
}



template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
template &lt;class _Unsigned&gt;
_InputIterator
num_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__do_</span>get_unsigned(iter_type __b, iter_type __e,
                                        ios_base&amp; __iob,
                                        ios_base::iostate&amp; __err,
                                        <span class="ge">_Unsigned&amp; _</span>_v) const
{

    int <span class="gs">__base = this-&gt;__</span>get_base(__iob);

    char_type __thousands_sep;
    const int __atoms_size = 26;





    char_type <span class="gs">__atoms[__</span>atoms_size];
    string <span class="gs">__grouping = this-&gt;__</span>stage2_int_prep(__iob, <span class="gs">__atoms, __</span>thousands_sep);

    string __buf;
    <span class="gs">__buf.resize(__</span>buf.capacity());
    char* <span class="gs">__a = &amp;__</span>buf[0];
    char* __a_end = __a;
    unsigned <span class="gs">__g[__</span>num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; <span class="gs">__b != __</span>e; ++__b)
    {
        if (__a_end == <span class="gs">__a + __</span>buf.size())
        {
            size_t <span class="gs">__tmp = __</span>buf.size();
            <span class="gs">__buf.resize(2*__</span>buf.size());
            <span class="gs">__buf.resize(__</span>buf.capacity());
            <span class="gs">__a = &amp;__</span>buf[0];
            __a_end = <span class="gs">__a + __</span>tmp;
        }
        if (this-&gt;__stage2_int_loop(*__b, <span class="gs">__base, __</span>a, __a_end, __dc,
                                    __thousands_sep, <span class="gs">__grouping, __</span>g, __g_end,
                                    __atoms))
            break;
    }
    if (<span class="gs">__grouping.size() != 0 &amp;&amp; __</span>g<span class="ge">_end-__g &lt; __num_</span>get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    <span class="gs">__v = __</span>num_get_unsigned_integral&lt;_Unsigned&gt;(__a, __a_end, <span class="gs">__err, __</span>base);

    __check_grouping(__grouping, <span class="gs">__g, __</span>g<span class="ge">_end, _</span>_err);

    if (<span class="gs">__b == __</span>e)
        __err |= ios_base::eofbit;
    return __b;
}



template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
template &lt;class _Fp&gt;
_InputIterator
num_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__do_</span>get_floating_point(iter_type __b, iter_type __e,
                                        ios_base&amp; __iob,
                                        ios_base::iostate&amp; __err,
                                        <span class="ge">_Fp&amp; _</span>_v) const
{


    char_type __atoms[32];
    char_type __decimal_point;
    char_type __thousands_sep;
    string <span class="gs">__grouping = this-&gt;__</span>stage2_float_prep(__iob, __atoms,
                                                  __decimal_point,
                                                  __thousands_sep);
    string __buf;
    <span class="gs">__buf.resize(__</span>buf.capacity());
    char* <span class="gs">__a = &amp;__</span>buf[0];
    char* __a_end = __a;
    unsigned <span class="gs">__g[__</span>num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    bool __in_units = true;
    char __exp = &#39;E&#39;;
    for (; <span class="gs">__b != __</span>e; ++__b)
    {
        if (__a_end == <span class="gs">__a + __</span>buf.size())
        {
            size_t <span class="gs">__tmp = __</span>buf.size();
            <span class="gs">__buf.resize(2*__</span>buf.size());
            <span class="gs">__buf.resize(__</span>buf.capacity());
            <span class="gs">__a = &amp;__</span>buf[0];
            __a_end = <span class="gs">__a + __</span>tmp;
        }
        if (this-&gt;__stage2_float_loop(*__b, __in_units, <span class="gs">__exp, __</span>a, __a_end,
                                      __decimal_point, __thousands_sep,
                                      <span class="gs">__grouping, __</span>g, __g_end,
                                      <span class="gs">__dc, __</span>atoms))
            break;
    }
    if (<span class="gs">__grouping.size() != 0 &amp;&amp; __</span>in_units &amp;&amp; __g_end-__g &lt; __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    <span class="gs">__v = __</span>num_get_float&lt;_Fp&gt;(__a, __a_end, __err);

    __check_grouping(__grouping, <span class="gs">__g, __</span>g<span class="ge">_end, _</span>_err);

    if (<span class="gs">__b == __</span>e)
        __err |= ios_base::eofbit;
    return __b;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
_InputIterator
num_get&lt;_CharT, <span class="ge">_InputIterator&gt;::do_</span>get(iter_type __b, iter_type __e,
                                        ios_base&amp; __iob,
                                        ios_base::iostate&amp; __err,
                                        void*&amp; __v) const
{

    int __base = 16;

    char_type __atoms[26];
    char_type __thousands_sep = 0;
    string __grouping;
    use_facet&lt;ctype&lt;_CharT&gt; &gt;(__iob.getloc()).widen(__num_get_base::__src,
                                                    __num_get_base::__src + 26, __atoms);
    string __buf;
    <span class="gs">__buf.resize(__</span>buf.capacity());
    char* <span class="gs">__a = &amp;__</span>buf[0];
    char* __a_end = __a;
    unsigned <span class="gs">__g[__</span>num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; <span class="gs">__b != __</span>e; ++__b)
    {
        if (__a_end == <span class="gs">__a + __</span>buf.size())
        {
            size_t <span class="gs">__tmp = __</span>buf.size();
            <span class="gs">__buf.resize(2*__</span>buf.size());
            <span class="gs">__buf.resize(__</span>buf.capacity());
            <span class="gs">__a = &amp;__</span>buf[0];
            __a_end = <span class="gs">__a + __</span>tmp;
        }
        if (this-&gt;__stage2_int_loop(*__b, <span class="gs">__base, __</span>a, __a_end, __dc,
                                    __thousands_sep, __grouping,
                                    <span class="gs">__g, __</span>g<span class="ge">_end, _</span>_atoms))
            break;
    }

    <span class="gs">__buf.resize(__</span>a<span class="ge">_end - _</span>_a);
    if (sscanf_l(__buf.c_str(), 0, &quot;%p&quot;, &amp;__v) != 1)
        __err = ios_base::failbit;

    if (<span class="gs">__b == __</span>e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) num_get&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) num_get&lt;wchar_t&gt;;

struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __num_put_base
{
protected:
    static void __format_int(char* <span class="gs">__fmt, const char* __</span>len, bool __signd,
                             ios_base::fmtflags __flags);
    static bool __format_float(char* <span class="gs">__fmt, const char* __</span>len,
                               ios_base::fmtflags __flags);
    static char* __identify_padding(char* <span class="gs">__nb, char* __</span>ne,
                                    const ios_base&amp; __iob);
};

template &lt;class _CharT&gt;
struct __num_put
    : protected __num_put_base
{
    static void __widen_and_group_int(char* <span class="gs">__nb, char* __</span>np, char* __ne,
                                      <span class="ge">_CharT* __ob, _</span>CharT*&amp; __op, <span class="ge">_CharT*&amp; _</span>_oe,
                                      const locale&amp; __loc);
    static void __widen_and_group_float(char* <span class="gs">__nb, char* __</span>np, char* __ne,
                                        <span class="ge">_CharT* __ob, _</span>CharT*&amp; __op, <span class="ge">_CharT*&amp; _</span>_oe,
                                        const locale&amp; __loc);
};

template &lt;class _CharT&gt;
void
__num_put&lt;_CharT&gt;::__widen_and_group_int(char* <span class="gs">__nb, char* __</span>np, char* __ne,
                                         <span class="ge">_CharT* __ob, _</span>CharT*&amp; __op, <span class="ge">_CharT*&amp; _</span>_oe,
                                         const locale&amp; __loc)
{
    const ctype&lt;_CharT&gt;&amp; __ct = use_facet&lt;ctype&lt;_CharT&gt; &gt; (__loc);
    const numpunct&lt;_CharT&gt;&amp; __npt = use_facet&lt;numpunct&lt;_CharT&gt; &gt;(__loc);
    string <span class="gs">__grouping = __</span>npt.grouping();
    if (__grouping.empty())
    {
        <span class="gs">__ct.widen(__</span>nb, <span class="gs">__ne, __</span>ob);
        <span class="gs">__oe = __</span>ob + (<span class="gs">__ne - __</span>nb);
    }
    else
    {
        <span class="gs">__oe = __</span>ob;
        char* <span class="gs">__nf = __</span>nb;
        if (<span class="ge">*__nf == &#39;-&#39; || *</span>__nf == &#39;+&#39;)
            <span class="ge">*__oe++ = __ct.widen(*</span>__nf++);
        if (<span class="gs">__ne - __</span>nf &gt;= 2 &amp;&amp; <span class="gs">__nf[0] == &#39;0&#39; &amp;&amp; (__</span>nf[1] == &#39;x&#39; ||
                                                   __nf[1] == &#39;X&#39;))
        {
            <span class="ge">*__oe++ = __ct.widen(*</span>__nf++);
            <span class="ge">*__oe++ = __ct.widen(*</span>__nf++);
        }
        reverse(__nf, __ne);
        <span class="ge">_CharT __thousands_</span>sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* <span class="gs">__p = __</span>nf; <span class="gs">__p &lt; __</span>ne; ++__p)
        {
            if (static_cast&lt;unsigned&gt;(__grouping[__dg]) &gt; 0 &amp;&amp;
                __dc == static_cast&lt;unsigned&gt;(__grouping[__dg]))
            {
                *<span class="gs">__oe++ = __</span>thousands_sep;
                __dc = 0;
                if (<span class="gs">__dg &lt; __</span>grouping.size()-1)
                    ++__dg;
            }
            <span class="ge">*__oe++ = __ct.widen(*</span>__p);
            ++__dc;
        }
        reverse(__ob + (<span class="gs">__nf - __</span>nb), __oe);
    }
    if (<span class="gs">__np == __</span>ne)
        <span class="gs">__op = __</span>oe;
    else
        <span class="gs">__op = __</span>ob + (<span class="gs">__np - __</span>nb);
}

template &lt;class _CharT&gt;
void
__num_put&lt;_CharT&gt;::__widen_and_group_float(char* <span class="gs">__nb, char* __</span>np, char* __ne,
                                           <span class="ge">_CharT* __ob, _</span>CharT*&amp; __op, <span class="ge">_CharT*&amp; _</span>_oe,
                                           const locale&amp; __loc)
{
    const ctype&lt;_CharT&gt;&amp; __ct = use_facet&lt;ctype&lt;_CharT&gt; &gt; (__loc);
    const numpunct&lt;_CharT&gt;&amp; __npt = use_facet&lt;numpunct&lt;_CharT&gt; &gt;(__loc);
    string <span class="gs">__grouping = __</span>npt.grouping();
    <span class="gs">__oe = __</span>ob;
    char* <span class="gs">__nf = __</span>nb;
    if (<span class="ge">*__nf == &#39;-&#39; || *</span>__nf == &#39;+&#39;)
        <span class="ge">*__oe++ = __ct.widen(*</span>__nf++);
    char* __ns;
    if (<span class="gs">__ne - __</span>nf &gt;= 2 &amp;&amp; <span class="gs">__nf[0] == &#39;0&#39; &amp;&amp; (__</span>nf[1] == &#39;x&#39; ||
                                               __nf[1] == &#39;X&#39;))
    {
        <span class="ge">*__oe++ = __ct.widen(*</span>__nf++);
        <span class="ge">*__oe++ = __ct.widen(*</span>__nf++);
        for (<span class="gs">__ns = __</span>nf; <span class="gs">__ns &lt; __</span>ne; ++__ns)
            if (!isxdigit_l(*__ns, 0))
                break;
    }
    else
    {
        for (<span class="gs">__ns = __</span>nf; <span class="gs">__ns &lt; __</span>ne; ++__ns)
            if (!isdigit_l(*__ns, 0))
                break;
    }
    if (__grouping.empty())
    {
        <span class="gs">__ct.widen(__</span>nf, <span class="gs">__ns, __</span>oe);
        <span class="gs">__oe += __</span>ns - __nf;
    }
    else
    {
        reverse(__nf, __ns);
        <span class="ge">_CharT __thousands_</span>sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* <span class="gs">__p = __</span>nf; <span class="gs">__p &lt; __</span>ns; ++__p)
        {
            if (<span class="gs">__grouping[__</span>dg] &gt; 0 &amp;&amp; __dc == static_cast&lt;unsigned&gt;(__grouping[__dg]))
            {
                *<span class="gs">__oe++ = __</span>thousands_sep;
                __dc = 0;
                if (<span class="gs">__dg &lt; __</span>grouping.size()-1)
                    ++__dg;
            }
            <span class="ge">*__oe++ = __ct.widen(*</span>__p);
            ++__dc;
        }
        reverse(__ob + (<span class="gs">__nf - __</span>nb), __oe);
    }
    for (<span class="gs">__nf = __</span>ns; <span class="gs">__nf &lt; __</span>ne; ++__nf)
    {
        if (*__nf == &#39;.&#39;)
        {
            *<span class="gs">__oe++ = __</span>npt.decimal_point();
            ++__nf;
            break;
        }
        else
            <span class="ge">*__oe++ = __ct.widen(*</span>__nf);
    }
    <span class="gs">__ct.widen(__</span>nf, <span class="gs">__ne, __</span>oe);
    <span class="gs">__oe += __</span>ne - __nf;
    if (<span class="gs">__np == __</span>ne)
        <span class="gs">__op = __</span>oe;
    else
        <span class="gs">__op = __</span>ob + (<span class="gs">__np - __</span>nb);
}

extern template struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __num_put&lt;char&gt;;
extern template struct <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __num_put&lt;wchar_t&gt;;

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator = ostreambuf_iterator&lt;_CharT&gt; &gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) num_put
    : public locale::facet,
      private __num_put&lt;_CharT&gt;
{
public:
    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_OutputIterator iter_</span>type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit num_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                  bool __v) const
    {
        return do_put(__s, <span class="gs">__iob, __</span>fl, __v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                  long __v) const
    {
        return do_put(__s, <span class="gs">__iob, __</span>fl, __v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                  long long __v) const
    {
        return do_put(__s, <span class="gs">__iob, __</span>fl, __v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                  unsigned long __v) const
    {
        return do_put(__s, <span class="gs">__iob, __</span>fl, __v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                  unsigned long long __v) const
    {
        return do_put(__s, <span class="gs">__iob, __</span>fl, __v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                  double __v) const
    {
        return do_put(__s, <span class="gs">__iob, __</span>fl, __v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                  long double __v) const
    {
        return do_put(__s, <span class="gs">__iob, __</span>fl, __v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                  const void* __v) const
    {
        return do_put(__s, <span class="gs">__iob, __</span>fl, __v);
    }

    static locale::id id;

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~num_put() {}

    virtual iter_type do_put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                             bool __v) const;
    virtual iter_type do_put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                             long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                             long long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                             unsigned long) const;
    virtual iter_type do_put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                             unsigned long long) const;
    virtual iter_type do_put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                             double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                             long double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                             const void* __v) const;
};

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
locale::id
num_put&lt;_CharT, _OutputIterator&gt;::id;

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
_OutputIterator
__pad_and_output(_OutputIterator __s,
                 const <span class="ge">_CharT* __ob, const _</span>CharT* __op, const <span class="ge">_CharT* _</span>_oe,
                 ios_base&amp; __iob, <span class="ge">_CharT _</span>_fl)
{
    streamsize <span class="gs">__sz = __</span>oe - __ob;
    streamsize <span class="gs">__ns = __</span>iob.width();
    if (<span class="gs">__ns &gt; __</span>sz)
        <span class="gs">__ns -= __</span>sz;
    else
        __ns = 0;
    for (;__ob &lt; <span class="gs">__op; ++__</span>ob, ++__s)
        <span class="ge">*__s = *</span>__ob;
    for (; <span class="gs">__ns; --__</span>ns, ++__s)
        *<span class="gs">__s = __</span>fl;
    for (; <span class="gs">__ob &lt; __</span>oe; ++__ob, ++__s)
        <span class="ge">*__s = *</span>__ob;
    __iob.width(0);
    return __s;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
ostreambuf_iterator&lt;_CharT, _Traits&gt;
__pad_and_output(ostreambuf_iterator&lt;_CharT, <span class="ge">_Traits&gt; _</span>_s,
                 const <span class="ge">_CharT* __ob, const _</span>CharT* __op, const <span class="ge">_CharT* _</span>_oe,
                 ios_base&amp; __iob, <span class="ge">_CharT _</span>_fl)
{
    if (<span class="gs">__s.__</span>sbuf_ == std::__1::__get_nullptr_t())
        return __s;
    streamsize <span class="gs">__sz = __</span>oe - __ob;
    streamsize <span class="gs">__ns = __</span>iob.width();
    if (<span class="gs">__ns &gt; __</span>sz)
        <span class="gs">__ns -= __</span>sz;
    else
        __ns = 0;
    streamsize <span class="gs">__np = __</span>op - __ob;
    if (__np &gt; 0)
    {
        if (<span class="gs">__s.__</span>sbuf_-&gt;sputn(__ob, <span class="gs">__np) != __</span>np)
        {
            <span class="gs">__s.__</span>sbuf_ = std::__1::__get_nullptr_t();
            return __s;
        }
    }
    if (__ns &gt; 0)
    {
        basic_string&lt;_CharT, <span class="ge">_Traits&gt; __sp(__ns, _</span>_fl);
        if (<span class="gs">__s.__</span>sbuf_-&gt;sputn(__sp.data(), <span class="gs">__ns) != __</span>ns)
        {
            <span class="gs">__s.__</span>sbuf_ = std::__1::__get_nullptr_t();
            return __s;
        }
    }
    <span class="gs">__np = __</span>oe - __op;
    if (__np &gt; 0)
    {
        if (<span class="gs">__s.__</span>sbuf_-&gt;sputn(__op, <span class="gs">__np) != __</span>np)
        {
            <span class="gs">__s.__</span>sbuf_ = std::__1::__get_nullptr_t();
            return __s;
        }
    }
    __iob.width(0);
    return __s;
}

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
_OutputIterator
num_put&lt;_CharT, <span class="ge">_OutputIterator&gt;::do_</span>put(iter_type __s, ios_base&amp; __iob,
                                         char_type <span class="gs">__fl, bool __</span>v) const
{
    if ((__iob.flags() &amp; ios_base::boolalpha) == 0)
        return do_put(__s, <span class="gs">__iob, __</span>fl, (unsigned long)__v);
    const numpunct&lt;char_type&gt;&amp; __np = use_facet&lt;numpunct&lt;char_type&gt; &gt;(__iob.getloc());
    typedef typename numpunct&lt;char_type&gt;::string_type string_type;




    string_type <span class="gs">__nm = __</span>v ? <span class="gs">__np.truename() : __</span>np.falsename();

    for (typename string_type::iterator <span class="gs">__i = __</span>nm.begin(); <span class="gs">__i != __</span>nm.end(); ++__i, ++__s)
        <span class="ge">*__s = *</span>__i;
    return __s;
}

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
_OutputIterator
num_put&lt;_CharT, <span class="ge">_OutputIterator&gt;::do_</span>put(iter_type __s, ios_base&amp; __iob,
                                         char_type <span class="gs">__fl, long __</span>v) const
{

    char __fmt[6] = {&#39;%&#39;, 0};
    const char* __len = &quot;l&quot;;
    this-&gt;__format_int(__fmt+1, <span class="gs">__len, true, __</span>iob.flags());
    const unsigned __nbuf = (numeric_limits&lt;long&gt;::digits / 3)
                          + ((numeric_limits&lt;long&gt;::digits % 3) != 0)
                          + ((__iob.flags() &amp; ios_base::showbase) != 0)
                          + 2;
    char <span class="gs">__nar[__</span>nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, <span class="gs">__fmt, __</span>v);
    char* <span class="gs">__ne = __</span>nar + __nc;
    char* <span class="gs">__np = this-&gt;__</span>identify_padding(__nar, <span class="gs">__ne, __</span>iob);

    char_type <span class="gs">__o[2*(__</span>nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this-&gt;__widen_and_group_int(__nar, <span class="gs">__np, __</span>ne, <span class="gs">__o, __</span>op, <span class="gs">__oe, __</span>iob.getloc());


    return __pad_and_output(__s, <span class="gs">__o, __</span>op, <span class="gs">__oe, __</span>iob, __fl);
}

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
_OutputIterator
num_put&lt;_CharT, <span class="ge">_OutputIterator&gt;::do_</span>put(iter_type __s, ios_base&amp; __iob,
                                         char_type <span class="gs">__fl, long long __</span>v) const
{

    char __fmt[8] = {&#39;%&#39;, 0};
    const char* __len = &quot;ll&quot;;
    this-&gt;__format_int(__fmt+1, <span class="gs">__len, true, __</span>iob.flags());
    const unsigned __nbuf = (numeric_limits&lt;long long&gt;::digits / 3)
                          + ((numeric_limits&lt;long long&gt;::digits % 3) != 0)
                          + ((__iob.flags() &amp; ios_base::showbase) != 0)
                          + 2;
    char <span class="gs">__nar[__</span>nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, <span class="gs">__fmt, __</span>v);
    char* <span class="gs">__ne = __</span>nar + __nc;
    char* <span class="gs">__np = this-&gt;__</span>identify_padding(__nar, <span class="gs">__ne, __</span>iob);

    char_type <span class="gs">__o[2*(__</span>nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this-&gt;__widen_and_group_int(__nar, <span class="gs">__np, __</span>ne, <span class="gs">__o, __</span>op, <span class="gs">__oe, __</span>iob.getloc());


    return __pad_and_output(__s, <span class="gs">__o, __</span>op, <span class="gs">__oe, __</span>iob, __fl);
}

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
_OutputIterator
num_put&lt;_CharT, <span class="ge">_OutputIterator&gt;::do_</span>put(iter_type __s, ios_base&amp; __iob,
                                         char_type <span class="gs">__fl, unsigned long __</span>v) const
{

    char __fmt[6] = {&#39;%&#39;, 0};
    const char* __len = &quot;l&quot;;
    this-&gt;__format_int(__fmt+1, <span class="gs">__len, false, __</span>iob.flags());
    const unsigned __nbuf = (numeric_limits&lt;unsigned long&gt;::digits / 3)
                          + ((numeric_limits&lt;unsigned long&gt;::digits % 3) != 0)
                          + ((__iob.flags() &amp; ios_base::showbase) != 0)
                          + 1;
    char <span class="gs">__nar[__</span>nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, <span class="gs">__fmt, __</span>v);
    char* <span class="gs">__ne = __</span>nar + __nc;
    char* <span class="gs">__np = this-&gt;__</span>identify_padding(__nar, <span class="gs">__ne, __</span>iob);

    char_type <span class="gs">__o[2*(__</span>nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this-&gt;__widen_and_group_int(__nar, <span class="gs">__np, __</span>ne, <span class="gs">__o, __</span>op, <span class="gs">__oe, __</span>iob.getloc());


    return __pad_and_output(__s, <span class="gs">__o, __</span>op, <span class="gs">__oe, __</span>iob, __fl);
}

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
_OutputIterator
num_put&lt;_CharT, <span class="ge">_OutputIterator&gt;::do_</span>put(iter_type __s, ios_base&amp; __iob,
                                         char_type <span class="gs">__fl, unsigned long long __</span>v) const
{

    char __fmt[8] = {&#39;%&#39;, 0};
    const char* __len = &quot;ll&quot;;
    this-&gt;__format_int(__fmt+1, <span class="gs">__len, false, __</span>iob.flags());
    const unsigned __nbuf = (numeric_limits&lt;unsigned long long&gt;::digits / 3)
                          + ((numeric_limits&lt;unsigned long long&gt;::digits % 3) != 0)
                          + ((__iob.flags() &amp; ios_base::showbase) != 0)
                          + 1;
    char <span class="gs">__nar[__</span>nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, <span class="gs">__fmt, __</span>v);
    char* <span class="gs">__ne = __</span>nar + __nc;
    char* <span class="gs">__np = this-&gt;__</span>identify_padding(__nar, <span class="gs">__ne, __</span>iob);

    char_type <span class="gs">__o[2*(__</span>nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this-&gt;__widen_and_group_int(__nar, <span class="gs">__np, __</span>ne, <span class="gs">__o, __</span>op, <span class="gs">__oe, __</span>iob.getloc());


    return __pad_and_output(__s, <span class="gs">__o, __</span>op, <span class="gs">__oe, __</span>iob, __fl);
}

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
_OutputIterator
num_put&lt;_CharT, <span class="ge">_OutputIterator&gt;::do_</span>put(iter_type __s, ios_base&amp; __iob,
                                         char_type <span class="gs">__fl, double __</span>v) const
{

    char __fmt[8] = {&#39;%&#39;, 0};
    const char* __len = &quot;&quot;;
    bool __specify_precision = this-&gt;__format_float(__fmt+1, <span class="gs">__len, __</span>iob.flags());
    const unsigned __nbuf = 30;
    char <span class="gs">__nar[__</span>nbuf];
    char* <span class="gs">__nb = __</span>nar;
    int __nc;
    if (__specify_precision)
        __nc = snprintf_l(__nb, <span class="gs">__nbuf, 0, __</span>fmt, (int)__iob.precision(), __v);

    else
        __nc = snprintf_l(__nb, <span class="gs">__nbuf, 0, __</span>fmt, __v);
    unique_ptr&lt;char, void(*)(void*)&gt; __nbh(0, free);
    if (__nc &gt; static_cast&lt;int&gt;(__nbuf-1))
    {
        if (__specify_precision)
            __nc = asprintf_l(&amp;__nb, 0, <span class="gs">__fmt, (int)__</span>iob.precision(), __v);
        else
            __nc = asprintf_l(&amp;__nb, 0, <span class="gs">__fmt, __</span>v);
        if (__nb == 0)
            __throw_bad_alloc();
        <span class="gs">__nbh.reset(__</span>nb);
    }
    char* <span class="gs">__ne = __</span>nb + __nc;
    char* <span class="gs">__np = this-&gt;__</span>identify_padding(__nb, <span class="gs">__ne, __</span>iob);

    char_type <span class="gs">__o[2*(__</span>nbuf-1) - 1];
    char_type* <span class="gs">__ob = __</span>o;
    unique_ptr&lt;char_type, void(*)(void*)&gt; __obh(0, free);
    if (<span class="gs">__nb != __</span>nar)
    {
        __ob = (char_type*)malloc(2*static_cast&lt;size_t&gt;(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        <span class="gs">__obh.reset(__</span>ob);
    }
    char_type* __op;
    char_type* __oe;
    this-&gt;__widen_and_group_float(__nb, <span class="gs">__np, __</span>ne, <span class="gs">__ob, __</span>op, <span class="gs">__oe, __</span>iob.getloc());


    <span class="gs">__s = __</span>pad_and_output(__s, <span class="gs">__ob, __</span>op, <span class="gs">__oe, __</span>iob, __fl);
    return __s;
}

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
_OutputIterator
num_put&lt;_CharT, <span class="ge">_OutputIterator&gt;::do_</span>put(iter_type __s, ios_base&amp; __iob,
                                         char_type <span class="gs">__fl, long double __</span>v) const
{

    char __fmt[8] = {&#39;%&#39;, 0};
    const char* __len = &quot;L&quot;;
    bool __specify_precision = this-&gt;__format_float(__fmt+1, <span class="gs">__len, __</span>iob.flags());
    const unsigned __nbuf = 30;
    char <span class="gs">__nar[__</span>nbuf];
    char* <span class="gs">__nb = __</span>nar;
    int __nc;
    if (__specify_precision)
        __nc = snprintf_l(__nb, <span class="gs">__nbuf, 0, __</span>fmt, (int)__iob.precision(), __v);

    else
        __nc = snprintf_l(__nb, <span class="gs">__nbuf, 0, __</span>fmt, __v);
    unique_ptr&lt;char, void(*)(void*)&gt; __nbh(0, free);
    if (__nc &gt; static_cast&lt;int&gt;(__nbuf-1))
    {
        if (__specify_precision)
            __nc = asprintf_l(&amp;__nb, 0, <span class="gs">__fmt, (int)__</span>iob.precision(), __v);
        else
            __nc = asprintf_l(&amp;__nb, 0, <span class="gs">__fmt, __</span>v);
        if (__nb == 0)
            __throw_bad_alloc();
        <span class="gs">__nbh.reset(__</span>nb);
    }
    char* <span class="gs">__ne = __</span>nb + __nc;
    char* <span class="gs">__np = this-&gt;__</span>identify_padding(__nb, <span class="gs">__ne, __</span>iob);

    char_type <span class="gs">__o[2*(__</span>nbuf-1) - 1];
    char_type* <span class="gs">__ob = __</span>o;
    unique_ptr&lt;char_type, void(*)(void*)&gt; __obh(0, free);
    if (<span class="gs">__nb != __</span>nar)
    {
        __ob = (char_type*)malloc(2*static_cast&lt;size_t&gt;(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        <span class="gs">__obh.reset(__</span>ob);
    }
    char_type* __op;
    char_type* __oe;
    this-&gt;__widen_and_group_float(__nb, <span class="gs">__np, __</span>ne, <span class="gs">__ob, __</span>op, <span class="gs">__oe, __</span>iob.getloc());


    <span class="gs">__s = __</span>pad_and_output(__s, <span class="gs">__ob, __</span>op, <span class="gs">__oe, __</span>iob, __fl);
    return __s;
}

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
_OutputIterator
num_put&lt;_CharT, <span class="ge">_OutputIterator&gt;::do_</span>put(iter_type __s, ios_base&amp; __iob,
                                         char_type <span class="gs">__fl, const void* __</span>v) const
{

    char __fmt[6] = &quot;%p&quot;;
    const unsigned __nbuf = 20;
    char <span class="gs">__nar[__</span>nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, <span class="gs">__fmt, __</span>v);
    char* <span class="gs">__ne = __</span>nar + __nc;
    char* <span class="gs">__np = this-&gt;__</span>identify_padding(__nar, <span class="gs">__ne, __</span>iob);

    char_type <span class="gs">__o[2*(__</span>nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    const ctype&lt;char_type&gt;&amp; __ct = use_facet&lt;ctype&lt;char_type&gt; &gt;(__iob.getloc());
    <span class="gs">__ct.widen(__</span>nar, <span class="gs">__ne, __</span>o);
    <span class="gs">__oe = __</span>o + (<span class="gs">__ne - __</span>nar);
    if (<span class="gs">__np == __</span>ne)
        <span class="gs">__op = __</span>oe;
    else
        <span class="gs">__op = __</span>o + (<span class="gs">__np - __</span>nar);


    return __pad_and_output(__s, <span class="gs">__o, __</span>op, <span class="gs">__oe, __</span>iob, __fl);
}

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) num_put&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) num_put&lt;wchar_t&gt;;

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
int
__get_up_to_n_digits(_InputIterator&amp; __b, <span class="ge">_InputIterator _</span>_e,
                     ios_base::iostate&amp; __err, const ctype&lt;_CharT&gt;&amp; <span class="gs">__ct, int __</span>n)
{

    if (<span class="gs">__b == __</span>e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return 0;
    }

    <span class="ge">_CharT __c = *_</span>_b;
    if (!__ct.is(ctype_base::digit, __c))
    {
        __err |= ios_base::failbit;
        return 0;
    }
    int <span class="gs">__r = __</span>ct.narrow(__c, 0) - &#39;0&#39;;
    for (++__b, (void) --__n; <span class="gs">__b != __</span>e &amp;&amp; <span class="gs">__n &gt; 0; ++__</span>b, (void) --__n)
    {

        <span class="gs">__c = *__</span>b;
        if (!__ct.is(ctype_base::digit, __c))
            return __r;
        <span class="gs">__r = __</span>r * 10 + <span class="gs">__ct.narrow(__</span>c, 0) - &#39;0&#39;;
    }
    if (<span class="gs">__b == __</span>e)
        __err |= ios_base::eofbit;
    return __r;
}

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) time_base
{
public:
    enum dateorder {no_order, dmy, mdy, ymd, ydm};
};

template &lt;class _CharT&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) __time_get_c_storage
{
protected:
    typedef basic_string&lt;_CharT&gt; string_type;

    virtual const string_type* __weeks() const;
    virtual const string_type* __months() const;
    virtual const string_type* __am_pm() const;
    virtual const string_type&amp; __c() const;
    virtual const string_type&amp; __r() const;
    virtual const string_type&amp; __x() const;
    virtual const string_type&amp; __X() const;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~__time_get_c_storage() {}
};

template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const string* __time_get_c_storage&lt;char&gt;::__weeks() const;
template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const string* __time_get_c_storage&lt;char&gt;::__months() const;
template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const string* __time_get_c_storage&lt;char&gt;::__am_pm() const;
template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const string&amp; __time_get_c_storage&lt;char&gt;::__c() const;
template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const string&amp; __time_get_c_storage&lt;char&gt;::__r() const;
template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const string&amp; __time_get_c_storage&lt;char&gt;::__x() const;
template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const string&amp; __time_get_c_storage&lt;char&gt;::__X() const;

template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const wstring* __time_get_c_storage&lt;wchar_t&gt;::__weeks() const;
template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const wstring* __time_get_c_storage&lt;wchar_t&gt;::__months() const;
template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const wstring* __time_get_c_storage&lt;wchar_t&gt;::__am_pm() const;
template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const wstring&amp; __time_get_c_storage&lt;wchar_t&gt;::__c() const;
template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const wstring&amp; __time_get_c_storage&lt;wchar_t&gt;::__r() const;
template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const wstring&amp; __time_get_c_storage&lt;wchar_t&gt;::__x() const;
template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) const wstring&amp; __time_get_c_storage&lt;wchar_t&gt;::__X() const;

template &lt;class <span class="ge">_CharT, class _</span>InputIterator = istreambuf_iterator&lt;_CharT&gt; &gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) time_get
    : public locale::facet,
      public time_base,
      private __time_get_c_storage&lt;_CharT&gt;
{
public:
    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_InputIterator iter_</span>type;
    typedef time_base::dateorder dateorder;
    typedef basic_string&lt;char_type&gt; string_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit time_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    dateorder date_order() const
    {
        return this-&gt;do_date_order();
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get_time(iter_type __b, iter_type __e, ios_base&amp; __iob,
                       ios_base::iostate&amp; <span class="gs">__err, tm* __</span>tm) const
    {
        return do_get_time(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get_date(iter_type __b, iter_type __e, ios_base&amp; __iob,
                       ios_base::iostate&amp; <span class="gs">__err, tm* __</span>tm) const
    {
        return do_get_date(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get_weekday(iter_type __b, iter_type __e, ios_base&amp; __iob,
                          ios_base::iostate&amp; <span class="gs">__err, tm* __</span>tm) const
    {
        return do_get_weekday(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get_monthname(iter_type __b, iter_type __e, ios_base&amp; __iob,
                            ios_base::iostate&amp; <span class="gs">__err, tm* __</span>tm) const
    {
        return do_get_monthname(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get_year(iter_type __b, iter_type __e, ios_base&amp; __iob,
                       ios_base::iostate&amp; <span class="gs">__err, tm* __</span>tm) const
    {
        return do_get_year(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                  ios_base::iostate&amp; <span class="gs">__err, tm *__</span>tm,
                  char <span class="gs">__fmt, char __</span>mod = 0) const
    {
        return do_get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm, <span class="gs">__fmt, __</span>mod);
    }

    iter_type get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                  ios_base::iostate&amp; <span class="gs">__err, tm* __</span>tm,
                  const char_type* __fmtb, const char_type* __fmte) const;

    static locale::id id;

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~time_get() {}

    virtual dateorder do_date_order() const;
    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base&amp; __iob,
                                  ios_base::iostate&amp; <span class="gs">__err, tm* __</span>tm) const;
    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base&amp; __iob,
                                  ios_base::iostate&amp; <span class="gs">__err, tm* __</span>tm) const;
    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base&amp; __iob,
                                     ios_base::iostate&amp; <span class="gs">__err, tm* __</span>tm) const;
    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base&amp; __iob,
                                       ios_base::iostate&amp; <span class="gs">__err, tm* __</span>tm) const;
    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base&amp; __iob,
                                  ios_base::iostate&amp; <span class="gs">__err, tm* __</span>tm) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base&amp; __iob,
                             ios_base::iostate&amp; <span class="gs">__err, tm* __</span>tm,
                             char <span class="gs">__fmt, char __</span>mod) const;
private:
    void __get_white_space(iter_type&amp; __b, iter_type __e,
                           ios_base::iostate&amp; __err, const ctype&lt;char_type&gt;&amp; __ct) const;
    void __get_percent(iter_type&amp; __b, iter_type __e, ios_base::iostate&amp; __err,
                       const ctype&lt;char_type&gt;&amp; __ct) const;

    void __get_weekdayname(int&amp; __m,
                           iter_type&amp; __b, iter_type __e,
                           ios_base::iostate&amp; __err,
                           const ctype&lt;char_type&gt;&amp; __ct) const;
    void __get_monthname(int&amp; __m,
                         iter_type&amp; __b, iter_type __e,
                         ios_base::iostate&amp; __err,
                         const ctype&lt;char_type&gt;&amp; __ct) const;
    void __get_day(int&amp; __d,
                   iter_type&amp; __b, iter_type __e,
                   ios_base::iostate&amp; __err,
                   const ctype&lt;char_type&gt;&amp; __ct) const;
    void __get_month(int&amp; __m,
                     iter_type&amp; __b, iter_type __e,
                     ios_base::iostate&amp; __err,
                     const ctype&lt;char_type&gt;&amp; __ct) const;
    void __get_year(int&amp; __y,
                   iter_type&amp; __b, iter_type __e,
                   ios_base::iostate&amp; __err,
                   const ctype&lt;char_type&gt;&amp; __ct) const;
    void __get_year4(int&amp; __y,
                    iter_type&amp; __b, iter_type __e,
                    ios_base::iostate&amp; __err,
                    const ctype&lt;char_type&gt;&amp; __ct) const;
    void __get_hour(int&amp; __d,
                    iter_type&amp; __b, iter_type __e,
                    ios_base::iostate&amp; __err,
                    const ctype&lt;char_type&gt;&amp; __ct) const;
    void __get_12_hour(int&amp; __h,
                       iter_type&amp; __b, iter_type __e,
                       ios_base::iostate&amp; __err,
                       const ctype&lt;char_type&gt;&amp; __ct) const;
    void __get_am_pm(int&amp; __h,
                     iter_type&amp; __b, iter_type __e,
                     ios_base::iostate&amp; __err,
                     const ctype&lt;char_type&gt;&amp; __ct) const;
    void __get_minute(int&amp; __m,
                      iter_type&amp; __b, iter_type __e,
                      ios_base::iostate&amp; __err,
                      const ctype&lt;char_type&gt;&amp; __ct) const;
    void __get_second(int&amp; __s,
                      iter_type&amp; __b, iter_type __e,
                      ios_base::iostate&amp; __err,
                      const ctype&lt;char_type&gt;&amp; __ct) const;
    void __get_weekday(int&amp; __w,
                       iter_type&amp; __b, iter_type __e,
                       ios_base::iostate&amp; __err,
                       const ctype&lt;char_type&gt;&amp; __ct) const;
    void __get_day_year_num(int&amp; __w,
                            iter_type&amp; __b, iter_type __e,
                            ios_base::iostate&amp; __err,
                            const ctype&lt;char_type&gt;&amp; __ct) const;
};

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
locale::id
time_get&lt;_CharT, _InputIterator&gt;::id;



template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>weekdayname(int&amp; __w,
                                                    iter_type&amp; __b, iter_type __e,
                                                    ios_base::iostate&amp; __err,
                                                    const ctype&lt;char_type&gt;&amp; __ct) const
{

    const string_type* <span class="gs">__wk = this-&gt;__</span>weeks();
    ptrdiff_t <span class="gs">__i = __</span>scan_keyword(__b, <span class="gs">__e, __</span>wk, <span class="gs">__wk+14, __</span>ct, <span class="gs">__err, false) - __</span>wk;
    if (__i &lt; 14)
        <span class="gs">__w = __</span>i % 7;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>monthname(int&amp; __m,
                                                  iter_type&amp; __b, iter_type __e,
                                                  ios_base::iostate&amp; __err,
                                                  const ctype&lt;char_type&gt;&amp; __ct) const
{

    const string_type* <span class="gs">__month = this-&gt;__</span>months();
    ptrdiff_t <span class="gs">__i = __</span>scan_keyword(__b, <span class="gs">__e, __</span>month, <span class="gs">__month+24, __</span>ct, <span class="gs">__err, false) - __</span>month;
    if (__i &lt; 24)
        <span class="gs">__m = __</span>i % 12;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>day(int&amp; __d,
                                            iter_type&amp; __b, iter_type __e,
                                            ios_base::iostate&amp; __err,
                                            const ctype&lt;char_type&gt;&amp; __ct) const
{
    int <span class="gs">__t = __</span>get_up_to_n_digits(__b, <span class="gs">__e, __</span>err, __ct, 2);
    if (!(__err &amp; ios_base::failbit) &amp;&amp; 1 &lt;= <span class="gs">__t &amp;&amp; __</span>t &lt;= 31)
        <span class="gs">__d = __</span>t;
    else
        __err |= ios_base::failbit;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>month(int&amp; __m,
                                              iter_type&amp; __b, iter_type __e,
                                              ios_base::iostate&amp; __err,
                                              const ctype&lt;char_type&gt;&amp; __ct) const
{
    int <span class="gs">__t = __</span>get_up_to_n_digits(__b, <span class="gs">__e, __</span>err, __ct, 2) - 1;
    if (!(__err &amp; ios_base::failbit) &amp;&amp; __t &lt;= 11)
        <span class="gs">__m = __</span>t;
    else
        __err |= ios_base::failbit;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>year(int&amp; __y,
                                             iter_type&amp; __b, iter_type __e,
                                             ios_base::iostate&amp; __err,
                                             const ctype&lt;char_type&gt;&amp; __ct) const
{
    int <span class="gs">__t = __</span>get_up_to_n_digits(__b, <span class="gs">__e, __</span>err, __ct, 4);
    if (!(__err &amp; ios_base::failbit))
    {
        if (__t &lt; 69)
            __t += 2000;
        else if (69 &lt;= <span class="gs">__t &amp;&amp; __</span>t &lt;= 99)
            __t += 1900;
        <span class="gs">__y = __</span>t - 1900;
    }
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>year4(int&amp; __y,
                                              iter_type&amp; __b, iter_type __e,
                                              ios_base::iostate&amp; __err,
                                              const ctype&lt;char_type&gt;&amp; __ct) const
{
    int <span class="gs">__t = __</span>get_up_to_n_digits(__b, <span class="gs">__e, __</span>err, __ct, 4);
    if (!(__err &amp; ios_base::failbit))
        <span class="gs">__y = __</span>t - 1900;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>hour(int&amp; __h,
                                             iter_type&amp; __b, iter_type __e,
                                             ios_base::iostate&amp; __err,
                                             const ctype&lt;char_type&gt;&amp; __ct) const
{
    int <span class="gs">__t = __</span>get_up_to_n_digits(__b, <span class="gs">__e, __</span>err, __ct, 2);
    if (!(__err &amp; ios_base::failbit) &amp;&amp; __t &lt;= 23)
        <span class="gs">__h = __</span>t;
    else
        __err |= ios_base::failbit;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>12_hour(int&amp; __h,
                                                iter_type&amp; __b, iter_type __e,
                                                ios_base::iostate&amp; __err,
                                                const ctype&lt;char_type&gt;&amp; __ct) const
{
    int <span class="gs">__t = __</span>get_up_to_n_digits(__b, <span class="gs">__e, __</span>err, __ct, 2);
    if (!(__err &amp; ios_base::failbit) &amp;&amp; 1 &lt;= <span class="gs">__t &amp;&amp; __</span>t &lt;= 12)
        <span class="gs">__h = __</span>t;
    else
        __err |= ios_base::failbit;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>minute(int&amp; __m,
                                               iter_type&amp; __b, iter_type __e,
                                               ios_base::iostate&amp; __err,
                                               const ctype&lt;char_type&gt;&amp; __ct) const
{
    int <span class="gs">__t = __</span>get_up_to_n_digits(__b, <span class="gs">__e, __</span>err, __ct, 2);
    if (!(__err &amp; ios_base::failbit) &amp;&amp; __t &lt;= 59)
        <span class="gs">__m = __</span>t;
    else
        __err |= ios_base::failbit;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>second(int&amp; __s,
                                               iter_type&amp; __b, iter_type __e,
                                               ios_base::iostate&amp; __err,
                                               const ctype&lt;char_type&gt;&amp; __ct) const
{
    int <span class="gs">__t = __</span>get_up_to_n_digits(__b, <span class="gs">__e, __</span>err, __ct, 2);
    if (!(__err &amp; ios_base::failbit) &amp;&amp; __t &lt;= 60)
        <span class="gs">__s = __</span>t;
    else
        __err |= ios_base::failbit;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>weekday(int&amp; __w,
                                                iter_type&amp; __b, iter_type __e,
                                                ios_base::iostate&amp; __err,
                                                const ctype&lt;char_type&gt;&amp; __ct) const
{
    int <span class="gs">__t = __</span>get_up_to_n_digits(__b, <span class="gs">__e, __</span>err, __ct, 1);
    if (!(__err &amp; ios_base::failbit) &amp;&amp; __t &lt;= 6)
        <span class="gs">__w = __</span>t;
    else
        __err |= ios_base::failbit;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>day_year_num(int&amp; __d,
                                                     iter_type&amp; __b, iter_type __e,
                                                     ios_base::iostate&amp; __err,
                                                     const ctype&lt;char_type&gt;&amp; __ct) const
{
    int <span class="gs">__t = __</span>get_up_to_n_digits(__b, <span class="gs">__e, __</span>err, __ct, 3);
    if (!(__err &amp; ios_base::failbit) &amp;&amp; __t &lt;= 365)
        <span class="gs">__d = __</span>t;
    else
        __err |= ios_base::failbit;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>white_space(iter_type&amp; __b, iter_type __e,
                                                    ios_base::iostate&amp; __err,
                                                    const ctype&lt;char_type&gt;&amp; __ct) const
{
    for (; <span class="gs">__b != __</span>e &amp;&amp; __ct.is(ctype_base::space, *<span class="gs">__b); ++__</span>b)
        ;
    if (<span class="gs">__b == __</span>e)
        __err |= ios_base::eofbit;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>am_pm(int&amp; __h,
                                              iter_type&amp; __b, iter_type __e,
                                              ios_base::iostate&amp; __err,
                                              const ctype&lt;char_type&gt;&amp; __ct) const
{
    const string_type* <span class="gs">__ap = this-&gt;__</span>am_pm();
    if (<span class="gs">__ap[0].size() + __</span>ap[1].size() == 0)
    {
        __err |= ios_base::failbit;
        return;
    }
    ptrdiff_t <span class="gs">__i = __</span>scan_keyword(__b, <span class="gs">__e, __</span>ap, <span class="gs">__ap+2, __</span>ct, <span class="gs">__err, false) - __</span>ap;
    if (<span class="gs">__i == 0 &amp;&amp; __</span>h == 12)
        __h = 0;
    else if (<span class="gs">__i == 1 &amp;&amp; __</span>h &lt; 12)
        __h += 12;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
void
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__get_</span>percent(iter_type&amp; __b, iter_type __e,
                                                ios_base::iostate&amp; __err,
                                                const ctype&lt;char_type&gt;&amp; __ct) const
{
    if (<span class="gs">__b == __</span>e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return;
    }
    if (<span class="gs">__ct.narrow(*__</span>b, 0) != &#39;%&#39;)
        __err |= ios_base::failbit;
    else if(++__b == __e)
        __err |= ios_base::eofbit;
}



template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
_InputIterator
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::get(iter_</span>type __b, iter_type __e,
                                      ios_base&amp; __iob,
                                      ios_base::iostate&amp; <span class="gs">__err, tm* __</span>tm,
                                      const char_type* __fmtb, const char_type* __fmte) const
{
    const ctype&lt;char_type&gt;&amp; __ct = use_facet&lt;ctype&lt;char_type&gt; &gt;(__iob.getloc());
    __err = ios_base::goodbit;
    while (<span class="gs">__fmtb != __</span>fmte &amp;&amp; __err == ios_base::goodbit)
    {
        if (<span class="gs">__b == __</span>e)
        {
            __err = ios_base::failbit;
            break;
        }
        if (<span class="gs">__ct.narrow(*__</span>fmtb, 0) == &#39;%&#39;)
        {
            if (++__fmtb == __fmte)
            {
                __err = ios_base::failbit;
                break;
            }
            char <span class="gs">__cmd = __</span>ct.narrow(*__fmtb, 0);
            char __opt = &#39;\0&#39;;
            if (<span class="gs">__cmd == &#39;E&#39; || __</span>cmd == &#39;0&#39;)
            {
                if (++__fmtb == __fmte)
                {
                    __err = ios_base::failbit;
                    break;
                }
                <span class="gs">__opt = __</span>cmd;
                <span class="gs">__cmd = __</span>ct.narrow(*__fmtb, 0);
            }
            __b = do_get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm, <span class="gs">__cmd, __</span>opt);
            ++__fmtb;
        }
        else if (__ct.is(ctype_base::space, *__fmtb))
        {
            for (++__fmtb; <span class="gs">__fmtb != __</span>fmte &amp;&amp; __ct.is(ctype_base::space, *<span class="gs">__fmtb); ++__</span>fmtb)
                ;
            for ( ; <span class="gs">__b != __</span>e &amp;&amp; __ct.is(ctype_base::space, *<span class="gs">__b); ++__</span>b)
                ;
        }
        else if (<span class="gs">__ct.toupper(*__</span>b) == <span class="gs">__ct.toupper(*__</span>fmtb))
        {
            ++__b;
            ++__fmtb;
        }
        else
            __err = ios_base::failbit;
    }
    if (<span class="gs">__b == __</span>e)
        __err |= ios_base::eofbit;
    return __b;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
typename time_get&lt;_CharT, _InputIterator&gt;::dateorder
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::do_</span>date_order() const
{
    return mdy;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
_InputIterator
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::do_</span>get_time(iter_type __b, iter_type __e,
                                              ios_base&amp; __iob,
                                              ios_base::iostate&amp; __err,
                                              tm* __tm) const
{
    const char_type __fmt[] = {&#39;%&#39;, &#39;H&#39;, &#39;:&#39;, &#39;%&#39;, &#39;M&#39;, &#39;:&#39;, &#39;%&#39;, &#39;S&#39;};
    return get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm, <span class="gs">__fmt, __</span>fmt + sizeof(__fmt)/sizeof(__fmt[0]));
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
_InputIterator
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::do_</span>get_date(iter_type __b, iter_type __e,
                                              ios_base&amp; __iob,
                                              ios_base::iostate&amp; __err,
                                              tm* __tm) const
{
    const string_type&amp; <span class="gs">__fmt = this-&gt;__</span>x();
    return get(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm, <span class="gs">__fmt.data(), __</span>fmt.data() + __fmt.size());
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
_InputIterator
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::do_</span>get_weekday(iter_type __b, iter_type __e,
                                                 ios_base&amp; __iob,
                                                 ios_base::iostate&amp; __err,
                                                 tm* __tm) const
{
    const ctype&lt;char_type&gt;&amp; __ct = use_facet&lt;ctype&lt;char_type&gt; &gt;(__iob.getloc());
    __get_weekdayname(__tm-&gt;tm_wday, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
    return __b;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
_InputIterator
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::do_</span>get_monthname(iter_type __b, iter_type __e,
                                                   ios_base&amp; __iob,
                                                   ios_base::iostate&amp; __err,
                                                   tm* __tm) const
{
    const ctype&lt;char_type&gt;&amp; __ct = use_facet&lt;ctype&lt;char_type&gt; &gt;(__iob.getloc());
    __get_monthname(__tm-&gt;tm_mon, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
    return __b;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
_InputIterator
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::do_</span>get_year(iter_type __b, iter_type __e,
                                              ios_base&amp; __iob,
                                              ios_base::iostate&amp; __err,
                                              tm* __tm) const
{
    const ctype&lt;char_type&gt;&amp; __ct = use_facet&lt;ctype&lt;char_type&gt; &gt;(__iob.getloc());
    __get_year(__tm-&gt;tm_year, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
    return __b;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
_InputIterator
time_get&lt;_CharT, <span class="ge">_InputIterator&gt;::do_</span>get(iter_type __b, iter_type __e,
                                         ios_base&amp; __iob,
                                         ios_base::iostate&amp; <span class="gs">__err, tm* __</span>tm,
                                         char __fmt, char) const
{
    __err = ios_base::goodbit;
    const ctype&lt;char_type&gt;&amp; __ct = use_facet&lt;ctype&lt;char_type&gt; &gt;(__iob.getloc());
    switch (__fmt)
    {
    case &#39;a&#39;:
    case &#39;A&#39;:
        __get_weekdayname(__tm-&gt;tm_wday, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
        break;
    case &#39;b&#39;:
    case &#39;B&#39;:
    case &#39;h&#39;:
        __get_monthname(__tm-&gt;tm_mon, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
        break;
    case &#39;c&#39;:
        {
        const string_type&amp; <span class="gs">__fm = this-&gt;__</span>c();
        <span class="gs">__b = get(__</span>b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm, <span class="gs">__fm.data(), __</span>fm.data() + __fm.size());
        }
        break;
    case &#39;d&#39;:
    case &#39;e&#39;:
        __get_day(__tm-&gt;tm_mday, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
        break;
    case &#39;D&#39;:
        {
        const char_type __fm[] = {&#39;%&#39;, &#39;m&#39;, &#39;/&#39;, &#39;%&#39;, &#39;d&#39;, &#39;/&#39;, &#39;%&#39;, &#39;y&#39;};
        <span class="gs">__b = get(__</span>b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm, <span class="gs">__fm, __</span>fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case &#39;F&#39;:
        {
        const char_type __fm[] = {&#39;%&#39;, &#39;Y&#39;, &#39;-&#39;, &#39;%&#39;, &#39;m&#39;, &#39;-&#39;, &#39;%&#39;, &#39;d&#39;};
        <span class="gs">__b = get(__</span>b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm, <span class="gs">__fm, __</span>fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case &#39;H&#39;:
        __get_hour(__tm-&gt;tm_hour, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
        break;
    case &#39;I&#39;:
        __get_12_hour(__tm-&gt;tm_hour, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
        break;
    case &#39;j&#39;:
        __get_day_year_num(__tm-&gt;tm_yday, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
        break;
    case &#39;m&#39;:
        __get_month(__tm-&gt;tm_mon, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
        break;
    case &#39;M&#39;:
        __get_minute(__tm-&gt;tm_min, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
        break;
    case &#39;n&#39;:
    case &#39;t&#39;:
        __get_white_space(__b, <span class="gs">__e, __</span>err, __ct);
        break;
    case &#39;p&#39;:
        __get_am_pm(__tm-&gt;tm_hour, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
        break;
    case &#39;r&#39;:
        {
        const char_type __fm[] = {&#39;%&#39;, &#39;I&#39;, &#39;:&#39;, &#39;%&#39;, &#39;M&#39;, &#39;:&#39;, &#39;%&#39;, &#39;S&#39;, &#39; &#39;, &#39;%&#39;, &#39;p&#39;};
        <span class="gs">__b = get(__</span>b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm, <span class="gs">__fm, __</span>fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case &#39;R&#39;:
        {
        const char_type __fm[] = {&#39;%&#39;, &#39;H&#39;, &#39;:&#39;, &#39;%&#39;, &#39;M&#39;};
        <span class="gs">__b = get(__</span>b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm, <span class="gs">__fm, __</span>fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case &#39;S&#39;:
        __get_second(__tm-&gt;tm_sec, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
        break;
    case &#39;T&#39;:
        {
        const char_type __fm[] = {&#39;%&#39;, &#39;H&#39;, &#39;:&#39;, &#39;%&#39;, &#39;M&#39;, &#39;:&#39;, &#39;%&#39;, &#39;S&#39;};
        <span class="gs">__b = get(__</span>b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm, <span class="gs">__fm, __</span>fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case &#39;w&#39;:
        __get_weekday(__tm-&gt;tm_wday, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
        break;
    case &#39;x&#39;:
        return do_get_date(__b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm);
    case &#39;X&#39;:
        {
        const string_type&amp; <span class="gs">__fm = this-&gt;__</span>X();
        <span class="gs">__b = get(__</span>b, <span class="gs">__e, __</span>iob, <span class="gs">__err, __</span>tm, <span class="gs">__fm.data(), __</span>fm.data() + __fm.size());
        }
        break;
    case &#39;y&#39;:
        __get_year(__tm-&gt;tm_year, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
        break;
    case &#39;Y&#39;:
        __get_year4(__tm-&gt;tm_year, <span class="gs">__b, __</span>e, <span class="gs">__err, __</span>ct);
        break;
    case &#39;%&#39;:
        __get_percent(__b, <span class="gs">__e, __</span>err, __ct);
        break;
    default:
        __err |= ios_base::failbit;
    }
    return __b;
}

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) time_get&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) time_get&lt;wchar_t&gt;;

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __time_get
{
protected:
    locale_t __loc_;

    __time_get(const char* __nm);
    __time_get(const string&amp; __nm);
    ~__time_get();
};

template &lt;class _CharT&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) __time_get_storage
    : public __time_get
{
protected:
    typedef basic_string&lt;_CharT&gt; string_type;

    string_type __weeks_[14];
    string_type __months_[24];
    string_type __am_pm_[2];
    string_type __c_;
    string_type __r_;
    string_type __x_;
    string_type __X_;

    explicit __time_get_storage(const char* __nm);
    explicit __time_get_storage(const string&amp; __nm);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) ~__time_get_storage() {}

    time_base::dateorder __do_date_order() const;

private:
    void init(const ctype&lt;_CharT&gt;&amp;);
    string_type <span class="gs">__analyze(char __</span>fmt, const ctype&lt;_CharT&gt;&amp;);
};
template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) time_base::dateorder __time_get_storage&lt;char&gt;::__do_date_order() const; template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __time_get_storage&lt;char&gt;::__time_get_storage(const char*); template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __time_get_storage&lt;char&gt;::__time_get_storage(const string&amp;); template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void __time_get_storage&lt;char&gt;::init(const ctype&lt;char&gt;&amp;); template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __time_get_storage&lt;char&gt;::string_type __time_get_storage&lt;char&gt;::__analyze(char, const ctype&lt;char&gt;&amp;); extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) time_base::dateorder __time_get_storage&lt;char&gt;::__do_date_order() const; extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __time_get_storage&lt;char&gt;::__time_get_storage(const char*); extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __time_get_storage&lt;char&gt;::__time_get_storage(const string&amp;); extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void __time_get_storage&lt;char&gt;::init(const ctype&lt;char&gt;&amp;); extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __time_get_storage&lt;char&gt;::string_type __time_get_storage&lt;char&gt;::__analyze(char, const ctype&lt;char&gt;&amp;);
template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) time_base::dateorder __time_get_storage&lt;wchar_t&gt;::__do_date_order() const; template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __time_get_storage&lt;wchar_t&gt;::__time_get_storage(const char*); template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __time_get_storage&lt;wchar_t&gt;::__time_get_storage(const string&amp;); template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void __time_get_storage&lt;wchar_t&gt;::init(const ctype&lt;wchar_t&gt;&amp;); template &lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __time_get_storage&lt;wchar_t&gt;::string_type __time_get_storage&lt;wchar_t&gt;::__analyze(char, const ctype&lt;wchar_t&gt;&amp;); extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) time_base::dateorder __time_get_storage&lt;wchar_t&gt;::__do_date_order() const; extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __time_get_storage&lt;wchar_t&gt;::__time_get_storage(const char*); extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __time_get_storage&lt;wchar_t&gt;::__time_get_storage(const string&amp;); extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void __time_get_storage&lt;wchar_t&gt;::init(const ctype&lt;wchar_t&gt;&amp;); extern template <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __time_get_storage&lt;wchar_t&gt;::string_type __time_get_storage&lt;wchar_t&gt;::__analyze(char, const ctype&lt;wchar_t&gt;&amp;);


template &lt;class <span class="ge">_CharT, class _</span>InputIterator = istreambuf_iterator&lt;_CharT&gt; &gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) time_get_byname
    : public time_get&lt;_CharT, _InputIterator&gt;,
      private __time_get_storage&lt;_CharT&gt;
{
public:
    typedef time_base::dateorder dateorder;
    typedef <span class="ge">_InputIterator iter_</span>type;
    typedef <span class="ge">_CharT char_</span>type;
    typedef basic_string&lt;char_type&gt; string_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit time_get_byname(const char* __nm, size_t __refs = 0)
        : time_get&lt;_CharT, <span class="ge">_InputIterator&gt;(_</span>_refs),
          __time_get_storage&lt;_CharT&gt;(__nm) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit time_get_byname(const string&amp; __nm, size_t __refs = 0)
        : time_get&lt;_CharT, <span class="ge">_InputIterator&gt;(_</span>_refs),
          __time_get_storage&lt;_CharT&gt;(__nm) {}

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~time_get_byname() {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    virtual dateorder do_date_order() const {return this-&gt;__do_date_order();}
private:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    virtual const string_type* <span class="gs">__weeks() const {return this-&gt;__</span>weeks_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    virtual const string_type* <span class="gs">__months() const {return this-&gt;__</span>months_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    virtual const string_type* __am_pm() const {return this-&gt;__am_pm_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    virtual const string_type&amp; <span class="gs">__c() const {return this-&gt;__</span>c_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    virtual const string_type&amp; <span class="gs">__r() const {return this-&gt;__</span>r_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    virtual const string_type&amp; <span class="gs">__x() const {return this-&gt;__</span>x_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    virtual const string_type&amp; <span class="gs">__X() const {return this-&gt;__</span>X_;}
};

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) time_get_byname&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) time_get_byname&lt;wchar_t&gt;;

class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __time_put
{
    locale_t __loc_;
protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __time_put() : __loc_(0) {}
    __time_put(const char* __nm);
    __time_put(const string&amp; __nm);
    ~__time_put();
    void __do_put(char* <span class="gs">__nb, char*&amp; __</span>ne, const tm* __tm,
                  char <span class="gs">__fmt, char __</span>mod) const;
    void __do_put(wchar_t* __wb, wchar_t*&amp; <span class="gs">__we, const tm* __</span>tm,
                  char <span class="gs">__fmt, char __</span>mod) const;
};

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator = ostreambuf_iterator&lt;_CharT&gt; &gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) time_put
    : public locale::facet,
      private __time_put
{
public:
    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_OutputIterator iter_</span>type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit time_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    iter_type put(iter_type __s, ios_base&amp; __iob, char_type <span class="gs">__fl, const tm* __</span>tm,
                  const char_type* __pb, const char_type* __pe) const;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type put(iter_type __s, ios_base&amp; __iob, char_type __fl,
                  const tm* <span class="gs">__tm, char __</span>fmt, char __mod = 0) const
    {
        return do_put(__s, <span class="gs">__iob, __</span>fl, <span class="gs">__tm, __</span>fmt, __mod);
    }

    static locale::id id;

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~time_put() {}
    virtual iter_type do_put(iter_type __s, ios_base&amp;, char_type, const tm* __tm,
                             char <span class="gs">__fmt, char __</span>mod) const;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit time_put(const char* __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit time_put(const string&amp; __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
};

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
locale::id
time_put&lt;_CharT, _OutputIterator&gt;::id;

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
_OutputIterator
time_put&lt;_CharT, <span class="ge">_OutputIterator&gt;::put(iter_</span>type __s, ios_base&amp; __iob,
                                       char_type <span class="gs">__fl, const tm* __</span>tm,
                                       const char_type* __pb,
                                       const char_type* __pe) const
{
    const ctype&lt;char_type&gt;&amp; __ct = use_facet&lt;ctype&lt;char_type&gt; &gt;(__iob.getloc());
    for (; <span class="gs">__pb != __</span>pe; ++__pb)
    {
        if (<span class="gs">__ct.narrow(*__</span>pb, 0) == &#39;%&#39;)
        {
            if (++__pb == __pe)
            {
                *<span class="gs">__s++ = __</span>pb[-1];
                break;
            }
            char __mod = 0;
            char <span class="gs">__fmt = __</span>ct.narrow(*__pb, 0);
            if (<span class="gs">__fmt == &#39;E&#39; || __</span>fmt == &#39;O&#39;)
            {
                if (++__pb == __pe)
                {
                    *<span class="gs">__s++ = __</span>pb[-2];
                    *<span class="gs">__s++ = __</span>pb[-1];
                    break;
                }
                <span class="gs">__mod = __</span>fmt;
                <span class="gs">__fmt = __</span>ct.narrow(*__pb, 0);
            }
            __s = do_put(__s, <span class="gs">__iob, __</span>fl, <span class="gs">__tm, __</span>fmt, __mod);
        }
        else
            <span class="ge">*__s++ = *</span>__pb;
    }
    return __s;
}

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
_OutputIterator
time_put&lt;_CharT, <span class="ge">_OutputIterator&gt;::do_</span>put(iter_type __s, ios_base&amp;,
                                          char_type, const tm* __tm,
                                          char <span class="gs">__fmt, char __</span>mod) const
{
    char_type __nar[100];
    char_type* <span class="gs">__nb = __</span>nar;
    char_type* <span class="gs">__ne = __</span>nb + 100;
    __do_put(__nb, <span class="gs">__ne, __</span>tm, <span class="gs">__fmt, __</span>mod);
    return std::__1::copy(__nb, <span class="gs">__ne, __</span>s);
}

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) time_put&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) time_put&lt;wchar_t&gt;;

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator = ostreambuf_iterator&lt;_CharT&gt; &gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) time_put_byname
    : public time_put&lt;_CharT, _OutputIterator&gt;
{
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit time_put_byname(const char* __nm, size_t __refs = 0)
        : time_put&lt;_CharT, <span class="ge">_OutputIterator&gt;(__nm, _</span>_refs) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit time_put_byname(const string&amp; __nm, size_t __refs = 0)
        : time_put&lt;_CharT, <span class="ge">_OutputIterator&gt;(__nm, _</span>_refs) {}

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~time_put_byname() {}
};

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) time_put_byname&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) time_put_byname&lt;wchar_t&gt;;



class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) money_base
{
public:
    enum part {none, space, symbol, sign, value};
    struct pattern {char field[4];};

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) money_base() {}
};



template &lt;class <span class="ge">_CharT, bool _</span>International = false&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) moneypunct
    : public locale::facet,
      public money_base
{
public:
    typedef <span class="ge">_CharT char_</span>type;
    typedef basic_string&lt;char_type&gt; string_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit moneypunct(size_t __refs = 0)
        : locale::facet(__refs) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) char_type decimal_point() const {return do_decimal_point();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) char_type thousands_sep() const {return do_thousands_sep();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) string grouping() const {return do_grouping();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) string_type curr_symbol() const {return do_curr_symbol();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) string_type positive_sign() const {return do_positive_sign();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) string_type negative_sign() const {return do_negative_sign();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) int frac_digits() const {return do_frac_digits();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) pattern pos_format() const {return do_pos_format();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) pattern neg_format() const {return do_neg_format();}

    static locale::id id;
    static const bool intl = _International;

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~moneypunct() {}

    virtual char_type do_decimal_point() const {return numeric_limits&lt;char_type&gt;::max();}
    virtual char_type do_thousands_sep() const {return numeric_limits&lt;char_type&gt;::max();}
    virtual string do_grouping() const {return string();}
    virtual string_type do_curr_symbol() const {return string_type();}
    virtual string_type do_positive_sign() const {return string_type();}
    virtual string_type do_negative_sign() const {return string_type(1, &#39;-&#39;);}
    virtual int do_frac_digits() const {return 0;}
    virtual pattern do_pos_format() const
        {pattern <span class="gs">__p = {{symbol, sign, none, value}}; return __</span>p;}
    virtual pattern do_neg_format() const
        {pattern <span class="gs">__p = {{symbol, sign, none, value}}; return __</span>p;}
};

template &lt;class <span class="ge">_CharT, bool _</span>International&gt;
locale::id
moneypunct&lt;_CharT, _International&gt;::id;

template &lt;class <span class="ge">_CharT, bool _</span>International&gt;
const bool
moneypunct&lt;_CharT, _International&gt;::intl;

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) moneypunct&lt;char, false&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) moneypunct&lt;char, true&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) moneypunct&lt;wchar_t, false&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) moneypunct&lt;wchar_t, true&gt;;



template &lt;class <span class="ge">_CharT, bool _</span>International = false&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) moneypunct_byname
    : public moneypunct&lt;_CharT, _International&gt;
{
public:
    typedef money_base::pattern pattern;
    typedef <span class="ge">_CharT char_</span>type;
    typedef basic_string&lt;char_type&gt; string_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)
        : moneypunct&lt;_CharT, <span class="ge">_International&gt;(__refs) {init(_</span>_nm);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit moneypunct_byname(const string&amp; __nm, size_t __refs = 0)
        : moneypunct&lt;_CharT, <span class="ge">_International&gt;(__refs) {init(__nm.c_</span>str());}

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~moneypunct_byname() {}

    virtual char_type do_decimal_point() const {return __decimal_point_;}
    virtual char_type do_thousands_sep() const {return __thousands_sep_;}
    virtual string do_grouping() const {return __grouping_;}
    virtual string_type do_curr_symbol() const {return __curr_symbol_;}
    virtual string_type do_positive_sign() const {return __positive_sign_;}
    virtual string_type do_negative_sign() const {return __negative_sign_;}
    virtual int do_frac_digits() const {return __frac_digits_;}
    virtual pattern do_pos_format() const {return __pos_format_;}
    virtual pattern do_neg_format() const {return __neg_format_;}

private:
    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
    string_type __curr_symbol_;
    string_type __positive_sign_;
    string_type __negative_sign_;
    int __frac_digits_;
    pattern __pos_format_;
    pattern __neg_format_;

    void init(const char*);
};

template&lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void moneypunct_byname&lt;char, false&gt;::init(const char*);
template&lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void moneypunct_byname&lt;char, true&gt;::init(const char*);
template&lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void moneypunct_byname&lt;wchar_t, false&gt;::init(const char*);
template&lt;&gt; <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void moneypunct_byname&lt;wchar_t, true&gt;::init(const char*);

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) moneypunct_byname&lt;char, false&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) moneypunct_byname&lt;char, true&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) moneypunct_byname&lt;wchar_t, false&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) moneypunct_byname&lt;wchar_t, true&gt;;



template &lt;class _CharT&gt;
class __money_get
{
protected:
    typedef <span class="ge">_CharT char_</span>type;
    typedef basic_string&lt;char_type&gt; string_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __money_get() {}

    static void __gather_info(bool <span class="gs">__intl, const locale&amp; __</span>loc,
                              money_base::pattern&amp; __pat, char_type&amp; __dp,
                              char_type&amp; <span class="gs">__ts, string&amp; __</span>grp,
                              string_type&amp; __sym, string_type&amp; __psn,
                              string_type&amp; <span class="gs">__nsn, int&amp; __</span>fd);
};

template &lt;class _CharT&gt;
void
__money_get&lt;_CharT&gt;::__gather_info(bool <span class="gs">__intl, const locale&amp; __</span>loc,
                                   money_base::pattern&amp; __pat, char_type&amp; __dp,
                                   char_type&amp; <span class="gs">__ts, string&amp; __</span>grp,
                                   string_type&amp; __sym, string_type&amp; __psn,
                                   string_type&amp; <span class="gs">__nsn, int&amp; __</span>fd)
{
    if (__intl)
    {
        const moneypunct&lt;char_type, true&gt;&amp; __mp =
            use_facet&lt;moneypunct&lt;char_type, true&gt; &gt;(__loc);
        <span class="gs">__pat = __</span>mp.neg_format();
        <span class="gs">__nsn = __</span>mp.negative_sign();
        <span class="gs">__psn = __</span>mp.positive_sign();
        <span class="gs">__dp = __</span>mp.decimal_point();
        <span class="gs">__ts = __</span>mp.thousands_sep();
        <span class="gs">__grp = __</span>mp.grouping();
        <span class="gs">__sym = __</span>mp.curr_symbol();
        <span class="gs">__fd = __</span>mp.frac_digits();
    }
    else
    {
        const moneypunct&lt;char_type, false&gt;&amp; __mp =
            use_facet&lt;moneypunct&lt;char_type, false&gt; &gt;(__loc);
        <span class="gs">__pat = __</span>mp.neg_format();
        <span class="gs">__nsn = __</span>mp.negative_sign();
        <span class="gs">__psn = __</span>mp.positive_sign();
        <span class="gs">__dp = __</span>mp.decimal_point();
        <span class="gs">__ts = __</span>mp.thousands_sep();
        <span class="gs">__grp = __</span>mp.grouping();
        <span class="gs">__sym = __</span>mp.curr_symbol();
        <span class="gs">__fd = __</span>mp.frac_digits();
    }
}

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __money_get&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __money_get&lt;wchar_t&gt;;

template &lt;class <span class="ge">_CharT, class _</span>InputIterator = istreambuf_iterator&lt;_CharT&gt; &gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) money_get
    : public locale::facet,
      private __money_get&lt;_CharT&gt;
{
public:
    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_InputIterator iter_</span>type;
    typedef basic_string&lt;char_type&gt; string_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit money_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get(iter_type __b, iter_type <span class="gs">__e, bool __</span>intl, ios_base&amp; __iob,
                  ios_base::iostate&amp; <span class="gs">__err, long double&amp; __</span>v) const
    {
        return do_get(__b, <span class="gs">__e, __</span>intl, <span class="gs">__iob, __</span>err, __v);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type get(iter_type __b, iter_type <span class="gs">__e, bool __</span>intl, ios_base&amp; __iob,
                  ios_base::iostate&amp; __err, string_type&amp; __v) const
    {
        return do_get(__b, <span class="gs">__e, __</span>intl, <span class="gs">__iob, __</span>err, __v);
    }

    static locale::id id;

protected:

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~money_get() {}

    virtual iter_type do_get(iter_type __b, iter_type <span class="gs">__e, bool __</span>intl,
                             ios_base&amp; __iob, ios_base::iostate&amp; __err,
                             long double&amp; __v) const;
    virtual iter_type do_get(iter_type __b, iter_type <span class="gs">__e, bool __</span>intl,
                             ios_base&amp; __iob, ios_base::iostate&amp; __err,
                             string_type&amp; __v) const;

private:
    static bool __do_get(iter_type&amp; __b, iter_type __e,
                         bool <span class="gs">__intl, const locale&amp; __</span>loc,
                         ios_base::fmtflags __flags, ios_base::iostate&amp; __err,
                         bool&amp; __neg, const ctype&lt;char_type&gt;&amp; __ct,
                         unique_ptr&lt;char_type, void(*)(void*)&gt;&amp; __wb,
                         char_type*&amp; __wn, char_type* __we);
};

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
locale::id
money_get&lt;_CharT, _InputIterator&gt;::id;

<span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) void __do_nothing(void*);

template &lt;class _Tp&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;)))
void
__double_or_nothing(unique_ptr&lt;_Tp, void(*)(void*)&gt;&amp; __b, <span class="ge">_Tp*&amp; __n, _</span>Tp*&amp; __e)
{
    bool <span class="gs">__owns = __</span>b.get_deleter() != __do_nothing;
    size_t __cur_cap = static_cast&lt;size_t&gt;(__e-__b.get()) * sizeof(_Tp);
    size_t __new_cap = __cur_cap &lt; numeric_limits&lt;size_t&gt;::max() / 2 ?
                       2 * __cur_cap : numeric_limits&lt;size_t&gt;::max();
    if (__new_cap == 0)
        __new_cap = sizeof(_Tp);
    size_t __n_off = static_cast&lt;size_t&gt;(__n - __b.get());
    <span class="ge">_Tp* __t = (_</span>Tp*)realloc(__owns ? <span class="gs">__b.get() : 0, __</span>new_cap);
    if (__t == 0)
        __throw_bad_alloc();
    if (__owns)
        __b.release();
    __b = unique_ptr&lt;_Tp, void(*)(void*)&gt;(__t, free);
    __new_cap /= sizeof(_Tp);
    <span class="gs">__n = __</span>b.get() + __n_off;
    <span class="gs">__e = __</span>b.get() + __new_cap;
}


template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
bool
money_get&lt;_CharT, <span class="ge">_InputIterator&gt;::__do_</span>get(iter_type&amp; __b, iter_type __e,
                                            bool <span class="gs">__intl, const locale&amp; __</span>loc,
                                            ios_base::fmtflags __flags,
                                            ios_base::iostate&amp; __err,
                                            bool&amp; __neg,
                                            const ctype&lt;char_type&gt;&amp; __ct,
                                            unique_ptr&lt;char_type, void(*)(void*)&gt;&amp; __wb,
                                            char_type*&amp; __wn, char_type* __we)
{
    const unsigned __bz = 100;
    unsigned <span class="gs">__gbuf[__</span>bz];
    unique_ptr&lt;unsigned, void(*)(void*)&gt; <span class="gs">__gb(__</span>gbuf, __do_nothing);
    unsigned* <span class="gs">__gn = __</span>gb.get();
    unsigned* <span class="gs">__ge = __</span>gn + __bz;
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __psn;
    string_type __nsn;


    string_type __spaces;
    int __fd;
    __money_get&lt;_CharT&gt;::__gather_info(__intl, <span class="gs">__loc, __</span>pat, <span class="gs">__dp, __</span>ts, __grp,
                                       <span class="gs">__sym, __</span>psn, <span class="gs">__nsn, __</span>fd);
    const string_type* __trailing_sign = 0;
    <span class="gs">__wn = __</span>wb.get();
    for (unsigned <span class="gs">__p = 0; __</span>p &lt; 4 &amp;&amp; <span class="gs">__b != __</span>e; ++__p)
    {
        switch (<span class="gs">__pat.field[__</span>p])
        {
        case money_base::space:
            if (__p != 3)
            {
                if (__ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
                else
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            <span class="gs">__attribute__</span>((__fallthrough__));
        case money_base::none:
            if (__p != 3)
            {
                while (<span class="gs">__b != __</span>e &amp;&amp; __ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
            }
            break;
        case money_base::sign:
            if (<span class="gs">__psn.size() + __</span>nsn.size() &gt; 0)
            {
                if (<span class="gs">__psn.size() == 0 || __</span>nsn.size() == 0)
                {
                    if (__psn.size() &gt; 0)
                    {
                        if (*__b == __psn[0])
                        {
                            ++__b;
                            if (__psn.size() &gt; 1)
                                __trailing_sign = &amp;__psn;
                        }
                        else
                            __neg = true;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() &gt; 1)
                            __trailing_sign = &amp;__nsn;
                    }
                }
                else
                {
                    if (*__b == __psn[0])
                    {
                        ++__b;
                        if (__psn.size() &gt; 1)
                            __trailing_sign = &amp;__psn;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() &gt; 1)
                            __trailing_sign = &amp;__nsn;
                    }
                    else
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                }
            }
            break;
        case money_base::symbol:
            {
            bool __more_needed = __trailing_sign ||
                                 (__p &lt; 2) ||
                                 (<span class="gs">__p == 2 &amp;&amp; __</span>pat.field[3] != static_cast&lt;char&gt;(money_base::none));
            bool <span class="gs">__sb = (__</span>flags &amp; ios_base::showbase) != 0;
            if (<span class="gs">__sb || __</span>more_needed)
            {
                typename string_type::const_iterator __sym_space_end = __sym.begin();
                if (<span class="gs">__p &gt; 0 &amp;&amp; (__</span>pat.field[__p - 1] == money_base::none ||
                                <span class="gs">__pat.field[__</span>p - 1] == money_base::space)) {


                    while (__sym_space_end != __sym.end() &amp;&amp;
                           __ct.is(ctype_base::space, *__sym_space_end))
                        ++__sym_space_end;
                    const size_t __num_spaces = __sym_space_end - __sym.begin();
                    if (__num_spaces &gt; __spaces.size() ||
                        !equal(__spaces.end() - __num_spaces, __spaces.end(),
                               __sym.begin())) {



                        __sym_space_end = __sym.begin();
                    }
                }
                typename string_type::const_iterator __sym_curr_char = __sym_space_end;
                while (__sym_curr_char != <span class="gs">__sym.end() &amp;&amp; __</span>b != __e &amp;&amp;
                       <span class="ge">*__b == *</span>__sym_curr_char) {
                    ++__b;
                    ++__sym_curr_char;
                }
                if (<span class="gs">__sb &amp;&amp; __</span>sym_curr_char != __sym.end())
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            }
            break;
        case money_base::value:
            {
            unsigned __ng = 0;
            for (; <span class="gs">__b != __</span>e; ++__b)
            {
                char_type <span class="gs">__c = *__</span>b;
                if (__ct.is(ctype_base::digit, __c))
                {
                    if (<span class="gs">__wn == __</span>we)
                        __double_or_nothing(__wb, <span class="gs">__wn, __</span>we);
                    *<span class="gs">__wn++ = __</span>c;
                    ++__ng;
                }
                else if (<span class="gs">__grp.size() &gt; 0 &amp;&amp; __</span>ng &gt; 0 &amp;&amp; <span class="gs">__c == __</span>ts)
                {
                    if (<span class="gs">__gn == __</span>ge)
                        __double_or_nothing(__gb, <span class="gs">__gn, __</span>ge);
                    *<span class="gs">__gn++ = __</span>ng;
                    __ng = 0;
                }
                else
                    break;
            }
            if (<span class="gs">__gb.get() != __</span>gn &amp;&amp; __ng &gt; 0)
            {
                if (<span class="gs">__gn == __</span>ge)
                    __double_or_nothing(__gb, <span class="gs">__gn, __</span>ge);
                *<span class="gs">__gn++ = __</span>ng;
            }
            if (__fd &gt; 0)
            {
                if (<span class="gs">__b == __</span>e || *<span class="gs">__b != __</span>dp)
                {
                    __err |= ios_base::failbit;
                    return false;
                }
                for (++__b; <span class="gs">__fd &gt; 0; --__</span>fd, ++__b)
                {
                    if (<span class="gs">__b == __</span>e || !__ct.is(ctype_base::digit, *__b))
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                    if (<span class="gs">__wn == __</span>we)
                        __double_or_nothing(__wb, <span class="gs">__wn, __</span>we);
                    <span class="ge">*__wn++ = *</span>__b;
                }
            }
            if (<span class="gs">__wn == __</span>wb.get())
            {
                __err |= ios_base::failbit;
                return false;
            }
            }
            break;
        }
    }
    if (__trailing_sign)
    {
        for (unsigned <span class="gs">__i = 1; __</span>i &lt; __trailing_sign-&gt;size(); ++__i, ++__b)
        {
            if (<span class="gs">__b == __</span>e || <span class="ge">*__b != (*</span>__trailing_sign)[__i])
            {
                __err |= ios_base::failbit;
                return false;
            }
        }
    }
    if (<span class="gs">__gb.get() != __</span>gn)
    {
        ios_base::iostate __et = ios_base::goodbit;
        __check_grouping(__grp, <span class="gs">__gb.get(), __</span>gn, __et);
        if (__et)
        {
            __err |= ios_base::failbit;
            return false;
        }
    }
    return true;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
_InputIterator
money_get&lt;_CharT, <span class="ge">_InputIterator&gt;::do_</span>get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base&amp; __iob,
                                          ios_base::iostate&amp; __err,
                                          long double&amp; __v) const
{
    const int __bz = 100;
    char_type <span class="gs">__wbuf[__</span>bz];
    unique_ptr&lt;char_type, void(*)(void*)&gt; <span class="gs">__wb(__</span>wbuf, __do_nothing);
    char_type* __wn;
    char_type* <span class="gs">__we = __</span>wbuf + __bz;
    locale <span class="gs">__loc = __</span>iob.getloc();
    const ctype&lt;char_type&gt;&amp; __ct = use_facet&lt;ctype&lt;char_type&gt; &gt;(__loc);
    bool __neg = false;
    if (__do_get(__b, <span class="gs">__e, __</span>intl, <span class="gs">__loc, __</span>iob.flags(), <span class="gs">__err, __</span>neg, __ct,
                 <span class="gs">__wb, __</span>wn, __we))
    {
        const char __src[] = &quot;0123456789&quot;;
        char_type <span class="gs">__atoms[sizeof(__</span>src)-1];
        <span class="gs">__ct.widen(__</span>src, <span class="gs">__src + (sizeof(__</span>src)-1), __atoms);
        char <span class="gs">__nbuf[__</span>bz];
        char* <span class="gs">__nc = __</span>nbuf;
        unique_ptr&lt;char, void(*)(void*)&gt; __h(0, free);
        if (<span class="gs">__wn - __</span>wb.get() &gt; __bz-2)
        {
            __h.reset((char*)malloc(static_cast&lt;size_t&gt;(__wn - __wb.get() + 2)));
            if (__h.get() == 0)
                __throw_bad_alloc();
            <span class="gs">__nc = __</span>h.get();
        }
        if (__neg)
            *__nc++ = &#39;-&#39;;
        for (const char_type* <span class="gs">__w = __</span>wb.get(); <span class="gs">__w &lt; __</span>wn; ++__w, ++__nc)
            <span class="ge">*__nc = __src[find(__atoms, std::__1::end(__atoms), *</span><span class="gs">__w) - __</span>atoms];
        *__nc = char();
        if (sscanf(__nbuf, &quot;%Lf&quot;, &amp;__v) != 1)
            __throw_runtime_error(&quot;money_get error&quot;);
    }
    if (<span class="gs">__b == __</span>e)
        __err |= ios_base::eofbit;
    return __b;
}

template &lt;class <span class="ge">_CharT, class _</span>InputIterator&gt;
_InputIterator
money_get&lt;_CharT, <span class="ge">_InputIterator&gt;::do_</span>get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base&amp; __iob,
                                          ios_base::iostate&amp; __err,
                                          string_type&amp; __v) const
{
    const int __bz = 100;
    char_type <span class="gs">__wbuf[__</span>bz];
    unique_ptr&lt;char_type, void(*)(void*)&gt; <span class="gs">__wb(__</span>wbuf, __do_nothing);
    char_type* __wn;
    char_type* <span class="gs">__we = __</span>wbuf + __bz;
    locale <span class="gs">__loc = __</span>iob.getloc();
    const ctype&lt;char_type&gt;&amp; __ct = use_facet&lt;ctype&lt;char_type&gt; &gt;(__loc);
    bool __neg = false;
    if (__do_get(__b, <span class="gs">__e, __</span>intl, <span class="gs">__loc, __</span>iob.flags(), <span class="gs">__err, __</span>neg, __ct,
                 <span class="gs">__wb, __</span>wn, __we))
    {
        __v.clear();
        if (__neg)
            __v.push_back(__ct.widen(&#39;-&#39;));
        char_type <span class="gs">__z = __</span>ct.widen(&#39;0&#39;);
        char_type* __w;
        for (<span class="gs">__w = __</span>wb.get(); <span class="gs">__w &lt; __</span>wn-1; ++__w)
            if (*__w != __z)
                break;
        <span class="gs">__v.append(__</span>w, __wn);
    }
    if (<span class="gs">__b == __</span>e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) money_get&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) money_get&lt;wchar_t&gt;;



template &lt;class _CharT&gt;
class __money_put
{
protected:
    typedef <span class="ge">_CharT char_</span>type;
    typedef basic_string&lt;char_type&gt; string_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __money_put() {}

    static void __gather_info(bool <span class="gs">__intl, bool __</span>neg, const locale&amp; __loc,
                              money_base::pattern&amp; __pat, char_type&amp; __dp,
                              char_type&amp; <span class="gs">__ts, string&amp; __</span>grp,
                              string_type&amp; __sym, string_type&amp; __sn,
                              int&amp; __fd);
    static void __format(char_type* __mb, char_type*&amp; __mi, char_type*&amp; __me,
                         ios_base::fmtflags __flags,
                         const char_type* __db, const char_type* __de,
                         const ctype&lt;char_type&gt;&amp; <span class="gs">__ct, bool __</span>neg,
                         const money_base::pattern&amp; __pat, char_type __dp,
                         char_type <span class="gs">__ts, const string&amp; __</span>grp,
                         const string_type&amp; __sym, const string_type&amp; __sn,
                         int __fd);
};

template &lt;class _CharT&gt;
void
__money_put&lt;_CharT&gt;::__gather_info(bool <span class="gs">__intl, bool __</span>neg, const locale&amp; __loc,
                                   money_base::pattern&amp; __pat, char_type&amp; __dp,
                                   char_type&amp; <span class="gs">__ts, string&amp; __</span>grp,
                                   string_type&amp; __sym, string_type&amp; __sn,
                                   int&amp; __fd)
{
    if (__intl)
    {
        const moneypunct&lt;char_type, true&gt;&amp; __mp =
            use_facet&lt;moneypunct&lt;char_type, true&gt; &gt;(__loc);
        if (__neg)
        {
            <span class="gs">__pat = __</span>mp.neg_format();
            <span class="gs">__sn = __</span>mp.negative_sign();
        }
        else
        {
            <span class="gs">__pat = __</span>mp.pos_format();
            <span class="gs">__sn = __</span>mp.positive_sign();
        }
        <span class="gs">__dp = __</span>mp.decimal_point();
        <span class="gs">__ts = __</span>mp.thousands_sep();
        <span class="gs">__grp = __</span>mp.grouping();
        <span class="gs">__sym = __</span>mp.curr_symbol();
        <span class="gs">__fd = __</span>mp.frac_digits();
    }
    else
    {
        const moneypunct&lt;char_type, false&gt;&amp; __mp =
            use_facet&lt;moneypunct&lt;char_type, false&gt; &gt;(__loc);
        if (__neg)
        {
            <span class="gs">__pat = __</span>mp.neg_format();
            <span class="gs">__sn = __</span>mp.negative_sign();
        }
        else
        {
            <span class="gs">__pat = __</span>mp.pos_format();
            <span class="gs">__sn = __</span>mp.positive_sign();
        }
        <span class="gs">__dp = __</span>mp.decimal_point();
        <span class="gs">__ts = __</span>mp.thousands_sep();
        <span class="gs">__grp = __</span>mp.grouping();
        <span class="gs">__sym = __</span>mp.curr_symbol();
        <span class="gs">__fd = __</span>mp.frac_digits();
    }
}

template &lt;class _CharT&gt;
void
__money_put&lt;_CharT&gt;::__format(char_type* __mb, char_type*&amp; __mi, char_type*&amp; __me,
                              ios_base::fmtflags __flags,
                              const char_type* __db, const char_type* __de,
                              const ctype&lt;char_type&gt;&amp; <span class="gs">__ct, bool __</span>neg,
                              const money_base::pattern&amp; __pat, char_type __dp,
                              char_type <span class="gs">__ts, const string&amp; __</span>grp,
                              const string_type&amp; __sym, const string_type&amp; __sn,
                              int __fd)
{
    <span class="gs">__me = __</span>mb;
    for (unsigned <span class="gs">__p = 0; __</span>p &lt; 4; ++__p)
    {
        switch (<span class="gs">__pat.field[__</span>p])
        {
        case money_base::none:
            <span class="gs">__mi = __</span>me;
            break;
        case money_base::space:
            <span class="gs">__mi = __</span>me;
            *<span class="gs">__me++ = __</span>ct.widen(&#39; &#39;);
            break;
        case money_base::sign:
            if (!__sn.empty())
                *<span class="gs">__me++ = __</span>sn[0];
            break;
        case money_base::symbol:
            if (!__sym.empty() &amp;&amp; (__flags &amp; ios_base::showbase))
                <span class="gs">__me = std::__</span>1::copy(__sym.begin(), <span class="gs">__sym.end(), __</span>me);
            break;
        case money_base::value:
            {

            char_type* <span class="gs">__t = __</span>me;

            if (__neg)
                ++__db;

            const char_type* __d;
            for (<span class="gs">__d = __</span>db; <span class="gs">__d &lt; __</span>de; ++__d)
                if (!__ct.is(ctype_base::digit, *__d))
                    break;

            if (__fd &gt; 0)
            {
                int __f;
                for (<span class="gs">__f = __</span>fd; <span class="gs">__d &gt; __</span>db &amp;&amp; <span class="gs">__f &gt; 0; --__</span>f)
                    <span class="ge">*__me++ = *</span>--__d;
                char_type <span class="gs">__z = __</span>f &gt; 0 ? __ct.widen(&#39;0&#39;) : char_type();
                for (; <span class="gs">__f &gt; 0; --__</span>f)
                    *<span class="gs">__me++ = __</span>z;
                *<span class="gs">__me++ = __</span>dp;
            }

            if (<span class="gs">__d == __</span>db)
            {
                *<span class="gs">__me++ = __</span>ct.widen(&#39;0&#39;);
            }
            else
            {
                unsigned __ng = 0;
                unsigned __ig = 0;
                unsigned <span class="gs">__gl = __</span>grp.empty() ? numeric_limits&lt;unsigned&gt;::max()
                                              : static_cast&lt;unsigned&gt;(__grp[__ig]);
                while (<span class="gs">__d != __</span>db)
                {
                    if (<span class="gs">__ng == __</span>gl)
                    {
                        *<span class="gs">__me++ = __</span>ts;
                        __ng = 0;
                        if (++__ig &lt; __grp.size())
                            <span class="gs">__gl = __</span>grp[__ig] == numeric_limits&lt;char&gt;::max() ?
                                        numeric_limits&lt;unsigned&gt;::max() :
                                        static_cast&lt;unsigned&gt;(__grp[__ig]);
                    }
                    <span class="ge">*__me++ = *</span>--__d;
                    ++__ng;
                }
            }

            reverse(__t, __me);
            }
            break;
        }
    }

    if (__sn.size() &gt; 1)
        <span class="gs">__me = std::__</span>1::copy(__sn.begin()+1, <span class="gs">__sn.end(), __</span>me);

    if ((__flags &amp; ios_base::adjustfield) == ios_base::left)
        <span class="gs">__mi = __</span>me;
    else if ((__flags &amp; ios_base::adjustfield) != ios_base::internal)
        <span class="gs">__mi = __</span>mb;
}

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __money_put&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) __money_put&lt;wchar_t&gt;;

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator = ostreambuf_iterator&lt;_CharT&gt; &gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) money_put
    : public locale::facet,
      private __money_put&lt;_CharT&gt;
{
public:
    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_OutputIterator iter_</span>type;
    typedef basic_string&lt;char_type&gt; string_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit money_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type put(iter_type <span class="gs">__s, bool __</span>intl, ios_base&amp; __iob, char_type __fl,
                  long double __units) const
    {
        return do_put(__s, <span class="gs">__intl, __</span>iob, <span class="gs">__fl, __</span>units);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    iter_type put(iter_type <span class="gs">__s, bool __</span>intl, ios_base&amp; __iob, char_type __fl,
                  const string_type&amp; __digits) const
    {
        return do_put(__s, <span class="gs">__intl, __</span>iob, <span class="gs">__fl, __</span>digits);
    }

    static locale::id id;

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~money_put() {}

    virtual iter_type do_put(iter_type <span class="gs">__s, bool __</span>intl, ios_base&amp; __iob,
                             char_type <span class="gs">__fl, long double __</span>units) const;
    virtual iter_type do_put(iter_type <span class="gs">__s, bool __</span>intl, ios_base&amp; __iob,
                             char_type __fl, const string_type&amp; __digits) const;
};

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
locale::id
money_put&lt;_CharT, _OutputIterator&gt;::id;

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
_OutputIterator
money_put&lt;_CharT, <span class="ge">_OutputIterator&gt;::do_</span>put(iter_type <span class="gs">__s, bool __</span>intl,
                                           ios_base&amp; __iob, char_type __fl,
                                           long double __units) const
{

    const size_t __bs = 100;
    char <span class="gs">__buf[__</span>bs];
    char* <span class="gs">__bb = __</span>buf;
    char_type <span class="gs">__digits[__</span>bs];
    char_type* <span class="gs">__db = __</span>digits;
    size_t __n = static_cast&lt;size_t&gt;(snprintf(__bb, <span class="gs">__bs, &quot;%.0Lf&quot;, __</span>units));
    unique_ptr&lt;char, void(*)(void*)&gt; __hn(0, free);
    unique_ptr&lt;char_type, void(*)(void*)&gt; __hd(0, free);

    if (<span class="gs">__n &gt; __</span>bs-1)
    {
        __n = static_cast&lt;size_t&gt;(asprintf_l(&amp;__bb, 0, &quot;%.0Lf&quot;, __units));
        if (__bb == 0)
            __throw_bad_alloc();
        <span class="gs">__hn.reset(__</span>bb);
        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));
        if (<span class="gs">__hd == std::__</span>1::__get_nullptr_t())
            __throw_bad_alloc();
        <span class="gs">__db = __</span>hd.get();
    }

    locale <span class="gs">__loc = __</span>iob.getloc();
    const ctype&lt;char_type&gt;&amp; __ct = use_facet&lt;ctype&lt;char_type&gt; &gt;(__loc);
    <span class="gs">__ct.widen(__</span>bb, <span class="gs">__bb + __</span>n, __db);
    bool <span class="gs">__neg = __</span>n &gt; 0 &amp;&amp; __bb[0] == &#39;-&#39;;
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this-&gt;__gather_info(__intl, <span class="gs">__neg, __</span>loc, <span class="gs">__pat, __</span>dp, <span class="gs">__ts, __</span>grp, <span class="gs">__sym, __</span>sn, __fd);

    char_type <span class="gs">__mbuf[__</span>bs];
    char_type* <span class="gs">__mb = __</span>mbuf;
    unique_ptr&lt;char_type, void(*)(void*)&gt; __hw(0, free);
    size_t __exn = static_cast&lt;int&gt;(__n) &gt; __fd ?
                   (__n - static_cast&lt;size_t&gt;(__fd)) * 2 + __sn.size() +
                    __sym.size() + static_cast&lt;size_t&gt;(__fd) + 1
                 : <span class="gs">__sn.size() + __</span>sym.size() + static_cast&lt;size_t&gt;(__fd) + 2;
    if (<span class="gs">__exn &gt; __</span>bs)
    {
        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
        <span class="gs">__mb = __</span>hw.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this-&gt;__format(__mb, <span class="gs">__mi, __</span>me, __iob.flags(),
                   <span class="gs">__db, __</span>db + <span class="gs">__n, __</span>ct,
                   <span class="gs">__neg, __</span>pat, <span class="gs">__dp, __</span>ts, <span class="gs">__grp, __</span>sym, <span class="gs">__sn, __</span>fd);
    return __pad_and_output(__s, <span class="gs">__mb, __</span>mi, <span class="gs">__me, __</span>iob, __fl);
}

template &lt;class <span class="ge">_CharT, class _</span>OutputIterator&gt;
_OutputIterator
money_put&lt;_CharT, <span class="ge">_OutputIterator&gt;::do_</span>put(iter_type <span class="gs">__s, bool __</span>intl,
                                           ios_base&amp; __iob, char_type __fl,
                                           const string_type&amp; __digits) const
{

    locale <span class="gs">__loc = __</span>iob.getloc();
    const ctype&lt;char_type&gt;&amp; __ct = use_facet&lt;ctype&lt;char_type&gt; &gt;(__loc);
    bool <span class="gs">__neg = __</span>digits.size() &gt; 0 &amp;&amp; <span class="gs">__digits[0] == __</span>ct.widen(&#39;-&#39;);
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this-&gt;__gather_info(__intl, <span class="gs">__neg, __</span>loc, <span class="gs">__pat, __</span>dp, <span class="gs">__ts, __</span>grp, <span class="gs">__sym, __</span>sn, __fd);

    char_type __mbuf[100];
    char_type* <span class="gs">__mb = __</span>mbuf;
    unique_ptr&lt;char_type, void(*)(void*)&gt; __h(0, free);
    size_t __exn = static_cast&lt;int&gt;(__digits.size()) &gt; __fd ?
                   (__digits.size() - static_cast&lt;size_t&gt;(__fd)) * 2 +
                    <span class="gs">__sn.size() + __</span>sym.size() + static_cast&lt;size_t&gt;(__fd) + 1
                 : <span class="gs">__sn.size() + __</span>sym.size() + static_cast&lt;size_t&gt;(__fd) + 2;
    if (__exn &gt; 100)
    {
        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));
        <span class="gs">__mb = __</span>h.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this-&gt;__format(__mb, <span class="gs">__mi, __</span>me, __iob.flags(),
                   <span class="gs">__digits.data(), __</span>digits.data() + <span class="gs">__digits.size(), __</span>ct,
                   <span class="gs">__neg, __</span>pat, <span class="gs">__dp, __</span>ts, <span class="gs">__grp, __</span>sym, <span class="gs">__sn, __</span>fd);
    return __pad_and_output(__s, <span class="gs">__mb, __</span>mi, <span class="gs">__me, __</span>iob, __fl);
}

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) money_put&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) money_put&lt;wchar_t&gt;;



class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) messages_base
{
public:
    typedef ptrdiff_t catalog;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) messages_base() {}
};

template &lt;class _CharT&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) messages
    : public locale::facet,
      public messages_base
{
public:
    typedef <span class="ge">_CharT char_</span>type;
    typedef basic_string&lt;_CharT&gt; string_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit messages(size_t __refs = 0)
        : locale::facet(__refs) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    catalog open(const basic_string&lt;char&gt;&amp; <span class="gs">__nm, const locale&amp; __</span>loc) const
    {
        return do_open(__nm, __loc);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    string_type get(catalog <span class="gs">__c, int __</span>set, int __msgid,
                    const string_type&amp; __dflt) const
    {
        return do_get(__c, <span class="gs">__set, __</span>msgid, __dflt);
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void close(catalog __c) const
    {
        do_close(__c);
    }

    static locale::id id;

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~messages() {}

    virtual catalog do_open(const basic_string&lt;char&gt;&amp;, const locale&amp;) const;
    virtual string_type do_get(catalog, int <span class="gs">__set, int __</span>msgid,
                               const string_type&amp; __dflt) const;
    virtual void do_close(catalog) const;
};

template &lt;class _CharT&gt;
locale::id
messages&lt;_CharT&gt;::id;

template &lt;class _CharT&gt;
typename messages&lt;_CharT&gt;::catalog
messages&lt;_CharT&gt;::do_open(const basic_string&lt;char&gt;&amp; __nm, const locale&amp;) const
{

    catalog <span class="gs">__cat = (catalog)catopen(__</span>nm.c_str(), 1);
    if (__cat != -1)
        __cat = static_cast&lt;catalog&gt;((static_cast&lt;size_t&gt;(__cat) &gt;&gt; 1));
    return __cat;




}

template &lt;class _CharT&gt;
typename messages&lt;_CharT&gt;::string_type
messages&lt;_CharT&gt;::do_get(catalog <span class="gs">__c, int __</span>set, int __msgid,
                         const string_type&amp; __dflt) const
{

    string __ndflt;
    __narrow_to_utf8&lt;sizeof(char_type)*8&gt;()(back_inserter(__ndflt),
                                                       __dflt.c_str(),
                                                       __dflt.c_str() + __dflt.size());
    if (__c != -1)
        __c &lt;&lt;= 1;
    nl_catd __cat = (nl_catd)__c;
    char* <span class="gs">__n = catgets(__</span>cat, <span class="gs">__set, __</span>msgid, __ndflt.c_str());
    string_type __w;
    __widen_from_utf8&lt;sizeof(char_type)*8&gt;()(back_inserter(__w),
                                                        <span class="gs">__n, __</span>n + strlen(__n));
    return __w;






}

template &lt;class _CharT&gt;
void
messages&lt;_CharT&gt;::do_close(catalog __c) const
{

    if (__c != -1)
        __c &lt;&lt;= 1;
    nl_catd __cat = (nl_catd)__c;
    catclose(__cat);



}

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) messages&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) messages&lt;wchar_t&gt;;

template &lt;class _CharT&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) messages_byname
    : public messages&lt;_CharT&gt;
{
public:
    typedef messages_base::catalog catalog;
    typedef basic_string&lt;_CharT&gt; string_type;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit messages_byname(const char*, size_t __refs = 0)
        : messages&lt;_CharT&gt;(__refs) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit messages_byname(const string&amp;, size_t __refs = 0)
        : messages&lt;_CharT&gt;(__refs) {}

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    ~messages_byname() {}
};

extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) messages_byname&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) messages_byname&lt;wchar_t&gt;;

template&lt;class <span class="ge">_Codecvt, class _</span>Elem = wchar_t,
         class <span class="ge">_Wide_</span>alloc = allocator&lt;_Elem&gt;,
         class <span class="ge">_Byte_</span>alloc = allocator&lt;char&gt; &gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) wstring_convert
{
public:
    typedef basic_string&lt;char, char_traits&lt;char&gt;, <span class="ge">_Byte_</span>alloc&gt; byte_string;
    typedef basic_string&lt;_Elem, char_traits&lt;_Elem&gt;, <span class="ge">_Wide_</span>alloc&gt; wide_string;
    typedef typename <span class="ge">_Codecvt::state_</span>type state_type;
    typedef typename wide_string::traits_type::int_type int_type;

private:
    byte_string __byte_err_string_;
    wide_string __wide_err_string_;
    <span class="ge">_Codecvt* __cvtptr_</span>;
    state_type __cvtstate_;
    size_t __cvtcount_;

    wstring_convert(const wstring_convert&amp; __wc);
    wstring_convert&amp; operator=(const wstring_convert&amp; __wc);
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                                 wstring_convert(_Codecvt* __pcvt = new _Codecvt);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    wstring_convert(_Codecvt* __pcvt, state_type __state);
                                 wstring_convert(const byte_string&amp; __byte_err,
                    const wide_string&amp; __wide_err = wide_string());




    ~wstring_convert();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    wide_string from_bytes(char __byte)
        {return from_bytes(&amp;__byte, &amp;__byte+1);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    wide_string from_bytes(const char* __ptr)
        {return from_bytes(__ptr, __ptr + char_traits&lt;char&gt;::length(__ptr));}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    wide_string from_bytes(const byte_string&amp; __str)
        {return from_bytes(__str.data(), <span class="gs">__str.data() + __</span>str.size());}
    wide_string from_bytes(const char* <span class="gs">__first, const char* __</span>last);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    byte_string to_bytes(_Elem __wchar)
        {return to_bytes(&amp;__wchar, &amp;__wchar+1);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    byte_string to_bytes(const <span class="ge">_Elem* _</span>_wptr)
        {return to_bytes(__wptr, __wptr + char_traits&lt;_Elem&gt;::length(__wptr));}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    byte_string to_bytes(const wide_string&amp; __wstr)
        {return to_bytes(__wstr.data(), <span class="gs">__wstr.data() + __</span>wstr.size());}
    byte_string to_bytes(const <span class="ge">_Elem* __first, const _</span>Elem* __last);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t converted() const throw() {return __cvtcount_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    state_type state() const {return __cvtstate_;}
};

template&lt;class <span class="ge">_Codecvt, class _</span>Elem, class <span class="ge">_Wide_</span>alloc, class <span class="ge">_Byte_</span>alloc&gt;
inline
wstring_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Wide_alloc, <span class="ge">_Byte_</span>alloc&gt;::
    wstring_convert(_Codecvt* __pcvt)
        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)
{
}

template&lt;class <span class="ge">_Codecvt, class _</span>Elem, class <span class="ge">_Wide_</span>alloc, class <span class="ge">_Byte_</span>alloc&gt;
inline
wstring_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Wide_alloc, <span class="ge">_Byte_</span>alloc&gt;::
    wstring_convert(_Codecvt* __pcvt, state_type __state)
        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)
{
}

template&lt;class <span class="ge">_Codecvt, class _</span>Elem, class <span class="ge">_Wide_</span>alloc, class <span class="ge">_Byte_</span>alloc&gt;
wstring_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Wide_alloc, <span class="ge">_Byte_</span>alloc&gt;::
    wstring_convert(const byte_string&amp; __byte_err, const wide_string&amp; __wide_err)
        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),
          __cvtstate_(), __cvtcount_(0)
{
    __cvtptr_ = new _Codecvt;
}
template&lt;class <span class="ge">_Codecvt, class _</span>Elem, class <span class="ge">_Wide_</span>alloc, class <span class="ge">_Byte_</span>alloc&gt;
wstring_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Wide_alloc, <span class="ge">_Byte_</span>alloc&gt;::~wstring_convert()
{
    delete __cvtptr_;
}

template&lt;class <span class="ge">_Codecvt, class _</span>Elem, class <span class="ge">_Wide_</span>alloc, class <span class="ge">_Byte_</span>alloc&gt;
typename wstring_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Wide_alloc, <span class="ge">_Byte_</span>alloc&gt;::wide_string
wstring_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Wide_alloc, <span class="ge">_Byte_</span>alloc&gt;::
    from_bytes(const char* <span class="gs">__frm, const char* __</span>frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != std::__1::__get_nullptr_t())
    {
        wide_string <span class="gs">__ws(2*(__</span>frm_end - __frm), _Elem());
        if (<span class="gs">__frm != __</span>frm_end)
            <span class="gs">__ws.resize(__</span>ws.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type <span class="gs">__st = __</span>cvtstate_;
        if (<span class="gs">__frm != __</span>frm_end)
        {
            <span class="ge">_Elem* __to = &amp;_</span>_ws[0];
            <span class="ge">_Elem* __to_</span>end = <span class="gs">__to + __</span>ws.size();
            const char* __frm_nxt;
            do
            {
                <span class="ge">_Elem* __to_</span>nxt;
                <span class="gs">__r = __</span>cvtptr_-&gt;in(__st, <span class="gs">__frm, __</span>frm_end, __frm_nxt,
                                          <span class="gs">__to, __</span>to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    <span class="gs">__ws.resize(__</span>to - &amp;__ws[0]);

                    __ws.append((const <span class="ge">_Elem*)__frm, (const _</span>Elem*)__frm_end);
                    <span class="gs">__frm = __</span>frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    <span class="gs">__ws.resize(__</span>to_nxt - &amp;__ws[0]);
                    <span class="gs">__frm = __</span>frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t <span class="gs">__s = __</span>to_nxt - &amp;__ws[0];
                    <span class="gs">__ws.resize(2 * __</span>s);
                    <span class="gs">__to = &amp;__</span>ws[0] + __s;
                    __to_end = &amp;<span class="gs">__ws[0] + __</span>ws.size();
                    <span class="gs">__frm = __</span>frm_nxt;
                }
            } while (__r == codecvt_base::partial &amp;&amp; __frm_nxt &lt; __frm_end);
        }
        if (__r == codecvt_base::ok)
            return __ws;
    }

    if (__wide_err_string_.empty())
        __throw_range_error(&quot;wstring_convert: from_bytes error&quot;);

    return __wide_err_string_;
}

template&lt;class <span class="ge">_Codecvt, class _</span>Elem, class <span class="ge">_Wide_</span>alloc, class <span class="ge">_Byte_</span>alloc&gt;
typename wstring_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Wide_alloc, <span class="ge">_Byte_</span>alloc&gt;::byte_string
wstring_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Wide_alloc, <span class="ge">_Byte_</span>alloc&gt;::
    to_bytes(const <span class="ge">_Elem* __frm, const _</span>Elem* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != std::__1::__get_nullptr_t())
    {
        byte_string <span class="gs">__bs(2*(__</span>frm_end - __frm), char());
        if (<span class="gs">__frm != __</span>frm_end)
            <span class="gs">__bs.resize(__</span>bs.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type <span class="gs">__st = __</span>cvtstate_;
        if (<span class="gs">__frm != __</span>frm_end)
        {
            char* <span class="gs">__to = &amp;__</span>bs[0];
            char* __to_end = <span class="gs">__to + __</span>bs.size();
            const <span class="ge">_Elem* __frm_</span>nxt;
            do
            {
                char* __to_nxt;
                <span class="gs">__r = __</span>cvtptr_-&gt;out(__st, <span class="gs">__frm, __</span>frm_end, __frm_nxt,
                                           <span class="gs">__to, __</span>to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    <span class="gs">__bs.resize(__</span>to - &amp;__bs[0]);

                    <span class="gs">__bs.append((const char*)__</span>frm, (const char*)__frm_end);
                    <span class="gs">__frm = __</span>frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    <span class="gs">__bs.resize(__</span>to_nxt - &amp;__bs[0]);
                    <span class="gs">__frm = __</span>frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t <span class="gs">__s = __</span>to_nxt - &amp;__bs[0];
                    <span class="gs">__bs.resize(2 * __</span>s);
                    <span class="gs">__to = &amp;__</span>bs[0] + __s;
                    __to_end = &amp;<span class="gs">__bs[0] + __</span>bs.size();
                    <span class="gs">__frm = __</span>frm_nxt;
                }
            } while (__r == codecvt_base::partial &amp;&amp; __frm_nxt &lt; __frm_end);
        }
        if (__r == codecvt_base::ok)
        {
            size_t <span class="gs">__s = __</span>bs.size();
            <span class="gs">__bs.resize(__</span>bs.capacity());
            char* <span class="gs">__to = &amp;__</span>bs[0] + __s;
            char* __to_end = <span class="gs">__to + __</span>bs.size();
            do
            {
                char* __to_nxt;
                <span class="gs">__r = __</span>cvtptr_-&gt;unshift(__st, <span class="gs">__to, __</span>to_end, __to_nxt);
                if (__r == codecvt_base::noconv)
                {
                    <span class="gs">__bs.resize(__</span>to - &amp;__bs[0]);
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    <span class="gs">__bs.resize(__</span>to_nxt - &amp;__bs[0]);
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t <span class="gs">__sp = __</span>to_nxt - &amp;__bs[0];
                    <span class="gs">__bs.resize(2 * __</span>sp);
                    <span class="gs">__to = &amp;__</span>bs[0] + __sp;
                    __to_end = &amp;<span class="gs">__bs[0] + __</span>bs.size();
                }
            } while (__r == codecvt_base::partial);
            if (__r == codecvt_base::ok)
                return __bs;
        }
    }

    if (__byte_err_string_.empty())
        __throw_range_error(&quot;wstring_convert: to_bytes error&quot;);

    return __byte_err_string_;
}

template &lt;class <span class="ge">_Codecvt, class _</span>Elem = wchar_t, class <span class="ge">_Tr = char_</span>traits&lt;_Elem&gt; &gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) wbuffer_convert
    : public basic_streambuf&lt;_Elem, _Tr&gt;
{
public:

    typedef <span class="ge">_Elem char_</span>type;
    typedef <span class="ge">_Tr traits_</span>type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename <span class="ge">_Codecvt::state_</span>type state_type;

private:
    char* __extbuf_;
    const char* __extbufnext_;
    const char* __extbufend_;
    char __extbuf_min_[8];
    size_t __ebs_;
    char_type* __intbuf_;
    size_t __ibs_;
    streambuf* __bufptr_;
    <span class="ge">_Codecvt* __cv_</span>;
    state_type __st_;
    ios_base::openmode __cm_;
    bool __owns_eb_;
    bool __owns_ib_;
    bool __always_noconv_;

    wbuffer_convert(const wbuffer_convert&amp;);
    wbuffer_convert&amp; operator=(const wbuffer_convert&amp;);
public:
                                 wbuffer_convert(streambuf* __bytebuf = 0,
            <span class="ge">_Codecvt* __pcvt = new _</span>Codecvt, state_type __state = state_type());
    ~wbuffer_convert();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    streambuf* rdbuf() const {return __bufptr_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    streambuf* rdbuf(streambuf* __bytebuf)
    {
        streambuf* <span class="gs">__r = __</span>bufptr_;
        __bufptr_ = __bytebuf;
        return __r;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    state_type state() const {return __st_;}

protected:
    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow (int_type __c = traits_type::eof());
    virtual basic_streambuf&lt;char_type, traits_type&gt;* setbuf(char_type* __s,
                                                            streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual int sync();

private:
    bool __read_mode();
    void __write_mode();
    wbuffer_convert* __close();
};

template &lt;class <span class="ge">_Codecvt, class _</span>Elem, class _Tr&gt;
wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::
    wbuffer_convert(streambuf* __bytebuf, <span class="ge">_Codecvt* __pcvt, state_</span>type __state)
    : __extbuf_(0),
      __extbufnext_(0),
      __extbufend_(0),
      __ebs_(0),
      __intbuf_(0),
      __ibs_(0),
      __bufptr_(__bytebuf),
      __cv_(__pcvt),
      __st_(__state),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(__cv_ ? __cv_-&gt;always_noconv() : false)
{
    setbuf(0, 4096);
}

template &lt;class <span class="ge">_Codecvt, class _</span>Elem, class _Tr&gt;
wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::~wbuffer_convert()
{
    __close();
    delete __cv_;
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
}

template &lt;class <span class="ge">_Codecvt, class _</span>Elem, class _Tr&gt;
typename wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::int_type
wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::underflow()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    bool <span class="gs">__initial = __</span>read_mode();
    char_type __1buf;
    if (this-&gt;gptr() == 0)
        this-&gt;setg(&amp;__1buf, &amp;<span class="gs">__1buf+1, &amp;__</span>1buf+1);
    const size_t __unget_sz = __initial ? 0 : min&lt;size_t&gt;((this-&gt;egptr() - this-&gt;eback()) / 2, 4);
    int_type __c = traits_type::eof();
    if (this-&gt;gptr() == this-&gt;egptr())
    {
        memmove(this-&gt;eback(), this-&gt;egptr() - __unget_sz, __unget_sz * sizeof(char_type));
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast&lt;streamsize&gt;(this-&gt;egptr() - this-&gt;eback() - __unget_sz);
            <span class="gs">__nmemb = __</span>bufptr_-&gt;sgetn((char*)this-&gt;eback() + __unget_sz, __nmemb);
            if (__nmemb != 0)
            {
                this-&gt;setg(this-&gt;eback(),
                           this-&gt;eback() + __unget_sz,
                           this-&gt;eback() + __unget_sz + __nmemb);
                __c = *this-&gt;gptr();
            }
        }
        else
        {
             ((void)0);
             if (__extbufend_ != __extbufnext_)
                memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
            streamsize <span class="gs">__nmemb = std::__</span>1::min(static_cast&lt;streamsize&gt;(this-&gt;egptr() - this-&gt;eback() - __unget_sz),
                                 static_cast&lt;streamsize&gt;(__extbufend_ - __extbufnext_));
            codecvt_base::result __r;


            streamsize <span class="gs">__nr = __</span>bufptr_-&gt;sgetn(const_cast&lt;char*&gt;(__extbufnext_), __nmemb);
            if (__nr != 0)
            {
                __extbufend_ = __extbufnext_ + __nr;
                char_type* __inext;
                <span class="gs">__r = __</span>cv_-&gt;in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                                       this-&gt;eback() + __unget_sz,
                                       this-&gt;egptr(), __inext);
                if (__r == codecvt_base::noconv)
                {
                    this-&gt;setg((char_type*)__extbuf_, (char_type*)__extbuf_,
                               (char_type*) const_cast&lt;char *&gt;(__extbufend_));
                    __c = *this-&gt;gptr();
                }
                else if (<span class="gs">__inext != this-&gt;eback() + __</span>unget_sz)
                {
                    this-&gt;setg(this-&gt;eback(), this-&gt;eback() + __unget_sz, __inext);
                    __c = *this-&gt;gptr();
                }
            }
        }
    }
    else
        __c = *this-&gt;gptr();
    if (this-&gt;eback() == &amp;__1buf)
        this-&gt;setg(0, 0, 0);
    return __c;
}

template &lt;class <span class="ge">_Codecvt, class _</span>Elem, class _Tr&gt;
typename wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::int_type
wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::pbackfail(int_type __c)
{
    if (__cv_ != 0 &amp;&amp; __bufptr_ != 0 &amp;&amp; this-&gt;eback() &lt; this-&gt;gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this-&gt;gbump(-1);
            return traits_type::not_eof(__c);
        }
        if (traits_type::eq(traits_type::to_char_type(__c), this-&gt;gptr()[-1]))
        {
            this-&gt;gbump(-1);
            *this-&gt;gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

template &lt;class <span class="ge">_Codecvt, class _</span>Elem, class _Tr&gt;
typename wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::int_type
wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::overflow(int_type __c)
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    __write_mode();
    char_type __1buf;
    char_type* __pb_save = this-&gt;pbase();
    char_type* __epb_save = this-&gt;epptr();
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        if (this-&gt;pptr() == 0)
            this-&gt;setp(&amp;__1buf, &amp;__1buf+1);
        *this-&gt;pptr() = traits_type::to_char_type(__c);
        this-&gt;pbump(1);
    }
    if (this-&gt;pptr() != this-&gt;pbase())
    {
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast&lt;streamsize&gt;(this-&gt;pptr() - this-&gt;pbase());
            if (__bufptr_-&gt;sputn((const char*)this-&gt;pbase(), <span class="gs">__nmemb) != __</span>nmemb)
                return traits_type::eof();
        }
        else
        {
            char* <span class="gs">__extbe = __</span>extbuf_;
            codecvt_base::result __r;
            do
            {
                const char_type* __e;
                <span class="gs">__r = __</span>cv_-&gt;out(__st_, this-&gt;pbase(), this-&gt;pptr(), __e,
                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
                if (__e == this-&gt;pbase())
                    return traits_type::eof();
                if (__r == codecvt_base::noconv)
                {
                    streamsize __nmemb = static_cast&lt;size_t&gt;(this-&gt;pptr() - this-&gt;pbase());
                    if (__bufptr_-&gt;sputn((const char*)this-&gt;pbase(), <span class="gs">__nmemb) != __</span>nmemb)
                        return traits_type::eof();
                }
                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
                {
                    streamsize __nmemb = static_cast&lt;size_t&gt;(__extbe - __extbuf_);
                    if (__bufptr_-&gt;sputn(__extbuf_, <span class="gs">__nmemb) != __</span>nmemb)
                        return traits_type::eof();
                    if (__r == codecvt_base::partial)
                    {
                        this-&gt;setp(const_cast&lt;char_type *&gt;(__e), this-&gt;pptr());
                        this-&gt;__pbump(this-&gt;epptr() - this-&gt;pbase());
                    }
                }
                else
                    return traits_type::eof();
            } while (__r == codecvt_base::partial);
        }
        this-&gt;setp(__pb_save, __epb_save);
    }
    return traits_type::not_eof(__c);
}

template &lt;class <span class="ge">_Codecvt, class _</span>Elem, class _Tr&gt;
basic_streambuf&lt;_Elem, _Tr&gt;*
wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::setbuf(char_type* <span class="gs">__s, streamsize __</span>n)
{
    this-&gt;setg(0, 0, 0);
    this-&gt;setp(0, 0);
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
    __ebs_ = __n;
    if (__ebs_ &gt; sizeof(__extbuf_min_))
    {
        if (__always_noconv_ &amp;&amp; __s)
        {
            __extbuf_ = (char*)__s;
            __owns_eb_ = false;
        }
        else
        {
            __extbuf_ = new char[__ebs_];
            __owns_eb_ = true;
        }
    }
    else
    {
        __extbuf_ = __extbuf_min_;
        __ebs_ = sizeof(__extbuf_min_);
        __owns_eb_ = false;
    }
    if (!__always_noconv_)
    {
        __ibs_ = max&lt;streamsize&gt;(__n, sizeof(__extbuf_min_));
        if (<span class="gs">__s &amp;&amp; __</span>ibs_ &gt;= sizeof(__extbuf_min_))
        {
            __intbuf_ = __s;
            __owns_ib_ = false;
        }
        else
        {
            __intbuf_ = new char_type[__ibs_];
            __owns_ib_ = true;
        }
    }
    else
    {
        __ibs_ = 0;
        __intbuf_ = 0;
        __owns_ib_ = false;
    }
    return this;
}

template &lt;class <span class="ge">_Codecvt, class _</span>Elem, class _Tr&gt;
typename wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::pos_type
wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::seekoff(off_type __off, ios_base::seekdir __way,
                                        ios_base::openmode __om)
{
    int <span class="gs">__width = __</span>cv_-&gt;encoding();
    if (__cv_ == 0 || __bufptr_ == 0 || (<span class="gs">__width &lt;= 0 &amp;&amp; __</span>off != 0) || sync())
        return pos_type(off_type(-1));

    if (__way != ios_base::beg &amp;&amp; __way != ios_base::cur &amp;&amp; __way != ios_base::end)
        return pos_type(off_type(-1));
    pos_type <span class="gs">__r = __</span>bufptr_-&gt;pubseekoff(__width * <span class="gs">__off, __</span>way, __om);
    <span class="gs">__r.state(__</span>st_);
    return __r;
}

template &lt;class <span class="ge">_Codecvt, class _</span>Elem, class _Tr&gt;
typename wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::pos_type
wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::seekpos(pos_type __sp, ios_base::openmode __wch)
{
    if (__cv_ == 0 || __bufptr_ == 0 || sync())
        return pos_type(off_type(-1));
    if (__bufptr_-&gt;pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
        return pos_type(off_type(-1));
    return __sp;
}

template &lt;class <span class="ge">_Codecvt, class _</span>Elem, class _Tr&gt;
int
wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::sync()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return 0;
    if (__cm_ &amp; ios_base::out)
    {
        if (this-&gt;pptr() != this-&gt;pbase())
            if (overflow() == traits_type::eof())
                return -1;
        codecvt_base::result __r;
        do
        {
            char* __extbe;
            <span class="gs">__r = __</span>cv_-&gt;unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
            streamsize __nmemb = static_cast&lt;streamsize&gt;(__extbe - __extbuf_);
            if (__bufptr_-&gt;sputn(__extbuf_, <span class="gs">__nmemb) != __</span>nmemb)
                return -1;
        } while (__r == codecvt_base::partial);
        if (__r == codecvt_base::error)
            return -1;
        if (__bufptr_-&gt;pubsync())
            return -1;
    }
    else if (__cm_ &amp; ios_base::in)
    {
        off_type __c;
        if (__always_noconv_)
            __c = this-&gt;egptr() - this-&gt;gptr();
        else
        {
            int <span class="gs">__width = __</span>cv_-&gt;encoding();
            <span class="gs">__c = __</span>extbufend_ - __extbufnext_;
            if (__width &gt; 0)
                <span class="gs">__c += __</span>width * (this-&gt;egptr() - this-&gt;gptr());
            else
            {
                if (this-&gt;gptr() != this-&gt;egptr())
                {
                    reverse(this-&gt;gptr(), this-&gt;egptr());
                    codecvt_base::result __r;
                    const char_type* __e = this-&gt;gptr();
                    char* __extbe;
                    do
                    {
                        <span class="gs">__r = __</span>cv_-&gt;out(__st_, <span class="gs">__e, this-&gt;egptr(), __</span>e,
                                         __extbuf_, __extbuf_ + __ebs_, __extbe);
                        switch (__r)
                        {
                        case codecvt_base::noconv:
                            __c += this-&gt;egptr() - this-&gt;gptr();
                            break;
                        case codecvt_base::ok:
                        case codecvt_base::partial:
                            <span class="gs">__c += __</span>extbe - __extbuf_;
                            break;
                        default:
                            return -1;
                        }
                    } while (__r == codecvt_base::partial);
                }
            }
        }
        if (__bufptr_-&gt;pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
            return -1;
        this-&gt;setg(0, 0, 0);
        __cm_ = 0;
    }
    return 0;
}

template &lt;class <span class="ge">_Codecvt, class _</span>Elem, class _Tr&gt;
bool
wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::__read_mode()
{
    if (!(__cm_ &amp; ios_base::in))
    {
        this-&gt;setp(0, 0);
        if (__always_noconv_)
            this-&gt;setg((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + __ebs_,
                       (char_type*)__extbuf_ + __ebs_);
        else
            this-&gt;setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
        __cm_ = ios_base::in;
        return true;
    }
    return false;
}

template &lt;class <span class="ge">_Codecvt, class _</span>Elem, class _Tr&gt;
void
wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::__write_mode()
{
    if (!(__cm_ &amp; ios_base::out))
    {
        this-&gt;setg(0, 0, 0);
        if (__ebs_ &gt; sizeof(__extbuf_min_))
        {
            if (__always_noconv_)
                this-&gt;setp((char_type*)__extbuf_,
                           (char_type*)__extbuf_ + (__ebs_ - 1));
            else
                this-&gt;setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
        }
        else
            this-&gt;setp(0, 0);
        __cm_ = ios_base::out;
    }
}

template &lt;class <span class="ge">_Codecvt, class _</span>Elem, class _Tr&gt;
wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;*
wbuffer_convert&lt;_Codecvt, <span class="ge">_Elem, _</span>Tr&gt;::__close()
{
    wbuffer_convert* __rt = 0;
    if (__cv_ != 0 &amp;&amp; __bufptr_ != 0)
    {
        __rt = this;
        if ((__cm_ &amp; ios_base::out) &amp;&amp; sync())
            __rt = 0;
    }
    return __rt;
}

} }






namespace std { inline namespace __1 {

template &lt;class <span class="ge">_Cp, bool _</span>IsConst, typename <span class="ge">_Cp::__storage_</span>type = 0&gt; class __bit_iterator;
template &lt;class <span class="ge">_Cp&gt; class __bit_</span>const_reference;

template &lt;class _Tp&gt;
struct __has_storage_type
{
    static const bool value = false;
};

template &lt;class <span class="ge">_Cp, bool = __has_</span>storage_type&lt;_Cp&gt;::value&gt;
class __bit_reference
{
    typedef typename <span class="ge">_Cp::__storage_</span>type __storage_type;
    typedef typename <span class="ge">_Cp::__storage_</span>pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;

    friend typename <span class="ge">_Cp::_</span>_self;

    friend class __bit_const_reference&lt;_Cp&gt;;
    friend class __bit_iterator&lt;_Cp, false&gt;;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __bit_reference(const __bit_reference&amp;) = default;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) operator bool() const throw()
        {return static_cast&lt;bool&gt;(*__seg_ &amp; __mask_);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool operator ~() const throw()
        {return !static_cast&lt;bool&gt;(*this);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __bit_reference&amp; operator=(bool __x) throw()
    {
        if (__x)
            *__seg_ |= __mask_;
        else
            *__seg_ &amp;= ~__mask_;
        return *this;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __bit_reference&amp; operator=(const __bit_reference&amp; __x) throw()
        {return operator=(static_cast&lt;bool&gt;(__x));}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void flip() throw() {*__seg_ ^= __mask_;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __bit_iterator&lt;_Cp, false&gt; operator&amp;() const throw()
        {return __bit_iterator&lt;_Cp, false&gt;(__seg_, static_cast&lt;unsigned&gt;(__libcpp_ctz(__mask_)));}
private:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __bit_reference(__storage_pointer <span class="gs">__s, __</span>storage_type __m) throw()
        : __seg_(__s), __mask_(__m) {}
};

template &lt;class _Cp&gt;
class __bit_reference&lt;_Cp, false&gt;
{
};

template &lt;class _Cp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
swap(__bit_reference&lt;_Cp&gt; <span class="gs">__x, __</span>bit_reference&lt;_Cp&gt; __y) throw()
{
    bool <span class="gs">__t = __</span>x;
    <span class="gs">__x = __</span>y;
    <span class="gs">__y = __</span>t;
}

template &lt;class <span class="ge">_Cp, class _</span>Dp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
swap(__bit_reference&lt;_Cp&gt; <span class="gs">__x, __</span>bit_reference&lt;_Dp&gt; __y) throw()
{
    bool <span class="gs">__t = __</span>x;
    <span class="gs">__x = __</span>y;
    <span class="gs">__y = __</span>t;
}

template &lt;class _Cp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
swap(__bit_reference&lt;_Cp&gt; <span class="gs">__x, bool&amp; __</span>y) throw()
{
    bool <span class="gs">__t = __</span>x;
    <span class="gs">__x = __</span>y;
    <span class="gs">__y = __</span>t;
}

template &lt;class _Cp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
swap(bool&amp; <span class="gs">__x, __</span>bit_reference&lt;_Cp&gt; __y) throw()
{
    bool <span class="gs">__t = __</span>x;
    <span class="gs">__x = __</span>y;
    <span class="gs">__y = __</span>t;
}

template &lt;class _Cp&gt;
class __bit_const_reference
{
    typedef typename <span class="ge">_Cp::__storage_</span>type __storage_type;
    typedef typename <span class="ge">_Cp::__const_</span>storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;

    friend typename <span class="ge">_Cp::_</span>_self;
    friend class __bit_iterator&lt;_Cp, true&gt;;
public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __bit_const_reference(const __bit_const_reference&amp;) = default;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __bit_const_reference(const __bit_reference&lt;_Cp&gt;&amp; __x) throw()
        : __seg_(__x.__seg_), __mask_(__x.__mask_) {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) operator bool() const throw()
        {return static_cast&lt;bool&gt;(*__seg_ &amp; __mask_);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __bit_iterator&lt;_Cp, true&gt; operator&amp;() const throw()
        {return __bit_iterator&lt;_Cp, true&gt;(__seg_, static_cast&lt;unsigned&gt;(__libcpp_ctz(__mask_)));}
private:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

    __bit_const_reference(__storage_pointer <span class="gs">__s, __</span>storage_type __m) throw()
        : __seg_(__s), __mask_(__m) {}

    __bit_const_reference&amp; operator=(const __bit_const_reference&amp;) = delete;
};



template &lt;class <span class="ge">_Cp, bool _</span>IsConst&gt;
__bit_iterator&lt;_Cp, _IsConst&gt;
__find_bool_true(__bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; __first, typename _</span>Cp::size_type __n)
{
    typedef __bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; _</span>It;
    typedef typename <span class="ge">_It::__storage_</span>type __storage_type;
    static const int __bits_per_word = <span class="ge">_It::__bits_</span>per_word;

    if (<span class="gs">__first.__</span>ctz_ != 0)
    {
        __storage_type __clz_f = static_cast&lt;__storage_type&gt;(__bits_per_word - <span class="gs">__first.__</span>ctz_);
        __storage_type <span class="gs">__dn = std::__</span>1::min(__clz_f, __n);
        __storage_type <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__first.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_f - __dn));
        __storage_type <span class="gs">__b = *__</span>first.__seg_ &amp; __m;
        if (__b)
            return <span class="ge">_It(__first.__seg_</span>, static_cast&lt;unsigned&gt;(std::__1::__libcpp_ctz(__b)));
        if (<span class="gs">__n == __</span>dn)
            return <span class="gs">__first + __</span>n;
        <span class="gs">__n -= __</span>dn;
        ++__first.__seg_;
    }

    for (; <span class="gs">__n &gt;= __</span>bits_per_word; ++__first.__seg_, <span class="gs">__n -= __</span>bits_per_word)
        if (*__first.__seg_)
            return <span class="ge">_It(__first.__seg_</span>, static_cast&lt;unsigned&gt;(std::__1::__libcpp_ctz(*__first.__seg_)));

    if (__n &gt; 0)
    {
        __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
        __storage_type <span class="gs">__b = *__</span>first.__seg_ &amp; __m;
        if (__b)
            return <span class="ge">_It(__first.__seg_</span>, static_cast&lt;unsigned&gt;(std::__1::__libcpp_ctz(__b)));
    }
    return <span class="ge">_It(__first.__seg_</span>, static_cast&lt;unsigned&gt;(__n));
}

template &lt;class <span class="ge">_Cp, bool _</span>IsConst&gt;
__bit_iterator&lt;_Cp, _IsConst&gt;
__find_bool_false(__bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; __first, typename _</span>Cp::size_type __n)
{
    typedef __bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; _</span>It;
    typedef typename <span class="ge">_It::__storage_</span>type __storage_type;
    const int __bits_per_word = <span class="ge">_It::__bits_</span>per_word;

    if (<span class="gs">__first.__</span>ctz_ != 0)
    {
        __storage_type __clz_f = static_cast&lt;__storage_type&gt;(__bits_per_word - <span class="gs">__first.__</span>ctz_);
        __storage_type <span class="gs">__dn = std::__</span>1::min(__clz_f, __n);
        __storage_type <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__first.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_f - __dn));
        __storage_type <span class="gs">__b = ~*__</span>first.__seg_ &amp; __m;
        if (__b)
            return <span class="ge">_It(__first.__seg_</span>, static_cast&lt;unsigned&gt;(std::__1::__libcpp_ctz(__b)));
        if (<span class="gs">__n == __</span>dn)
            return <span class="gs">__first + __</span>n;
        <span class="gs">__n -= __</span>dn;
        ++__first.__seg_;
    }

    for (; <span class="gs">__n &gt;= __</span>bits_per_word; ++__first.__seg_, <span class="gs">__n -= __</span>bits_per_word)
    {
        __storage_type <span class="gs">__b = ~*__</span>first.__seg_;
        if (__b)
            return <span class="ge">_It(__first.__seg_</span>, static_cast&lt;unsigned&gt;(std::__1::__libcpp_ctz(__b)));
    }

    if (__n &gt; 0)
    {
        __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
        __storage_type <span class="gs">__b = ~*__</span>first.__seg_ &amp; __m;
        if (__b)
            return <span class="ge">_It(__first.__seg_</span>, static_cast&lt;unsigned&gt;(std::__1::__libcpp_ctz(__b)));
    }
    return <span class="ge">_It(__first.__seg_</span>, static_cast&lt;unsigned&gt;(__n));
}

template &lt;class <span class="ge">_Cp, bool _</span>IsConst, class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__bit_iterator&lt;_Cp, _IsConst&gt;
find(__bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; __first, __bit_</span>iterator&lt;_Cp, <span class="ge">_IsConst&gt; __last, const _</span>Tp&amp; __value_)
{
    if (static_cast&lt;bool&gt;(__value_))
        return __find_bool_true(__first, static_cast&lt;typename <span class="ge">_Cp::size_</span>type&gt;(__last - __first));
    return __find_bool_false(__first, static_cast&lt;typename <span class="ge">_Cp::size_</span>type&gt;(__last - __first));
}



template &lt;class <span class="ge">_Cp, bool _</span>IsConst&gt;
typename __bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt;::difference_</span>type
__count_bool_true(__bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; __first, typename _</span>Cp::size_type __n)
{
    typedef __bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; _</span>It;
    typedef typename <span class="ge">_It::__storage_</span>type __storage_type;
    typedef typename <span class="ge">_It::difference_</span>type difference_type;
    const int __bits_per_word = <span class="ge">_It::__bits_</span>per_word;
    difference_type __r = 0;

    if (<span class="gs">__first.__</span>ctz_ != 0)
    {
        __storage_type __clz_f = static_cast&lt;__storage_type&gt;(__bits_per_word - <span class="gs">__first.__</span>ctz_);
        __storage_type <span class="gs">__dn = std::__</span>1::min(__clz_f, __n);
        __storage_type <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__first.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_f - __dn));
        <span class="gs">__r = std::__</span>1::__libcpp_popcount(*__first.__seg_ &amp; __m);
        <span class="gs">__n -= __</span>dn;
        ++__first.__seg_;
    }

    for (; <span class="gs">__n &gt;= __</span>bits_per_word; ++__first.__seg_, <span class="gs">__n -= __</span>bits_per_word)
        <span class="gs">__r += std::__</span>1::__libcpp_popcount(*__first.__seg_);

    if (__n &gt; 0)
    {
        __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
        <span class="gs">__r += std::__</span>1::__libcpp_popcount(*__first.__seg_ &amp; __m);
    }
    return __r;
}

template &lt;class <span class="ge">_Cp, bool _</span>IsConst&gt;
typename __bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt;::difference_</span>type
__count_bool_false(__bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; __first, typename _</span>Cp::size_type __n)
{
    typedef __bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; _</span>It;
    typedef typename <span class="ge">_It::__storage_</span>type __storage_type;
    typedef typename <span class="ge">_It::difference_</span>type difference_type;
    const int __bits_per_word = <span class="ge">_It::__bits_</span>per_word;
    difference_type __r = 0;

    if (<span class="gs">__first.__</span>ctz_ != 0)
    {
        __storage_type __clz_f = static_cast&lt;__storage_type&gt;(__bits_per_word - <span class="gs">__first.__</span>ctz_);
        __storage_type <span class="gs">__dn = std::__</span>1::min(__clz_f, __n);
        __storage_type <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__first.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_f - __dn));
        <span class="gs">__r = std::__</span>1::__libcpp_popcount(~*__first.__seg_ &amp; __m);
        <span class="gs">__n -= __</span>dn;
        ++__first.__seg_;
    }

    for (; <span class="gs">__n &gt;= __</span>bits_per_word; ++__first.__seg_, <span class="gs">__n -= __</span>bits_per_word)
        <span class="gs">__r += std::__</span>1::__libcpp_popcount(~*__first.__seg_);

    if (__n &gt; 0)
    {
        __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
        <span class="gs">__r += std::__</span>1::__libcpp_popcount(~*__first.__seg_ &amp; __m);
    }
    return __r;
}

template &lt;class <span class="ge">_Cp, bool _</span>IsConst, class _Tp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename __bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt;::difference_</span>type
count(__bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; __first, __bit_</span>iterator&lt;_Cp, <span class="ge">_IsConst&gt; __last, const _</span>Tp&amp; __value_)
{
    if (static_cast&lt;bool&gt;(__value_))
        return __count_bool_true(__first, static_cast&lt;typename <span class="ge">_Cp::size_</span>type&gt;(__last - __first));
    return __count_bool_false(__first, static_cast&lt;typename <span class="ge">_Cp::size_</span>type&gt;(__last - __first));
}



template &lt;class _Cp&gt;
void
__fill_n_false(__bit_iterator&lt;_Cp, false&gt; __first, typename <span class="ge">_Cp::size_</span>type __n)
{
    typedef __bit_iterator&lt;_Cp, false&gt; _It;
    typedef typename <span class="ge">_It::__storage_</span>type __storage_type;
    const int __bits_per_word = <span class="ge">_It::__bits_</span>per_word;

    if (<span class="gs">__first.__</span>ctz_ != 0)
    {
        __storage_type __clz_f = static_cast&lt;__storage_type&gt;(__bits_per_word - <span class="gs">__first.__</span>ctz_);
        __storage_type <span class="gs">__dn = std::__</span>1::min(__clz_f, __n);
        __storage_type <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__first.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_f - __dn));
        *<span class="gs">__first.__</span>seg_ &amp;= ~__m;
        <span class="gs">__n -= __</span>dn;
        ++__first.__seg_;
    }

    __storage_type <span class="gs">__nw = __</span>n / __bits_per_word;
    std::__1::memset(std::__1::__to_address(__first.__seg_), 0, <span class="gs">__nw * sizeof(__</span>storage_type));
    <span class="gs">__n -= __</span>nw * __bits_per_word;

    if (__n &gt; 0)
    {
        <span class="gs">__first.__</span>seg_ += __nw;
        __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
        *<span class="gs">__first.__</span>seg_ &amp;= ~__m;
    }
}

template &lt;class _Cp&gt;
void
__fill_n_true(__bit_iterator&lt;_Cp, false&gt; __first, typename <span class="ge">_Cp::size_</span>type __n)
{
    typedef __bit_iterator&lt;_Cp, false&gt; _It;
    typedef typename <span class="ge">_It::__storage_</span>type __storage_type;
    const int __bits_per_word = <span class="ge">_It::__bits_</span>per_word;

    if (<span class="gs">__first.__</span>ctz_ != 0)
    {
        __storage_type __clz_f = static_cast&lt;__storage_type&gt;(__bits_per_word - <span class="gs">__first.__</span>ctz_);
        __storage_type <span class="gs">__dn = std::__</span>1::min(__clz_f, __n);
        __storage_type <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__first.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_f - __dn));
        *<span class="gs">__first.__</span>seg_ |= __m;
        <span class="gs">__n -= __</span>dn;
        ++__first.__seg_;
    }

    __storage_type <span class="gs">__nw = __</span>n / __bits_per_word;
    std::__1::memset(std::__1::__to_address(__first.__seg_), -1, <span class="gs">__nw * sizeof(__</span>storage_type));
    <span class="gs">__n -= __</span>nw * __bits_per_word;

    if (__n &gt; 0)
    {
        <span class="gs">__first.__</span>seg_ += __nw;
        __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
        *<span class="gs">__first.__</span>seg_ |= __m;
    }
}

template &lt;class _Cp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
fill_n(__bit_iterator&lt;_Cp, false&gt; __first, typename <span class="ge">_Cp::size_</span>type <span class="gs">__n, bool __</span>value_)
{
    if (__n &gt; 0)
    {
        if (__value_)
            __fill_n_true(__first, __n);
        else
            __fill_n_false(__first, __n);
    }
}



template &lt;class _Cp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
fill(__bit_iterator&lt;_Cp, false&gt; <span class="gs">__first, __</span>bit_iterator&lt;_Cp, false&gt; <span class="gs">__last, bool __</span>value_)
{
    std::__1::fill_n(__first, static_cast&lt;typename <span class="ge">_Cp::size_</span>type&gt;(__last - <span class="gs">__first), __</span>value_);
}



template &lt;class <span class="ge">_Cp, bool _</span>IsConst&gt;
__bit_iterator&lt;_Cp, false&gt;
__copy_aligned(__bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; __first, __bit_</span>iterator&lt;_Cp, <span class="ge">_IsConst&gt; _</span>_last,
                                                     __bit_iterator&lt;_Cp, false&gt; __result)
{
    typedef __bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; _</span>In;
    typedef typename <span class="ge">_In::difference_</span>type difference_type;
    typedef typename <span class="ge">_In::__storage_</span>type __storage_type;
    const int __bits_per_word = <span class="ge">_In::__bits_</span>per_word;
    difference_type <span class="gs">__n = __</span>last - __first;
    if (__n &gt; 0)
    {

        if (<span class="gs">__first.__</span>ctz_ != 0)
        {
            unsigned <span class="gs">__clz = __</span>bits_per_word - <span class="gs">__first.__</span>ctz_;
            difference_type <span class="gs">__dn = std::__</span>1::min(static_cast&lt;difference_type&gt;(__clz), __n);
            <span class="gs">__n -= __</span>dn;
            __storage_type <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__first.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (<span class="gs">__clz - __</span>dn));
            __storage_type <span class="gs">__b = *__</span>first.__seg_ &amp; __m;
            *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
            *<span class="gs">__result.__</span>seg_ |= __b;
            <span class="gs">__result.__</span>seg_ += (<span class="gs">__dn + __</span>result.__ctz_) / __bits_per_word;
            <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;((__dn + <span class="gs">__result.__</span>ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        __storage_type <span class="gs">__nw = __</span>n / __bits_per_word;
        std::__1::memmove(std::__1::__to_address(__result.__seg_),
                       std::__1::__to_address(__first.__seg_),
                       <span class="gs">__nw * sizeof(__</span>storage_type));
        <span class="gs">__n -= __</span>nw * __bits_per_word;
        <span class="gs">__result.__</span>seg_ += __nw;

        if (__n &gt; 0)
        {
            <span class="gs">__first.__</span>seg_ += __nw;
            __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
            __storage_type <span class="gs">__b = *__</span>first.__seg_ &amp; __m;
            *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
            *<span class="gs">__result.__</span>seg_ |= __b;
            <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;(__n);
        }
    }
    return __result;
}

template &lt;class <span class="ge">_Cp, bool _</span>IsConst&gt;
__bit_iterator&lt;_Cp, false&gt;
__copy_unaligned(__bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; __first, __bit_</span>iterator&lt;_Cp, <span class="ge">_IsConst&gt; _</span>_last,
                                                       __bit_iterator&lt;_Cp, false&gt; __result)
{
    typedef __bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; _</span>In;
    typedef typename <span class="ge">_In::difference_</span>type difference_type;
    typedef typename <span class="ge">_In::__storage_</span>type __storage_type;
    static const int __bits_per_word = <span class="ge">_In::__bits_</span>per_word;
    difference_type <span class="gs">__n = __</span>last - __first;
    if (__n &gt; 0)
    {

        if (<span class="gs">__first.__</span>ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - <span class="gs">__first.__</span>ctz_;
            difference_type <span class="gs">__dn = std::__</span>1::min(static_cast&lt;difference_type&gt;(__clz_f), __n);
            <span class="gs">__n -= __</span>dn;
            __storage_type <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__first.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_f - __dn));
            __storage_type <span class="gs">__b = *__</span>first.__seg_ &amp; __m;
            unsigned __clz_r = __bits_per_word - <span class="gs">__result.__</span>ctz_;
            __storage_type <span class="gs">__ddn = std::__</span>1::min&lt;__storage_type&gt;(__dn, __clz_r);
            <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__result.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_r - __ddn));
            *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
            if (<span class="gs">__result.__</span>ctz_ &gt; <span class="gs">__first.__</span>ctz_)
                *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b &lt;&lt; (__</span>result.__ctz_ - <span class="gs">__first.__</span>ctz_);
            else
                *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b &gt;&gt; (__</span>first.__ctz_ - <span class="gs">__result.__</span>ctz_);
            <span class="gs">__result.__</span>seg_ += (<span class="gs">__ddn + __</span>result.__ctz_) / __bits_per_word;
            <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;((__ddn + <span class="gs">__result.__</span>ctz_) % __bits_per_word);
            <span class="gs">__dn -= __</span>ddn;
            if (__dn &gt; 0)
            {
                <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __dn);
                *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
                *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b &gt;&gt; (__</span>first.__ctz_ + __ddn);
                <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;(__dn);
            }
            ++__first.__seg_;

        }


        unsigned __clz_r = __bits_per_word - <span class="gs">__result.__</span>ctz_;
        __storage_type <span class="gs">__m = ~__</span>storage_type(0) &lt;&lt; <span class="gs">__result.__</span>ctz_;
        for (; <span class="gs">__n &gt;= __</span>bits_per_word; <span class="gs">__n -= __</span>bits_per_word, ++__first.__seg_)
        {
            __storage_type <span class="gs">__b = *__</span>first.__seg_;
            *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
            *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b &lt;&lt; __</span>result.__ctz_;
            ++__result.__seg_;
            *<span class="gs">__result.__</span>seg_ &amp;= __m;
            *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b &gt;&gt; __</span>clz_r;
        }

        if (__n &gt; 0)
        {
            <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
            __storage_type <span class="gs">__b = *__</span>first.__seg_ &amp; __m;
            __storage_type <span class="gs">__dn = std::__</span>1::min(__n, static_cast&lt;difference_type&gt;(__clz_r));
            <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__result.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_r - __dn));
            *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
            *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b &lt;&lt; __</span>result.__ctz_;
            <span class="gs">__result.__</span>seg_ += (<span class="gs">__dn + __</span>result.__ctz_) / __bits_per_word;
            <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;((__dn + <span class="gs">__result.__</span>ctz_) % __bits_per_word);
            <span class="gs">__n -= __</span>dn;
            if (__n &gt; 0)
            {
                <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
                *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
                *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b &gt;&gt; __</span>dn;
                <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;(__n);
            }
        }
    }
    return __result;
}

template &lt;class <span class="ge">_Cp, bool _</span>IsConst&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__bit_iterator&lt;_Cp, false&gt;
copy(__bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; __first, __bit_</span>iterator&lt;_Cp, <span class="ge">_IsConst&gt; __last, __bit_</span>iterator&lt;_Cp, false&gt; __result)
{
    if (<span class="gs">__first.__</span>ctz_ == <span class="gs">__result.__</span>ctz_)
        return __copy_aligned(__first, <span class="gs">__last, __</span>result);
    return __copy_unaligned(__first, <span class="gs">__last, __</span>result);
}



template &lt;class <span class="ge">_Cp, bool _</span>IsConst&gt;
__bit_iterator&lt;_Cp, false&gt;
__copy_backward_aligned(__bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; __first, __bit_</span>iterator&lt;_Cp, <span class="ge">_IsConst&gt; _</span>_last,
                                                     __bit_iterator&lt;_Cp, false&gt; __result)
{
    typedef __bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; _</span>In;
    typedef typename <span class="ge">_In::difference_</span>type difference_type;
    typedef typename <span class="ge">_In::__storage_</span>type __storage_type;
    const int __bits_per_word = <span class="ge">_In::__bits_</span>per_word;
    difference_type <span class="gs">__n = __</span>last - __first;
    if (__n &gt; 0)
    {

        if (<span class="gs">__last.__</span>ctz_ != 0)
        {
            difference_type <span class="gs">__dn = std::__</span>1::min(static_cast&lt;difference_type&gt;(__last.__ctz_), __n);
            <span class="gs">__n -= __</span>dn;
            unsigned <span class="gs">__clz = __</span>bits_per_word - <span class="gs">__last.__</span>ctz_;
            __storage_type <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; (<span class="gs">__last.__</span>ctz_ - <span class="gs">__dn)) &amp; (~__</span>storage_type(0) &gt;&gt; __clz);
            __storage_type <span class="gs">__b = *__</span>last.__seg_ &amp; __m;
            *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
            *<span class="gs">__result.__</span>seg_ |= __b;
            <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;(((-__dn &amp; (__bits_per_word - 1)) +
                                                       <span class="gs">__result.__</span>ctz_) % __bits_per_word);

         }



        __storage_type <span class="gs">__nw = __</span>n / __bits_per_word;
        <span class="gs">__result.__</span>seg_ -= __nw;
        <span class="gs">__last.__</span>seg_ -= __nw;
        std::__1::memmove(std::__1::__to_address(__result.__seg_),
                       std::__1::__to_address(__last.__seg_),
                       <span class="gs">__nw * sizeof(__</span>storage_type));
        <span class="gs">__n -= __</span>nw * __bits_per_word;

        if (__n &gt; 0)
        {
            __storage_type <span class="gs">__m = ~__</span>storage_type(0) &lt;&lt; (__bits_per_word - __n);
            __storage_type <span class="gs">__b = *--__</span>last.__seg_ &amp; __m;
            *--__result.__seg_ &amp;= ~__m;
            *<span class="gs">__result.__</span>seg_ |= __b;
            <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;(-__n &amp; (__bits_per_word - 1));
        }
    }
    return __result;
}

template &lt;class <span class="ge">_Cp, bool _</span>IsConst&gt;
__bit_iterator&lt;_Cp, false&gt;
__copy_backward_unaligned(__bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; __first, __bit_</span>iterator&lt;_Cp, <span class="ge">_IsConst&gt; _</span>_last,
                                                       __bit_iterator&lt;_Cp, false&gt; __result)
{
    typedef __bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; _</span>In;
    typedef typename <span class="ge">_In::difference_</span>type difference_type;
    typedef typename <span class="ge">_In::__storage_</span>type __storage_type;
    const int __bits_per_word = <span class="ge">_In::__bits_</span>per_word;
    difference_type <span class="gs">__n = __</span>last - __first;
    if (__n &gt; 0)
    {

        if (<span class="gs">__last.__</span>ctz_ != 0)
        {
            difference_type <span class="gs">__dn = std::__</span>1::min(static_cast&lt;difference_type&gt;(__last.__ctz_), __n);
            <span class="gs">__n -= __</span>dn;
            unsigned __clz_l = __bits_per_word - <span class="gs">__last.__</span>ctz_;
            __storage_type <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; (<span class="gs">__last.__</span>ctz_ - <span class="gs">__dn)) &amp; (~__</span>storage_type(0) &gt;&gt; __clz_l);
            __storage_type <span class="gs">__b = *__</span>last.__seg_ &amp; __m;
            unsigned __clz_r = __bits_per_word - <span class="gs">__result.__</span>ctz_;
            __storage_type <span class="gs">__ddn = std::__</span>1::min(__dn, static_cast&lt;difference_type&gt;(__result.__ctz_));
            if (__ddn &gt; 0)
            {
                <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; (<span class="gs">__result.__</span>ctz_ - <span class="gs">__ddn)) &amp; (~__</span>storage_type(0) &gt;&gt; __clz_r);
                *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
                if (<span class="gs">__result.__</span>ctz_ &gt; <span class="gs">__last.__</span>ctz_)
                    *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b &lt;&lt; (__</span>result.__ctz_ - <span class="gs">__last.__</span>ctz_);
                else
                    *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b &gt;&gt; (__</span>last.__ctz_ - <span class="gs">__result.__</span>ctz_);
                <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;(((-__ddn &amp; (__bits_per_word - 1)) +
                                                         <span class="gs">__result.__</span>ctz_) % __bits_per_word);
                <span class="gs">__dn -= __</span>ddn;
            }
            if (__dn &gt; 0)
            {

                --__result.__seg_;
                <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;(-__dn &amp; (__bits_per_word - 1));
                <span class="gs">__m = ~__</span>storage_type(0) &lt;&lt; <span class="gs">__result.__</span>ctz_;
                *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
                <span class="gs">__last.__</span>ctz_ -= <span class="gs">__dn + __</span>ddn;
                *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b &lt;&lt; (__</span>result.__ctz_ - <span class="gs">__last.__</span>ctz_);
            }

         }



        unsigned __clz_r = __bits_per_word - <span class="gs">__result.__</span>ctz_;
        __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; __clz_r;
        for (; <span class="gs">__n &gt;= __</span>bits_per_word; <span class="gs">__n -= __</span>bits_per_word)
        {
            __storage_type <span class="gs">__b = *--__</span>last.__seg_;
            *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
            *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b &gt;&gt; __</span>clz_r;
            *--__result.__seg_ &amp;= __m;
            *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b &lt;&lt; __</span>result.__ctz_;
        }

        if (__n &gt; 0)
        {
            <span class="gs">__m = ~__</span>storage_type(0) &lt;&lt; (__bits_per_word - __n);
            __storage_type <span class="gs">__b = *--__</span>last.__seg_ &amp; __m;
            __clz_r = __bits_per_word - <span class="gs">__result.__</span>ctz_;
            __storage_type <span class="gs">__dn = std::__</span>1::min(__n, static_cast&lt;difference_type&gt;(__result.__ctz_));
            <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; (<span class="gs">__result.__</span>ctz_ - <span class="gs">__dn)) &amp; (~__</span>storage_type(0) &gt;&gt; __clz_r);
            *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
            *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b &gt;&gt; (__</span>bits_per_word - <span class="gs">__result.__</span>ctz_);
            <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;(((-__dn &amp; (__bits_per_word - 1)) +
                                                     <span class="gs">__result.__</span>ctz_) % __bits_per_word);
            <span class="gs">__n -= __</span>dn;
            if (__n &gt; 0)
            {

                --__result.__seg_;
                <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;(-__n &amp; (__bits_per_word - 1));
                <span class="gs">__m = ~__</span>storage_type(0) &lt;&lt; <span class="gs">__result.__</span>ctz_;
                *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
                *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b &lt;&lt; (__</span>result.__ctz_ - (__bits_per_word - <span class="gs">__n - __</span>dn));
            }
        }
    }
    return __result;
}

template &lt;class <span class="ge">_Cp, bool _</span>IsConst&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__bit_iterator&lt;_Cp, false&gt;
copy_backward(__bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; __first, __bit_</span>iterator&lt;_Cp, <span class="ge">_IsConst&gt; __last, __bit_</span>iterator&lt;_Cp, false&gt; __result)
{
    if (<span class="gs">__last.__</span>ctz_ == <span class="gs">__result.__</span>ctz_)
        return __copy_backward_aligned(__first, <span class="gs">__last, __</span>result);
    return __copy_backward_unaligned(__first, <span class="gs">__last, __</span>result);
}



template &lt;class <span class="ge">_Cp, bool _</span>IsConst&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__bit_iterator&lt;_Cp, false&gt;
move(__bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; __first, __bit_</span>iterator&lt;_Cp, <span class="ge">_IsConst&gt; __last, __bit_</span>iterator&lt;_Cp, false&gt; __result)
{
    return std::__1::copy(__first, <span class="gs">__last, __</span>result);
}



template &lt;class <span class="ge">_Cp, bool _</span>IsConst&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__bit_iterator&lt;_Cp, false&gt;
move_backward(__bit_iterator&lt;_Cp, <span class="ge">_IsConst&gt; __first, __bit_</span>iterator&lt;_Cp, <span class="ge">_IsConst&gt; __last, __bit_</span>iterator&lt;_Cp, false&gt; __result)
{
    return std::__1::copy_backward(__first, <span class="gs">__last, __</span>result);
}



template &lt;class <span class="gs">__C1, class __</span>C2&gt;
__bit_iterator&lt;__C2, false&gt;
__swap_ranges_aligned(__bit_iterator&lt;__C1, false&gt; <span class="gs">__first, __</span>bit_iterator&lt;__C1, false&gt; __last,
                      __bit_iterator&lt;__C2, false&gt; __result)
{
    typedef __bit_iterator&lt;__C1, false&gt; _I1;
    typedef typename <span class="ge">_I1::difference_</span>type difference_type;
    typedef typename <span class="ge">_I1::__storage_</span>type __storage_type;
    const int __bits_per_word = <span class="ge">_I1::__bits_</span>per_word;
    difference_type <span class="gs">__n = __</span>last - __first;
    if (__n &gt; 0)
    {

        if (<span class="gs">__first.__</span>ctz_ != 0)
        {
            unsigned <span class="gs">__clz = __</span>bits_per_word - <span class="gs">__first.__</span>ctz_;
            difference_type <span class="gs">__dn = std::__</span>1::min(static_cast&lt;difference_type&gt;(__clz), __n);
            <span class="gs">__n -= __</span>dn;
            __storage_type <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__first.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (<span class="gs">__clz - __</span>dn));
            __storage_type <span class="gs">__b1 = *__</span>first.__seg_ &amp; __m;
            *<span class="gs">__first.__</span>seg_ &amp;= ~__m;
            __storage_type <span class="gs">__b2 = *__</span>result.__seg_ &amp; __m;
            *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
            *<span class="gs">__result.__</span>seg_ |= __b1;
            *<span class="gs">__first.__</span>seg_ |= __b2;
            <span class="gs">__result.__</span>seg_ += (<span class="gs">__dn + __</span>result.__ctz_) / __bits_per_word;
            <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;((__dn + <span class="gs">__result.__</span>ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        for (; <span class="gs">__n &gt;= __</span>bits_per_word; <span class="gs">__n -= __</span>bits_per_word, ++__first.__seg_, ++__result.__seg_)
            swap(*__first.__seg_, *<span class="gs">__result.__</span>seg_);

        if (__n &gt; 0)
        {
            __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
            __storage_type <span class="gs">__b1 = *__</span>first.__seg_ &amp; __m;
            *<span class="gs">__first.__</span>seg_ &amp;= ~__m;
            __storage_type <span class="gs">__b2 = *__</span>result.__seg_ &amp; __m;
            *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
            *<span class="gs">__result.__</span>seg_ |= __b1;
            *<span class="gs">__first.__</span>seg_ |= __b2;
            <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;(__n);
        }
    }
    return __result;
}

template &lt;class <span class="gs">__C1, class __</span>C2&gt;
__bit_iterator&lt;__C2, false&gt;
__swap_ranges_unaligned(__bit_iterator&lt;__C1, false&gt; <span class="gs">__first, __</span>bit_iterator&lt;__C1, false&gt; __last,
                        __bit_iterator&lt;__C2, false&gt; __result)
{
    typedef __bit_iterator&lt;__C1, false&gt; _I1;
    typedef typename <span class="ge">_I1::difference_</span>type difference_type;
    typedef typename <span class="ge">_I1::__storage_</span>type __storage_type;
    const int __bits_per_word = <span class="ge">_I1::__bits_</span>per_word;
    difference_type <span class="gs">__n = __</span>last - __first;
    if (__n &gt; 0)
    {

        if (<span class="gs">__first.__</span>ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - <span class="gs">__first.__</span>ctz_;
            difference_type <span class="gs">__dn = std::__</span>1::min(static_cast&lt;difference_type&gt;(__clz_f), __n);
            <span class="gs">__n -= __</span>dn;
            __storage_type <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__first.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_f - __dn));
            __storage_type <span class="gs">__b1 = *__</span>first.__seg_ &amp; __m;
            *<span class="gs">__first.__</span>seg_ &amp;= ~__m;
            unsigned __clz_r = __bits_per_word - <span class="gs">__result.__</span>ctz_;
            __storage_type <span class="gs">__ddn = std::__</span>1::min&lt;__storage_type&gt;(__dn, __clz_r);
            <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__result.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_r - __ddn));
            __storage_type <span class="gs">__b2 = *__</span>result.__seg_ &amp; __m;
            *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
            if (<span class="gs">__result.__</span>ctz_ &gt; <span class="gs">__first.__</span>ctz_)
            {
                unsigned <span class="gs">__s = __</span>result.__ctz_ - <span class="gs">__first.__</span>ctz_;
                *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b1 &lt;&lt; __</span>s;
                *<span class="gs">__first.__</span>seg_ |= <span class="gs">__b2 &gt;&gt; __</span>s;
            }
            else
            {
                unsigned <span class="gs">__s = __</span>first.__ctz_ - <span class="gs">__result.__</span>ctz_;
                *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b1 &gt;&gt; __</span>s;
                *<span class="gs">__first.__</span>seg_ |= <span class="gs">__b2 &lt;&lt; __</span>s;
            }
            <span class="gs">__result.__</span>seg_ += (<span class="gs">__ddn + __</span>result.__ctz_) / __bits_per_word;
            <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;((__ddn + <span class="gs">__result.__</span>ctz_) % __bits_per_word);
            <span class="gs">__dn -= __</span>ddn;
            if (__dn &gt; 0)
            {
                <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __dn);
                <span class="gs">__b2 = *__</span>result.__seg_ &amp; __m;
                *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
                unsigned <span class="gs">__s = __</span>first.__ctz_ + __ddn;
                *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b1 &gt;&gt; __</span>s;
                *<span class="gs">__first.__</span>seg_ |= <span class="gs">__b2 &lt;&lt; __</span>s;
                <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;(__dn);
            }
            ++__first.__seg_;

        }


        __storage_type <span class="gs">__m = ~__</span>storage_type(0) &lt;&lt; <span class="gs">__result.__</span>ctz_;
        unsigned __clz_r = __bits_per_word - <span class="gs">__result.__</span>ctz_;
        for (; <span class="gs">__n &gt;= __</span>bits_per_word; <span class="gs">__n -= __</span>bits_per_word, ++__first.__seg_)
        {
            __storage_type <span class="gs">__b1 = *__</span>first.__seg_;
            __storage_type <span class="gs">__b2 = *__</span>result.__seg_ &amp; __m;
            *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
            *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b1 &lt;&lt; __</span>result.__ctz_;
            *<span class="gs">__first.__</span>seg_ = <span class="gs">__b2 &gt;&gt; __</span>result.__ctz_;
            ++__result.__seg_;
            <span class="gs">__b2 = *__</span>result.__seg_ &amp; ~__m;
            *<span class="gs">__result.__</span>seg_ &amp;= __m;
            *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b1 &gt;&gt; __</span>clz_r;
            *<span class="gs">__first.__</span>seg_ |= <span class="gs">__b2 &lt;&lt; __</span>clz_r;
        }

        if (__n &gt; 0)
        {
            <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
            __storage_type <span class="gs">__b1 = *__</span>first.__seg_ &amp; __m;
            *<span class="gs">__first.__</span>seg_ &amp;= ~__m;
            __storage_type <span class="gs">__dn = std::__</span>1::min&lt;__storage_type&gt;(__n, __clz_r);
            <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__result.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_r - __dn));
            __storage_type <span class="gs">__b2 = *__</span>result.__seg_ &amp; __m;
            *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
            *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b1 &lt;&lt; __</span>result.__ctz_;
            *<span class="gs">__first.__</span>seg_ |= <span class="gs">__b2 &gt;&gt; __</span>result.__ctz_;
            <span class="gs">__result.__</span>seg_ += (<span class="gs">__dn + __</span>result.__ctz_) / __bits_per_word;
            <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;((__dn + <span class="gs">__result.__</span>ctz_) % __bits_per_word);
            <span class="gs">__n -= __</span>dn;
            if (__n &gt; 0)
            {
                <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
                <span class="gs">__b2 = *__</span>result.__seg_ &amp; __m;
                *<span class="gs">__result.__</span>seg_ &amp;= ~__m;
                *<span class="gs">__result.__</span>seg_ |= <span class="gs">__b1 &gt;&gt; __</span>dn;
                *<span class="gs">__first.__</span>seg_ |= <span class="gs">__b2 &lt;&lt; __</span>dn;
                <span class="gs">__result.__</span>ctz_ = static_cast&lt;unsigned&gt;(__n);
            }
        }
    }
    return __result;
}

template &lt;class <span class="gs">__C1, class __</span>C2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
__bit_iterator&lt;__C2, false&gt;
swap_ranges(__bit_iterator&lt;__C1, false&gt; <span class="gs">__first1, __</span>bit_iterator&lt;__C1, false&gt; __last1,
            __bit_iterator&lt;__C2, false&gt; __first2)
{
    if (<span class="gs">__first1.__</span>ctz_ == <span class="gs">__first2.__</span>ctz_)
        return __swap_ranges_aligned(__first1, <span class="gs">__last1, __</span>first2);
    return __swap_ranges_unaligned(__first1, <span class="gs">__last1, __</span>first2);
}



template &lt;class _Cp&gt;
struct __bit_array
{
    typedef typename <span class="ge">_Cp::difference_</span>type difference_type;
    typedef typename <span class="ge">_Cp::__storage_</span>type __storage_type;
    typedef typename <span class="ge">_Cp::__storage_</span>pointer __storage_pointer;
    typedef typename _Cp::iterator iterator;
    static const unsigned __bits_per_word = <span class="ge">_Cp::__bits_</span>per_word;
    static const unsigned _Np = 4;

    difference_type __size_;
    __storage_type __word_[_Np];

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) static difference_type capacity()
        {return static_cast&lt;difference_type&gt;(_Np * __bits_per_word);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) explicit __bit_array(difference_type <span class="gs">__s) : __</span>size_(__s) {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) iterator begin()
    {
        return iterator(pointer_traits&lt;__storage_pointer&gt;::pointer_to(__word_[0]), 0);
    }
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) iterator end()
    {
        return iterator(pointer_traits&lt;__storage_pointer&gt;::pointer_to(__word_[0]) + __size_ / __bits_per_word,
                                                  static_cast&lt;unsigned&gt;(__size_ % __bits_per_word));
    }
};

template &lt;class _Cp&gt;
__bit_iterator&lt;_Cp, false&gt;
rotate(__bit_iterator&lt;_Cp, false&gt; <span class="gs">__first, __</span>bit_iterator&lt;_Cp, false&gt; <span class="gs">__middle, __</span>bit_iterator&lt;_Cp, false&gt; __last)
{
    typedef __bit_iterator&lt;_Cp, false&gt; _I1;
    typedef typename <span class="ge">_I1::difference_</span>type difference_type;
    difference_type <span class="gs">__d1 = __</span>middle - __first;
    difference_type <span class="gs">__d2 = __</span>last - __middle;
    <span class="ge">_I1 __r = __first + _</span>_d2;
    while (<span class="gs">__d1 != 0 &amp;&amp; __</span>d2 != 0)
    {
        if (<span class="gs">__d1 &lt;= __</span>d2)
        {
            if (<span class="gs">__d1 &lt;= __</span>bit_array&lt;_Cp&gt;::capacity())
            {
                __bit_array&lt;_Cp&gt; <span class="gs">__b(__</span>d1);
                std::__1::copy(__first, <span class="gs">__middle, __</span>b.begin());
                std::__1::copy(__b.begin(), <span class="gs">__b.end(), std::__</span>1::copy(__middle, <span class="gs">__last, __</span>first));
                break;
            }
            else
            {
                __bit_iterator&lt;_Cp, false&gt; <span class="gs">__mp = std::__</span>1::swap_ranges(__first, <span class="gs">__middle, __</span>middle);
                <span class="gs">__first = __</span>middle;
                <span class="gs">__middle = __</span>mp;
                <span class="gs">__d2 -= __</span>d1;
            }
        }
        else
        {
            if (<span class="gs">__d2 &lt;= __</span>bit_array&lt;_Cp&gt;::capacity())
            {
                __bit_array&lt;_Cp&gt; <span class="gs">__b(__</span>d2);
                std::__1::copy(__middle, <span class="gs">__last, __</span>b.begin());
                std::__1::copy_backward(__b.begin(), <span class="gs">__b.end(), std::__</span>1::copy_backward(__first, <span class="gs">__middle, __</span>last));
                break;
            }
            else
            {
                __bit_iterator&lt;_Cp, false&gt; <span class="gs">__mp = __</span>first + __d2;
                std::__1::swap_ranges(__first, <span class="gs">__mp, __</span>middle);
                <span class="gs">__first = __</span>mp;
                <span class="gs">__d1 -= __</span>d2;
            }
        }
    }
    return __r;
}



template &lt;class <span class="ge">_Cp, bool _</span>IC1, bool _IC2&gt;
bool
__equal_unaligned(__bit_iterator&lt;_Cp, <span class="ge">_IC1&gt; __first1, __bit_</span>iterator&lt;_Cp, <span class="ge">_IC1&gt; _</span>_last1,
                  __bit_iterator&lt;_Cp, <span class="ge">_IC2&gt; _</span>_first2)
{
    typedef __bit_iterator&lt;_Cp, <span class="ge">_IC1&gt; _</span>It;
    typedef typename <span class="ge">_It::difference_</span>type difference_type;
    typedef typename <span class="ge">_It::__storage_</span>type __storage_type;
    static const int __bits_per_word = <span class="ge">_It::__bits_</span>per_word;
    difference_type <span class="gs">__n = __</span>last1 - __first1;
    if (__n &gt; 0)
    {

        if (<span class="gs">__first1.__</span>ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - <span class="gs">__first1.__</span>ctz_;
            difference_type <span class="gs">__dn = std::__</span>1::min(static_cast&lt;difference_type&gt;(__clz_f), __n);
            <span class="gs">__n -= __</span>dn;
            __storage_type <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__first1.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_f - __dn));
            __storage_type <span class="gs">__b = *__</span>first1.__seg_ &amp; __m;
            unsigned __clz_r = __bits_per_word - <span class="gs">__first2.__</span>ctz_;
            __storage_type <span class="gs">__ddn = std::__</span>1::min&lt;__storage_type&gt;(__dn, __clz_r);
            <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__first2.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_r - __ddn));
            if (<span class="gs">__first2.__</span>ctz_ &gt; <span class="gs">__first1.__</span>ctz_)
            {
                if ((*__first2.__seg_ &amp; <span class="gs">__m) != (__</span>b &lt;&lt; (<span class="gs">__first2.__</span>ctz_ - <span class="gs">__first1.__</span>ctz_)))
                    return false;
            }
            else
            {
                if ((*__first2.__seg_ &amp; <span class="gs">__m) != (__</span>b &gt;&gt; (<span class="gs">__first1.__</span>ctz_ - <span class="gs">__first2.__</span>ctz_)))
                    return false;
            }
            <span class="gs">__first2.__</span>seg_ += (<span class="gs">__ddn + __</span>first2.__ctz_) / __bits_per_word;
            <span class="gs">__first2.__</span>ctz_ = static_cast&lt;unsigned&gt;((__ddn + <span class="gs">__first2.__</span>ctz_) % __bits_per_word);
            <span class="gs">__dn -= __</span>ddn;
            if (__dn &gt; 0)
            {
                <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __dn);
                if ((*__first2.__seg_ &amp; <span class="gs">__m) != (__</span>b &gt;&gt; (<span class="gs">__first1.__</span>ctz_ + __ddn)))
                    return false;
                <span class="gs">__first2.__</span>ctz_ = static_cast&lt;unsigned&gt;(__dn);
            }
            ++__first1.__seg_;

        }


        unsigned __clz_r = __bits_per_word - <span class="gs">__first2.__</span>ctz_;
        __storage_type <span class="gs">__m = ~__</span>storage_type(0) &lt;&lt; <span class="gs">__first2.__</span>ctz_;
        for (; <span class="gs">__n &gt;= __</span>bits_per_word; <span class="gs">__n -= __</span>bits_per_word, ++__first1.__seg_)
        {
            __storage_type <span class="gs">__b = *__</span>first1.__seg_;
            if ((*__first2.__seg_ &amp; <span class="gs">__m) != (__</span>b &lt;&lt; <span class="gs">__first2.__</span>ctz_))
                return false;
            ++__first2.__seg_;
            if ((*__first2.__seg_ &amp; ~<span class="gs">__m) != (__</span>b &gt;&gt; __clz_r))
                return false;
        }

        if (__n &gt; 0)
        {
            <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
            __storage_type <span class="gs">__b = *__</span>first1.__seg_ &amp; __m;
            __storage_type <span class="gs">__dn = std::__</span>1::min(__n, static_cast&lt;difference_type&gt;(__clz_r));
            <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__first2.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (__clz_r - __dn));
            if ((*__first2.__seg_ &amp; <span class="gs">__m) != (__</span>b &lt;&lt; <span class="gs">__first2.__</span>ctz_))
                return false;
            <span class="gs">__first2.__</span>seg_ += (<span class="gs">__dn + __</span>first2.__ctz_) / __bits_per_word;
            <span class="gs">__first2.__</span>ctz_ = static_cast&lt;unsigned&gt;((__dn + <span class="gs">__first2.__</span>ctz_) % __bits_per_word);
            <span class="gs">__n -= __</span>dn;
            if (__n &gt; 0)
            {
                <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
                if ((*__first2.__seg_ &amp; <span class="gs">__m) != (__</span>b &gt;&gt; __dn))
                    return false;
            }
        }
    }
    return true;
}

template &lt;class <span class="ge">_Cp, bool _</span>IC1, bool _IC2&gt;
bool
__equal_aligned(__bit_iterator&lt;_Cp, <span class="ge">_IC1&gt; __first1, __bit_</span>iterator&lt;_Cp, <span class="ge">_IC1&gt; _</span>_last1,
                __bit_iterator&lt;_Cp, <span class="ge">_IC2&gt; _</span>_first2)
{
    typedef __bit_iterator&lt;_Cp, <span class="ge">_IC1&gt; _</span>It;
    typedef typename <span class="ge">_It::difference_</span>type difference_type;
    typedef typename <span class="ge">_It::__storage_</span>type __storage_type;
    static const int __bits_per_word = <span class="ge">_It::__bits_</span>per_word;
    difference_type <span class="gs">__n = __</span>last1 - __first1;
    if (__n &gt; 0)
    {

        if (<span class="gs">__first1.__</span>ctz_ != 0)
        {
            unsigned <span class="gs">__clz = __</span>bits_per_word - <span class="gs">__first1.__</span>ctz_;
            difference_type <span class="gs">__dn = std::__</span>1::min(static_cast&lt;difference_type&gt;(__clz), __n);
            <span class="gs">__n -= __</span>dn;
            __storage_type <span class="gs">__m = (~__</span>storage_type(0) &lt;&lt; <span class="gs">__first1.__</span>ctz_) &amp; (~__storage_type(0) &gt;&gt; (<span class="gs">__clz - __</span>dn));
            if ((*__first2.__seg_ &amp; <span class="gs">__m) != (*__</span>first1.__seg_ &amp; __m))
                return false;
            ++__first2.__seg_;
            ++__first1.__seg_;


        }



        for (; <span class="gs">__n &gt;= __</span>bits_per_word; <span class="gs">__n -= __</span>bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
            if (<span class="ge">*__first2.__seg_ != *</span><span class="gs">__first1.__</span>seg_)
                return false;

        if (__n &gt; 0)
        {
            __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
            if ((*__first2.__seg_ &amp; <span class="gs">__m) != (*__</span>first1.__seg_ &amp; __m))
                return false;
        }
    }
    return true;
}

template &lt;class <span class="ge">_Cp, bool _</span>IC1, bool _IC2&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bool
equal(__bit_iterator&lt;_Cp, <span class="ge">_IC1&gt; __first1, __bit_</span>iterator&lt;_Cp, <span class="ge">_IC1&gt; __last1, __bit_</span>iterator&lt;_Cp, <span class="ge">_IC2&gt; _</span>_first2)
{
    if (<span class="gs">__first1.__</span>ctz_ == <span class="gs">__first2.__</span>ctz_)
        return __equal_aligned(__first1, <span class="gs">__last1, __</span>first2);
    return __equal_unaligned(__first1, <span class="gs">__last1, __</span>first2);
}

template &lt;class <span class="ge">_Cp, bool _</span>IsConst,
          typename <span class="ge">_Cp::__storage_</span>type&gt;
class __bit_iterator
{
public:
    typedef typename <span class="ge">_Cp::difference_</span>type difference_type;
    typedef bool value_type;
    typedef __bit_iterator pointer;
    typedef typename conditional&lt;_IsConst, __bit_const_reference&lt;_Cp&gt;, __bit_reference&lt;_Cp&gt; &gt;::type reference;
    typedef random_access_iterator_tag iterator_category;

private:
    typedef typename <span class="ge">_Cp::__storage_</span>type __storage_type;
    typedef typename conditional&lt;_IsConst, typename <span class="ge">_Cp::__const_</span>storage_pointer,
                                           typename <span class="ge">_Cp::__storage_</span>pointer&gt;::type __storage_pointer;
    static const unsigned __bits_per_word = <span class="ge">_Cp::__bits_</span>per_word;

    __storage_pointer __seg_;
    unsigned __ctz_;

public:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __bit_iterator() throw()



    {}


    using __type_for_copy_to_const =
      <span class="ge">_If&lt;_</span>IsConst, __bit_iterator&lt;_Cp, false&gt;, struct __private_nat&gt;;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __bit_iterator(const __type_for_copy_to_const&amp; __it) throw()
        : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}




    using __type_for_abi_non_trivial_copy_ctor =
      <span class="ge">_If&lt;!_</span>IsConst, __bit_iterator, struct __private_nat&gt;;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __bit_iterator(__type_for_abi_non_trivial_copy_ctor const&amp; __it) throw()
      : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}



    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __bit_iterator&amp; operator=(__bit_iterator const&amp;) = default;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) reference operator*() const throw()
        {return reference(__seg_, __storage_type(1) &lt;&lt; __ctz_);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __bit_iterator&amp; operator++()
    {
        if (__ctz_ != __bits_per_word-1)
            ++__ctz_;
        else
        {
            __ctz_ = 0;
            ++__seg_;
        }
        return *this;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __bit_iterator operator++(int)
    {
        __bit_iterator __tmp = *this;
        ++(*this);
        return __tmp;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __bit_iterator&amp; operator--()
    {
        if (__ctz_ != 0)
            --__ctz_;
        else
        {
            __ctz_ = __bits_per_word - 1;
            --__seg_;
        }
        return *this;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __bit_iterator operator--(int)
    {
        __bit_iterator __tmp = *this;
        --(*this);
        return __tmp;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __bit_iterator&amp; operator+=(difference_type __n)
    {
        if (__n &gt;= 0)
            __seg_ += (<span class="gs">__n + __</span>ctz_) / __bits_per_word;
        else
            __seg_ += static_cast&lt;difference_type&gt;(__n - __bits_per_word + __ctz_ + 1)
                    / static_cast&lt;difference_type&gt;(__bits_per_word);
        <span class="gs">__n &amp;= (__</span>bits_per_word - 1);
        __ctz_ = static_cast&lt;unsigned&gt;((__n + __ctz_) % __bits_per_word);
        return *this;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __bit_iterator&amp; operator-=(difference_type __n)
    {
        return *this += -__n;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __bit_iterator operator+(difference_type __n) const
    {
        __bit_iterator __t(*this);
        <span class="gs">__t += __</span>n;
        return __t;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) __bit_iterator operator-(difference_type __n) const
    {
        __bit_iterator __t(*this);
        <span class="gs">__t -= __</span>n;
        return __t;
    }

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    friend __bit_iterator operator+(difference_type <span class="gs">__n, const __</span>bit_iterator&amp; <span class="gs">__it) {return __</span>it + __n;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    friend difference_type operator-(const __bit_iterator&amp; <span class="gs">__x, const __</span>bit_iterator&amp; __y)
        {return (<span class="gs">__x.__</span>seg_ - <span class="gs">__y.__</span>seg_) * __bits_per_word + <span class="gs">__x.__</span>ctz_ - <span class="gs">__y.__</span>ctz_;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) reference operator[](difference_type <span class="gs">__n) const {return *(*this + __</span>n);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) friend bool operator==(const __bit_iterator&amp; <span class="gs">__x, const __</span>bit_iterator&amp; __y)
        {return <span class="gs">__x.__</span>seg_ == <span class="gs">__y.__</span>seg_ &amp;&amp; <span class="gs">__x.__</span>ctz_ == <span class="gs">__y.__</span>ctz_;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) friend bool operator!=(const __bit_iterator&amp; <span class="gs">__x, const __</span>bit_iterator&amp; __y)
        {return !(__x == __y);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) friend bool operator&lt;(const __bit_iterator&amp; <span class="gs">__x, const __</span>bit_iterator&amp; __y)
        {return <span class="gs">__x.__</span>seg_ &lt; <span class="gs">__y.__</span>seg_ || (<span class="gs">__x.__</span>seg_ == <span class="gs">__y.__</span>seg_ &amp;&amp; <span class="gs">__x.__</span>ctz_ &lt; <span class="gs">__y.__</span>ctz_);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) friend bool operator&gt;(const __bit_iterator&amp; <span class="gs">__x, const __</span>bit_iterator&amp; __y)
        {return <span class="gs">__y &lt; __</span>x;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) friend bool operator&lt;=(const __bit_iterator&amp; <span class="gs">__x, const __</span>bit_iterator&amp; __y)
        {return !(__y &lt; __x);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) friend bool operator&gt;=(const __bit_iterator&amp; <span class="gs">__x, const __</span>bit_iterator&amp; __y)
        {return !(__x &lt; __y);}

private:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    __bit_iterator(__storage_pointer <span class="gs">__s, unsigned __</span>ctz) throw()
        : __seg_(__s), __ctz_(__ctz) {}

    friend typename <span class="ge">_Cp::_</span>_self;

    friend class __bit_reference&lt;_Cp&gt;;
    friend class __bit_const_reference&lt;_Cp&gt;;
    friend class __bit_iterator&lt;_Cp, true&gt;;
    template &lt;class <span class="ge">_Dp&gt; friend struct __bit_</span>array;
    template &lt;class <span class="ge">_Dp&gt; friend void __fill_</span>n<span class="ge">_false(__bit_</span>iterator&lt;_Dp, false&gt; __first, typename <span class="ge">_Dp::size_</span>type __n);
    template &lt;class <span class="ge">_Dp&gt; friend void __fill_</span>n<span class="ge">_true(__bit_</span>iterator&lt;_Dp, false&gt; __first, typename <span class="ge">_Dp::size_</span>type __n);
    template &lt;class <span class="ge">_Dp, bool _</span>IC&gt; friend __bit_iterator&lt;_Dp, false&gt; __copy_aligned(__bit_iterator&lt;_Dp, <span class="ge">_IC&gt; _</span>_first,
                                                                                  __bit_iterator&lt;_Dp, <span class="ge">_IC&gt; _</span>_last,
                                                                                  __bit_iterator&lt;_Dp, false&gt; __result);
    template &lt;class <span class="ge">_Dp, bool _</span>IC&gt; friend __bit_iterator&lt;_Dp, false&gt; __copy_unaligned(__bit_iterator&lt;_Dp, <span class="ge">_IC&gt; _</span>_first,
                                                                                    __bit_iterator&lt;_Dp, <span class="ge">_IC&gt; _</span>_last,
                                                                                    __bit_iterator&lt;_Dp, false&gt; __result);
    template &lt;class <span class="ge">_Dp, bool _</span>IC&gt; friend __bit_iterator&lt;_Dp, false&gt; copy(__bit_iterator&lt;_Dp, <span class="ge">_IC&gt; _</span>_first,
                                                                        __bit_iterator&lt;_Dp, <span class="ge">_IC&gt; _</span>_last,
                                                                        __bit_iterator&lt;_Dp, false&gt; __result);
    template &lt;class <span class="ge">_Dp, bool _</span>IC&gt; friend __bit_iterator&lt;_Dp, false&gt; __copy_backward_aligned(__bit_iterator&lt;_Dp, <span class="ge">_IC&gt; _</span>_first,
                                                                                           __bit_iterator&lt;_Dp, <span class="ge">_IC&gt; _</span>_last,
                                                                                           __bit_iterator&lt;_Dp, false&gt; __result);
    template &lt;class <span class="ge">_Dp, bool _</span>IC&gt; friend __bit_iterator&lt;_Dp, false&gt; __copy_backward_unaligned(__bit_iterator&lt;_Dp, <span class="ge">_IC&gt; _</span>_first,
                                                                                             __bit_iterator&lt;_Dp, <span class="ge">_IC&gt; _</span>_last,
                                                                                             __bit_iterator&lt;_Dp, false&gt; __result);
    template &lt;class <span class="ge">_Dp, bool _</span>IC&gt; friend __bit_iterator&lt;_Dp, false&gt; copy_backward(__bit_iterator&lt;_Dp, <span class="ge">_IC&gt; _</span>_first,
                                                                                 __bit_iterator&lt;_Dp, <span class="ge">_IC&gt; _</span>_last,
                                                                                 __bit_iterator&lt;_Dp, false&gt; __result);
    template &lt;class <span class="gs">__C1, class __</span>C2&gt;friend __bit_iterator&lt;__C2, false&gt; __swap_ranges_aligned(__bit_iterator&lt;__C1, false&gt;,
                                                                                           __bit_iterator&lt;__C1, false&gt;,
                                                                                           __bit_iterator&lt;__C2, false&gt;);
    template &lt;class <span class="gs">__C1, class __</span>C2&gt;friend __bit_iterator&lt;__C2, false&gt; __swap_ranges_unaligned(__bit_iterator&lt;__C1, false&gt;,
                                                                                             __bit_iterator&lt;__C1, false&gt;,
                                                                                             __bit_iterator&lt;__C2, false&gt;);
    template &lt;class <span class="gs">__C1, class __</span>C2&gt;friend __bit_iterator&lt;__C2, false&gt; swap_ranges(__bit_iterator&lt;__C1, false&gt;,
                                                                                 __bit_iterator&lt;__C1, false&gt;,
                                                                                 __bit_iterator&lt;__C2, false&gt;);
    template &lt;class <span class="ge">_Dp&gt; friend __bit_</span>iterator&lt;_Dp, false&gt; rotate(__bit_iterator&lt;_Dp, false&gt;,
                                                                __bit_iterator&lt;_Dp, false&gt;,
                                                                __bit_iterator&lt;_Dp, false&gt;);
    template &lt;class <span class="ge">_Dp, bool _</span>IC1, bool <span class="ge">_IC2&gt; friend bool __equal_</span>aligned(__bit_iterator&lt;_Dp, _IC1&gt;,
                                                    __bit_iterator&lt;_Dp, _IC1&gt;,
                                                    __bit_iterator&lt;_Dp, _IC2&gt;);
    template &lt;class <span class="ge">_Dp, bool _</span>IC1, bool <span class="ge">_IC2&gt; friend bool __equal_</span>unaligned(__bit_iterator&lt;_Dp, _IC1&gt;,
                                                      __bit_iterator&lt;_Dp, _IC1&gt;,
                                                      __bit_iterator&lt;_Dp, _IC2&gt;);
    template &lt;class <span class="ge">_Dp, bool _</span>IC1, bool <span class="ge">_IC2&gt; friend bool equal(__bit_</span>iterator&lt;_Dp, _IC1&gt;,
                                                                __bit_iterator&lt;_Dp, _IC1&gt;,
                                                                __bit_iterator&lt;_Dp, _IC2&gt;);
    template &lt;class <span class="ge">_Dp, bool _</span>IC&gt; friend __bit_iterator&lt;_Dp, <span class="ge">_IC&gt; __find_</span>bool_true(__bit_iterator&lt;_Dp, _IC&gt;,
                                                                          typename <span class="ge">_Dp::size_</span>type);
    template &lt;class <span class="ge">_Dp, bool _</span>IC&gt; friend __bit_iterator&lt;_Dp, <span class="ge">_IC&gt; __find_</span>bool_false(__bit_iterator&lt;_Dp, _IC&gt;,
                                                                           typename <span class="ge">_Dp::size_</span>type);
    template &lt;class <span class="ge">_Dp, bool _</span>IC&gt; friend typename __bit_iterator&lt;_Dp, <span class="ge">_IC&gt;::difference_</span>type
                   __count_bool_true(__bit_iterator&lt;_Dp, <span class="ge">_IC&gt;, typename _</span>Dp::size_type);
    template &lt;class <span class="ge">_Dp, bool _</span>IC&gt; friend typename __bit_iterator&lt;_Dp, <span class="ge">_IC&gt;::difference_</span>type
                   __count_bool_false(__bit_iterator&lt;_Dp, <span class="ge">_IC&gt;, typename _</span>Dp::size_type);
};

} }





namespace std { inline namespace __1 {

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
class __bitset;

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
struct __has_storage_type&lt;__bitset&lt;_N_words, _Size&gt; &gt;
{
    static const bool value = true;
};

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
class __bitset
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef <span class="gs">__bitset __</span>self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast&lt;unsigned&gt;(sizeof(__storage_type) * 8);

    friend class __bit_reference&lt;__bitset&gt;;
    friend class __bit_const_reference&lt;__bitset&gt;;
    friend class __bit_iterator&lt;__bitset, false&gt;;
    friend class __bit_iterator&lt;__bitset, true&gt;;
    friend struct __bit_array&lt;__bitset&gt;;

    __storage_type __first_[_N_words];

    typedef __bit_reference&lt;__bitset&gt; reference;
    typedef __bit_const_reference&lt;__bitset&gt; const_reference;
    typedef __bit_iterator&lt;__bitset, false&gt; iterator;
    typedef __bit_iterator&lt;__bitset, true&gt; const_iterator;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                      __bitset() throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit <span class="gs">__bitset(unsigned long long __</span>v) throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) reference __make_ref(size_t __pos) throw()
        {return reference(__first_ + <span class="gs">__pos / __</span>bits_per_word, __storage_type(1) &lt;&lt; <span class="gs">__pos % __</span>bits_per_word);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) const_reference __make_ref(size_t __pos) const throw()
        {return const_reference(__first_ + <span class="gs">__pos / __</span>bits_per_word, __storage_type(1) &lt;&lt; <span class="gs">__pos % __</span>bits_per_word);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) iterator __make_iter(size_t __pos) throw()
        {return iterator(__first_ + <span class="gs">__pos / __</span>bits_per_word, <span class="gs">__pos % __</span>bits_per_word);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) const_iterator __make_iter(size_t __pos) const throw()
        {return const_iterator(__first_ + <span class="gs">__pos / __</span>bits_per_word, <span class="gs">__pos % __</span>bits_per_word);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void operator&amp;=(const <span class="gs">__bitset&amp; __</span>v) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void operator|=(const <span class="gs">__bitset&amp; __</span>v) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void operator^=(const <span class="gs">__bitset&amp; __</span>v) throw();

    void flip() throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) unsigned long to_ulong() const
        {return to_ulong(integral_constant&lt;bool, _Size &lt; sizeof(unsigned long) * 8&gt;());}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) unsigned long long to_ullong() const
        {return to_ullong(integral_constant&lt;bool, _Size &lt; sizeof(unsigned long long) * 8&gt;());}

    bool all() const throw();
    bool any() const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t __hash_code() const throw();
private:

    void <span class="gs">__init(unsigned long long __</span>v, false_type) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void <span class="gs">__init(unsigned long long __</span>v, true_type) throw();

    unsigned long to_ulong(false_type) const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    unsigned long to_ulong(true_type) const;
    unsigned long long to_ullong(false_type) const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    unsigned long long to_ullong(true_type) const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    unsigned long long to_ullong(true_type, false_type) const;
    unsigned long long to_ullong(true_type, true_type) const;
};

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
inline

__bitset&lt;_N_words, <span class="ge">_Size&gt;::_</span>_bitset() throw()



{

    std::__1::fill_n(__first_, <span class="ge">_N_</span>words, __storage_type(0));

}



template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
void
__bitset&lt;_N_words, <span class="ge">_Size&gt;::__init(unsigned long long __v, false_</span>type) throw()
{
    __storage_type <span class="gs">__t[sizeof(unsigned long long) / sizeof(__</span>storage_type)];
    size_t __sz = _Size;
    for (size_t <span class="gs">__i = 0; __</span>i &lt; sizeof(__t)/sizeof(__t[0]); ++__i, <span class="gs">__v &gt;&gt;= __</span>bits_per_word, <span class="gs">__sz -= __</span>bits_per_word )
        if ( <span class="gs">__sz &lt; __</span>bits_per_word)
            <span class="gs">__t[__</span>i] = static_cast&lt;__storage_type&gt;(__v) &amp; ( 1ULL &lt;&lt; __sz ) - 1;
        else
            <span class="gs">__t[__</span>i] = static_cast&lt;__storage_type&gt;(__v);

    std::__1::copy(__t, <span class="gs">__t + sizeof(__</span>t)/sizeof(__t[0]), __first_);
    std::__1::fill(__first_ + sizeof(__t)/sizeof(__t[0]), __first_ + sizeof(__first_)/sizeof(__first_[0]),
               __storage_type(0));
}

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
void
__bitset&lt;_N_words, <span class="ge">_Size&gt;::__init(unsigned long long __v, true_</span>type) throw()
{
    __first_[0] = __v;
    if (<span class="ge">_Size &lt; __bits_</span>per_word)
        __first_[0] &amp;= ( 1ULL &lt;&lt; _Size ) - 1;

    std::__1::fill(__first_ + 1, __first_ + sizeof(__first_)/sizeof(__first_[0]), __storage_type(0));
}



template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
inline

__bitset&lt;_N_words, <span class="ge">_Size&gt;::__bitset(unsigned long long _</span>_v) throw()
{

    <span class="gs">__init(__</span>v, integral_constant&lt;bool, sizeof(unsigned long long) == sizeof(__storage_type)&gt;());

}

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
inline
void
__bitset&lt;_N_words, <span class="ge">_Size&gt;::operator&amp;=(const __bitset&amp; _</span>_v) throw()
{
    for (size_type <span class="gs">__i = 0; __</span>i &lt; <span class="ge">_N_</span>words; ++__i)
        __first_[__i] &amp;= <span class="gs">__v.__</span>first_[__i];
}

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
inline
void
__bitset&lt;_N_words, <span class="ge">_Size&gt;::operator|=(const __bitset&amp; _</span>_v) throw()
{
    for (size_type <span class="gs">__i = 0; __</span>i &lt; <span class="ge">_N_</span>words; ++__i)
        __first_[__i] |= <span class="gs">__v.__</span>first_[__i];
}

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
inline
void
__bitset&lt;_N_words, <span class="ge">_Size&gt;::operator^=(const __bitset&amp; _</span>_v) throw()
{
    for (size_type <span class="gs">__i = 0; __</span>i &lt; <span class="ge">_N_</span>words; ++__i)
        __first_[__i] ^= <span class="gs">__v.__</span>first_[__i];
}

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
void
__bitset&lt;_N_words, _Size&gt;::flip() throw()
{

    size_type __n = _Size;
    __storage_pointer <span class="gs">__p = __</span>first_;
    for (; <span class="gs">__n &gt;= __</span>bits_per_word; ++__p, <span class="gs">__n -= __</span>bits_per_word)
        <span class="ge">*__p = ~*</span>__p;

    if (__n &gt; 0)
    {
        __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
        __storage_type <span class="gs">__b = *__</span>p &amp; __m;
        *<span class="gs">__p &amp;= ~__</span>m;
        *<span class="gs">__p |= ~__</span>b &amp; __m;
    }
}

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
unsigned long
__bitset&lt;_N_words, <span class="ge">_Size&gt;::to_</span>ulong(false_type) const
{
    const_iterator <span class="gs">__e = __</span>make_iter(_Size);
    const_iterator <span class="gs">__i = std::__</span>1::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
    if (<span class="gs">__i != __</span>e)
        __throw_overflow_error(&quot;bitset to_ulong overflow error&quot;);

    return __first_[0];
}

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
inline
unsigned long
__bitset&lt;_N_words, <span class="ge">_Size&gt;::to_</span>ulong(true_type) const
{
    return __first_[0];
}

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
unsigned long long
__bitset&lt;_N_words, <span class="ge">_Size&gt;::to_</span>ullong(false_type) const
{
    const_iterator <span class="gs">__e = __</span>make_iter(_Size);
    const_iterator <span class="gs">__i = std::__</span>1::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
    if (<span class="gs">__i != __</span>e)
        __throw_overflow_error(&quot;bitset to_ullong overflow error&quot;);

    return to_ullong(true_type());
}

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
inline
unsigned long long
__bitset&lt;_N_words, <span class="ge">_Size&gt;::to_</span>ullong(true_type) const
{
    return to_ullong(true_type(), integral_constant&lt;bool, sizeof(__storage_type) &lt; sizeof(unsigned long long)&gt;());
}

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
inline
unsigned long long
__bitset&lt;_N_words, <span class="ge">_Size&gt;::to_</span>ullong(true_type, false_type) const
{
    return __first_[0];
}

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
unsigned long long
__bitset&lt;_N_words, <span class="ge">_Size&gt;::to_</span>ullong(true_type, true_type) const
{
    unsigned long long <span class="gs">__r = __</span>first_[0];
    for (std::size_t <span class="gs">__i = 1; __</span>i &lt; sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
        __r |= static_cast&lt;unsigned long long&gt;(__first_[__i]) &lt;&lt; (sizeof(__storage_type) * 8);
    return __r;
}

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
bool
__bitset&lt;_N_words, _Size&gt;::all() const throw()
{

    size_type __n = _Size;
    __const_storage_pointer <span class="gs">__p = __</span>first_;
    for (; <span class="gs">__n &gt;= __</span>bits_per_word; ++__p, <span class="gs">__n -= __</span>bits_per_word)
        if (~*__p)
            return false;

    if (__n &gt; 0)
    {
        __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
        if (~*__p &amp; __m)
            return false;
    }
    return true;
}

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
bool
__bitset&lt;_N_words, _Size&gt;::any() const throw()
{

    size_type __n = _Size;
    __const_storage_pointer <span class="gs">__p = __</span>first_;
    for (; <span class="gs">__n &gt;= __</span>bits_per_word; ++__p, <span class="gs">__n -= __</span>bits_per_word)
        if (*__p)
            return true;

    if (__n &gt; 0)
    {
        __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - __n);
        if (*__p &amp; __m)
            return true;
    }
    return false;
}

template &lt;size_t <span class="ge">_N_</span>words, size_t _Size&gt;
inline
size_t
__bitset&lt;_N_words, <span class="ge">_Size&gt;::__hash_</span>code() const throw()
{
    size_t __h = 0;
    for (size_type <span class="gs">__i = 0; __</span>i &lt; <span class="ge">_N_</span>words; ++__i)
        <span class="gs">__h ^= __</span>first_[__i];
    return __h;
}

template &lt;size_t _Size&gt;
class __bitset&lt;1, _Size&gt;
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef <span class="gs">__bitset __</span>self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast&lt;unsigned&gt;(sizeof(__storage_type) * 8);

    friend class __bit_reference&lt;__bitset&gt;;
    friend class __bit_const_reference&lt;__bitset&gt;;
    friend class __bit_iterator&lt;__bitset, false&gt;;
    friend class __bit_iterator&lt;__bitset, true&gt;;
    friend struct __bit_array&lt;__bitset&gt;;

    __storage_type __first_;

    typedef __bit_reference&lt;__bitset&gt; reference;
    typedef __bit_const_reference&lt;__bitset&gt; const_reference;
    typedef __bit_iterator&lt;__bitset, false&gt; iterator;
    typedef __bit_iterator&lt;__bitset, true&gt; const_iterator;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                      __bitset() throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit <span class="gs">__bitset(unsigned long long __</span>v) throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) reference __make_ref(size_t __pos) throw()
        {return reference(&amp;__first_, __storage_type(1) &lt;&lt; __pos);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) const_reference __make_ref(size_t __pos) const throw()
        {return const_reference(&amp;__first_, __storage_type(1) &lt;&lt; __pos);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) iterator __make_iter(size_t __pos) throw()
        {return iterator(&amp;__first_ + <span class="gs">__pos / __</span>bits_per_word, <span class="gs">__pos % __</span>bits_per_word);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) const_iterator __make_iter(size_t __pos) const throw()
        {return const_iterator(&amp;__first_ + <span class="gs">__pos / __</span>bits_per_word, <span class="gs">__pos % __</span>bits_per_word);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void operator&amp;=(const <span class="gs">__bitset&amp; __</span>v) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void operator|=(const <span class="gs">__bitset&amp; __</span>v) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void operator^=(const <span class="gs">__bitset&amp; __</span>v) throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void flip() throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    unsigned long to_ulong() const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    unsigned long long to_ullong() const;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool all() const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool any() const throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t __hash_code() const throw();
};

template &lt;size_t _Size&gt;
inline

__bitset&lt;1, <span class="ge">_Size&gt;::_</span>_bitset() throw()
    : __first_(0)
{
}

template &lt;size_t _Size&gt;
inline

__bitset&lt;1, <span class="ge">_Size&gt;::__bitset(unsigned long long _</span>_v) throw()
    : __first_(
        <span class="ge">_Size == __bits_</span>per_word ? static_cast&lt;__storage_type&gt;(__v)
                                 : static_cast&lt;__storage_type&gt;(__v) &amp; ((__storage_type(1) &lt;&lt; _Size) - 1)
    )
{
}

template &lt;size_t _Size&gt;
inline
void
__bitset&lt;1, <span class="ge">_Size&gt;::operator&amp;=(const __bitset&amp; _</span>_v) throw()
{
    __first_ &amp;= <span class="gs">__v.__</span>first_;
}

template &lt;size_t _Size&gt;
inline
void
__bitset&lt;1, <span class="ge">_Size&gt;::operator|=(const __bitset&amp; _</span>_v) throw()
{
    __first_ |= <span class="gs">__v.__</span>first_;
}

template &lt;size_t _Size&gt;
inline
void
__bitset&lt;1, <span class="ge">_Size&gt;::operator^=(const __bitset&amp; _</span>_v) throw()
{
    __first_ ^= <span class="gs">__v.__</span>first_;
}

template &lt;size_t _Size&gt;
inline
void
__bitset&lt;1, _Size&gt;::flip() throw()
{
    __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - _Size);
    __first_ = ~__first_;
    __first_ &amp;= __m;
}

template &lt;size_t _Size&gt;
inline
unsigned long
__bitset&lt;1, <span class="ge">_Size&gt;::to_</span>ulong() const
{
    return __first_;
}

template &lt;size_t _Size&gt;
inline
unsigned long long
__bitset&lt;1, <span class="ge">_Size&gt;::to_</span>ullong() const
{
    return __first_;
}

template &lt;size_t _Size&gt;
inline
bool
__bitset&lt;1, _Size&gt;::all() const throw()
{
    __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - _Size);
    return !(~__first_ &amp; __m);
}

template &lt;size_t _Size&gt;
inline
bool
__bitset&lt;1, _Size&gt;::any() const throw()
{
    __storage_type <span class="gs">__m = ~__</span>storage_type(0) &gt;&gt; (__bits_per_word - _Size);
    return __first_ &amp; __m;
}

template &lt;size_t _Size&gt;
inline
size_t
__bitset&lt;1, <span class="ge">_Size&gt;::__hash_</span>code() const throw()
{
    return __first_;
}

template &lt;&gt;
class __bitset&lt;0, 0&gt;
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef <span class="gs">__bitset __</span>self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast&lt;unsigned&gt;(sizeof(__storage_type) * 8);

    friend class __bit_reference&lt;__bitset&gt;;
    friend class __bit_const_reference&lt;__bitset&gt;;
    friend class __bit_iterator&lt;__bitset, false&gt;;
    friend class __bit_iterator&lt;__bitset, true&gt;;
    friend struct __bit_array&lt;__bitset&gt;;

    typedef __bit_reference&lt;__bitset&gt; reference;
    typedef __bit_const_reference&lt;__bitset&gt; const_reference;
    typedef __bit_iterator&lt;__bitset, false&gt; iterator;
    typedef __bit_iterator&lt;__bitset, true&gt; const_iterator;

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                      __bitset() throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit __bitset(unsigned long long) throw();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) reference __make_ref(size_t) throw()
        {return reference(0, 1);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) const_reference __make_ref(size_t) const throw()
        {return const_reference(0, 1);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) iterator __make_iter(size_t) throw()
        {return iterator(0, 0);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) const_iterator __make_iter(size_t) const throw()
        {return const_iterator(0, 0);}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void operator&amp;=(const __bitset&amp;) throw() {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void operator|=(const __bitset&amp;) throw() {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void operator^=(const __bitset&amp;) throw() {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) void flip() throw() {}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) unsigned long to_ulong() const {return 0;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) unsigned long long to_ullong() const {return 0;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool all() const throw() {return true;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool any() const throw() {return false;}

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) size_t __hash_code() const throw() {return 0;}
};

inline

<span class="gs">__bitset&lt;0, 0&gt;::__</span>bitset() throw()
{
}

inline

<span class="gs">__bitset&lt;0, 0&gt;::__</span>bitset(unsigned long long) throw()
{
}

template &lt;size_t <span class="ge">_Size&gt; class __attribute_</span>_ ((__type_visibility__(&quot;default&quot;))) bitset;
template &lt;size_t <span class="ge">_Size&gt; struct hash&lt;bitset&lt;_</span>Size&gt; &gt;;

template &lt;size_t _Size&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) bitset
    : private __bitset&lt;_Size == 0 ? 0 : (<span class="ge">_Size - 1) / (sizeof(size_</span>t) * 8) + 1, _Size&gt;
{
public:
    static const unsigned __n_words = <span class="ge">_Size == 0 ? 0 : (_</span>Size - 1) / (sizeof(size_t) * 8) + 1;
    typedef <span class="gs">__bitset&lt;__</span>n<span class="ge">_words, _</span>Size&gt; base;

public:
    typedef typename base::reference reference;
    typedef typename base::const_reference const_reference;


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bitset() throw() {}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        bitset(unsigned long long <span class="gs">__v) throw() : base(__</span>v) {}
    template&lt;class <span class="ge">_CharT, class = _</span>EnableIf&lt;_IsCharLikeType&lt;_CharT&gt;::value&gt; &gt;
        explicit bitset(const <span class="ge">_CharT* _</span>_str,
                        typename basic_string&lt;_CharT&gt;::size_type __n = basic_string&lt;_CharT&gt;::npos,
                        <span class="ge">_CharT __zero = _</span>CharT(&#39;0&#39;), <span class="ge">_CharT __one = _</span>CharT(&#39;1&#39;));
    template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
        explicit bitset(const basic_string&lt;_CharT,_Traits,_Allocator&gt;&amp; __str,
                        typename basic_string&lt;_CharT,_Traits,_Allocator&gt;::size_type __pos = 0,
                        typename basic_string&lt;_CharT,_Traits,_Allocator&gt;::size_type __n =
                                (basic_string&lt;_CharT,_Traits,_Allocator&gt;::npos),
                        <span class="ge">_CharT __zero = _</span>CharT(&#39;0&#39;), <span class="ge">_CharT __one = _</span>CharT(&#39;1&#39;));


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bitset&amp; operator&amp;=(const bitset&amp; __rhs) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bitset&amp; operator|=(const bitset&amp; __rhs) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bitset&amp; operator^=(const bitset&amp; __rhs) throw();
    bitset&amp; operator&lt;&lt;=(size_t __pos) throw();
    bitset&amp; operator&gt;&gt;=(size_t __pos) throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bitset&amp; set() throw();
    bitset&amp; set(size_t <span class="gs">__pos, bool __</span>val = true);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bitset&amp; reset() throw();
    bitset&amp; reset(size_t __pos);
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bitset operator~() const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bitset&amp; flip() throw();
    bitset&amp; flip(size_t __pos);


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                              const_reference operator[](size_t <span class="gs">__p) const {return base::__</span>make_ref(__p);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) reference operator[](size_t <span class="gs">__p) {return base::__</span>make_ref(__p);}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    unsigned long to_ulong() const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    unsigned long long to_ullong() const;
    template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
        basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt; to_string(_CharT __zero = _CharT(&#39;0&#39;),
                                                            <span class="ge">_CharT __one = _</span>CharT(&#39;1&#39;)) const;
    template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        basic_string&lt;_CharT, <span class="ge">_Traits, allocator&lt;_</span>CharT&gt; &gt; to_string(_CharT __zero = _CharT(&#39;0&#39;),
                                                                    <span class="ge">_CharT __one = _</span>CharT(&#39;1&#39;)) const;
    template &lt;class _CharT&gt;
        <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
        basic_string&lt;_CharT, char_traits&lt;_CharT&gt;, allocator&lt;_CharT&gt; &gt; to_string(_CharT __zero = _CharT(&#39;0&#39;),
                                                                                <span class="ge">_CharT __one = _</span>CharT(&#39;1&#39;)) const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt; to_string(char __zero = &#39;0&#39;,
                                                                      char __one = &#39;1&#39;) const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t count() const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) size_t size() const throw() {return _Size;}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator==(const bitset&amp; __rhs) const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool operator!=(const bitset&amp; __rhs) const throw();
    bool test(size_t __pos) const;
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool all() const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bool any() const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage)) bool none() const throw() {return !any();}
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bitset operator&lt;&lt;(size_t __pos) const throw();
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    bitset operator&gt;&gt;(size_t __pos) const throw();

private:

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t __hash_code() const throw() {return base::__hash_code();}

    friend struct hash&lt;bitset&gt;;
};

template &lt;size_t _Size&gt;
template&lt;class _CharT, class&gt;
bitset&lt;_Size&gt;::bitset(const <span class="ge">_CharT* _</span>_str,
                      typename basic_string&lt;_CharT&gt;::size_type __n,
                      <span class="ge">_CharT __zero, _</span>CharT __one)
{
    size_t <span class="gs">__rlen = std::__</span>1::min(__n, char_traits&lt;_CharT&gt;::length(__str));
    for (size_t <span class="gs">__i = 0; __</span>i &lt; <span class="gs">__rlen; ++__</span>i)
        if (<span class="gs">__str[__</span>i] != <span class="gs">__zero &amp;&amp; __</span>str[__i] != __one)
            __throw_invalid_argument(&quot;bitset string ctor has invalid argument&quot;);

    size_t <span class="ge">_Mp = std::__1::min(__rlen, _</span>Size);
    size_t __i = 0;
    for (; __i &lt; <span class="ge">_Mp; ++_</span>_i)
    {
        <span class="ge">_CharT __c = __str[_</span>Mp - 1 - __i];
        if (<span class="gs">__c == __</span>zero)
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template &lt;size_t _Size&gt;
template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
bitset&lt;_Size&gt;::bitset(const basic_string&lt;_CharT,_Traits,_Allocator&gt;&amp; __str,
       typename basic_string&lt;_CharT,_Traits,_Allocator&gt;::size_type __pos,
       typename basic_string&lt;_CharT,_Traits,_Allocator&gt;::size_type __n,
       <span class="ge">_CharT __zero, _</span>CharT __one)
{
    if (<span class="gs">__pos &gt; __</span>str.size())
        __throw_out_of_range(&quot;bitset string pos out of range&quot;);

    size_t <span class="gs">__rlen = std::__</span>1::min(__n, <span class="gs">__str.size() - __</span>pos);
    for (size_t <span class="gs">__i = __</span>pos; <span class="gs">__i &lt; __</span>pos + <span class="gs">__rlen; ++__</span>i)
        if (!_Traits::eq(__str[__i], __zero) &amp;&amp; !<span class="ge">_Traits::eq(__str[__i], _</span>_one))
            __throw_invalid_argument(&quot;bitset string ctor has invalid argument&quot;);

    size_t <span class="ge">_Mp = std::__1::min(__rlen, _</span>Size);
    size_t __i = 0;
    for (; __i &lt; <span class="ge">_Mp; ++_</span>_i)
    {
        <span class="ge">_CharT __c = __str[__pos + _</span>Mp - 1 - __i];
        if (<span class="ge">_Traits::eq(__c, _</span>_zero))
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template &lt;size_t _Size&gt;
inline
bitset&lt;_Size&gt;&amp;
bitset&lt;_Size&gt;::operator&amp;=(const bitset&amp; __rhs) throw()
{
    base::operator&amp;=(__rhs);
    return *this;
}

template &lt;size_t _Size&gt;
inline
bitset&lt;_Size&gt;&amp;
bitset&lt;_Size&gt;::operator|=(const bitset&amp; __rhs) throw()
{
    base::operator|=(__rhs);
    return *this;
}

template &lt;size_t _Size&gt;
inline
bitset&lt;_Size&gt;&amp;
bitset&lt;_Size&gt;::operator^=(const bitset&amp; __rhs) throw()
{
    base::operator^=(__rhs);
    return *this;
}

template &lt;size_t _Size&gt;
bitset&lt;_Size&gt;&amp;
bitset&lt;_Size&gt;::operator&lt;&lt;=(size_t __pos) throw()
{
    <span class="gs">__pos = std::__</span>1::min(__pos, _Size);
    std::__1::copy_backward(base::__make_iter(0), base::__make_iter(_Size - <span class="gs">__pos), base::__</span>make_iter(_Size));
    std::__1::fill_n(base::__make_iter(0), __pos, false);
    return *this;
}

template &lt;size_t _Size&gt;
bitset&lt;_Size&gt;&amp;
bitset&lt;_Size&gt;::operator&gt;&gt;=(size_t __pos) throw()
{
    <span class="gs">__pos = std::__</span>1::min(__pos, _Size);
    std::__1::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
    std::__1::fill_n(base::__make_iter(_Size - <span class="gs">__pos), __</span>pos, false);
    return *this;
}

template &lt;size_t _Size&gt;
inline
bitset&lt;_Size&gt;&amp;
bitset&lt;_Size&gt;::set() throw()
{
    std::__1::fill_n(base::__make_iter(0), _Size, true);
    return *this;
}

template &lt;size_t _Size&gt;
bitset&lt;_Size&gt;&amp;
bitset&lt;_Size&gt;::set(size_t <span class="gs">__pos, bool __</span>val)
{
    if (__pos &gt;= _Size)
        __throw_out_of_range(&quot;bitset set argument out of range&quot;);

    (*this)[__pos] = __val;
    return *this;
}

template &lt;size_t _Size&gt;
inline
bitset&lt;_Size&gt;&amp;
bitset&lt;_Size&gt;::reset() throw()
{
    std::__1::fill_n(base::__make_iter(0), _Size, false);
    return *this;
}

template &lt;size_t _Size&gt;
bitset&lt;_Size&gt;&amp;
bitset&lt;_Size&gt;::reset(size_t __pos)
{
    if (__pos &gt;= _Size)
        __throw_out_of_range(&quot;bitset reset argument out of range&quot;);

    (*this)[__pos] = false;
    return *this;
}

template &lt;size_t _Size&gt;
inline
bitset&lt;_Size&gt;
bitset&lt;_Size&gt;::operator~() const throw()
{
    bitset __x(*this);
    __x.flip();
    return __x;
}

template &lt;size_t _Size&gt;
inline
bitset&lt;_Size&gt;&amp;
bitset&lt;_Size&gt;::flip() throw()
{
    base::flip();
    return *this;
}

template &lt;size_t _Size&gt;
bitset&lt;_Size&gt;&amp;
bitset&lt;_Size&gt;::flip(size_t __pos)
{
    if (__pos &gt;= _Size)
        __throw_out_of_range(&quot;bitset flip argument out of range&quot;);

    reference r = base::__make_ref(__pos);
    r = ~r;
    return *this;
}

template &lt;size_t _Size&gt;
inline
unsigned long
bitset&lt;_Size&gt;::to_ulong() const
{
    return base::to_ulong();
}

template &lt;size_t _Size&gt;
inline
unsigned long long
bitset&lt;_Size&gt;::to_ullong() const
{
    return base::to_ullong();
}

template &lt;size_t _Size&gt;
template &lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;
bitset&lt;_Size&gt;::to_string(_CharT __zero, <span class="ge">_CharT _</span>_one) const
{
    basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt; __r(_Size, __zero);
    for (size_t <span class="gs">__i = 0; __</span>i &lt; <span class="ge">_Size; ++_</span>_i)
    {
        if ((*this)[__i])
            __r[_Size - 1 - <span class="gs">__i] = __</span>one;
    }
    return __r;
}

template &lt;size_t _Size&gt;
template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline
basic_string&lt;_CharT, <span class="ge">_Traits, allocator&lt;_</span>CharT&gt; &gt;
bitset&lt;_Size&gt;::to_string(_CharT __zero, <span class="ge">_CharT _</span>_one) const
{
    return to_string&lt;_CharT, <span class="ge">_Traits, allocator&lt;_</span>CharT&gt; &gt;(__zero, __one);
}

template &lt;size_t _Size&gt;
template &lt;class _CharT&gt;
inline
basic_string&lt;_CharT, char_traits&lt;_CharT&gt;, allocator&lt;_CharT&gt; &gt;
bitset&lt;_Size&gt;::to_string(_CharT __zero, <span class="ge">_CharT _</span>_one) const
{
    return to_string&lt;_CharT, char_traits&lt;_CharT&gt;, allocator&lt;_CharT&gt; &gt;(__zero, __one);
}

template &lt;size_t _Size&gt;
inline
basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt;
bitset&lt;_Size&gt;::to_string(char <span class="gs">__zero, char __</span>one) const
{
    return to_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt;(__zero, __one);
}

template &lt;size_t _Size&gt;
inline
size_t
bitset&lt;_Size&gt;::count() const throw()
{
    return static_cast&lt;size_t&gt;(__count_bool_true(base::__make_iter(0), _Size));
}

template &lt;size_t _Size&gt;
inline
bool
bitset&lt;_Size&gt;::operator==(const bitset&amp; __rhs) const throw()
{
    return std::__1::equal(base::__make_iter(0), base::__make_iter(_Size), <span class="gs">__rhs.__</span>make_iter(0));
}

template &lt;size_t _Size&gt;
inline
bool
bitset&lt;_Size&gt;::operator!=(const bitset&amp; __rhs) const throw()
{
    return !(*this == __rhs);
}

template &lt;size_t _Size&gt;
bool
bitset&lt;_Size&gt;::test(size_t __pos) const
{
    if (__pos &gt;= _Size)
        __throw_out_of_range(&quot;bitset test argument out of range&quot;);

    return (*this)[__pos];
}

template &lt;size_t _Size&gt;
inline
bool
bitset&lt;_Size&gt;::all() const throw()
{
    return base::all();
}

template &lt;size_t _Size&gt;
inline
bool
bitset&lt;_Size&gt;::any() const throw()
{
    return base::any();
}

template &lt;size_t _Size&gt;
inline
bitset&lt;_Size&gt;
bitset&lt;_Size&gt;::operator&lt;&lt;(size_t __pos) const throw()
{
    bitset __r = *this;
    <span class="gs">__r &lt;&lt;= __</span>pos;
    return __r;
}

template &lt;size_t _Size&gt;
inline
bitset&lt;_Size&gt;
bitset&lt;_Size&gt;::operator&gt;&gt;(size_t __pos) const throw()
{
    bitset __r = *this;
    <span class="gs">__r &gt;&gt;= __</span>pos;
    return __r;
}

template &lt;size_t _Size&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bitset&lt;_Size&gt;
operator&amp;(const bitset&lt;_Size&gt;&amp; __x, const bitset&lt;_Size&gt;&amp; __y) throw()
{
    bitset&lt;_Size&gt; <span class="gs">__r = __</span>x;
    <span class="gs">__r &amp;= __</span>y;
    return __r;
}

template &lt;size_t _Size&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bitset&lt;_Size&gt;
operator|(const bitset&lt;_Size&gt;&amp; __x, const bitset&lt;_Size&gt;&amp; __y) throw()
{
    bitset&lt;_Size&gt; <span class="gs">__r = __</span>x;
    <span class="gs">__r |= __</span>y;
    return __r;
}

template &lt;size_t _Size&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
bitset&lt;_Size&gt;
operator^(const bitset&lt;_Size&gt;&amp; __x, const bitset&lt;_Size&gt;&amp; __y) throw()
{
    bitset&lt;_Size&gt; <span class="gs">__r = __</span>x;
    <span class="gs">__r ^= __</span>y;
    return __r;
}

template &lt;size_t _Size&gt;
struct <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) hash&lt;bitset&lt;_Size&gt; &gt;
    : public unary_function&lt;bitset&lt;_Size&gt;, size_t&gt;
{
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    size_t operator()(const bitset&lt;_Size&gt;&amp; __bs) const throw()
        {return <span class="gs">__bs.__</span>hash_code();}
};

template &lt;class <span class="ge">_CharT, class _</span>Traits, size_t _Size&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __is, bitset&lt;_</span>Size&gt;&amp; __x);

template &lt;class <span class="ge">_CharT, class _</span>Traits, size_t _Size&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __os, const bitset&lt;_</span>Size&gt;&amp; __x);

} }


namespace std { inline namespace __1 {

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_ostream
    : virtual public basic_ios&lt;_CharT, _Traits&gt;
{
public:

    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_Traits traits_</span>type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit basic_ostream(basic_streambuf&lt;char_type, traits_type&gt;* __sb)
    { this-&gt;init(__sb); }
    virtual ~basic_ostream();
protected:
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void swap(basic_ostream&amp; __rhs)
    { basic_ios&lt;char_type, traits_type&gt;::swap(__rhs); }





    basic_ostream (const basic_ostream&amp; __rhs);
    basic_ostream&amp; operator=(const basic_ostream&amp; __rhs);

public:


    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) sentry;


    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_ostream&amp; operator&lt;&lt;(basic_ostream&amp; (*__pf)(basic_ostream&amp;))
    { return __pf(*this); }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_ostream&amp; operator&lt;&lt;(basic_ios&lt;char_type, traits_type&gt;&amp;
                              (*__pf)(basic_ios&lt;char_type,traits_type&gt;&amp;))
    { __pf(*this); return *this; }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_ostream&amp; operator&lt;&lt;(ios_base&amp; (*__pf)(ios_base&amp;))
    { __pf(*this); return *this; }

    basic_ostream&amp; operator&lt;&lt;(bool __n);
    basic_ostream&amp; operator&lt;&lt;(short __n);
    basic_ostream&amp; operator&lt;&lt;(unsigned short __n);
    basic_ostream&amp; operator&lt;&lt;(int __n);
    basic_ostream&amp; operator&lt;&lt;(unsigned int __n);
    basic_ostream&amp; operator&lt;&lt;(long __n);
    basic_ostream&amp; operator&lt;&lt;(unsigned long __n);
    basic_ostream&amp; operator&lt;&lt;(long long __n);
    basic_ostream&amp; operator&lt;&lt;(unsigned long long __n);
    basic_ostream&amp; operator&lt;&lt;(float __f);
    basic_ostream&amp; operator&lt;&lt;(double __f);
    basic_ostream&amp; operator&lt;&lt;(long double __f);
    basic_ostream&amp; operator&lt;&lt;(const void* __p);
    basic_ostream&amp; operator&lt;&lt;(basic_streambuf&lt;char_type, traits_type&gt;* __sb);

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_ostream&amp; operator&lt;&lt;(nullptr_t)
    { return *this &lt;&lt; &quot;nullptr&quot;; }


    basic_ostream&amp; put(char_type __c);
    basic_ostream&amp; write(const char_type* <span class="gs">__s, streamsize __</span>n);
    basic_ostream&amp; flush();


    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    pos_type tellp();
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_ostream&amp; seekp(pos_type __pos);
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_ostream&amp; seekp(off_type __off, ios_base::seekdir __dir);

protected:
    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_ostream() {}
};

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_ostream&lt;_CharT, _Traits&gt;::sentry
{
    bool __ok_;
    basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __os_</span>;

    sentry(const sentry&amp;);
    sentry&amp; operator=(const sentry&amp;);

public:
    explicit sentry(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_os);
    ~sentry();

    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

        operator bool() const {return __ok_;}
};

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::sentry::sentry(basic_</span>ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_os)
    : __ok_(false),
      __os_(__os)
{
    if (__os.good())
    {
        if (__os.tie())
            __os.tie()-&gt;flush();
        __ok_ = true;
    }
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;::sentry::~sentry()
{
    if (__os_.rdbuf() &amp;&amp; __os_.good() &amp;&amp; (__os_.flags() &amp; ios_base::unitbuf)
                      &amp;&amp; !uncaught_exception())
    {

        try
        {

            if (__os_.rdbuf()-&gt;pubsync() == -1)
                __os_.setstate(ios_base::badbit);

        }
        catch (...)
        {
        }

    }
}
template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::~basic_</span>ostream()
{
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::operator&lt;&lt;(basic_</span>streambuf&lt;char_type, traits_type&gt;* __sb)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            if (__sb)
            {

                try
                {

                    typedef istreambuf_iterator&lt;_CharT, <span class="ge">_Traits&gt; _</span>Ip;
                    typedef ostreambuf_iterator&lt;_CharT, <span class="ge">_Traits&gt; _</span>Op;
                    <span class="ge">_Ip __i(_</span>_sb);
                    <span class="ge">_Ip _</span>_eof;
                    <span class="ge">_Op _</span>_o(*this);
                    size_t __c = 0;
                    for (; <span class="gs">__i != __</span>eof; ++__i, ++__o, ++__c)
                    {
                        <span class="ge">*__o = *</span>__i;
                        if (__o.failed())
                            break;
                    }
                    if (__c == 0)
                        this-&gt;setstate(ios_base::failbit);

                }
                catch (...)
                {
                    this-&gt;__set_failbit_and_consider_rethrow();
                }

            }
            else
                this-&gt;setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::operator&lt;&lt;(bool _</span>_n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put&lt;char_type, ostreambuf_iterator&lt;char_type, traits_type&gt; &gt; _Fp;
            const <span class="ge">_Fp&amp; __f = use_</span>facet&lt;_Fp&gt;(this-&gt;getloc());
            if (<span class="gs">__f.put(*this, *this, this-&gt;fill(), __</span>n).failed())
                this-&gt;setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::operator&lt;&lt;(short _</span>_n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() &amp; ios_base::basefield;
            typedef num_put&lt;char_type, ostreambuf_iterator&lt;char_type, traits_type&gt; &gt; _Fp;
            const <span class="ge">_Fp&amp; __f = use_</span>facet&lt;_Fp&gt;(this-&gt;getloc());
            if (__f.put(*this, *this, this-&gt;fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast&lt;long&gt;(static_cast&lt;unsigned short&gt;(__n)) :
                        static_cast&lt;long&gt;(__n)).failed())
                this-&gt;setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::operator&lt;&lt;(unsigned short _</span>_n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put&lt;char_type, ostreambuf_iterator&lt;char_type, traits_type&gt; &gt; _Fp;
            const <span class="ge">_Fp&amp; __f = use_</span>facet&lt;_Fp&gt;(this-&gt;getloc());
            if (__f.put(*this, *this, this-&gt;fill(), static_cast&lt;unsigned long&gt;(__n)).failed())
                this-&gt;setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::operator&lt;&lt;(int _</span>_n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() &amp; ios_base::basefield;
            typedef num_put&lt;char_type, ostreambuf_iterator&lt;char_type, traits_type&gt; &gt; _Fp;
            const <span class="ge">_Fp&amp; __f = use_</span>facet&lt;_Fp&gt;(this-&gt;getloc());
            if (__f.put(*this, *this, this-&gt;fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast&lt;long&gt;(static_cast&lt;unsigned int&gt;(__n)) :
                        static_cast&lt;long&gt;(__n)).failed())
                this-&gt;setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::operator&lt;&lt;(unsigned int _</span>_n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put&lt;char_type, ostreambuf_iterator&lt;char_type, traits_type&gt; &gt; _Fp;
            const <span class="ge">_Fp&amp; __f = use_</span>facet&lt;_Fp&gt;(this-&gt;getloc());
            if (__f.put(*this, *this, this-&gt;fill(), static_cast&lt;unsigned long&gt;(__n)).failed())
                this-&gt;setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::operator&lt;&lt;(long _</span>_n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put&lt;char_type, ostreambuf_iterator&lt;char_type, traits_type&gt; &gt; _Fp;
            const <span class="ge">_Fp&amp; __f = use_</span>facet&lt;_Fp&gt;(this-&gt;getloc());
            if (<span class="gs">__f.put(*this, *this, this-&gt;fill(), __</span>n).failed())
                this-&gt;setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::operator&lt;&lt;(unsigned long _</span>_n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put&lt;char_type, ostreambuf_iterator&lt;char_type, traits_type&gt; &gt; _Fp;
            const <span class="ge">_Fp&amp; __f = use_</span>facet&lt;_Fp&gt;(this-&gt;getloc());
            if (<span class="gs">__f.put(*this, *this, this-&gt;fill(), __</span>n).failed())
                this-&gt;setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::operator&lt;&lt;(long long _</span>_n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put&lt;char_type, ostreambuf_iterator&lt;char_type, traits_type&gt; &gt; _Fp;
            const <span class="ge">_Fp&amp; __f = use_</span>facet&lt;_Fp&gt;(this-&gt;getloc());
            if (<span class="gs">__f.put(*this, *this, this-&gt;fill(), __</span>n).failed())
                this-&gt;setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::operator&lt;&lt;(unsigned long long _</span>_n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put&lt;char_type, ostreambuf_iterator&lt;char_type, traits_type&gt; &gt; _Fp;
            const <span class="ge">_Fp&amp; __f = use_</span>facet&lt;_Fp&gt;(this-&gt;getloc());
            if (<span class="gs">__f.put(*this, *this, this-&gt;fill(), __</span>n).failed())
                this-&gt;setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::operator&lt;&lt;(float _</span>_n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put&lt;char_type, ostreambuf_iterator&lt;char_type, traits_type&gt; &gt; _Fp;
            const <span class="ge">_Fp&amp; __f = use_</span>facet&lt;_Fp&gt;(this-&gt;getloc());
            if (__f.put(*this, *this, this-&gt;fill(), static_cast&lt;double&gt;(__n)).failed())
                this-&gt;setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::operator&lt;&lt;(double _</span>_n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put&lt;char_type, ostreambuf_iterator&lt;char_type, traits_type&gt; &gt; _Fp;
            const <span class="ge">_Fp&amp; __f = use_</span>facet&lt;_Fp&gt;(this-&gt;getloc());
            if (<span class="gs">__f.put(*this, *this, this-&gt;fill(), __</span>n).failed())
                this-&gt;setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::operator&lt;&lt;(long double _</span>_n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put&lt;char_type, ostreambuf_iterator&lt;char_type, traits_type&gt; &gt; _Fp;
            const <span class="ge">_Fp&amp; __f = use_</span>facet&lt;_Fp&gt;(this-&gt;getloc());
            if (<span class="gs">__f.put(*this, *this, this-&gt;fill(), __</span>n).failed())
                this-&gt;setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::operator&lt;&lt;(const void* _</span>_n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put&lt;char_type, ostreambuf_iterator&lt;char_type, traits_type&gt; &gt; _Fp;
            const <span class="ge">_Fp&amp; __f = use_</span>facet&lt;_Fp&gt;(this-&gt;getloc());
            if (<span class="gs">__f.put(*this, *this, this-&gt;fill(), __</span>n).failed())
                this-&gt;setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
__put_character_sequence(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_os,
                          const <span class="ge">_CharT* __str, size_</span>t __len)
{

    try
    {

        typename basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::sentry __s(_</span>_os);
        if (__s)
        {
            typedef ostreambuf_iterator&lt;_CharT, <span class="ge">_Traits&gt; _</span>Ip;
            if (__pad_and_output(_Ip(__os),
                                 __str,
                                 (__os.flags() &amp; ios_base::adjustfield) == ios_base::left ?
                                     <span class="gs">__str + __</span>len :
                                     __str,
                                 <span class="gs">__str + __</span>len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        <span class="gs">__os.__</span>set_badbit_and_consider_rethrow();
    }

    return __os;
}


template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __os, _</span>CharT __c)
{
    return std::__1::__put_character_sequence(__os, &amp;__c, 1);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __os, char _</span>_cn)
{

    try
    {

        typename basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::sentry __s(_</span>_os);
        if (__s)
        {
            <span class="ge">_CharT __c = __os.widen(_</span>_cn);
            typedef ostreambuf_iterator&lt;_CharT, <span class="ge">_Traits&gt; _</span>Ip;
            if (__pad_and_output(_Ip(__os),
                                 &amp;__c,
                                 (__os.flags() &amp; ios_base::adjustfield) == ios_base::left ?
                                     &amp;__c + 1 :
                                     &amp;__c,
                                 &amp;__c + 1,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        <span class="gs">__os.__</span>set_badbit_and_consider_rethrow();
    }

    return __os;
}

template&lt;class _Traits&gt;
basic_ostream&lt;char, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;char, <span class="ge">_Traits&gt;&amp; __os, char _</span>_c)
{
    return std::__1::__put_character_sequence(__os, &amp;__c, 1);
}

template&lt;class _Traits&gt;
basic_ostream&lt;char, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;char, <span class="ge">_Traits&gt;&amp; __os, signed char _</span>_c)
{
    return std::__1::__put_character_sequence(__os, (char *) &amp;__c, 1);
}

template&lt;class _Traits&gt;
basic_ostream&lt;char, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;char, <span class="ge">_Traits&gt;&amp; __os, unsigned char _</span>_c)
{
    return std::__1::__put_character_sequence(__os, (char *) &amp;__c, 1);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __os, const _</span>CharT* __str)
{
    return std::__1::__put_character_sequence(__os, __str, <span class="ge">_Traits::length(_</span>_str));
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __os, const char* _</span>_strn)
{

    try
    {

        typename basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::sentry __s(_</span>_os);
        if (__s)
        {
            typedef ostreambuf_iterator&lt;_CharT, <span class="ge">_Traits&gt; _</span>Ip;
            size_t __len = char_traits&lt;char&gt;::length(__strn);
            const int __bs = 100;
            <span class="ge">_CharT __wbb[_</span>_bs];
            <span class="ge">_CharT* __wb = _</span>_wbb;
            unique_ptr&lt;_CharT, void(*)(void*)&gt; __h(0, free);
            if (<span class="gs">__len &gt; __</span>bs)
            {
                __wb = (<span class="ge">_CharT*)malloc(__len*sizeof(_</span>CharT));
                if (__wb == 0)
                    __throw_bad_alloc();
                <span class="gs">__h.reset(__</span>wb);
            }
            for (<span class="ge">_CharT* __p = __wb; *__strn != &#39;\0&#39;; ++__strn, ++_</span>_p)
                <span class="ge">*__p = __os.widen(*</span>__strn);
            if (__pad_and_output(_Ip(__os),
                                 __wb,
                                 (__os.flags() &amp; ios_base::adjustfield) == ios_base::left ?
                                     <span class="gs">__wb + __</span>len :
                                     __wb,
                                 <span class="gs">__wb + __</span>len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        <span class="gs">__os.__</span>set_badbit_and_consider_rethrow();
    }

    return __os;
}

template&lt;class _Traits&gt;
basic_ostream&lt;char, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;char, <span class="ge">_Traits&gt;&amp; __os, const char* _</span>_str)
{
    return std::__1::__put_character_sequence(__os, __str, <span class="ge">_Traits::length(_</span>_str));
}

template&lt;class _Traits&gt;
basic_ostream&lt;char, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;char, <span class="ge">_Traits&gt;&amp; __os, const signed char* _</span>_str)
{
    const char <span class="ge">*__s = (const char *</span>) __str;
    return std::__1::__put_character_sequence(__os, __s, <span class="ge">_Traits::length(_</span>_s));
}

template&lt;class _Traits&gt;
basic_ostream&lt;char, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;char, <span class="ge">_Traits&gt;&amp; __os, const unsigned char* _</span>_str)
{
    const char <span class="ge">*__s = (const char *</span>) __str;
    return std::__1::__put_character_sequence(__os, __s, <span class="ge">_Traits::length(_</span>_s));
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::put(char_</span>type __c)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef ostreambuf_iterator&lt;_CharT, <span class="ge">_Traits&gt; _</span>Op;
            <span class="ge">_Op _</span>_o(*this);
            *<span class="gs">__o = __</span>c;
            if (__o.failed())
                this-&gt;setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::write(const char_</span>type* <span class="gs">__s, streamsize __</span>n)
{

    try
    {

        sentry __sen(*this);
        if (<span class="gs">__sen &amp;&amp; __</span>n)
        {
            if (this-&gt;rdbuf()-&gt;sputn(__s, <span class="gs">__n) != __</span>n)
                this-&gt;setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, _Traits&gt;::flush()
{

    try
    {

        if (this-&gt;rdbuf())
        {
            sentry __s(*this);
            if (__s)
            {
                if (this-&gt;rdbuf()-&gt;pubsync() == -1)
                    this-&gt;setstate(ios_base::badbit);
            }
        }

    }
    catch (...)
    {
        this-&gt;__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
typename basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::pos_</span>type
basic_ostream&lt;_CharT, _Traits&gt;::tellp()
{
    if (this-&gt;fail())
        return pos_type(-1);
    return this-&gt;rdbuf()-&gt;pubseekoff(0, ios_base::cur, ios_base::out);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::seekp(pos_</span>type __pos)
{
    sentry __s(*this);
    if (!this-&gt;fail())
    {
        if (this-&gt;rdbuf()-&gt;pubseekpos(__pos, ios_base::out) == pos_type(-1))
            this-&gt;setstate(ios_base::failbit);
    }
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;::seekp(off_</span>type __off, ios_base::seekdir __dir)
{
    sentry __s(*this);
    if (!this-&gt;fail())
    {
        if (this-&gt;rdbuf()-&gt;pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))
            this-&gt;setstate(ios_base::failbit);
    }
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_ostream&lt;_CharT, _Traits&gt;&amp;
endl(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_os)
{
    <span class="gs">__os.put(__</span>os.widen(&#39;\n&#39;));
    __os.flush();
    return __os;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_ostream&lt;_CharT, _Traits&gt;&amp;
ends(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_os)
{
    __os.put(_CharT());
    return __os;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_ostream&lt;_CharT, _Traits&gt;&amp;
flush(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_os)
{
    __os.flush();
    return __os;
}
template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_os,
           const basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __str)
{
    return std::__1::__put_character_sequence(__os, <span class="gs">__str.data(), __</span>str.size());
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_os,
           basic_string_view&lt;_CharT, <span class="ge">_Traits&gt; _</span>_sv)
{
    return std::__1::__put_character_sequence(__os, <span class="gs">__sv.data(), __</span>sv.size());
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_ostream&lt;_CharT, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __os, const error_</span>code&amp; __ec)
{
    return <span class="gs">__os &lt;&lt; __</span>ec.category().name() &lt;&lt; &#39;:&#39; &lt;&lt; __ec.value();
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Yp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_ostream&lt;_CharT, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __os, shared_</span>ptr&lt;_Yp&gt; const&amp; __p)
{
    return <span class="gs">__os &lt;&lt; __</span>p.get();
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class <span class="ge">_Yp, class _</span>Dp&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
typename enable_if
&lt;
    is_same&lt;void, typename __void_t&lt;__decltype((declval&lt;basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp;&gt;() &lt;&lt; declval&lt;typename unique_</span>ptr&lt;_Yp, _Dp&gt;::pointer&gt;()))&gt;::type&gt;::value,
    basic_ostream&lt;_CharT, _Traits&gt;&amp;
&gt;::type
operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __os, unique_</span>ptr&lt;_Yp, <span class="ge">_Dp&gt; const&amp; _</span>_p)
{
    return <span class="gs">__os &lt;&lt; __</span>p.get();
}

template &lt;class <span class="ge">_CharT, class _</span>Traits, size_t _Size&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __os, const bitset&lt;_</span>Size&gt;&amp; __x)
{
    return <span class="gs">__os &lt;&lt; __</span>x.template to_string&lt;_CharT, _Traits&gt;
                        (use_facet&lt;ctype&lt;_CharT&gt; &gt;(__os.getloc()).widen(&#39;0&#39;),
                         use_facet&lt;ctype&lt;_CharT&gt; &gt;(__os.getloc()).widen(&#39;1&#39;));
}


extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) basic_ostream&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) basic_ostream&lt;wchar_t&gt;;


} }





namespace std { inline namespace __1 {

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_istream
    : virtual public basic_ios&lt;_CharT, _Traits&gt;
{
    streamsize __gc_;
public:

    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_Traits traits_</span>type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit basic_istream(basic_streambuf&lt;char_type, traits_type&gt;* <span class="gs">__sb) : __</span>gc_(0)
    { this-&gt;init(__sb); }
    virtual ~basic_istream();
protected:
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void swap(basic_istream&amp; __rhs) {
      std::__1::swap(__gc_, <span class="gs">__rhs.__</span>gc_);
      basic_ios&lt;char_type, traits_type&gt;::swap(__rhs);
    }





public:


    class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) sentry;


    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_istream&amp; operator&gt;&gt;(basic_istream&amp; (*__pf)(basic_istream&amp;))
    { return __pf(*this); }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_istream&amp; operator&gt;&gt;(basic_ios&lt;char_type, traits_type&gt;&amp;
                              (*__pf)(basic_ios&lt;char_type, traits_type&gt;&amp;))
    { __pf(*this); return *this; }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_istream&amp; operator&gt;&gt;(ios_base&amp; (*__pf)(ios_base&amp;))
    { __pf(*this); return *this; }

    basic_istream&amp; operator&gt;&gt;(basic_streambuf&lt;char_type, traits_type&gt;* __sb);
    basic_istream&amp; operator&gt;&gt;(bool&amp; __n);
    basic_istream&amp; operator&gt;&gt;(short&amp; __n);
    basic_istream&amp; operator&gt;&gt;(unsigned short&amp; __n);
    basic_istream&amp; operator&gt;&gt;(int&amp; __n);
    basic_istream&amp; operator&gt;&gt;(unsigned int&amp; __n);
    basic_istream&amp; operator&gt;&gt;(long&amp; __n);
    basic_istream&amp; operator&gt;&gt;(unsigned long&amp; __n);
    basic_istream&amp; operator&gt;&gt;(long long&amp; __n);
    basic_istream&amp; operator&gt;&gt;(unsigned long long&amp; __n);
    basic_istream&amp; operator&gt;&gt;(float&amp; __f);
    basic_istream&amp; operator&gt;&gt;(double&amp; __f);
    basic_istream&amp; operator&gt;&gt;(long double&amp; __f);
    basic_istream&amp; operator&gt;&gt;(void*&amp; __p);


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    streamsize gcount() const {return __gc_;}
    int_type get();

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_istream&amp; get(char_type&amp; __c) {
      int_type __ch = get();
      if (__ch != traits_type::eof())
        __c = traits_type::to_char_type(__ch);
      return *this;
    }

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_istream&amp; get(char_type* <span class="gs">__s, streamsize __</span>n)
    { return get(__s, __n, this-&gt;widen(&#39;\n&#39;)); }

    basic_istream&amp; get(char_type* <span class="gs">__s, streamsize __</span>n, char_type __dlm);

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_istream&amp; get(basic_streambuf&lt;char_type, traits_type&gt;&amp; __sb)
    { return get(__sb, this-&gt;widen(&#39;\n&#39;)); }

    basic_istream&amp; get(basic_streambuf&lt;char_type, traits_type&gt;&amp; __sb, char_type __dlm);

    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    basic_istream&amp; getline(char_type* <span class="gs">__s, streamsize __</span>n)
    { return getline(__s, __n, this-&gt;widen(&#39;\n&#39;)); }

    basic_istream&amp; getline(char_type* <span class="gs">__s, streamsize __</span>n, char_type __dlm);

    basic_istream&amp; ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());
    int_type peek();
    basic_istream&amp; read (char_type* <span class="gs">__s, streamsize __</span>n);
    streamsize readsome(char_type* <span class="gs">__s, streamsize __</span>n);

    basic_istream&amp; putback(char_type __c);
    basic_istream&amp; unget();
    int sync();

    pos_type tellg();
    basic_istream&amp; seekg(pos_type __pos);
    basic_istream&amp; seekg(off_type __off, ios_base::seekdir __dir);
};

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_istream&lt;_CharT, _Traits&gt;::sentry
{
    bool __ok_;

    sentry(const sentry&amp;);
    sentry&amp; operator=(const sentry&amp;);

public:
    explicit sentry(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __is, bool _</span>_noskipws = false);


    <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))

        operator bool() const {return __ok_;}
};

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::sentry::sentry(basic_</span>istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_is,
                                               bool __noskipws)
    : __ok_(false)
{
    if (__is.good())
    {
        if (__is.tie())
            __is.tie()-&gt;flush();
        if (!__noskipws &amp;&amp; (__is.flags() &amp; ios_base::skipws))
        {
            typedef istreambuf_iterator&lt;_CharT, <span class="ge">_Traits&gt; _</span>Ip;
            const ctype&lt;_CharT&gt;&amp; __ct = use_facet&lt;ctype&lt;_CharT&gt; &gt;(__is.getloc());
            <span class="ge">_Ip __i(_</span>_is);
            <span class="ge">_Ip _</span>_eof;
            for (; <span class="gs">__i != __</span>eof; ++__i)
                if (!__ct.is(__ct.space, *__i))
                    break;
            if (<span class="gs">__i == __</span>eof)
                __is.setstate(ios_base::failbit | ios_base::eofbit);
        }
        __ok_ = __is.good();
    }
    else
        __is.setstate(ios_base::failbit);
}
template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::~basic_</span>istream()
{
}

template &lt;class <span class="ge">_Tp, class _</span>CharT, class _Traits&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_istream&lt;_CharT, _Traits&gt;&amp;
__input_arithmetic(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __is, _</span>Tp&amp; __n) {
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::sentry __s(_</span>_is);
    if (__s)
    {

        try
        {

            typedef istreambuf_iterator&lt;_CharT, <span class="ge">_Traits&gt; _</span>Ip;
            typedef num_get&lt;_CharT, <span class="ge">_Ip&gt; _</span>Fp;
            use_facet&lt;_Fp&gt;(__is.getloc()).get(_Ip(__is), <span class="ge">_Ip(), __is, __state, _</span>_n);

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            <span class="gs">__is.__</span>setstate_nothrow(__state);
            if (__is.exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        <span class="gs">__is.setstate(__</span>state);
    }
    return __is;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::operator&gt;&gt;(unsigned short&amp; _</span>_n)
{
    return std::__1::__input_arithmetic&lt;unsigned short&gt;(*this, __n);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::operator&gt;&gt;(unsigned int&amp; _</span>_n)
{
    return std::__1::__input_arithmetic&lt;unsigned int&gt;(*this, __n);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::operator&gt;&gt;(long&amp; _</span>_n)
{
    return std::__1::__input_arithmetic&lt;long&gt;(*this, __n);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::operator&gt;&gt;(unsigned long&amp; _</span>_n)
{
    return std::__1::__input_arithmetic&lt;unsigned long&gt;(*this, __n);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::operator&gt;&gt;(long long&amp; _</span>_n)
{
    return std::__1::__input_arithmetic&lt;long long&gt;(*this, __n);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::operator&gt;&gt;(unsigned long long&amp; _</span>_n)
{
    return std::__1::__input_arithmetic&lt;unsigned long long&gt;(*this, __n);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::operator&gt;&gt;(float&amp; _</span>_n)
{
    return std::__1::__input_arithmetic&lt;float&gt;(*this, __n);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::operator&gt;&gt;(double&amp; _</span>_n)
{
    return std::__1::__input_arithmetic&lt;double&gt;(*this, __n);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::operator&gt;&gt;(long double&amp; _</span>_n)
{
    return std::__1::__input_arithmetic&lt;long double&gt;(*this, __n);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::operator&gt;&gt;(bool&amp; _</span>_n)
{
    return std::__1::__input_arithmetic&lt;bool&gt;(*this, __n);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::operator&gt;&gt;(void*&amp; _</span>_n)
{
    return std::__1::__input_arithmetic&lt;void*&gt;(*this, __n);
}

template &lt;class <span class="ge">_Tp, class _</span>CharT, class _Traits&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_istream&lt;_CharT, _Traits&gt;&amp;
__input_arithmetic_with_numeric_limits(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __is, _</span>Tp&amp; __n) {
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::sentry __s(_</span>_is);
    if (__s)
    {

        try
        {

            typedef istreambuf_iterator&lt;_CharT, <span class="ge">_Traits&gt; _</span>Ip;
            typedef num_get&lt;_CharT, <span class="ge">_Ip&gt; _</span>Fp;
            long __temp;
            use_facet&lt;_Fp&gt;(__is.getloc()).get(_Ip(__is), <span class="ge">_Ip(), __is, __state, _</span>_temp);
            if (__temp &lt; numeric_limits&lt;_Tp&gt;::min())
            {
                __state |= ios_base::failbit;
                __n = numeric_limits&lt;_Tp&gt;::min();
            }
            else if (__temp &gt; numeric_limits&lt;_Tp&gt;::max())
            {
                __state |= ios_base::failbit;
                __n = numeric_limits&lt;_Tp&gt;::max();
            }
            else
            {
                __n = static_cast&lt;_Tp&gt;(__temp);
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            <span class="gs">__is.__</span>setstate_nothrow(__state);
            if (__is.exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        <span class="gs">__is.setstate(__</span>state);
    }
    return __is;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::operator&gt;&gt;(short&amp; _</span>_n)
{
    return std::__1::__input_arithmetic_with_numeric_limits&lt;short&gt;(*this, __n);
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::operator&gt;&gt;(int&amp; _</span>_n)
{
    return std::__1::__input_arithmetic_with_numeric_limits&lt;int&gt;(*this, __n);
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_istream&lt;_CharT, _Traits&gt;&amp;
__input_c_string(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __is, _</span>CharT* __p, size_t __n)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::sentry __sen(_</span>_is);
    if (__sen)
    {

        try
        {

            <span class="ge">_CharT* __s = _</span>_p;
            const ctype&lt;_CharT&gt;&amp; __ct = use_facet&lt;ctype&lt;_CharT&gt; &gt;(__is.getloc());
            while (<span class="gs">__s != __</span>p + (__n-1))
            {
                typename <span class="ge">_Traits::int_</span>type <span class="gs">__i = __</span>is.rdbuf()-&gt;sgetc();
                if (<span class="ge">_Traits::eq_</span>int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                <span class="ge">_CharT __ch = _</span>Traits::to_char_type(__i);
                if (<span class="gs">__ct.is(__</span>ct.space, __ch))
                    break;
                *<span class="gs">__s++ = __</span>ch;
                 __is.rdbuf()-&gt;sbumpc();
            }
            *__s = _CharT();
            __is.width(0);
            if (<span class="gs">__s == __</span>p)
               __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            <span class="gs">__is.__</span>setstate_nothrow(__state);
            if (__is.exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        <span class="gs">__is.setstate(__</span>state);
    }
    return __is;
}
template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_istream&lt;_CharT, _Traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __is, _</span>CharT* __s)
{
    streamsize <span class="gs">__n = __</span>is.width();
    if (__n &lt;= 0)
        __n = numeric_limits&lt;streamsize&gt;::max() / sizeof(_CharT) - 1;
    return std::__1::__input_c_string(__is, __s, size_t(__n));
}

template&lt;class _Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_istream&lt;char, _Traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;char, <span class="ge">_Traits&gt;&amp; __is, unsigned char* _</span>_s)
{
    return <span class="gs">__is &gt;&gt; (char*)__</span>s;
}

template&lt;class _Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_istream&lt;char, _Traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;char, <span class="ge">_Traits&gt;&amp; __is, signed char* _</span>_s)
{
    return <span class="gs">__is &gt;&gt; (char*)__</span>s;
}



template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __is, _</span>CharT&amp; __c)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::sentry __sen(_</span>_is);
    if (__sen)
    {

        try
        {

            typename <span class="ge">_Traits::int_</span>type <span class="gs">__i = __</span>is.rdbuf()-&gt;sbumpc();
            if (<span class="ge">_Traits::eq_</span>int_type(__i, _Traits::eof()))
                __state |= ios_base::eofbit | ios_base::failbit;
            else
                __c = <span class="ge">_Traits::to_</span>char_type(__i);

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            <span class="gs">__is.__</span>setstate_nothrow(__state);
            if (__is.exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        <span class="gs">__is.setstate(__</span>state);
    }
    return __is;
}

template&lt;class _Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_istream&lt;char, _Traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;char, <span class="ge">_Traits&gt;&amp; __is, unsigned char&amp; _</span>_c)
{
    return <span class="gs">__is &gt;&gt; (char&amp;)__</span>c;
}

template&lt;class _Traits&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_istream&lt;char, _Traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;char, <span class="ge">_Traits&gt;&amp; __is, signed char&amp; _</span>_c)
{
    return <span class="gs">__is &gt;&gt; (char&amp;)__</span>c;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::operator&gt;&gt;(basic_</span>streambuf&lt;char_type, traits_type&gt;* __sb)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __s(*this, true);
    if (__s)
    {
        if (__sb)
        {

            try
            {

                while (true)
                {
                    typename traits_type::int_type __i = this-&gt;rdbuf()-&gt;sgetc();
                    if (traits_type::eq_int_type(__i, _Traits::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    if (traits_type::eq_int_type(
                            __sb-&gt;sputc(traits_type::to_char_type(__i)),
                            traits_type::eof()))
                        break;
                    ++__gc_;
                    this-&gt;rdbuf()-&gt;sbumpc();
                }
                if (__gc_ == 0)
                   __state |= ios_base::failbit;

            }
            catch (...)
            {
                __state |= ios_base::badbit;
                if (__gc_ == 0)
                    __state |= ios_base::failbit;

                this-&gt;__setstate_nothrow(__state);
                if (this-&gt;exceptions() &amp; ios_base::failbit || this-&gt;exceptions() &amp; ios_base::badbit)
                {
                    throw;
                }
            }

        }
        else
        {
            __state |= ios_base::failbit;
        }
        this-&gt;setstate(__state);
    }
    return *this;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
typename basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::int_</span>type
basic_istream&lt;_CharT, _Traits&gt;::get()
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    int_type __r = traits_type::eof();
    sentry __s(*this, true);
    if (__s)
    {

        try
        {

            __r = this-&gt;rdbuf()-&gt;sbumpc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
               __state |= ios_base::failbit | ios_base::eofbit;
            else
                __gc_ = 1;

        }
        catch (...)
        {
            this-&gt;__setstate_nothrow(this-&gt;rdstate() | ios_base::badbit);
            if (this-&gt;exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        this-&gt;setstate(__state);
    }
    return __r;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::get(char_</span>type* <span class="gs">__s, streamsize __</span>n, char_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {
        if (__n &gt; 0)
        {

            try
            {

                while (__gc_ &lt; __n-1)
                {
                    int_type __i = this-&gt;rdbuf()-&gt;sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    *<span class="gs">__s++ = __</span>ch;
                    ++__gc_;
                     this-&gt;rdbuf()-&gt;sbumpc();
                }
                if (__gc_ == 0)
                   __state |= ios_base::failbit;

            }
            catch (...)
            {
                __state |= ios_base::badbit;
                this-&gt;__setstate_nothrow(__state);
                if (this-&gt;exceptions() &amp; ios_base::badbit)
                {
                    if (__n &gt; 0)
                        *__s = char_type();
                    throw;
                }
            }

        }
        else
        {
            __state |= ios_base::failbit;
        }

        if (__n &gt; 0)
            *__s = char_type();
        this-&gt;setstate(__state);
    }
    if (__n &gt; 0)
        *__s = char_type();
    return *this;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::get(basic_</span>streambuf&lt;char_type, traits_type&gt;&amp; __sb,
                                    char_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            while (true)
            {
                typename traits_type::int_type __i = this-&gt;rdbuf()-&gt;sgetc();
                if (traits_type::eq_int_type(__i, traits_type::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                char_type __ch = traits_type::to_char_type(__i);
                if (traits_type::eq(__ch, __dlm))
                    break;
                if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
                    break;
                ++__gc_;
                this-&gt;rdbuf()-&gt;sbumpc();
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;

        }

        if (__gc_ == 0)
           __state |= ios_base::failbit;
        this-&gt;setstate(__state);
    }
    return *this;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::getline(char_</span>type* <span class="gs">__s, streamsize __</span>n, char_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            while (true)
            {
                typename traits_type::int_type __i = this-&gt;rdbuf()-&gt;sgetc();
                if (traits_type::eq_int_type(__i, traits_type::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                char_type __ch = traits_type::to_char_type(__i);
                if (traits_type::eq(__ch, __dlm))
                {
                    this-&gt;rdbuf()-&gt;sbumpc();
                    ++__gc_;
                    break;
                }
                if (__gc_ &gt;= __n-1)
                {
                    __state |= ios_base::failbit;
                    break;
                }
                *<span class="gs">__s++ = __</span>ch;
                this-&gt;rdbuf()-&gt;sbumpc();
                ++__gc_;
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this-&gt;__setstate_nothrow(__state);
            if (this-&gt;exceptions() &amp; ios_base::badbit)
            {
                if (__n &gt; 0)
                    *__s = char_type();
                if (__gc_ == 0)
                    __state |= ios_base::failbit;
                throw;
            }
        }

    }
    if (__n &gt; 0)
        *__s = char_type();
    if (__gc_ == 0)
        __state |= ios_base::failbit;
    this-&gt;setstate(__state);
    return *this;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::ignore(streamsize __n, int_</span>type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (__n == numeric_limits&lt;streamsize&gt;::max())
            {
                while (true)
                {
                    typename traits_type::int_type __i = this-&gt;rdbuf()-&gt;sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
            else
            {
                while (__gc_ &lt; __n)
                {
                    typename traits_type::int_type __i = this-&gt;rdbuf()-&gt;sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this-&gt;__setstate_nothrow(__state);
            if (this-&gt;exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        this-&gt;setstate(__state);
    }
    return *this;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
typename basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::int_</span>type
basic_istream&lt;_CharT, _Traits&gt;::peek()
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    int_type __r = traits_type::eof();
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            __r = this-&gt;rdbuf()-&gt;sgetc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
                __state |= ios_base::eofbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this-&gt;__setstate_nothrow(__state);
            if (this-&gt;exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        this-&gt;setstate(__state);
    }
    return __r;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::read(char_</span>type* <span class="gs">__s, streamsize __</span>n)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            __gc_ = this-&gt;rdbuf()-&gt;sgetn(__s, __n);
            if (__gc_ != __n)
                __state |= ios_base::failbit | ios_base::eofbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this-&gt;__setstate_nothrow(__state);
            if (this-&gt;exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

    }
    else
    {
        __state |= ios_base::failbit;
    }
    this-&gt;setstate(__state);
    return *this;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
streamsize
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::readsome(char_</span>type* <span class="gs">__s, streamsize __</span>n)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            streamsize __c = this-&gt;rdbuf()-&gt;in_avail();
            switch (__c)
            {
            case -1:
                __state |= ios_base::eofbit;
                break;
            case 0:
                break;
            default:
                <span class="gs">__n = std::__</span>1::min(__c, __n);
                __gc_ = this-&gt;rdbuf()-&gt;sgetn(__s, __n);
                if (__gc_ != __n)
                    __state |= ios_base::failbit | ios_base::eofbit;
                break;
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this-&gt;__setstate_nothrow(__state);
            if (this-&gt;exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

    }
    else
    {
        __state |= ios_base::failbit;
    }
    this-&gt;setstate(__state);
    return __gc_;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::putback(char_</span>type __c)
{
    ios_base::iostate __state = this-&gt;rdstate() &amp; ~ios_base::eofbit;
    __gc_ = 0;
    this-&gt;clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this-&gt;rdbuf() == 0 || this-&gt;rdbuf()-&gt;sputbackc(__c) == traits_type::eof())
                __state |= ios_base::badbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this-&gt;__setstate_nothrow(__state);
            if (this-&gt;exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

    }
    else
    {
        __state |= ios_base::failbit;
    }
    this-&gt;setstate(__state);
    return *this;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, _Traits&gt;::unget()
{
    ios_base::iostate __state = this-&gt;rdstate() &amp; ~ios_base::eofbit;
    __gc_ = 0;
    this-&gt;clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this-&gt;rdbuf() == 0 || this-&gt;rdbuf()-&gt;sungetc() == traits_type::eof())
                __state |= ios_base::badbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this-&gt;__setstate_nothrow(__state);
            if (this-&gt;exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

    }
    else
    {
        __state |= ios_base::failbit;
    }
    this-&gt;setstate(__state);
    return *this;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
int
basic_istream&lt;_CharT, _Traits&gt;::sync()
{
    ios_base::iostate __state = ios_base::goodbit;
    int __r = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this-&gt;rdbuf() == 0)
                return -1;
            if (this-&gt;rdbuf()-&gt;pubsync() == -1)
            {
                __state |= ios_base::badbit;
                return -1;
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this-&gt;__setstate_nothrow(__state);
            if (this-&gt;exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        this-&gt;setstate(__state);
    }
    return __r;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
typename basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::pos_</span>type
basic_istream&lt;_CharT, _Traits&gt;::tellg()
{
    ios_base::iostate __state = ios_base::goodbit;
    pos_type __r(-1);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

        __r = this-&gt;rdbuf()-&gt;pubseekoff(0, ios_base::cur, ios_base::in);

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this-&gt;__setstate_nothrow(__state);
            if (this-&gt;exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        this-&gt;setstate(__state);
    }
    return __r;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::seekg(pos_</span>type __pos)
{
    ios_base::iostate __state = this-&gt;rdstate() &amp; ~ios_base::eofbit;
    this-&gt;clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this-&gt;rdbuf()-&gt;pubseekpos(__pos, ios_base::in) == pos_type(-1))
                __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this-&gt;__setstate_nothrow(__state);
            if (this-&gt;exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        this-&gt;setstate(__state);
    }
    return *this;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::seekg(off_</span>type __off, ios_base::seekdir __dir)
{
    ios_base::iostate __state = this-&gt;rdstate() &amp; ~ios_base::eofbit;
    this-&gt;clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this-&gt;rdbuf()-&gt;pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))
                __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this-&gt;__setstate_nothrow(__state);
            if (this-&gt;exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        this-&gt;setstate(__state);
    }
    return *this;
}

template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
ws(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_is)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::sentry __sen(_</span>_is, true);
    if (__sen)
    {

        try
        {

            const ctype&lt;_CharT&gt;&amp; __ct = use_facet&lt;ctype&lt;_CharT&gt; &gt;(__is.getloc());
            while (true)
            {
                typename <span class="ge">_Traits::int_</span>type <span class="gs">__i = __</span>is.rdbuf()-&gt;sgetc();
                if (<span class="ge">_Traits::eq_</span>int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                if (!__ct.is(__ct.space, <span class="ge">_Traits::to_</span>char_type(__i)))
                    break;
                __is.rdbuf()-&gt;sbumpc();
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            <span class="gs">__is.__</span>setstate_nothrow(__state);
            if (__is.exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        <span class="gs">__is.setstate(__</span>state);
    }
    return __is;
}
template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
class <span class="gs">__attribute__</span> ((__type_visibility__(&quot;default&quot;))) basic_iostream
    : public basic_istream&lt;_CharT, _Traits&gt;,
      public basic_ostream&lt;_CharT, _Traits&gt;
{
public:

    typedef <span class="ge">_CharT char_</span>type;
    typedef <span class="ge">_Traits traits_</span>type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    explicit basic_iostream(basic_streambuf&lt;char_type, traits_type&gt;* __sb)
      : basic_istream&lt;_CharT, <span class="ge">_Traits&gt;(_</span>_sb)
    {}

    virtual ~basic_iostream();
protected:
    inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
    void swap(basic_iostream&amp; __rhs)
    { basic_istream&lt;char_type, traits_type&gt;::swap(__rhs); }
};
template &lt;class <span class="ge">_CharT, class _</span>Traits&gt;
basic_iostream&lt;_CharT, <span class="ge">_Traits&gt;::~basic_</span>iostream()
{
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_is,
           basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __str)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::sentry __sen(_</span>_is);
    if (__sen)
    {

        try
        {

            __str.clear();
            streamsize <span class="gs">__n = __</span>is.width();
            if (__n &lt;= 0)
                <span class="gs">__n = __</span>str.max_size();
            if (__n &lt;= 0)
                __n = numeric_limits&lt;streamsize&gt;::max();
            streamsize __c = 0;
            const ctype&lt;_CharT&gt;&amp; __ct = use_facet&lt;ctype&lt;_CharT&gt; &gt;(__is.getloc());
            while (<span class="gs">__c &lt; __</span>n)
            {
                typename <span class="ge">_Traits::int_</span>type <span class="gs">__i = __</span>is.rdbuf()-&gt;sgetc();
                if (<span class="ge">_Traits::eq_</span>int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                <span class="ge">_CharT __ch = _</span>Traits::to_char_type(__i);
                if (<span class="gs">__ct.is(__</span>ct.space, __ch))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()-&gt;sbumpc();
            }
            __is.width(0);
            if (__c == 0)
               __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            <span class="gs">__is.__</span>setstate_nothrow(__state);
            if (__is.exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        <span class="gs">__is.setstate(__</span>state);
    }
    return __is;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
getline(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_is,
        basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __str, <span class="ge">_CharT _</span>_dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::sentry __sen(_</span>_is, true);
    if (__sen)
    {

        try
        {

            __str.clear();
            streamsize __extr = 0;
            while (true)
            {
                typename <span class="ge">_Traits::int_</span>type <span class="gs">__i = __</span>is.rdbuf()-&gt;sbumpc();
                if (<span class="ge">_Traits::eq_</span>int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                ++__extr;
                <span class="ge">_CharT __ch = _</span>Traits::to_char_type(__i);
                if (<span class="ge">_Traits::eq(__ch, _</span>_dlm))
                    break;
                __str.push_back(__ch);
                if (<span class="gs">__str.size() == __</span>str.max_size())
                {
                    __state |= ios_base::failbit;
                    break;
                }
            }
            if (__extr == 0)
               __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            <span class="gs">__is.__</span>setstate_nothrow(__state);
            if (__is.exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        <span class="gs">__is.setstate(__</span>state);
    }
    return __is;
}

template&lt;class <span class="ge">_CharT, class _</span>Traits, class _Allocator&gt;
inline <span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
basic_istream&lt;_CharT, _Traits&gt;&amp;
getline(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; _</span>_is,
        basic_string&lt;_CharT, <span class="ge">_Traits, _</span>Allocator&gt;&amp; __str)
{
    return getline(__is, <span class="gs">__str, __</span>is.widen(&#39;\n&#39;));
}
template &lt;class <span class="ge">_CharT, class _</span>Traits, size_t _Size&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;_CharT, <span class="ge">_Traits&gt;&amp; __is, bitset&lt;_</span>Size&gt;&amp; __x)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream&lt;_CharT, <span class="ge">_Traits&gt;::sentry __sen(_</span>_is);
    if (__sen)
    {

        try
        {

            basic_string&lt;_CharT, <span class="ge">_Traits&gt; _</span>_str;
            const ctype&lt;_CharT&gt;&amp; __ct = use_facet&lt;ctype&lt;_CharT&gt; &gt;(__is.getloc());
            size_t __c = 0;
            <span class="ge">_CharT __zero = _</span>_ct.widen(&#39;0&#39;);
            <span class="ge">_CharT __one = _</span>_ct.widen(&#39;1&#39;);
            while (__c &lt; _Size)
            {
                typename <span class="ge">_Traits::int_</span>type <span class="gs">__i = __</span>is.rdbuf()-&gt;sgetc();
                if (<span class="ge">_Traits::eq_</span>int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                <span class="ge">_CharT __ch = _</span>Traits::to_char_type(__i);
                if (!_Traits::eq(__ch, __zero) &amp;&amp; !<span class="ge">_Traits::eq(__ch, _</span>_one))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()-&gt;sbumpc();
            }
            __x = bitset&lt;_Size&gt;(__str);
            if (<span class="ge">_Size &gt; 0 &amp;&amp; _</span>_c == 0)
               __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            <span class="gs">__is.__</span>setstate_nothrow(__state);
            if (__is.exceptions() &amp; ios_base::badbit)
            {
                throw;
            }
        }

        <span class="gs">__is.setstate(__</span>state);
    }
    return __is;
}


extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) basic_istream&lt;char&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) basic_istream&lt;wchar_t&gt;;
extern template class <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) basic_iostream&lt;char&gt;;


} }


namespace std { inline namespace __1 {


extern <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) istream cin;
extern <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) wistream wcin;


extern <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) ostream cout;
extern <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) wostream wcout;

extern <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) ostream cerr;
extern <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) wostream wcerr;
extern <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) ostream clog;
extern <span class="gs">__attribute__</span> ((__visibility__(&quot;default&quot;))) wostream wclog;

} }









namespace std { inline namespace __1 {

using ::signbit;
using ::fpclassify;
using ::isfinite;
using ::isinf;
using ::isnan;
using ::isnormal;
using ::isgreater;
using ::isgreaterequal;
using ::isless;
using ::islessequal;
using ::islessgreater;
using ::isunordered;
using ::isunordered;

using ::float_t;
using ::double_t;


using ::abs;


using ::acos;
using ::acosf;
using ::asin;
using ::asinf;
using ::atan;
using ::atanf;
using ::atan2;
using ::atan2f;
using ::ceil;
using ::ceilf;
using ::cos;
using ::cosf;
using ::cosh;
using ::coshf;

using ::exp;
using ::expf;

using ::fabs;
using ::fabsf;
using ::floor;
using ::floorf;

using ::fmod;
using ::fmodf;

using ::frexp;
using ::frexpf;
using ::ldexp;
using ::ldexpf;

using ::log;
using ::logf;

using ::log10;
using ::log10f;
using ::modf;
using ::modff;

using ::pow;
using ::powf;

using ::sin;
using ::sinf;
using ::sinh;
using ::sinhf;

using ::sqrt;
using ::sqrtf;
using ::tan;
using ::tanf;

using ::tanh;
using ::tanhf;

using ::acosh;
using ::acoshf;
using ::asinh;
using ::asinhf;
using ::atanh;
using ::atanhf;
using ::cbrt;
using ::cbrtf;

using ::copysign;
using ::copysignf;

using ::erf;
using ::erff;
using ::erfc;
using ::erfcf;
using ::exp2;
using ::exp2f;
using ::expm1;
using ::expm1f;
using ::fdim;
using ::fdimf;
using ::fmaf;
using ::fma;
using ::fmax;
using ::fmaxf;
using ::fmin;
using ::fminf;
using ::hypot;
using ::hypotf;
using ::ilogb;
using ::ilogbf;
using ::lgamma;
using ::lgammaf;
using ::llrint;
using ::llrintf;
using ::llround;
using ::llroundf;
using ::log1p;
using ::log1pf;
using ::log2;
using ::log2f;
using ::logb;
using ::logbf;
using ::lrint;
using ::lrintf;
using ::lround;
using ::lroundf;

using ::nan;
using ::nanf;

using ::nearbyint;
using ::nearbyintf;
using ::nextafter;
using ::nextafterf;
using ::nexttoward;
using ::nexttowardf;
using ::remainder;
using ::remainderf;
using ::remquo;
using ::remquof;
using ::rint;
using ::rintf;
using ::round;
using ::roundf;
using ::scalbln;
using ::scalblnf;
using ::scalbn;
using ::scalbnf;
using ::tgamma;
using ::tgammaf;
using ::trunc;
using ::truncf;

using ::acosl;
using ::asinl;
using ::atanl;
using ::atan2l;
using ::ceill;
using ::cosl;
using ::coshl;
using ::expl;
using ::fabsl;
using ::floorl;
using ::fmodl;
using ::frexpl;
using ::ldexpl;
using ::logl;
using ::log10l;
using ::modfl;
using ::powl;
using ::sinl;
using ::sinhl;
using ::sqrtl;
using ::tanl;

using ::tanhl;
using ::acoshl;
using ::asinhl;
using ::atanhl;
using ::cbrtl;

using ::copysignl;

using ::erfl;
using ::erfcl;
using ::exp2l;
using ::expm1l;
using ::fdiml;
using ::fmal;
using ::fmaxl;
using ::fminl;
using ::hypotl;
using ::ilogbl;
using ::lgammal;
using ::llrintl;
using ::llroundl;
using ::log1pl;
using ::log2l;
using ::logbl;
using ::lrintl;
using ::lroundl;
using ::nanl;
using ::nearbyintl;
using ::nextafterl;
using ::nexttowardl;
using ::remainderl;
using ::remquol;
using ::rintl;
using ::roundl;
using ::scalblnl;
using ::scalbnl;
using ::tgammal;
using ::truncl;
template &lt;class _A1&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                  typename enable_if&lt;is_floating_point&lt;_A1&gt;::value, bool&gt;::type
__libcpp_isnan_or_builtin(_A1 __lcpp_x) throw()
{

    return __builtin_isnan(__lcpp_x);



}

template &lt;class _A1&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                  typename enable_if&lt;!is_floating_point&lt;_A1&gt;::value, bool&gt;::type
__libcpp_isnan_or_builtin(_A1 __lcpp_x) throw()
{
    return isnan(__lcpp_x);
}

template &lt;class _A1&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                  typename enable_if&lt;is_floating_point&lt;_A1&gt;::value, bool&gt;::type
__libcpp_isinf_or_builtin(_A1 __lcpp_x) throw()
{

    return __builtin_isinf(__lcpp_x);



}

template &lt;class _A1&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                  typename enable_if&lt;!is_floating_point&lt;_A1&gt;::value, bool&gt;::type
__libcpp_isinf_or_builtin(_A1 __lcpp_x) throw()
{
    return isinf(__lcpp_x);
}

template &lt;class _A1&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                  typename enable_if&lt;is_floating_point&lt;_A1&gt;::value, bool&gt;::type
__libcpp_isfinite_or_builtin(_A1 __lcpp_x) throw()
{

    return __builtin_isfinite(__lcpp_x);



}

template &lt;class _A1&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                  typename enable_if&lt;!is_floating_point&lt;_A1&gt;::value, bool&gt;::type
__libcpp_isfinite_or_builtin(_A1 __lcpp_x) throw()
{
    return isfinite(__lcpp_x);
}
template &lt;class <span class="ge">_IntT, class _</span>FloatT,
    bool <span class="ge">_FloatBigger = (numeric_</span>limits&lt;_FloatT&gt;::digits &gt; numeric_limits&lt;_IntT&gt;::digits),
    int <span class="ge">_Bits = (numeric_</span>limits&lt;_IntT&gt;::digits - numeric_limits&lt;_FloatT&gt;::digits)&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
                  <span class="ge">_IntT __max_</span>representable_int_for_float() throw() {
  <span class="ge">_Static_</span>assert(is_floating_point&lt;_FloatT&gt;::value, &quot;must be a floating point type&quot;);
  <span class="ge">_Static_</span>assert(is_integral&lt;_IntT&gt;::value, &quot;must be an integral type&quot;);
  <span class="ge">_Static_</span>assert(numeric_limits&lt;_FloatT&gt;::radix == 2, &quot;FloatT has incorrect radix&quot;);
  <span class="ge">_Static_</span>assert((_IsSame&lt;_FloatT, float&gt;::value || <span class="ge">_IsSame&lt;_</span>FloatT, double&gt;::value || <span class="ge">_IsSame&lt;_</span>FloatT,long double&gt;::value), &quot;unsupported floating point type&quot;);

  return <span class="ge">_FloatBigger ? numeric_</span>limits&lt;_IntT&gt;::max() : (numeric_limits&lt;_IntT&gt;::max() &gt;&gt; <span class="ge">_Bits &lt;&lt; _</span>Bits);
}





template &lt;class <span class="ge">_IntT, class _</span>RealT&gt;
<span class="gs">__attribute__</span> ((__visibility__(&quot;hidden&quot;))) <span class="gs">__attribute__</span> ((internal_linkage))
<span class="ge">_IntT __clamp_</span>to_integral(_RealT __r) throw() {
  using <span class="ge">_Lim = std::numeric_</span>limits&lt;_IntT&gt;;
  const <span class="ge">_IntT _</span>MaxVal = std::__max_representable_int_for_float&lt;_IntT, _RealT&gt;();
  if (__r &gt;= ::nextafter(static_cast&lt;_RealT&gt;(_MaxVal), __builtin_huge_valf())) {
    return _Lim::max();
  } else if (__r &lt;= _Lim::lowest()) {
    return _Lim::min();
  }
  return static_cast&lt;_IntT&gt;(__r);
}

} }



namespace TNT
{
template &lt;class Real&gt;
Real hypot(const Real &amp;a, const Real &amp;b)
{

 if (a== 0)
  return abs(b);
 else
 {
  Real c = b/a;
  return abs(a) * sqrt(1 + c*c);
 }
}
}

extern &quot;C&quot; {
void __assert_rtn(const char <span class="ge">*, const char *</span>, int, const char *) <span class="gs">__attribute__</span>((__noreturn__)) <span class="gs">__attribute__</span>((__cold__)) <span class="gs">__attribute__</span>((__disable_tail_calls__));



}


extern &quot;C&quot; {
void __assert_rtn(const char <span class="ge">*, const char *</span>, int, const char *) <span class="gs">__attribute__</span>((__noreturn__)) <span class="gs">__attribute__</span>((__cold__)) <span class="gs">__attribute__</span>((__disable_tail_calls__));



}






namespace TNT
{
template &lt;class T&gt;
class i_refvec
{


  private:
    T* data_;
    int *ref_count_;


  public:

    i_refvec();
 explicit i_refvec(int n);
 inline i_refvec(T* data);
 inline i<span class="ge">_refvec(const i_</span>refvec &amp;v);
 inline T* begin();
 inline const T* begin() const;
 inline T&amp; operator[](int i);
 inline const T&amp; operator[](int i) const;
 inline i<span class="ge">_refvec&lt;T&gt; &amp; operator=(const i_</span>refvec&lt;T&gt; &amp;V);
      void copy_(T* p, const T* q, const T* e);
      void set_(T* p, const T* b, const T* e);
 inline int ref_count() const;
 inline int is_null() const;
 inline void destroy();
    ~i_refvec();

};

template &lt;class T&gt;
void i<span class="ge">_refvec&lt;T&gt;::copy_</span>(T* p, const T* q, const T* e)
{
 for (T* t=p; q&lt;e; t++, q++)
  <span class="ge">*t= *</span>q;
}

template &lt;class T&gt;
i<span class="ge">_refvec&lt;T&gt;::i_</span>refvec() : data_(__null), ref_count_(__null) {}




template &lt;class T&gt;
i<span class="ge">_refvec&lt;T&gt;::i_</span>refvec(int n) : data_(__null), ref_count_(__null)
{
 if (n &gt;= 1)
 {



  data_ = new T[n];
  ref_count_ = new int;
  *ref_count_ = 1;
 }
}

template &lt;class T&gt;
inline i<span class="ge">_refvec&lt;T&gt;::i_</span>refvec(const i<span class="ge">_refvec&lt;T&gt; &amp;V): data_</span>(V.data_),
 ref_count_(V.ref_count_)
{
 if (V.ref_count_ != __null)
     (*(V.ref_count_))++;
}


template &lt;class T&gt;
i<span class="ge">_refvec&lt;T&gt;::i_</span>refvec(T* data) : data_(data), ref_count_(__null) {}

template &lt;class T&gt;
inline T* i_refvec&lt;T&gt;::begin()
{
 return data_;
}

template &lt;class T&gt;
inline const T&amp; i_refvec&lt;T&gt;::operator[](int i) const
{
 return data_[i];
}

template &lt;class T&gt;
inline T&amp; i_refvec&lt;T&gt;::operator[](int i)
{
 return data_[i];
}


template &lt;class T&gt;
inline const T* i_refvec&lt;T&gt;::begin() const
{
 return data_;
}



template &lt;class T&gt;
i<span class="ge">_refvec&lt;T&gt; &amp; i_</span>refvec&lt;T&gt;::operator=(const i_refvec&lt;T&gt; &amp;V)
{
 if (this == &amp;V)
  return *this;


 if (ref_count_ != __null)
 {
  (*ref_count_) --;
  if ((*ref_count_) == 0)
   destroy();
 }

 data_ = V.data_;
 ref_count_ = V.ref_count_;

 if (V.ref_count_ != __null)
     (*(V.ref_count_))++;

 return *this;
}

template &lt;class T&gt;
void i_refvec&lt;T&gt;::destroy()
{
 if (ref_count_ != __null)
 {



  delete ref_count_;




  if (data_ != __null)
   delete []data_;



  data_ = __null;
 }
}







template&lt;class T&gt;
int i<span class="ge">_refvec&lt;T&gt;::is_</span>null() const
{
 return (data_ == __null ? 1 : 0);
}







template &lt;class T&gt;
int i<span class="ge">_refvec&lt;T&gt;::ref_</span>count() const
{
 if (data_ == __null)
  return 0;
 else
  return (ref_count_ != __null ? *ref_count_ : -1) ;
}

template &lt;class T&gt;
i<span class="ge">_refvec&lt;T&gt;::~i_</span>refvec()
{
 if (ref_count_ != __null)
 {
  (*ref_count_)--;

  if (*ref_count_ == 0)
  destroy();
 }
}


}

namespace TNT
{
template &lt;class T&gt;
class Array1D
{

  private:


    i<span class="ge">_refvec&lt;T&gt; v_</span>;
    int n_;
    T* data_;




    void copy_(T* p, const T* q, int len) const;
    void set_(T* begin, T* end, const T&amp; val);


  public:




    typedef T value_type;


          Array1D();
 explicit Array1D(int n);
          Array1D(int n, const T &amp;a);
          Array1D(int n, T *a);
    inline Array1D(const Array1D &amp;A);
 inline operator T*();
 inline operator const T*();
 inline Array1D &amp; operator=(const T &amp;a);
 inline Array1D &amp; operator=(const Array1D &amp;A);
 inline Array1D &amp; ref(const Array1D &amp;A);
          Array1D copy() const;
       Array1D &amp; inject(const Array1D &amp; A);
 inline T&amp; operator[](int i);
 inline T&amp; operator()(int i);
 inline const T&amp; operator[](int i) const;
 inline const T&amp; operator()(int i) const;
 inline int dim1() const;
 inline int dim() const;
              ~Array1D();




 inline int ref_count() const;
 inline Array1D&lt;T&gt; subarray(int i0, int i1);

};
template &lt;class T&gt;
Array1D&lt;T&gt;::Array1D() : v<span class="ge">_(), n_</span>(0), data_(0) {}
template &lt;class T&gt;
Array1D&lt;T&gt;::Array1D(const Array1D&lt;T&gt; &amp;A) : v<span class="ge">_(A.v_</span>), n<span class="ge">_(A.n_</span>),
  data_(A.data_)
{




}
template &lt;class T&gt;
Array1D&lt;T&gt;::Array1D(int n) : v<span class="ge">_(n), n_</span>(n), data_(v_.begin())
{



}
template &lt;class T&gt;
Array1D&lt;T&gt;::Array1D(int n, const T &amp;val) : v<span class="ge">_(n), n_</span>(n), data_(v_.begin())
{



 set_(data_, data_+ n, val);

}
template &lt;class T&gt;
Array1D&lt;T&gt;::Array1D(int n, T *a) : v<span class="ge">_(a), n_</span>(n) , data_(v_.begin())
{



}
template &lt;class T&gt;
inline Array1D&lt;T&gt;::operator T*()
{
 return &amp;(v_[0]);
}
template &lt;class T&gt;
inline Array1D&lt;T&gt;::operator const T*()
{
 return &amp;(v_[0]);
}
template &lt;class T&gt;
inline T&amp; Array1D&lt;T&gt;::operator[](int i)
{

 (__builtin_expect(!(i&gt;= 0), 0) ? __assert_rtn(__func__, &quot;tnt/tnt_array1d.h&quot;, 272, &quot;i&gt;= 0&quot;) : (void)0);
 (__builtin_expect(!(i &lt; n<span class="ge">_), 0) ? __assert_</span>rtn(__func__, &quot;tnt/tnt_array1d.h&quot;, 273, &quot;i &lt; n_&quot;) : (void)0);

 return data_[i];
}
template &lt;class T&gt;
inline const T&amp; Array1D&lt;T&gt;::operator[](int i) const
{

 (__builtin_expect(!(i&gt;= 0), 0) ? __assert_rtn(__func__, &quot;tnt/tnt_array1d.h&quot;, 296, &quot;i&gt;= 0&quot;) : (void)0);
 (__builtin_expect(!(i &lt; n<span class="ge">_), 0) ? __assert_</span>rtn(__func__, &quot;tnt/tnt_array1d.h&quot;, 297, &quot;i &lt; n_&quot;) : (void)0);

 return data_[i];
}
template &lt;class T&gt;
inline T&amp; Array1D&lt;T&gt;::operator()(int i)
{

 (__builtin_expect(!(i &gt; 0), 0) ? __assert_rtn(__func__, &quot;tnt/tnt_array1d.h&quot;, 320, &quot;i &gt; 0&quot;) : (void)0);
 (__builtin_expect(!(i &lt;= n<span class="ge">_), 0) ? __assert_</span>rtn(__func__, &quot;tnt/tnt_array1d.h&quot;, 321, &quot;i &lt;= n_&quot;) : (void)0);

 return data_[i-1];
}
template &lt;class T&gt;
inline const T&amp; Array1D&lt;T&gt;::operator()(int i) const
{

 (__builtin_expect(!(i &gt; 0), 0) ? __assert_rtn(__func__, &quot;tnt/tnt_array1d.h&quot;, 344, &quot;i &gt; 0&quot;) : (void)0);
 (__builtin_expect(!(i &lt;= n<span class="ge">_), 0) ? __assert_</span>rtn(__func__, &quot;tnt/tnt_array1d.h&quot;, 345, &quot;i &lt;= n_&quot;) : (void)0);

 return data_[i-1];
}
template &lt;class T&gt;
Array1D&lt;T&gt; &amp; Array1D&lt;T&gt;::operator=(const T &amp;a)
{
 set_(data_, data_+n_, a);
 return *this;
}
template &lt;class T&gt;
Array1D&lt;T&gt; Array1D&lt;T&gt;::copy() const
{
 Array1D A( n_);
 copy_(A.data_, data_, n_);

 return A;
}
template &lt;class T&gt;
Array1D&lt;T&gt; &amp; Array1D&lt;T&gt;::inject(const Array1D &amp;A)
{
 if (A.n_ == n_)
  copy_(data_, A.data_, n_);

 return *this;
}
template &lt;class T&gt;
Array1D&lt;T&gt; &amp; Array1D&lt;T&gt;::ref(const Array1D&lt;T&gt; &amp;A)
{
 if (this != &amp;A)
 {
  v_ = A.v_;
  n_ = A.n_;
  data_ = A.data_;

 }
 return *this;
}
template &lt;class T&gt;
Array1D&lt;T&gt; &amp; Array1D&lt;T&gt;::operator=(const Array1D&lt;T&gt; &amp;A)
{
 return ref(A);
}
template &lt;class T&gt;
inline int Array1D&lt;T&gt;::dim1() const { return n_; }
template &lt;class T&gt;
inline int Array1D&lt;T&gt;::dim() const { return n_; }
template &lt;class T&gt;
Array1D&lt;T&gt;::~Array1D() {}
template &lt;class T&gt;
inline int Array1D&lt;T&gt;::ref_count() const
{
 return v<span class="ge">_.ref_</span>count();
}
template &lt;class T&gt;
inline Array1D&lt;T&gt; Array1D&lt;T&gt;::subarray(int i0, int i1)
{
 if ((i0 &gt;= 0) &amp;&amp; (i1 &lt; n_) &amp;&amp; (i0 &lt;= i1))
 {
  Array1D&lt;T&gt; X(*this);
  X.n_ = i1-i0+1;
  X.data_ += i0;

  return X;
 }
 else
 {
  return Array1D&lt;T&gt;();
 }
}





template &lt;class T&gt;
void Array1D&lt;T&gt;::set_(T* begin, T* end, const T&amp; a)
{
 for (T* p=begin; p&lt;end; p++)
  *p = a;

}

template &lt;class T&gt;
void Array1D&lt;T&gt;::copy_(T* p, const T* q, int len) const
{
 T *end = p + len;
 while (p&lt;end )
  <span class="ge">*p++ = *</span>q++;

}


}
extern &quot;C&quot; {
void __assert_rtn(const char <span class="ge">*, const char *</span>, int, const char *) <span class="gs">__attribute__</span>((__noreturn__)) <span class="gs">__attribute__</span>((__cold__)) <span class="gs">__attribute__</span>((__disable_tail_calls__));



}




namespace TNT
{
template &lt;class T&gt;
class Array2D
{


  private:



   Array1D&lt;T&gt; data_;
 Array1D&lt;T*&gt; v_;
 int m_;
    int n_;

  public:
    typedef T value_type;






        Array2D();
        Array2D(int m, int n);
        Array2D(int m, int n, T *a);
        Array2D(int m, int n, const T &amp;val);
    inline Array2D(const Array2D &amp;A);
 inline operator T**();
 inline operator const T**() const;







 inline Array2D &amp; operator=(const T &amp;val);
 inline Array2D &amp; operator=(const Array2D &amp;A);


 inline Array2D &amp; ref(const Array2D &amp;A);
        Array2D copy() const;
     Array2D &amp; inject(const Array2D &amp; A);
 inline T* operator[](int i);
 inline const T* operator[](int i) const;
 inline int dim1() const;
 inline int dim2() const;
     ~Array2D();




 inline int ref_count();
 inline int ref_count_data();
 inline int ref_count_dim1();
 Array2D subarray(int i0, int i1, int j0, int j1);

};
template &lt;class T&gt;
Array2D&lt;T&gt;::Array2D() : data_(), v<span class="ge">_(), m_</span>(0), n_(0) {}


template &lt;class T&gt;
Array2D&lt;T&gt;::Array2D(const Array2D&lt;T&gt; &amp;A) : data_(A.data_), v<span class="ge">_(A.v_</span>),
 m<span class="ge">_(A.m_</span>), n<span class="ge">_(A.n_</span>) {}




template &lt;class T&gt;
Array2D&lt;T&gt;::Array2D(int m, int n) : data_(m*n), v<span class="ge">_(m), m_</span>(m), n_(n)
{
 if (m&gt;0 &amp;&amp; n&gt;0)
 {
  T* p = &amp;(data_[0]);
  for (int i=0; i&lt;m; i++)
  {
   v_[i] = p;
   p += n;
  }
 }
}



template &lt;class T&gt;
Array2D&lt;T&gt;::Array2D(int m, int n, const T &amp;val) : data_(m*n), v_(m),
             m<span class="ge">_(m), n_</span>(n)
{
  if (m&gt;0 &amp;&amp; n&gt;0)
  {
 data_ = val;
 T* p = &amp;(data_[0]);
 for (int i=0; i&lt;m; i++)
 {
   v_[i] = p;
   p += n;
 }
  }
}

template &lt;class T&gt;
Array2D&lt;T&gt;::Array2D(int m, int n, T <span class="ge">*a) : data_(m*</span>n, a), v<span class="ge">_(m), m_</span>(m), n_(n)
{
  if (m&gt;0 &amp;&amp; n&gt;0)
  {
 T* p = &amp;(data_[0]);

 for (int i=0; i&lt;m; i++)
 {
   v_[i] = p;
   p += n;
 }
  }
}


template &lt;class T&gt;
inline T* Array2D&lt;T&gt;::operator[](int i)
{

 (__builtin_expect(!(i &gt;= 0), 0) ? __assert_rtn(__func__, &quot;tnt/tnt_array2d.h&quot;, 280, &quot;i &gt;= 0&quot;) : (void)0);
 (__builtin_expect(!(i &lt; m<span class="ge">_), 0) ? __assert_</span>rtn(__func__, &quot;tnt/tnt_array2d.h&quot;, 281, &quot;i &lt; m_&quot;) : (void)0);


return v_[i];

}


template &lt;class T&gt;
inline const T* Array2D&lt;T&gt;::operator[](int i) const
{

 (__builtin_expect(!(i &gt;= 0), 0) ? __assert_rtn(__func__, &quot;tnt/tnt_array2d.h&quot;, 293, &quot;i &gt;= 0&quot;) : (void)0);
 (__builtin_expect(!(i &lt; m<span class="ge">_), 0) ? __assert_</span>rtn(__func__, &quot;tnt/tnt_array2d.h&quot;, 294, &quot;i &lt; m_&quot;) : (void)0);


return v_[i];

}

template &lt;class T&gt;
Array2D&lt;T&gt; &amp; Array2D&lt;T&gt;::operator=(const T &amp;a)
{


 for (int i=0; i&lt;m_; i++)
  for (int j=0; j&lt;n_; j++)
  v_[i][j] = a;
 return *this;
}




template &lt;class T&gt;
Array2D&lt;T&gt; Array2D&lt;T&gt;::copy() const
{
 Array2D A(m_, n_);

 for (int i=0; i&lt;m_; i++)
  for (int j=0; j&lt;n_; j++)
   A[i][j] = v_[i][j];


 return A;
}


template &lt;class T&gt;
Array2D&lt;T&gt; &amp; Array2D&lt;T&gt;::inject(const Array2D &amp;A)
{
 if (A.m_ == m_ &amp;&amp; A.n_ == n_)
 {
  for (int i=0; i&lt;m_; i++)
   for (int j=0; j&lt;n_; j++)
    v_[i][j] = A[i][j];
 }
 return *this;
}




template &lt;class T&gt;
Array2D&lt;T&gt; &amp; Array2D&lt;T&gt;::ref(const Array2D&lt;T&gt; &amp;A)
{
 if (this != &amp;A)
 {
  v_ = A.v_;
  data_ = A.data_;
  m_ = A.m_;
  n_ = A.n_;

 }
 return *this;
}



template &lt;class T&gt;
Array2D&lt;T&gt; &amp; Array2D&lt;T&gt;::operator=(const Array2D&lt;T&gt; &amp;A)
{
 return ref(A);
}

template &lt;class T&gt;
inline int Array2D&lt;T&gt;::dim1() const { return m_; }

template &lt;class T&gt;
inline int Array2D&lt;T&gt;::dim2() const { return n_; }


template &lt;class T&gt;
Array2D&lt;T&gt;::~Array2D() {}




template &lt;class T&gt;
inline Array2D&lt;T&gt;::operator T**()
{
 return &amp;(v_[0]);
}
template &lt;class T&gt;
inline Array2D&lt;T&gt;::operator const T**() const
{
 return static_cast&lt;const T**&gt;(&amp;(v_[0]));
}
template &lt;class T&gt;
Array2D&lt;T&gt; Array2D&lt;T&gt;::subarray(int i0, int i1, int j0, int j1)
{
 Array2D&lt;T&gt; A;
 int m = i1-i0+1;
 int n = j1-j0+1;




 if (m&lt;1 || n&lt;1)
  return A;

 A.data_ = data_;
 A.m_ = m;
 A.n_ = n;
 A.v_ = Array1D&lt;T*&gt;(m);
 T* p = &amp;(data_[0]) + i0 * n_ + j0;
 for (int i=0; i&lt;m; i++)
 {
  A.v_[i] = p + i*n_;

 }
 return A;
}

template &lt;class T&gt;
inline int Array2D&lt;T&gt;::ref_count()
{
 return ref_count_data();
}



template &lt;class T&gt;
inline int Array2D&lt;T&gt;::ref_count_data()
{
 return data_.ref_count();
}

template &lt;class T&gt;
inline int Array2D&lt;T&gt;::ref_count_dim1()
{
 return v<span class="ge">_.ref_</span>count();
}




}
extern &quot;C&quot; {
void __assert_rtn(const char <span class="ge">*, const char *</span>, int, const char *) <span class="gs">__attribute__</span>((__noreturn__)) <span class="gs">__attribute__</span>((__cold__)) <span class="gs">__attribute__</span>((__disable_tail_calls__));



}





namespace TNT
{

template &lt;class T&gt;
class Array3D
{


  private:
   Array1D&lt;T&gt; data_;
 Array2D&lt;T*&gt; v_;
 int m_;
    int n_;
 int g_;


  public:

    typedef T value_type;

        Array3D();
        Array3D(int m, int n, int g);
        Array3D(int m, int n, int g, T val);
        Array3D(int m, int n, int g, T *a);

 inline operator T***();
 inline operator const T***();
    inline Array3D(const Array3D &amp;A);
 inline Array3D &amp; operator=(const T &amp;a);
 inline Array3D &amp; operator=(const Array3D &amp;A);
 inline Array3D &amp; ref(const Array3D &amp;A);
        Array3D copy() const;
     Array3D &amp; inject(const Array3D &amp; A);

 inline T** operator[](int i);
 inline const T* const * operator[](int i) const;
 inline int dim1() const;
 inline int dim2() const;
 inline int dim3() const;
               ~Array3D();



 inline int ref_count(){ return data_.ref_count(); }
   Array3D subarray(int i0, int i1, int j0, int j1,
       int k0, int k1);
};

template &lt;class T&gt;
Array3D&lt;T&gt;::Array3D() : data_(), v<span class="ge">_(), m_</span>(0), n<span class="ge">_(0), g_</span>(0) {}

template &lt;class T&gt;
Array3D&lt;T&gt;::Array3D(const Array3D&lt;T&gt; &amp;A) : data_(A.data_),
 v<span class="ge">_(A.v_</span>), m<span class="ge">_(A.m_</span>), n<span class="ge">_(A.n_</span>), g<span class="ge">_(A.g_</span>)
{
}



template &lt;class T&gt;
Array3D&lt;T&gt;::Array3D(int m, int n, int g) : data_(m*n*g), v_(m,n),
 m<span class="ge">_(m), n_</span>(n), g_(g)
{

  if (m&gt;0 &amp;&amp; n&gt;0 &amp;&amp; g&gt;0)
  {
 T* p = &amp; (data_[0]);
 int ng = n<span class="ge">_*g_</span>;

 for (int i=0; i&lt;m_; i++)
 {
  T* ping = p+ i*ng;
  for (int j=0; j&lt;n; j++)
   v<span class="ge">_[i][j] = ping + j*g_</span>;
 }
  }
}



template &lt;class T&gt;
Array3D&lt;T&gt;::Array3D(int m, int n, int g, T val) : data_(m*n*g, val),
 v<span class="ge">_(m,n), m_</span>(m), n<span class="ge">_(n), g_</span>(g)
{
  if (m&gt;0 &amp;&amp; n&gt;0 &amp;&amp; g&gt;0)
  {

 T* p = &amp; (data_[0]);
 int ng = n<span class="ge">_*g_</span>;

 for (int i=0; i&lt;m_; i++)
 {
  T* ping = p+ i*ng;
  for (int j=0; j&lt;n; j++)
   v<span class="ge">_[i][j] = ping + j*g_</span>;
 }
  }
}



template &lt;class T&gt;
Array3D&lt;T&gt;::Array3D(int m, int n, int g, T* a) :
  data_(m*n*g, a), v<span class="ge">_(m,n), m_</span>(m), n<span class="ge">_(n), g_</span>(g)
{

  if (m&gt;0 &amp;&amp; n&gt;0 &amp;&amp; g&gt;0)
  {
 T* p = &amp; (data_[0]);
 int ng = n<span class="ge">_*g_</span>;

 for (int i=0; i&lt;m_; i++)
 {
  T* ping = p+ i*ng;
  for (int j=0; j&lt;n; j++)
   v<span class="ge">_[i][j] = ping + j*g_</span>;
 }
  }
}



template &lt;class T&gt;
inline T** Array3D&lt;T&gt;::operator[](int i)
{

 (__builtin_expect(!(i &gt;= 0), 0) ? __assert_rtn(__func__, &quot;tnt/tnt_array3d.h&quot;, 160, &quot;i &gt;= 0&quot;) : (void)0);
 (__builtin_expect(!(i &lt; m<span class="ge">_), 0) ? __assert_</span>rtn(__func__, &quot;tnt/tnt_array3d.h&quot;, 161, &quot;i &lt; m_&quot;) : (void)0);


return v_[i];

}

template &lt;class T&gt;
inline const T* const * Array3D&lt;T&gt;::operator[](int i) const
{ return v_[i]; }

template &lt;class T&gt;
Array3D&lt;T&gt; &amp; Array3D&lt;T&gt;::operator=(const T &amp;a)
{
 for (int i=0; i&lt;m_; i++)
  for (int j=0; j&lt;n_; j++)
   for (int k=0; k&lt;g_; k++)
    v_[i][j][k] = a;

 return *this;
}

template &lt;class T&gt;
Array3D&lt;T&gt; Array3D&lt;T&gt;::copy() const
{
 Array3D A(m_, n<span class="ge">_, g_</span>);
 for (int i=0; i&lt;m_; i++)
  for (int j=0; j&lt;n_; j++)
   for (int k=0; k&lt;g_; k++)
    A.v_[i][j][k] = v_[i][j][k];

 return A;
}


template &lt;class T&gt;
Array3D&lt;T&gt; &amp; Array3D&lt;T&gt;::inject(const Array3D &amp;A)
{
 if (A.m_ == m_ &amp;&amp; A.n_ == n_ &amp;&amp; A.g_ == g_)

 for (int i=0; i&lt;m_; i++)
  for (int j=0; j&lt;n_; j++)
   for (int k=0; k&lt;g_; k++)
    v<span class="ge">_[i][j][k] = A.v_</span>[<span class="nt">i</span>][<span class="nl">j</span>][k];

 return *this;
}



template &lt;class T&gt;
Array3D&lt;T&gt; &amp; Array3D&lt;T&gt;::ref(const Array3D&lt;T&gt; &amp;A)
{
 if (this != &amp;A)
 {
  m_ = A.m_;
  n_ = A.n_;
  g_ = A.g_;
  v_ = A.v_;
  data_ = A.data_;
 }
 return *this;
}

template &lt;class T&gt;
Array3D&lt;T&gt; &amp; Array3D&lt;T&gt;::operator=(const Array3D&lt;T&gt; &amp;A)
{
 return ref(A);
}


template &lt;class T&gt;
inline int Array3D&lt;T&gt;::dim1() const { return m_; }

template &lt;class T&gt;
inline int Array3D&lt;T&gt;::dim2() const { return n_; }

template &lt;class T&gt;
inline int Array3D&lt;T&gt;::dim3() const { return g_; }



template &lt;class T&gt;
Array3D&lt;T&gt;::~Array3D() {}

template &lt;class T&gt;
inline Array3D&lt;T&gt;::operator T***()
{
 return v_;
}


template &lt;class T&gt;
inline Array3D&lt;T&gt;::operator const T***()
{
 return v_;
}


template &lt;class T&gt;
Array3D&lt;T&gt; Array3D&lt;T&gt;::subarray(int i0, int i1, int j0,
 int j1, int k0, int k1)
{


 if (!( 0 &lt;= i0 &amp;&amp; i0 &lt;= i1 &amp;&amp; i1 &lt; m_ &amp;&amp;
       0 &lt;= j0 &amp;&amp; j0 &lt;= j1 &amp;&amp; j1 &lt; n_ &amp;&amp;
       0 &lt;= k0 &amp;&amp; k0 &lt;= k1 &amp;&amp; k1 &lt; g_))
  return Array3D&lt;T&gt;();


 Array3D&lt;T&gt; A;
 A.data_ = data_;
 A.m_ = i1-i0+1;
 A.n_ = j1-j0+1;
 A.g_ = k1-k0+1;
 A.v_ = Array2D&lt;T*&gt;(A.m_,A.n_);
 T* p = &amp;(data_[0]) + i0*n_*g_ + j0*g_ + k0;

 for (int i=0; i&lt;A.m_; i++)
 {
  T* ping = p + i<span class="ge">*n_*</span>g_;
  for (int j=0; j&lt;A.n_; j++)
   A.v_[i][j] = ping + j*g_ ;
 }

 return A;
}



}
namespace TNT
{
template &lt;class T&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream &amp;s, const Array1D&lt;T&gt; &amp;A)
{
    int N=A.dim1();




    s &lt;&lt; &quot;Dimension: &quot; &lt;&lt; N &lt;&lt; &quot;\n&quot;;
 s &lt;&lt; &quot;Components: \n&quot;;
    for (int j=0; j&lt;N; j++)
    {
       s &lt;&lt; A[j] &lt;&lt; &quot;\n&quot;;
    }
    s &lt;&lt; &quot;\n&quot;;

    return s;
}
template &lt;class T&gt;
std::istream&amp; operator&gt;&gt;(std::istream &amp;s, Array1D&lt;T&gt; &amp;A)
{
 int N;
 s &gt;&gt; N;

 Array1D&lt;T&gt; B(N);
 for (int i=0; i&lt;N; i++)
  s &gt;&gt; B[i];
 A = B;
 return s;
}
template &lt;class T&gt;
Array1D&lt;T&gt; operator+(const Array1D&lt;T&gt; &amp;A, const Array1D&lt;T&gt; &amp;B)
{
 int n = A.dim1();

 if (B.dim1() != n )
  return Array1D&lt;T&gt;();

 else
 {
  Array1D&lt;T&gt; C(n);

  for (int i=0; i&lt;n; i++)
  {
   C[i] = A[i] + B[i];
  }
  return C;
 }
}
template &lt;class T&gt;
Array1D&lt;T&gt; operator-(const Array1D&lt;T&gt; &amp;A, const Array1D&lt;T&gt; &amp;B)
{
 int n = A.dim1();

 if (B.dim1() != n )
  return Array1D&lt;T&gt;();

 else
 {
  Array1D&lt;T&gt; C(n);

  for (int i=0; i&lt;n; i++)
  {
   C[i] = A[i] - B[i];
  }
  return C;
 }
}
template &lt;class T&gt;
Array1D&lt;T&gt; operator*(const Array1D&lt;T&gt; &amp;A, const Array1D&lt;T&gt; &amp;B)
{
 int n = A.dim1();

 if (B.dim1() != n )
  return Array1D&lt;T&gt;();

 else
 {
  Array1D&lt;T&gt; C(n);

  for (int i=0; i&lt;n; i++)
  {
   C[i] = A[i] * B[i];
  }
  return C;
 }
}
template &lt;class T&gt;
Array1D&lt;T&gt; operator*(Array1D&lt;T&gt; &amp;A, const T &amp;b)
{
 int n = A.dim1();
    Array1D&lt;T&gt; C(n);

 for (int i=0; i&lt;n; i++)
 {
  C[i] = A[i]*b;
 }
 return C;
}
template &lt;class T&gt;
inline Array1D&lt;T&gt; operator*(const T &amp;b, Array1D&lt;T&gt; &amp;A)
{
 return A*b;
}
template &lt;class T&gt;
Array1D&lt;T&gt; operator/(const Array1D&lt;T&gt; &amp;A, const Array1D&lt;T&gt; &amp;B)
{
 int n = A.dim1();

 if (B.dim1() != n )
  return Array1D&lt;T&gt;();

 else
 {
  Array1D&lt;T&gt; C(n);

  for (int i=0; i&lt;n; i++)
  {
   C[i] = A[i] / B[i];
  }
  return C;
 }
}
template &lt;class T&gt;
Array1D&lt;T&gt; operator/(const Array1D&lt;T&gt; &amp;A, const T &amp;b)
{
 int n = A.dim1();
    Array1D&lt;T&gt; C(n);
 for (int i=0; i&lt;n; i++)
 {
  C[i] = A[i]/b;
 }
 return C;
}
template &lt;class T&gt;
Array1D&lt;T&gt;&amp; operator+=(Array1D&lt;T&gt; &amp;A, const Array1D&lt;T&gt; &amp;B)
{
 int n = A.dim1();

 if (B.dim1() == n)
 {
  for (int i=0; i&lt;n; i++)
  {
    A[i] += B[i];
  }
 }
 return A;
}
template &lt;class T&gt;
Array1D&lt;T&gt;&amp; operator-=(Array1D&lt;T&gt; &amp;A, const Array1D&lt;T&gt; &amp;B)
{
 int n = A.dim1();

 if (B.dim1() == n)
 {
  for (int i=0; i&lt;n; i++)
  {
    A[i] -= B[i];
  }
 }
 return A;
}
template &lt;class T&gt;
Array1D&lt;T&gt;&amp; operator*=(Array1D&lt;T&gt; &amp;A, const Array1D&lt;T&gt; &amp;B)
{
 int n = A.dim1();

 if (B.dim1() == n)
 {
  for (int i=0; i&lt;n; i++)
  {
    A[i] *= B[i];
  }
 }
 return A;
}
template &lt;class T&gt;
Array1D&lt;T&gt;&amp; operator*=(Array1D&lt;T&gt; &amp;A, const T &amp;b)
{
 int n = A.dim1();
  for (int i=0; i&lt;n; i++)
  {
    A[i] *= b;
  }
 return A;
}
template &lt;class T&gt;
Array1D&lt;T&gt;&amp; operator/=(Array1D&lt;T&gt; &amp;A, const Array1D&lt;T&gt; &amp;B)
{
 int n = A.dim1();

 if (B.dim1() == n)
 {
  for (int i=0; i&lt;n; i++)
  {
    A[i] /= B[i];
  }
 }
 return A;
}
template &lt;class T&gt;
Array1D&lt;T&gt;&amp; operator/=(Array1D&lt;T&gt; &amp;A, const T &amp;b)
{
 int n = A.dim1();
  for (int i=0; i&lt;n; i++)
  {
    A[i] /= b;
  }
 return A;
}
template &lt;class T&gt;
double norm(const Array1D&lt;T&gt; &amp;A)
{
 int n = A.dim1();

 double sum = 0.0;
 for (int i=0; i&lt;n; i++)
  sum += abs(A[i])*abs(A[i]);
 return sqrt(sum);
}
template &lt;class T&gt;
Array1D&lt;T&gt; cross(const Array1D&lt;T&gt; &amp;A, const Array1D&lt;T&gt; &amp;B)
{
    int n = A.dim1();
    int m = B.dim1();

    if (n != 3 || m != 3 )
        return Array1D&lt;T&gt;();
    else
    {
        Array1D&lt;T&gt; C(n);
        C[0] = A[1]*B[2] - A[2]*B[1];
        C[1] = A[2]*B[0] - A[0]*B[2];
        C[2] = A[0]*B[1] - A[1]*B[0];
            return C;
    }
}
template &lt;class T&gt;
T dot_product(const Array1D&lt;T&gt; &amp;A, const Array1D&lt;T&gt; &amp;B)
{
    int n = A.dim1();
    int m = B.dim1();

    if (n != 3 || m != 3 )
        return Array1D&lt;T&gt;();
    else
    {
  T sum = 0;
  for (int i=0; i&lt;n; i++)
   sum += A[i] * B[i];

        return sum;
    }
}

}
extern &quot;C&quot; {
void __assert_rtn(const char <span class="ge">*, const char *</span>, int, const char *) <span class="gs">__attribute__</span>((__noreturn__)) <span class="gs">__attribute__</span>((__cold__)) <span class="gs">__attribute__</span>((__disable_tail_calls__));



}

namespace TNT
{


template &lt;class T&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream &amp;s, const Array2D&lt;T&gt; &amp;A)
{
    int M=A.dim1();
    int N=A.dim2();

    s &lt;&lt; M &lt;&lt; &quot; &quot; &lt;&lt; N &lt;&lt; &quot;\n&quot;;

    for (int i=0; i&lt;M; i++)
    {
        for (int j=0; j&lt;N; j++)
        {
            s &lt;&lt; A[i][j] &lt;&lt; &quot; &quot;;
        }
        s &lt;&lt; &quot;\n&quot;;
    }


    return s;
}

template &lt;class T&gt;
std::istream&amp; operator&gt;&gt;(std::istream &amp;s, Array2D&lt;T&gt; &amp;A)
{

    int M, N;

    s &gt;&gt; M &gt;&gt; N;

 Array2D&lt;T&gt; B(M,N);

    for (int i=0; i&lt;M; i++)
        for (int j=0; j&lt;N; j++)
        {
            s &gt;&gt; B[i][j];
        }

 A = B;
    return s;
}


template &lt;class T&gt;
Array2D&lt;T&gt; operator+(const Array2D&lt;T&gt; &amp;A, const Array2D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();

 if (B.dim1() != m || B.dim2() != n )
  return Array2D&lt;T&gt;();

 else
 {
  Array2D&lt;T&gt; C(m,n);

  for (int i=0; i&lt;m; i++)
  {
   for (int j=0; j&lt;n; j++)
    C[i][j] = A[i][j] + B[i][j];
  }
  return C;
 }
}

template &lt;class T&gt;
Array2D&lt;T&gt; operator-(const Array2D&lt;T&gt; &amp;A, const Array2D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();

 if (B.dim1() != m || B.dim2() != n )
  return Array2D&lt;T&gt;();

 else
 {
  Array2D&lt;T&gt; C(m,n);

  for (int i=0; i&lt;m; i++)
  {
   for (int j=0; j&lt;n; j++)
    C[i][j] = A[i][j] - B[i][j];
  }
  return C;
 }
}


template &lt;class T&gt;
Array2D&lt;T&gt; operator*(const Array2D&lt;T&gt; &amp;A, const Array2D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();

 if (B.dim1() != m || B.dim2() != n )
  return Array2D&lt;T&gt;();

 else
 {
  Array2D&lt;T&gt; C(m,n);

  for (int i=0; i&lt;m; i++)
  {
   for (int j=0; j&lt;n; j++)
    C[i][j] = A[i][j] * B[i][j];
  }
  return C;
 }
}




template &lt;class T&gt;
Array2D&lt;T&gt; operator/(const Array2D&lt;T&gt; &amp;A, const Array2D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();

 if (B.dim1() != m || B.dim2() != n )
  return Array2D&lt;T&gt;();

 else
 {
  Array2D&lt;T&gt; C(m,n);

  for (int i=0; i&lt;m; i++)
  {
   for (int j=0; j&lt;n; j++)
    C[i][j] = A[i][j] / B[i][j];
  }
  return C;
 }
}





template &lt;class T&gt;
Array2D&lt;T&gt;&amp; operator+=(Array2D&lt;T&gt; &amp;A, const Array2D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();

 if (B.dim1() == m || B.dim2() == n )
 {
  for (int i=0; i&lt;m; i++)
  {
   for (int j=0; j&lt;n; j++)
    A[i][j] += B[i][j];
  }
 }
 return A;
}



template &lt;class T&gt;
Array2D&lt;T&gt;&amp; operator-=(Array2D&lt;T&gt; &amp;A, const Array2D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();

 if (B.dim1() == m || B.dim2() == n )
 {
  for (int i=0; i&lt;m; i++)
  {
   for (int j=0; j&lt;n; j++)
    A[i][j] -= B[i][j];
  }
 }
 return A;
}



template &lt;class T&gt;
Array2D&lt;T&gt;&amp; operator*=(Array2D&lt;T&gt; &amp;A, const Array2D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();

 if (B.dim1() == m || B.dim2() == n )
 {
  for (int i=0; i&lt;m; i++)
  {
   for (int j=0; j&lt;n; j++)
    A[i][j] *= B[i][j];
  }
 }
 return A;
}





template &lt;class T&gt;
Array2D&lt;T&gt;&amp; operator/=(Array2D&lt;T&gt; &amp;A, const Array2D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();

 if (B.dim1() == m || B.dim2() == n )
 {
  for (int i=0; i&lt;m; i++)
  {
   for (int j=0; j&lt;n; j++)
    A[i][j] /= B[i][j];
  }
 }
 return A;
}
template &lt;class T&gt;
Array2D&lt;T&gt; matmult(const Array2D&lt;T&gt; &amp;A, const Array2D&lt;T&gt; &amp;B)
{
    if (A.dim2() != B.dim1())
        return Array2D&lt;T&gt;();

    int M = A.dim1();
    int N = A.dim2();
    int K = B.dim2();

    Array2D&lt;T&gt; C(M,K);

    for (int i=0; i&lt;M; i++)
        for (int j=0; j&lt;K; j++)
        {
            T sum = 0;

            for (int k=0; k&lt;N; k++)
                sum += A[i][k] * B [<span class="nt">k</span>][<span class="nl">j</span>];

            C[i][j] = sum;
        }

    return C;

}

}






extern &quot;C&quot; {
void __assert_rtn(const char <span class="ge">*, const char *</span>, int, const char *) <span class="gs">__attribute__</span>((__noreturn__)) <span class="gs">__attribute__</span>((__cold__)) <span class="gs">__attribute__</span>((__disable_tail_calls__));



}

namespace TNT
{


template &lt;class T&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream &amp;s, const Array3D&lt;T&gt; &amp;A)
{
    int M=A.dim1();
    int N=A.dim2();
    int K=A.dim3();

    s &lt;&lt; M &lt;&lt; &quot; &quot; &lt;&lt; N &lt;&lt; &quot; &quot; &lt;&lt; K &lt;&lt; &quot;\n&quot;;

    for (int i=0; i&lt;M; i++)
    {
        for (int j=0; j&lt;N; j++)
        {
   for (int k=0; k&lt;K; k++)
             s &lt;&lt; A[i][j][k] &lt;&lt; &quot; &quot;;
   s &lt;&lt; &quot;\n&quot;;
        }
        s &lt;&lt; &quot;\n&quot;;
    }


    return s;
}

template &lt;class T&gt;
std::istream&amp; operator&gt;&gt;(std::istream &amp;s, Array3D&lt;T&gt; &amp;A)
{

    int M, N, K;

    s &gt;&gt; M &gt;&gt; N &gt;&gt; K;

 Array3D&lt;T&gt; B(M,N,K);

    for (int i=0; i&lt;M; i++)
        for (int j=0; j&lt;N; j++)
   for (int k=0; k&lt;K; k++)
             s &gt;&gt; B[i][j][k];

 A = B;
    return s;
}



template &lt;class T&gt;
Array3D&lt;T&gt; operator+(const Array3D&lt;T&gt; &amp;A, const Array3D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();
 int p = A.dim3();

 if (B.dim1() != m || B.dim2() != n || B.dim3() != p )
  return Array3D&lt;T&gt;();

 else
 {
  Array3D&lt;T&gt; C(m,n,p);

  for (int i=0; i&lt;m; i++)
   for (int j=0; j&lt;n; j++)
    for (int k=0; k&lt;p; k++)
    C[i][j][k] = A[i][j][k] + B[i][j][k];

  return C;
 }
}


template &lt;class T&gt;
Array3D&lt;T&gt; operator-(const Array3D&lt;T&gt; &amp;A, const Array3D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();
 int p = A.dim3();

 if (B.dim1() != m || B.dim2() != n || B.dim3() != p )
  return Array3D&lt;T&gt;();

 else
 {
  Array3D&lt;T&gt; C(m,n,p);

  for (int i=0; i&lt;m; i++)
   for (int j=0; j&lt;n; j++)
    for (int k=0; k&lt;p; k++)
    C[i][j][k] = A[i][j][k] - B[i][j][k];

  return C;
 }
}




template &lt;class T&gt;
Array3D&lt;T&gt; operator*(const Array3D&lt;T&gt; &amp;A, const Array3D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();
 int p = A.dim3();

 if (B.dim1() != m || B.dim2() != n || B.dim3() != p )
  return Array3D&lt;T&gt;();

 else
 {
  Array3D&lt;T&gt; C(m,n,p);

  for (int i=0; i&lt;m; i++)
   for (int j=0; j&lt;n; j++)
    for (int k=0; k&lt;p; k++)
    C[i][j][k] = A[i][j][k] * B[i][j][k];

  return C;
 }
}


template &lt;class T&gt;
Array3D&lt;T&gt; operator/(const Array3D&lt;T&gt; &amp;A, const Array3D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();
 int p = A.dim3();

 if (B.dim1() != m || B.dim2() != n || B.dim3() != p )
  return Array3D&lt;T&gt;();

 else
 {
  Array3D&lt;T&gt; C(m,n,p);

  for (int i=0; i&lt;m; i++)
   for (int j=0; j&lt;n; j++)
    for (int k=0; k&lt;p; k++)
    C[i][j][k] = A[i][j][k] / B[i][j][k];

  return C;
 }
}



template &lt;class T&gt;
Array3D&lt;T&gt;&amp; operator+=(Array3D&lt;T&gt; &amp;A, const Array3D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();
 int p = A.dim3();

 if (B.dim1() == m &amp;&amp; B.dim2() == n &amp;&amp; B.dim3() == p )
 {
  for (int i=0; i&lt;m; i++)
   for (int j=0; j&lt;n; j++)
    for (int k=0; k&lt;p; k++)
     A[i][j][k] += B[i][j][k];
 }

 return A;
}

template &lt;class T&gt;
Array3D&lt;T&gt;&amp; operator-=(Array3D&lt;T&gt; &amp;A, const Array3D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();
 int p = A.dim3();

 if (B.dim1() == m &amp;&amp; B.dim2() == n &amp;&amp; B.dim3() == p )
 {
  for (int i=0; i&lt;m; i++)
   for (int j=0; j&lt;n; j++)
    for (int k=0; k&lt;p; k++)
     A[i][j][k] -= B[i][j][k];
 }

 return A;
}

template &lt;class T&gt;
Array3D&lt;T&gt;&amp; operator*=(Array3D&lt;T&gt; &amp;A, const Array3D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();
 int p = A.dim3();

 if (B.dim1() == m &amp;&amp; B.dim2() == n &amp;&amp; B.dim3() == p )
 {
  for (int i=0; i&lt;m; i++)
   for (int j=0; j&lt;n; j++)
    for (int k=0; k&lt;p; k++)
     A[i][j][k] *= B[i][j][k];
 }

 return A;
}


template &lt;class T&gt;
Array3D&lt;T&gt;&amp; operator/=(Array3D&lt;T&gt; &amp;A, const Array3D&lt;T&gt; &amp;B)
{
 int m = A.dim1();
 int n = A.dim2();
 int p = A.dim3();

 if (B.dim1() == m &amp;&amp; B.dim2() == n &amp;&amp; B.dim3() == p )
 {
  for (int i=0; i&lt;m; i++)
   for (int j=0; j&lt;n; j++)
    for (int k=0; k&lt;p; k++)
     A[i][j][k] /= B[i][j][k];
 }

 return A;
}





}

int main()
{

        std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl;
  TNT::Array1D&lt;double&gt; A (3,1);
  TNT::Array1D&lt;double&gt; B (3,1);


  A+=B;

  std::cout &lt;&lt; A;
        return 0;
}
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>