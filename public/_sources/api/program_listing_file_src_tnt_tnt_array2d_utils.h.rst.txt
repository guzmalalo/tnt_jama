
.. _program_listing_file_src_tnt_tnt_array2d_utils.h:

Program Listing for File tnt_array2d_utils.h
============================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_tnt_tnt_array2d_utils.h>` (``src/tnt/tnt_array2d_utils.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
   *
   * Template Numerical Toolkit (TNT)
   *
   * Mathematical and Computational Sciences Division
   * National Institute of Technology,
   * Gaithersburg, MD USA
   *
   *
   * This software was developed at the National Institute of Standards and
   * Technology (NIST) by employees of the Federal Government in the course
   * of their official duties. Pursuant to title 17 Section 105 of the
   * United States Code, this software is not subject to copyright protection
   * and is in the public domain. NIST assumes no responsibility whatsoever for
   * its use by other parties, and makes no guarantees, expressed or implied,
   * about its quality, reliability, or any other characteristic.
   *
   */
   
   #ifndef TNT_ARRAY2D_UTILS_H
   #define TNT_ARRAY2D_UTILS_H
   
   // local includes
   #include "tnt_array2d.h"
   
   namespace TNT
   {
   
     template <class T>
     std::ostream &operator<<(std::ostream &s, const Array2D<T> &A)
     {
       int M = A.dim1();
       int N = A.dim2();
   
       s << "Dimensions: " << M << " " << N << "\n";
       s << "Components: \n";
       for (int i = 0; i < M; i++)
       {
         for (int j = 0; j < N; j++)
         {
           s << A[i][j] << " ";
         }
         s << "\n";
       }
       s << "\n";
   
       return s;
     }
   
     template <class T>
     std::istream &operator>>(std::istream &s, Array2D<T> &A)
     {
   
       int M, N;
   
       s >> M >> N;
   
       Array2D<T> B(M, N);
   
       for (int i = 0; i < M; i++)
         for (int j = 0; j < N; j++)
         {
           s >> B[i][j];
         }
   
       A = B;
       return s;
     }
   
     template <class T>
     Array2D<T> operator+(const Array2D<T> &A, const Array2D<T> &B)
     {
       int m = A.dim1();
       int n = A.dim2();
   
       if (B.dim1() != m || B.dim2() != n)
         return Array2D<T>();
   
       else
       {
         Array2D<T> C(m, n);
   
         for (int i = 0; i < m; i++)
         {
           for (int j = 0; j < n; j++)
             C[i][j] = A[i][j] + B[i][j];
         }
         return C;
       }
     }
   
     template <class T>
     Array2D<T> operator-(const Array2D<T> &A, const Array2D<T> &B)
     {
       int m = A.dim1();
       int n = A.dim2();
   
       if (B.dim1() != m || B.dim2() != n)
         return Array2D<T>();
   
       else
       {
         Array2D<T> C(m, n);
   
         for (int i = 0; i < m; i++)
         {
           for (int j = 0; j < n; j++)
             C[i][j] = A[i][j] - B[i][j];
         }
         return C;
       }
     }
   
     template <class T>
     Array2D<T> operator*(const Array2D<T> &A, const Array2D<T> &B)
     {
       int m = A.dim1();
       int n = A.dim2();
   
       if (B.dim1() != m || B.dim2() != n)
         return Array2D<T>();
   
       else
       {
         Array2D<T> C(m, n);
   
         for (int i = 0; i < m; i++)
         {
           for (int j = 0; j < n; j++)
             C[i][j] = A[i][j] * B[i][j];
         }
         return C;
       }
     }
   
     template <class T>
     Array2D<T> operator*(const Array2D<T> &A, const double &b)
     {
       int m = A.dim1();
       int n = A.dim2();
   
       Array2D<T> C(m, n);
   
       for (int i = 0; i < m; i++)
       {
         for (int j = 0; j < n; j++)
           C[i][j] = A[i][j] * b;
       }
       return C;
     }
   
     template <class T>
     inline Array2D<T> operator*(const T &b, Array2D<T> &A)
     {
       return A * b;
     }
   
     template <class T>
     Array2D<T> operator/(const Array2D<T> &A, const Array2D<T> &B)
     {
       int m = A.dim1();
       int n = A.dim2();
   
       if (B.dim1() != m || B.dim2() != n)
         return Array2D<T>();
   
       else
       {
         Array2D<T> C(m, n);
   
         for (int i = 0; i < m; i++)
         {
           for (int j = 0; j < n; j++)
             C[i][j] = A[i][j] / B[i][j];
         }
         return C;
       }
     }
   
     template <class T>
     Array2D<T> operator/(const Array2D<T> &A, const T &b)
     {
       int m = A.dim1();
       int n = A.dim2();
   
       Array2D<T> C(m, n);
   
       for (int i = 0; i < m; i++)
       {
         for (int j = 0; j < n; j++)
           C[i][j] = A[i][j] / b;
       }
       return C;
     }
   
     template <class T>
     Array2D<T> &operator+=(Array2D<T> &A, const Array2D<T> &B)
     {
       int m = A.dim1();
       int n = A.dim2();
   
       if (B.dim1() == m || B.dim2() == n)
       {
         for (int i = 0; i < m; i++)
         {
           for (int j = 0; j < n; j++)
             A[i][j] += B[i][j];
         }
       }
       return A;
     }
   
     template <class T>
     Array2D<T> &operator-=(Array2D<T> &A, const Array2D<T> &B)
     {
       int m = A.dim1();
       int n = A.dim2();
   
       if (B.dim1() == m || B.dim2() == n)
       {
         for (int i = 0; i < m; i++)
         {
           for (int j = 0; j < n; j++)
             A[i][j] -= B[i][j];
         }
       }
       return A;
     }
   
     template <class T>
     Array2D<T> &operator*=(Array2D<T> &A, const Array2D<T> &B)
     {
       int m = A.dim1();
       int n = A.dim2();
   
       if (B.dim1() == m || B.dim2() == n)
       {
         for (int i = 0; i < m; i++)
         {
           for (int j = 0; j < n; j++)
             A[i][j] *= B[i][j];
         }
       }
       return A;
     }
   
     template <class T>
     Array2D<T> &operator*=(Array2D<T> &A, const T &b)
     {
       int m = A.dim1();
       int n = A.dim2();
   
       for (int i = 0; i < m; i++)
       {
         for (int j = 0; j < n; j++)
           A[i][j] *= b;
       }
       return A;
     }
   
     template <class T>
     Array2D<T> &operator/=(Array2D<T> &A, const Array2D<T> &B)
     {
       int m = A.dim1();
       int n = A.dim2();
   
       if (B.dim1() == m || B.dim2() == n)
       {
         for (int i = 0; i < m; i++)
         {
           for (int j = 0; j < n; j++)
             A[i][j] /= B[i][j];
         }
       }
       return A;
     }
   
     template <class T>
     Array2D<T> &operator/=(Array2D<T> &A, const T &b)
     {
       int m = A.dim1();
       int n = A.dim2();
   
       for (int i = 0; i < m; i++)
       {
         for (int j = 0; j < n; j++)
           A[i][j] /= b;
       }
       return A;
     }
   
     /* ........................ extended functions ......................*/
     template <class T>
     bool operator==(const Array2D<T> &A, const Array2D<T> &B)
     {
       int m = A.dim1();
       int n = A.dim2();
   
       if (B.dim1() != m || B.dim2() != n)
         return false;
   
       else
       {
         for (int i = 0; i < m; i++)
         {
           for (int j = 0; j < n; j++)
             if (A[i][j] != B[i][j])
               return false;
         }
         return true;
       }
     }
   
     template <class T>
     Array2D<T> matmult(const Array2D<T> &A, const Array2D<T> &B)
     {
       if (A.dim2() != B.dim1())
         return Array2D<T>();
   
       int M = A.dim1();
       int N = A.dim2();
       int K = B.dim2();
   
       Array2D<T> C(M, K);
   
       T sum = 0;
   
       for (int i = 0; i < M; i++)
         for (int j = 0; j < K; j++)
         {
           for (int k = 0; k < N; k++)
           {
             sum += A[i][k] * B[k][j];
           }
           C[i][j] = sum;
           sum = 0;
         }
   
       return C;
     }
   
     template <class T>
     TNT::Array2D<T> transpose(const TNT::Array2D<T> &A)
     {
       int M = A.dim1();
       int N = A.dim2();
   
       TNT::Array2D<T> B(N, M);
   
       for (int i = 0; i < M; ++i)
         for (int j = 0; j < N; ++j)
           B[j][i] = A[i][j];
   
       return B;
     }
   
     template <class T>
     Array2D<T> transpose_mult(const Array2D<T> &A, const Array2D<T> &B)
     {
   
       if (A.dim1() != B.dim1())
         return Array2D<T>();
   
       int M = A.dim1();
       int N = A.dim2();
       int K = B.dim2();
   
       Array2D<T> C(M, K);
       T sum;
   
       for (int i = 0; i < N; i++)
         for (int k = 0; k < K; k++)
         {
           sum = 0;
           for (int j = 0; j < M; j++)
             sum = sum + A[j][i] * B[j][k];
   
           C[i][k] = sum;
         }
   
       return C;
     }
   
     template <class T>
     Array2D<T> mult_transpose(const Array2D<T> &A, const Array2D<T> &B)
     {
   
       if (A.dim2() != B.dim2())
         return Array2D<T>();
   
       int M = A.dim1();
       int N = A.dim2();
       int K = B.dim1();
   
       Array2D<T> C(M, K);
       T sum;
   
       for (int i = 0; i < M; i++)
         for (int k = 0; k < K; k++)
         {
           sum = 0;
           for (int j = 0; j < N; j++)
             sum = sum + A[i][j] * B[k][j];
   
           C[i][k] = sum;
         }
   
       return C;
     }
   
     template <class T>
     Array1D<T> matmult(const Array2D<T> &A, const Array1D<T> &b)
     {
   
       if (A.dim2() != b.dim1())
         return Array1D<T>();
   
       int M = A.dim1();
       int N = A.dim2();
   
       Array1D<T> tmp(M);
   
       for (int i = 0; i < M; i++)
       {
         T sum = 0;
         for (int j = 0; j < N; j++)
           sum = sum + A[i][j] * b[j];
   
         tmp[i] = sum;
       }
   
       return tmp;
     }
   
     template <class T>
     Array1D<T> transpose_mult(const Array2D<T> &A, const Array1D<T> &b)
     {
   
       if (A.dim1() != b.dim1())
         return Array1D<T>();
   
       int M = A.dim2();
       int N = A.dim1();
   
       Array1D<T> tmp(M);
   
       for (int i = 0; i < M; i++)
       {
         T sum = 0;
         for (int j = 0; j < N; j++)
           sum = sum + A[j][i] * b[j];
   
         tmp[i] = sum;
       }
   
       return tmp;
     }
   
     template <class T>
     TNT::Array2D<T> invert(const TNT::Array2D<T> &M)
     {
       // square matrices only
       assert(M.dim1() == M.dim2());
       int m = M.dim1();
   
       T det_m;
       TNT::Array2D<T> inv(m, m);
   
       T C11, C12, C13;
       T C21, C22, C23;
       T C31, C32, C33;
   
       switch (m)
       {
       case 1:
         if(M[0][0] == 0)
           return Array2D<T>();
         inv[0][0] = 1. / M[0][0];
         break;
       case 2:
         det_m = M[0][0] * M[1][1] - M[0][1] * M[1][0];
         if (det_m == 0)
           return Array2D<T>();
         inv[0][0] = M[1][1] / det_m;
         inv[1][1] = M[0][0] / det_m;
         inv[0][1] = -M[0][1] / det_m;
         inv[1][0] = -M[1][0] / det_m;
         break;
       case 3:
         C11 = M[0][0];
         C12 = M[0][1];
         C13 = M[0][2];
         C21 = M[1][0];
         C22 = M[1][1];
         C23 = M[1][2];
         C31 = M[2][0];
         C32 = M[2][1];
         C33 = M[2][2];
   
         det_m = C11 * (C22 * C33 - C23 * C32)
               - C12 * (C21 * C33 - C23 * C31)
               + C13 * (C21 * C32 - C22 * C31);
   
         if (det_m == 0)
           return Array2D<T>();
   
         inv[0][0] = (C22 * C33 - C32 * C23) / det_m;
         inv[1][0] = (C23 * C31 - C33 * C21) / det_m;
         inv[2][0] = (C21 * C32 - C31 * C22) / det_m;
         inv[0][1] = (C32 * C13 - C12 * C33) / det_m;
         inv[1][1] = (C33 * C11 - C13 * C31) / det_m;
         inv[2][1] = (C31 * C12 - C11 * C32) / det_m;
         inv[0][2] = (C12 * C23 - C22 * C13) / det_m;
         inv[1][2] = (C13 * C21 - C23 * C11) / det_m;
         inv[2][2] = (C11 * C22 - C21 * C12) / det_m;
   
         break;
       default:
         /* @todo
         // solve for inverse with LU decomposition
         JAMA::LU<T> lu(M);
         // create identity matrix
         TNT::Array2D<T> id(M.dim1(), M.dim2(), (T)0);
         for (int i = 0; i < M.dim1(); i++)
           id[i][i] = 1;
         // solves A * A_inv = Identity
         inv = lu.solve(id);
         
         */
         break;
       }
       return inv;
     }
   
     template <class T>
     T det(const TNT::Array2D<T> &M)
     {
       // square matrices only
       assert(M.dim1() == M.dim2());
       int m = M.dim1();
   
       T det_m;
   
       T C11, C12, C13;
       T C21, C22, C23;
       T C31, C32, C33;
   
       switch (m)
       {
       case 1:
         det_m = M[0][0];
         break;
       case 2:
         det_m = M[0][0] * M[1][1] - M[0][1] * M[1][0];
         break;
       case 3:
         C11 = M[0][0];
         C12 = M[0][1];
         C13 = M[0][2];
         C21 = M[1][0];
         C22 = M[1][1];
         C23 = M[1][2];
         C31 = M[2][0];
         C32 = M[2][1];
         C33 = M[2][2];
   
         det_m = C11 * (C22 * C33 - C23 * C32) 
               - C12 * (C21 * C33 - C23 * C31) 
               + C13 * (C21 * C32 - C22 * C31);
         break;
       default:
         /* @todo
         // solve for inverse with LU decomposition
         JAMA::LU<T> lu(M);
         // create identity matrix
         TNT::Array2D<T> id(M.dim1(), M.dim2(), (T)0);
         for (int i = 0; i < M.dim1(); i++)
           id[i][i] = 1;
         // solves A * A_inv = Identity
         inv = lu.solve(id);
         
         */
         break;
       }
       return det_m;
     }
   
   } // namespace TNT
   
   #endif
