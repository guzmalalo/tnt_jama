
.. _program_listing_file_src_tnt_tnt_array2d.h:

Program Listing for File tnt_array2d.h
======================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_tnt_tnt_array2d.h>` (``src/tnt/tnt_array2d.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
   *
   * Template Numerical Toolkit (TNT)
   *
   * Mathematical and Computational Sciences Division
   * National Institute of Technology,
   * Gaithersburg, MD USA
   *
   *
   * This software was developed at the National Institute of Standards and
   * Technology (NIST) by employees of the Federal Government in the course
   * of their official duties. Pursuant to title 17 Section 105 of the
   * United States Code, this software is not subject to copyright protection
   * and is in the public domain. NIST assumes no responsibility whatsoever for
   * its use by other parties, and makes no guarantees, expressed or implied,
   * about its quality, reliability, or any other characteristic.
   *
   */
   
   #ifndef TNT_ARRAY2D_H
   #define TNT_ARRAY2D_H
   
   #include <iostream>
   #ifdef TNT_BOUNDS_CHECK
   #include <cassert>
   #endif
   
   #include "tnt_array1d.h"
   
   namespace TNT 
   {
   
   
   template <class T>
   class Array2D 
   {
     private:
   
       Array1D<T> data_;
       Array1D<T*> v_;
       int m_;
       int n_;
   
     public:
   
       typedef         T   value_type;
   
   /*
     Create a null array.  This is <b>not</b> the same
     as Array2D(0,0), which consumes some memory overhead.
   */
              Array2D();
   
   /*
       Create a new (m x n) array, without initalizing elements.
       (This incurs an O(1) operation cost, rather than a O(m*n) cost.)
   */
              Array2D(int m, int n);
   
   /*
     Create a new (m x n) array,  as a view of an existing one-dimensional
     array stored in row-major order, i.e. right-most dimension varying fastest.
     Note that the storage for this pre-existing array will
     never be destroyed by TNT.
   */
              Array2D(int m, int n,  T *a);
   
   /*
     Create a new (m x n) array,  initializing array elements to
     constant specified by argument.  Most often used to
     create an array of zeros, as in A(m, n, 0.0).
   */
   
              Array2D(int m, int n, const T &val);
   
   
   /*
     Copy constructor. Array data is NOT copied, but shared.
     Thus, in Array2D B(A), subsequent changes to A will
     be reflected in B.  For an indepent copy of A, use
     Array2D B(A.copy()), or B = A.copy(), instead.
   */
       inline Array2D(const Array2D &A);
   
   
   /*
       Convert 2D array into a regular multidimensional C pointer.  Most often
       called automatically when calling C interfaces that expect things like
       double** rather than Array2D<double>.
   */
       inline operator T**();
   
   /*
       Convert a const 2D array into a const multidimensional C pointer.  
       Most often called automatically when calling C interfaces that expect 
       things like "const double**" rather than "const Array2D<double>&".
   */
       inline operator const T**() const;
   
   /*
       Assign all elements of array the same value.
   */
       inline Array2D & operator=(const T &val);
   
   /*
       Assign one Array2D to another.  (This is a shallow-assignement operation,
       and it is the identical semantics to ref(A).
   */
       inline Array2D & operator=(const Array2D &A);
   
   
   /*
    * Change the reference of one array B to another array B,
    * if B has only one reference the data is destroyed, if not the
    * reference counter is decreased.
   */
       inline Array2D & ref(const Array2D &A);
              Array2D copy() const;
              Array2D & inject(const Array2D & A);
       inline T* operator[](int i);
       inline const T* operator[](int i) const;
       inline int dim1() const;
       inline int dim2() const;
        ~Array2D();
   
       /* extended interface (not part of the standard) */
   
   
       inline int ref_count();
       inline int ref_count_data();
       inline int ref_count_dim1();
       Array2D subarray(int i0, int i1, int j0, int j1);
     Array2D subarray(const Array1D<int> &r, int j0, int j1);
   };
   
   
   template <class T>
   Array2D<T>::Array2D() : data_(), v_(), m_(0), n_(0) {} 
   
   template <class T>
   Array2D<T>::Array2D(const Array2D<T> &A) : data_(A.data_), v_(A.v_), 
       m_(A.m_), n_(A.n_) {}
   
   
   template <class T>
   Array2D<T>::Array2D(int m, int n) : data_(m*n), v_(m), m_(m), n_(n)
   {
       if (m>0 && n>0)
       {
           T* p = &(data_[0]);
           for (int i=0; i<m; i++)
           {
               v_[i] = p;
               p += n;
           }
       }
   }
   
   
   template <class T>
   Array2D<T>::Array2D(int m, int n, const T &val) : data_(m*n), v_(m), 
                                                       m_(m), n_(n) 
   {
     if (m>0 && n>0)
     {
       data_ = val;
       T* p  = &(data_[0]);
       for (int i=0; i<m; i++)
       {
               v_[i] = p;
               p += n;
       }
     }
   }
   
   template <class T>
   Array2D<T>::Array2D(int m, int n, T *a) : data_(m*n, a), v_(m), m_(m), n_(n)
   {
     if (m>0 && n>0)
     {
       T* p = &(data_[0]);
       
       for (int i=0; i<m; i++)
       {
               v_[i] = p;
               p += n;
       }
     }
   }
   
   
   template <class T>
   inline T* Array2D<T>::operator[](int i) 
   { 
   #ifdef TNT_BOUNDS_CHECK
       assert(i >= 0);
       assert(i < m_);
   #endif
   
   return v_[i]; 
   
   }
   
   template <class T>
   inline const T* Array2D<T>::operator[](int i) const
   { 
   #ifdef TNT_BOUNDS_CHECK
       assert(i >= 0);
       assert(i < m_);
   #endif
   
   return v_[i]; 
   
   }
   
   template <class T>
   Array2D<T> & Array2D<T>::operator=(const T &a)
   {
       /* non-optimized, but will work with subarrays in future verions */
       for (int i=0; i<m_; i++)
           for (int j=0; j<n_; j++)
           v_[i][j] = a;
       return *this;
   }
   
   template <class T>
   Array2D<T> Array2D<T>::copy() const
   {
       Array2D A(m_, n_);
   
       for (int i=0; i<m_; i++)
           for (int j=0; j<n_; j++)
               A[i][j] = v_[i][j];
   
   
       return A;
   }
   
   template <class T>
   Array2D<T> & Array2D<T>::inject(const Array2D &A)
   {
       if (A.m_ == m_ &&  A.n_ == n_)
       {
           for (int i=0; i<m_; i++)
               for (int j=0; j<n_; j++)
                   v_[i][j] = A[i][j];
       }
       return *this;
   }
   
   template <class T>
   Array2D<T> & Array2D<T>::ref(const Array2D<T> &A)
   {
       if (this != &A)
       {
           v_ = A.v_;
           data_ = A.data_;
           m_ = A.m_;
           n_ = A.n_;
           
       }
       return *this;
   }
   
   template <class T>
   Array2D<T> & Array2D<T>::operator=(const Array2D<T> &A)
   {
       return ref(A);
   }
   
   template <class T>
   inline int Array2D<T>::dim1() const { return m_; }
   
   template <class T>
   inline int Array2D<T>::dim2() const { return n_; }
   
   template <class T>
   Array2D<T>::~Array2D() {}
   
   
   template <class T>
   inline Array2D<T>::operator T**()
   {
       return &(v_[0]);
   }
   
   template <class T>
   inline Array2D<T>::operator const T**() const
   {
       return static_cast<const T**>(&(v_[0]));
   }
   
   /* ............... extended interface ............... */
   
   template <class T>
   Array2D<T> Array2D<T>::subarray(int i0, int i1, int j0, int j1) 
   {
       Array2D<T> A;
   
       if (!((i0 >= 0) && (i1 < m_) && (i0 <= i1)))
           return A;
   
       if (!((j0 >= 0) && (j1 < n_) && (j0 <= j1)))
           return A;
        
   
       int m = i1-i0+1;
       int n = j1-j0+1;
   
       /* if either length is zero or negative, this is an invalide
           subarray. return a null view.
       */
       if (m<1 || n<1)
           return A;
   
       A.data_ = data_;
       A.m_ = m;
       A.n_ = n;
       A.v_ = Array1D<T*>(m);
       T* p = &(data_[0]) + i0 *  n_ + j0;
       for (int i=0; i<m; i++)
       {
           A.v_[i] = p + i*n_;
   
       }   
       return A;
   }
   
   template <class T>
   Array2D<T> Array2D<T>::subarray(const Array1D<int> &r, int j0, int j1)
   {
    
     if (!((r.dim() > 0) && (r.dim() <= m_)))
       return Array2D<T>();
   
     if (!((j0 >= 0) && (j1 < n_) && (j0 <= j1)))
       return Array2D<T>();
   
     int m = r.dim();
     int n = j1 - j0 + 1;
   
     Array2D<T> A(m,n);
     for (int i = 0; i < m; i++)
     {
       for (int j = j0; j <= j1; j++)
       {
         A[i][j - j0] = v_[r[i]][j];
       }
     }
     return A;
   }
   
   template <class T>
   inline int Array2D<T>::ref_count()
   {
       return ref_count_data();
   }
   
   template <class T>
   inline int Array2D<T>::ref_count_data()
   {
       return data_.ref_count();
   }
   
   template <class T>
   inline int Array2D<T>::ref_count_dim1()
   {
       return v_.ref_count();
   }
   
   } /* namespace TNT */
   
   #endif
   /* TNT_ARRAY2D_H */
   
