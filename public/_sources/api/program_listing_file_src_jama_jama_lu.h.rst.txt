
.. _program_listing_file_src_jama_jama_lu.h:

Program Listing for File jama_lu.h
==================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_jama_jama_lu.h>` (``src/jama/jama_lu.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef JAMA_LU_H
   #define JAMA_LU_H
   
   #include "tnt_math_utils.h"
   #include "tnt_array1d.h"
   #include "tnt_array2d.h"
   
   namespace JAMA
   {
   
     template <class T>
     class LU
     {
     private:
       TNT::Array2D<T> LU_;
   
       int m, n, pivsign;
   
       TNT::Array1D<int> piv;
   
       TNT::Array2D<T> permute_copy(const TNT::Array2D<T> &A,
                                    const TNT::Array1D<int> &piv, int j0, int j1)
       {
         int piv_length = piv.dim();
   
         TNT::Array2D<T> X(piv_length, j1 - j0 + 1);
   
         for (int i = 0; i < piv_length; i++)
           for (int j = j0; j <= j1; j++)
             X[i][j - j0] = A[piv[i]][j];
   
         return X;
       }
   
       TNT::Array1D<T> permute_copy(const TNT::Array1D<T> &A,
                                    const TNT::Array1D<int> &piv)
       {
         int piv_length = piv.dim();
         if (piv_length != A.dim())
           return TNT::Array1D<T>();
   
         TNT::Array1D<T> x(piv_length);
   
         for (int i = 0; i < piv_length; i++)
           x[i] = A[piv[i]];
   
         return x;
       }
   
     public:
       LU(const TNT::Array2D<T> &A) : LU_(A.copy()), m(A.dim1()), n(A.dim2()),
                                      piv(A.dim1())
       {
   
         // Use a "left-looking", dot-product, Crout/Doolittle algorithm.
   
         for (int i = 0; i < m; i++)
         {
           piv[i] = i;
         }
         pivsign = 1;
         T *LUrowi = 0;
   
         TNT::Array1D<T> LUcolj(m);
   
         // Outer loop.
         for (int j = 0; j < n; j++)
         {
           // Make a copy of the j-th column to localize references.
           for (int i = 0; i < m; i++)
           {
             LUcolj[i] = LU_[i][j];
           }
   
           // Apply previous transformations.
           for (int i = 0; i < m; i++)
           {
             LUrowi = LU_[i];
   
             // Most of the time is spent in the following dot product.
             int kmax = std::min(i, j);
             double s = 0.0;
             for (int k = 0; k < kmax; k++)
             {
               s += LUrowi[k] * LUcolj[k];
             }
   
             LUrowi[j] = LUcolj[i] -= s;
           }
   
           // Find pivot and exchange if necessary.
           int p = j;
           for (int i = j + 1; i < m; i++)
           {
             if (std::abs(LUcolj[i]) > std::abs(LUcolj[p]))
             {
               p = i;
             }
           }
           if (p != j)
           {
             int k = 0;
             for (k = 0; k < n; k++)
             {
               double t = LU_[p][k];
               LU_[p][k] = LU_[j][k];
               LU_[j][k] = t;
             }
             k = piv[p];
             piv[p] = piv[j];
             piv[j] = k;
             pivsign = -pivsign;
           }
   
           // Compute multipliers.
           if ((j < m) && (LU_[j][j] != 0.0))
           {
             for (int i = j + 1; i < m; i++)
             {
               LU_[i][j] /= LU_[j][j];
             }
           }
         }
       }
   
       int isNonsingular()
       {
         for (int j = 0; j < n; j++)
         {
           if (LU_[j][j] == 0)
             return 0;
         }
         return 1;
       };
   
       TNT::Array2D<T> getL()
       {
         TNT::Array2D<T> L_(m, n);
         for (int i = 0; i < m; i++)
         {
           for (int j = 0; j < n; j++)
           {
             if (i > j)
             {
               L_[i][j] = LU_[i][j];
             }
             else if (i == j)
             {
               L_[i][j] = 1.0;
             }
             else
             {
               L_[i][j] = 0.0;
             }
           }
         }
         return L_;
       }
   
       TNT::Array2D<T> getU()
       {
         TNT::Array2D<T> U_(m, n);
         for (int i = 0; i < m; i++)
         {
           for (int j = 0; j < n; j++)
           {
             if (i <= j)
             {
               U_[i][j] = LU_[i][j];
             }
             else
             {
               U_[i][j] = 0.0;
             }
           }
         }
         return U_;
       }
   
       TNT::Array1D<int> getPivot()
       {
         return piv;
       }
   
       T det()
       {
         if (m != n)
         {
           return T(0);
         }
         T d = T(pivsign);
         for (int j = 0; j < n; j++)
         {
           d *= LU_[j][j];
         }
         return d;
       }
   
       TNT::Array2D<T> solve(const TNT::Array2D<T> &B)
       {
   
         /* Dimensions: A is mxn, X is nxk, B is mxk */
   
         if (B.dim1() != m)
         {
           return TNT::Array2D<T>();
         }
         if (!isNonsingular())
         {
           return TNT::Array2D<T>();
         }
   
         // Copy right hand side with pivoting
         int nx = B.dim2();
   
         TNT::Array2D<T> X = permute_copy(B, piv, 0, nx - 1);
   
         // Solve L*Y = B(piv,:)
         for (int k = 0; k < n; k++)
         {
           for (int i = k + 1; i < n; i++)
           {
             for (int j = 0; j < nx; j++)
             {
               X[i][j] -= X[k][j] * LU_[i][k];
             }
           }
         }
         // Solve U*X = Y;
         for (int k = n - 1; k >= 0; k--)
         {
           for (int j = 0; j < nx; j++)
           {
             X[k][j] /= LU_[k][k];
           }
           for (int i = 0; i < k; i++)
           {
             for (int j = 0; j < nx; j++)
             {
               X[i][j] -= X[k][j] * LU_[i][k];
             }
           }
         }
         return X;
       }
   
       TNT::Array1D<T> solve(const TNT::Array1D<T> &b)
       {
   
         /* Dimensions: A is mxn, X is nxk, B is mxk */
   
         if (b.dim1() != m)
         {
           return TNT::Array1D<T>();
         }
         if (!isNonsingular())
         {
           return TNT::Array1D<T>();
         }
   
         TNT::Array1D<T> x = permute_copy(b, piv);
   
         // Solve L*Y = B(piv)
         for (int k = 0; k < n; k++)
         {
           for (int i = k + 1; i < n; i++)
           {
             x[i] -= x[k] * LU_[i][k];
           }
         }
   
         // Solve U*X = Y;
         for (int k = n - 1; k >= 0; k--)
         {
           x[k] /= LU_[k][k];
           for (int i = 0; i < k; i++)
             x[i] -= x[k] * LU_[i][k];
         }
   
         return x;
       }
   
     }; /* class LU */
   
   } /* namespace JAMA */
   
   #endif
   /* JAMA_LU_H */
