
.. _program_listing_file_src_tnt_tnt_array1d_utils.h:

Program Listing for File tnt_array1d_utils.h
============================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_tnt_tnt_array1d_utils.h>` (``src/tnt/tnt_array1d_utils.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
   *
   * Template Numerical Toolkit (TNT)
   *
   * Mathematical and Computational Sciences Division
   * National Institute of Technology,
   * Gaithersburg, MD USA
   *
   *
   * This software was developed at the National Institute of Standards and
   * Technology (NIST) by employees of the Federal Government in the course
   * of their official duties. Pursuant to title 17 Section 105 of the
   * United States Code, this software is not subject to copyright protection
   * and is in the public domain. NIST assumes no responsibility whatsoever for
   * its use by other parties, and makes no guarantees, expressed or implied,
   * about its quality, reliability, or any other characteristic.
   *
   */
   
   #ifndef TNT_ARRAY1D_UTILS_H
   #define TNT_ARRAY1D_UTILS_H
   
   // local includes
   #include "tnt_array1d.h"
   
   namespace TNT
   {
   
     template <class T>
     std::ostream &operator<<(std::ostream &s, const Array1D<T> &A)
     {
       int N = A.dim1();
   
   #ifdef TNT_DEBUG
       s << "addr: " << (void *)&A[0] << "\n";
   #endif
       s << "Dimension: " << N << "\n";
       s << "Components: \n";
       for (int j = 0; j < N; j++)
       {
         s << A[j] << "\n";
       }
       s << "\n";
   
       return s;
     }
   
     template <class T>
     std::istream &operator>>(std::istream &s, Array1D<T> &A)
     {
       int N;
       s >> N;
   
       Array1D<T> B(N);
       for (int i = 0; i < N; i++)
         s >> B[i];
       A = B;
       return s;
     }
   
     template <class T>
     Array1D<T> operator+(const Array1D<T> &A, const Array1D<T> &B)
     {
       int n = A.dim1();
   
       // Add assert instead of if for release
       /*#ifdef TNT_BOUNDS_CHECK
           assert(("dim B is no equal to dim A",B.dim1() == n) );
   #endif*/
   
       if (B.dim1() != n)
         return Array1D<T>();
       else
       {
         Array1D<T> C(n);
   
         for (int i = 0; i < n; i++)
         {
           C[i] = A[i] + B[i];
         }
         return C;
       }
     }
   
     template <class T>
     Array1D<T> operator-(const Array1D<T> &A, const Array1D<T> &B)
     {
       int n = A.dim1();
   
       if (B.dim1() != n)
         return Array1D<T>();
       else
       {
         Array1D<T> C(n);
   
         for (int i = 0; i < n; i++)
         {
           C[i] = A[i] - B[i];
         }
         return C;
       }
     }
   
     template <class T>
     Array1D<T> operator*(const Array1D<T> &A, const Array1D<T> &B)
     {
       int n = A.dim1();
   
       if (B.dim1() != n)
         return Array1D<T>();
       else
       {
         Array1D<T> C(n);
   
         for (int i = 0; i < n; i++)
         {
           C[i] = A[i] * B[i];
         }
         return C;
       }
     }
   
     template <class T>
     Array1D<T> operator*(Array1D<T> &A, const T &b)
     {
       int n = A.dim1();
       Array1D<T> C(n);
   
       for (int i = 0; i < n; i++)
       {
         C[i] = A[i] * b;
       }
       return C;
     }
   
     template <class T>
     inline Array1D<T> operator*(const T &b, Array1D<T> &A)
     {
       return A * b;
     }
   
     template <class T>
     Array1D<T> operator/(const Array1D<T> &A, const Array1D<T> &B)
     {
       int n = A.dim1();
   
       if (B.dim1() != n)
         return Array1D<T>();
   
       else
       {
         Array1D<T> C(n);
   
         for (int i = 0; i < n; i++)
         {
           C[i] = A[i] / B[i];
         }
         return C;
       }
     }
   
     template <class T>
     Array1D<T> operator/(const Array1D<T> &A, const T &b)
     {
       int n = A.dim1();
       Array1D<T> C(n);
       for (int i = 0; i < n; i++)
       {
         C[i] = A[i] / b;
       }
       return C;
     }
   
     template <class T>
     Array1D<T> &operator+=(Array1D<T> &A, const Array1D<T> &B)
     {
       int n = A.dim1();
   
       if (B.dim1() == n)
       {
         for (int i = 0; i < n; i++)
         {
           A[i] += B[i];
         }
       }
       return A;
     }
   
     template <class T>
     Array1D<T> &operator-=(Array1D<T> &A, const Array1D<T> &B)
     {
       int n = A.dim1();
   
       if (B.dim1() == n)
       {
         for (int i = 0; i < n; i++)
         {
           A[i] -= B[i];
         }
       }
       return A;
     }
   
     template <class T>
     Array1D<T> &operator*=(Array1D<T> &A, const Array1D<T> &B)
     {
       int n = A.dim1();
   
       if (B.dim1() == n)
       {
         for (int i = 0; i < n; i++)
         {
           A[i] *= B[i];
         }
       }
       return A;
     }
   
     template <class T>
     Array1D<T> &operator*=(Array1D<T> &A, const T &b)
     {
       int n = A.dim1();
       for (int i = 0; i < n; i++)
       {
         A[i] *= b;
       }
       return A;
     }
   
     template <class T>
     Array1D<T> &operator/=(Array1D<T> &A, const Array1D<T> &B)
     {
       int n = A.dim1();
   
       if (B.dim1() == n)
       {
         for (int i = 0; i < n; i++)
         {
           A[i] /= B[i];
         }
       }
       return A;
     }
   
     template <class T>
     Array1D<T> &operator/=(Array1D<T> &A, const T &b)
     {
       int n = A.dim1();
       for (int i = 0; i < n; i++)
       {
         A[i] /= b;
       }
       return A;
     }
   
     /* ........................ extended functions ......................*/
   
     template <class T>
     T norm(const Array1D<T> &A)
     {
       int n = A.dim1();
   
       T sum = 0.;
       for (int i = 0; i < n; i++)
         sum += A[i] * A[i];
       return std::sqrt(sum);
     }
   
     template <class T>
     Array1D<T> cross(const Array1D<T> &A, const Array1D<T> &B)
     {
       int n = A.dim1();
       int m = B.dim1();
   
       if (n != 3 || m != 3)
         return Array1D<T>();
       else
       {
         Array1D<T> C(n);
         C[0] = A[1] * B[2] - A[2] * B[1];
         C[1] = A[2] * B[0] - A[0] * B[2];
         C[2] = A[0] * B[1] - A[1] * B[0];
         return C;
       }
     }
   
     template <class T>
     T dot_product(const Array1D<T> &A, const Array1D<T> &B)
     {
       int n = A.dim1();
       int m = B.dim1();
   
       if (n != 3 || m != 3)
         return 0;
       else
       {
         T sum = 0;
         for (int i = 0; i < n; i++)
           sum += A[i] * B[i];
   
         return sum;
       }
     }
   
   } // namespace TNT
   
   #endif
